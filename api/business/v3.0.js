var mongoose = require("mongoose"),
  express = require("express"),
  router = express.Router(),
  config = require("../../config"),
  bcrypt = require("bcrypt-nodejs"),
  assert = require("assert"),
  jwt = require("jsonwebtoken"),
  aws = require("aws-sdk"),
  multerS3 = require("multer-s3"),
  uuidv1 = require("uuid/v1"),
  Validator = require("validatorjs"),
  multer = require("multer"),
  moment = require("moment-timezone"),
  redis = require("redis"),
  FCM = require("fcm-node"),
  q = require("q"),
  xlsxtojson = require("xlsx-to-json-lc"), //Abhinav
  xlstojson = require("xls-to-json-lc"), //Abhinav
  // bodyParser = require('body-parser'),       //Abhinav
  request = require("request");

// app.use(bodyParser.json());
//webpush = require('web-push');

var s3 = new aws.S3({
  accessKeyId: config.IAM_USER_KEY,
  secretAccessKey: config.IAM_USER_SECRET,
  Bucket: config.BUCKET_NAME,
});

var currencyFormatter = require("currency-formatter");
var client = redis.createClient({ host: "localhost", port: 6379 });

const xAccessToken = require("../../middlewares/xAccessTokenBusiness");
const fun = require("../function");
const event = require("../event");
const whatsAppEvent = require("../whatsapp/whatsappEvent");
const businessFunctions = require("../erpWeb/businessFunctions");
var paytm_config = require("../../paytm/paytm_config").paytm_config;
var paytm_checksum = require("../../paytm/checksum");
const numWords = require("num-words");

var salt = bcrypt.genSaltSync(10);
const User = require("../../models/user");
const Statements = require("../../models/statements");

const BusinessTiming = require("../../models/businessTiming");
const BusinessConvenience = require("../../models/businessConvenience");
const BookingTiming = require("../../models/bookingTiming");
// const Type = require('../../models/type');
// const BusinessType = require('../../models/businessType');
const Category = require("../../models/category");
const Automaker = require("../../models/automaker");
const Model = require("../../models/model");
const QuotationOrders = require("../../models/quotationOrders");
const OrderLogs = require("../../models/orderLogs");
const State = require("../../models/state");
const BookingCategory = require("../../models/bookingCategory");
const ProductImage = require("../../models/productImage");
const Country = require("../../models/country");
const BusinessOffer = require("../../models/businessOffer");
const BusinessUser = require("../../models/businessUser");
const ProductOffer = require("../../models/productOffer");
const Order = require("../../models/order");
const BusinessOrder = require("../../models/businessOrder");
const OrderLine = require("../../models/orderLine");
const OrderConvenience = require("../../models/orderConvenience");
const OrderInvoice = require("../../models/orderInvoice");
const BookmarkProduct = require("../../models/bookmarkProduct");
const BookmarkOffer = require("../../models/bookmarkOffer");
const Car = require("../../models/car");
const CarSell = require("../../models/carSell");
const Asset = require("../../models/asset");
const CarImage = require("../../models/carImage");
const CarDocument = require("../../models/carDocument");
const BookmarkCar = require("../../models/bookmarkCar");
const BodyStyle = require("../../models/bodyStyle");
const FuelType = require("../../models/fuelType");
const Transmission = require("../../models/transmission");
const Color = require("../../models/color");
const Owner = require("../../models/owner");
const ServiceGallery = require("../../models/serviceGallery"); //abhinav
const BusinessGallery = require("../../models/businessGallery");
const ProfileView = require("../../models/profileViews");
const Variant = require("../../models/variant");
const ClaimBusiness = require("../../models/claimBusiness");
const Review = require("../../models/review");
const Battery = require("../../models/battery");
const BatteryBrand = require("../../models/batteryBrand");
const TyreSize = require("../../models/tyreSize");
const Booking = require("../../models/booking");
const Lead = require("../../models/lead");
const Service = require("../../models/service");
const Customization = require("../../models/customization");
const Collision = require("../../models/collision");
const Washing = require("../../models/washing");
const ProductCategory = require("../../models/productCategory");
const Product = require("../../models/product");
const ProductBrand = require("../../models/productBrand");
const ProductModel = require("../../models/productModel");
const BusinessProduct = require("../../models/businessProduct");
const LeadRemark = require("../../models/leadRemark");
const LeadGenRemark = require("../../models/leadGenRemark");
const LeadStatus = require("../../models/leadStatus");
const Package = require("../../models/package");
const UserPackage = require("../../models/userPackage");
const PackageUsed = require("../../models/packageUsed");
const Management = require("../../models/management");
const LeadManagement = require("../../models/leadManagement");
const Address = require("../../models/address");
const Gallery = require("../../models/gallery");
const Coupon = require("../../models/coupon");
const Detailing = require("../../models/detailing");
const CouponUsed = require("../../models/couponUsed");
const Purchase = require("../../models/purchase");
const PurchaseReturn = require("../../models/purchaseReturn");
const PurchaseOrder = require("../../models/purchaseOrder");
const Tax = require("../../models/tax");
const BusinessVendor = require("../../models/businessVendor");
const JobInspection = require("../../models/jobInspection");
const ClubMember = require("../../models/clubMember");
const InsuranceCompany = require("../../models/insuranceCompany");
const LabourRate = require("../../models/labourRate");
const Point = require("../../models/point");
const QualityCheck = require("../../models/qualityCheck");
const Invoice = require("../../models/invoice");
const Expense = require("../../models/expense");
const Estimate = require("../../models/estimate");
const StockLogs = require("../../models/stockLogs");
const Sales = require("../../models/sales");
const Parchi = require("../../models/parchi");
// Vinay Model added
const VendorOrders = require("../../models/vendorOrders");

const TransactionLog = require("../../models/transactionLog");
const RFQ = require("../../models/rfq");
const Quotation = require("../../models/quotation");
const BusinessPlan = require("../../models/businessPlan");
const Referral = require("../../models/referral");
const ManagementRole = require("../../models/managementRole");
const Location = require("../../models/location");
const BusinessSetting = require("../../models/businessSetting");
const ExpenseCategory = require("../../models/expenseCategory");
const OutBoundLead = require("../../models/outBoundLead");
const ReviewPoint = require("../../models/reviewPoint");
const LeadGen = require("../../models/leadGen");
const SuitePlan = require("../../models/suitePlan");
const { updateMany } = require("../../models/user");
const { filter, rangeRight, parseInt } = require("lodash");
const orders = require("../../models/orderLogs");

var secret = config.secret;
var Log_Level = config.Log_Level;

router.post("/short-codes", async function (req, res, next) {
  var last_invoice = "2019-20/787";
  var lst = last_invoice.split("/");
  var fiscalyear = "";
  var today = new Date();

  var thisFullYear = today.getFullYear().toString();
  thisFullYear = thisFullYear.toString();
  var nextFullYear = today.getFullYear() + 1;
  nextFullYear = nextFullYear.toString();

  if (today.getMonth() + 1 <= 3) {
    fiscalyear = today.getFullYear() - 1 + "-" + thisFullYear.slice(-2);
  } else {
    fiscalyear = today.getFullYear() + "-" + nextFullYear.slice(-2);
  }

  var date = new Date(today.getFullYear() + "-04-01");

  if (lst.length > 0) {
    if (lst[0] == fiscalyear) {
      var match = true;
      var invoice = invNum.next(lst[0] + "/" + lst[1]);
    } else {
      var match = false;
      var invoice = fiscalyear + "/001";
    }
  } else {
    var invoice = invNum.next(fiscalyear + "/000");
  }

  res.json({
    lst: lst[0],
    last_invoice: last_invoice,
    match: match,
    date: date,
    today: today,
    fiscalyear: fiscalyear,
    invoice: invoice,
  });
});

router.get(
  "/side-menu/get",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var business = req.headers["business"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var chat = false;
    var loggedInDetails = await User.findById(decoded.user).exec();

    var role = await Management.findOne({
      user: decoded.user,
      business: business,
    })
      .populate({
        path: "business",
        select:
          "name avatar avatar_address contact_no isCarEager uuid business_info",
      })
      .populate({
        path: "user",
        select: "name avatar avatar_address contact_no",
      })
      .exec();

    if (role) {
      var def = [];
      var main = [];
      var multi = false;

      var plans = await BusinessPlan.find({ business: business })
        .populate("suite")
        .exec();
      var suite = _.map(plans, "suite");

      for (var i = 0; i < suite.length; i++) {
        var defaults = suite[i].default;
        for (var j = 0; j < defaults.length; j++) {
          var foundIndex = def.findIndex((x) => x.action == defaults[j].action);
          if (foundIndex == -1) {
            def.push({
              tag: defaults[j].tag,
              module: defaults[j].module,
              action: defaults[j].action,
              enable: defaults[j].enable,
              activityTab: defaults[j].activityTab,
              icon:
                "https://careager-staging.s3.ap-south-1.amazonaws.com/icon/" +
                defaults[j].tag +
                ".svg",
            });
          }
        }

        var serverTime = moment.tz(new Date(), req.headers["tz"]);
        var bar = plans[i].created_at;
        bar.setDate(bar.getDate() + plans[i].validity);
        var e = bar;
        bar = moment.tz(bar, req.headers["tz"]);

        var baz = bar.diff(serverTime);

        if (baz > 0) {
          var mains = suite[i].main;
          for (var k = 0; k < mains.length; k++) {
            var foundIndex = main.findIndex((x) => x.action == mains[k].action);
            if (foundIndex >= 0) {
              main[foundIndex] = {
                tag: mains[k].tag,
                module: mains[k].action,
                action: mains[k].action,
                enable: mains[k].enable,
                activityTab: mains[k].activityTab,
                icon:
                  "https://careager-staging.s3.ap-south-1.amazonaws.com/icon/" +
                  mains[k].tag +
                  ".svg",
              };
            } else {
              main.push({
                tag: mains[k].tag,
                module: mains[k].module,
                action: mains[k].action,
                enable: mains[k].enable,
                activityTab: mains[k].activityTab,
                icon:
                  "https://careager-staging.s3.ap-south-1.amazonaws.com/icon/" +
                  mains[k].tag +
                  ".svg",
              });
            }
          }
        }

        if (suite[i].chat == true) {
          chat = true;
        }
      }

      def = _(def)
        .groupBy((x) => x.module)
        .map((value, key) => ({ module: key, group: value }))
        .value();
      def = _.orderBy(def, ["plan"], ["asc"]);

      main = _(main)
        .groupBy((x) => x.module)
        .map((value, key) => ({ module: key, group: value }))
        .value();
      main = _.orderBy(main, ["plan"], ["asc"]);

      var business_info = role.business.business_info;

      var manifest = await BusinessSetting.findOne({
        business: business,
      }).exec();
      if (manifest == null) {
        manifest = {
          discount_on: "Labour",
          job_inspection_pics_limit: 13,
          skip_insurance_info: false,
          skip_store_approval: true,
          skip_qc: true,
          gst_invoice: true,
        };
      }

      res.status(200).json({
        responseCode: 200,
        responseMessage: "navigation",
        responseData: {
          business: role.business,
          user: role.user,
          navigation: main.concat(def),
          chat: chat,
          manifest: manifest,
          management: {
            _id: role._id,
            id: role.id,
            role: role.role,
          },
        },
      });
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Unauthorized",
        responseData: {},
      });
    }
  }
);

router.get(
  "/management/roles/get",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var business = req.headers["business"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    res.status(200).json({
      responseCode: 200,
      responseMessage: "Role",
      responseData: await ManagementRole.find({}).exec(),
    });
  }
);

router.post(
  "/management/add",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var business = req.headers["business"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    var rules = {
      name: "required",
      contact_no: "required",
      role: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Mobile No. is required",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var checkPhone = await User.find({
        contact_no: req.body.contact_no,
        "account_info.type": "business",
      })
        .count()
        .exec();
      if (checkPhone == 0) {
        var otp = Math.floor(Math.random() * 90000) + 10000;
        var password = Math.floor(Math.random() * 90000) + 10000;

        req.body.username = shortid.generate();
        req.body.socialite = {};
        req.body.optional_info = {};

        var country = await Country.findOne({
          timezone: req.headers["tz"],
        }).exec();
        req.body.address = {
          country: country.countryName,
          timezone: req.headers["tz"],
          location: req.body.location,
        };

        req.body.account_info = {
          type: "business",
          status: "Complete",
          phone_verified: false,
          verified_account: false,
          approved_by_admin: false,
        };

        req.body.geometry = [0, 0];
        req.body.password = password;
        req.body.device = [];
        req.body.otp = otp;
        req.body.visibility = false;
        req.body.uuid = uuidv1();

        req.body.business_info = {
          business_category: "",
          company: "",
        };

        var firstPart = (Math.random() * 46656) | 0;
        var secondPart = (Math.random() * 46656) | 0;
        firstPart = ("000" + firstPart.toString(36)).slice(-3);
        secondPart = ("000" + secondPart.toString(36)).slice(-3);
        req.body.referral_code =
          firstPart.toUpperCase() + secondPart.toUpperCase();

        User.create(req.body).then(async function (user) {
          Management.create({
            business: business,
            user: user._id,
            department: req.body.department,
            role: req.body.role,
            created_at: new Date(),
            updated_at: new Date(),
          });

          event.signupSMS(user);

          res.status(200).json({
            responseCode: 200,
            responseMessage: "success",
            responseData: {
              user: user,
            },
          });
        });
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Phone number already in use.",
          responseData: {},
        });
      }
    }
  }
);

router.put(
  "/management-info/update",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      user: "required",
      name: "required",
      contact_no: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "All field required",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var business = req.headers["business"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var user = await User.findById(req.body.user).exec();
      if (user) {
        var check = await User.findOne({
          contact_no: req.body.contact_no,
          _id: { $ne: user._id },
          "account_info.type": user.account_info.type,
        }).exec();

        if (check) {
          res.status(400).json({
            responseCode: 400,
            responseMessage: "Contact no already exist",
            responseData: {},
          });
        } else {
          User.findOneAndUpdate(
            { _id: user._id },
            {
              $set: {
                name: req.body.name,
                contact_no: req.body.contact_no,
                email: req.body.email,
                updated_at: new Date(),
              },
            },
            { new: false },
            function (err, doc) {
              if (err) {
                res.status(422).json({
                  responseCode: 422,
                  responseMessage: "Error Occurred",
                  responseData: err,
                });
              } else {
                Management.findOneAndUpdate(
                  { user: user._id, business: business },
                  {
                    $set: {
                      department: req.body.department,
                      role: req.body.role,
                      updated_at: new Date(),
                    },
                  },
                  { new: false },
                  function (err, doc) {
                    if (err) {
                      res.status(422).json({
                        responseCode: 422,
                        responseMessage: "Error Occurred",
                        responseData: err,
                      });
                    } else {
                      res.status(200).json({
                        responseCode: 200,
                        responseMessage: "User details updated...",
                        responseData: {},
                      });
                    }
                  }
                );
              }
            }
          );
        }
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "User not found",
          responseData: {},
        });
      }
    }
  }
);

router.delete(
  "/management/remove",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var business = req.headers["business"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    var rules = {
      user: "required",
    };

    var validation = new Validator(req.query, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Employee Required",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var role = await Management.findOne({
        user: req.query.user,
        business: business,
      }).exec();
      if (role) {
        if (!role.business.equals(req.query.user)) {
          return res.status(422).json({
            responseCode: 422,
            responseMessage: "Server Error",
            responseData: {},
          });

          User.findOneAndUpdate(
            { _id: req.query.user },
            {
              $set: {
                "account_info.type": "deleted",
                "account_info.status": "Deleted",
              },
            },
            { new: true },
            async function (err, doc) {
              if (err) {
                res.status(422).json({
                  responseCode: 422,
                  responseMessage: "Server Error",
                  responseData: err,
                });
              } else {
                await Management.remove({
                  user: req.query.user,
                  business: business,
                }).exec();
                res.status(200).json({
                  responseCode: 200,
                  responseMessage: "Removed Successfully",
                  responseData: {},
                });
              }
            }
          );
        } else {
          res.status(400).json({
            responseCode: 400,
            responseMessage: "User not found",
            responseData: {},
          });
        }
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "User not found",
          responseData: {},
        });
      }
    }
  }
);

router.get(
  "/managements/get/",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    var business = req.headers["business"];

    var managements = [];

    if (req.query.page == undefined) {
      var page = 0;
    } else {
      var page = req.query.page;
    }

    var page = Math.max(0, parseInt(page));

    await Management.find({ business: business, user: { $ne: business } })
      .populate({
        path: "user",
        select: "_id id name contact_no avatar avatar_address email",
      })
      .sort({ created_at: -1 })
      .skip(config.perPage * page)
      .limit(config.perPage)
      .cursor()
      .eachAsync(async (management) => {
        managements.push({
          id: management.user._id,
          name: management.user.name,
          role: management.role,
          department: management.department,
          username: management.user.username,
          email: management.user.email,
          contact_no: management.user.contact_no,
          avatar: management.user.avatar,
          avatar_address: management.user.avatar_address,
        });
      });

    res.status(200).json({
      responseCode: 200,
      responseMessage: "Analytics",
      responseData: managements,
    });
  }
);

router.get("/chat/leads/add", async function (req, res, next) {
  var business = req.headers["business"];
  var user = await User.findById(req.query.id).exec();
  if (user) {
    var checklead = await Lead.findOne({
      contact_no: user.contact_no,
      business: business,
      "remark.status": { $in: ["Open", "Follow-Up"] },
    })
      .sort({ updated_at: -1 })
      .exec();

    if (checklead) {
      Lead.findOneAndUpdate(
        { _id: checklead._id },
        {
          $set: {
            "remark.status": "Open",
            type: "Booking",
            source: "Chat",
            "remark.source": "Chat",
            updated_at: new Date(),
          },
        },
        { new: false },
        async function (err, doc) {}
      );
    } else {
      var data = {};
      var manager = business;

      var status = await LeadStatus.findOne({ status: "Open" }).exec();

      var managers = [];
      await Management.find({ business: business, role: "CRE" })
        .cursor()
        .eachAsync(async (a) => {
          // var d = await Lead.find({ business: business, assignee: a.user, 'remark.status': { $in: ['Open', 'Follow-Up'] } }).count().exec();
          var open = await Lead.find({
            business: business,
            assignee: a.user,
            "remark.status": { $in: ["Open"] },
          })
            .count()
            .exec();
          var follow_up = await Lead.find({
            business: business,
            assignee: a.user,
            "remark.status": { $in: ["Follow-Up"] },
            "follow_up.date": { $lte: new Date() },
          })
            .count()
            .exec();
          var d = open + follow_up;
          managers.push({
            user: a.user,
            count: d,
          });
        });

      if (managers.length != 0) {
        managers.sort(function (a, b) {
          return a.count > b.count;
        });

        manager = managers[0].user;
      }

      data.user = user._id;
      data.business = business;
      data.name = user.name;
      data.contact_no = user.contact_no;
      data.email = user.email;
      data.assignee = manager;
      data.type = "Chat";
      data.geometry = [0, 0];
      data.follow_up = null;
      (data.source = "Chat"),
        (data.remark = {
          status: req.body.status,
          customer_remark: "",
          assignee_remark: "",
          assignee: manager,
          color_code: "",
          created_at: new Date(),
          updated_at: new Date(),
        });
      data.created_at = new Date();
      data.updated_at = new Date();

      Lead.create(data).then(async function (lead) {
        var count = await Lead.find({
          _id: { $lt: l._id },
          business: business,
        }).count();
        var lead_id = count + 10000;

        Lead.findOneAndUpdate(
          { _id: l._id },
          { $set: { lead_id: lead_id } },
          { new: true },
          async function (err, doc) {}
        );
        var status = await LeadStatus.findOne({ status: "Open" }).exec();
        LeadRemark.create({
          lead: lead._id,
          type: "Chat",
          source: req.headers["devicetype"],
          status: req.body.status,
          customer_remark: "",
          assignee_remark: "",
          assignee: manager,
          color_code: "",
          created_at: new Date(),
          updated_at: new Date(),
        }).then(function (newRemark) {
          Lead.findOneAndUpdate(
            { _id: lead._id },
            { $push: { remarks: newRemark._id } },
            { new: true },
            async function (err, doc) {}
          );
        });

        event.assistance(lead, req.headers["tz"]);

        res.status(200).json({
          responseCode: 200,
          responseMessage: "",
          responseData: {},
        });
      });
    }
  } else {
    var json = {
      responseCode: 400,
      responseMessage: "Invalid user",
      responseData: {},
    };

    res.status(400).json(json);
  }
});

router.get(
  "/lead/category/get",
  xAccessToken.token,
  async function (req, res, next) {
    console.log("Abhinav");
    var token = req.headers["x-access-token"];
    var business = req.headers["business"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    var loggedInDetails = await User.findById(decoded.user).exec();
    var plans = await BusinessPlan.find({ business: business })
      .populate("suite")
      .exec();
    var suite = _.map(plans, "suite");
    var def = [];
    for (var i = 0; i < suite.length; i++) {
      var serverTime = moment.tz(new Date(), req.headers["tz"]);
      var bar = plans[i].created_at;
      bar.setDate(bar.getDate() + plans[i].validity);
      var e = bar;
      bar = moment.tz(bar, req.headers["tz"]);

      var baz = bar.diff(serverTime);
      if (baz > 0) {
        var defaults = suite[i].default;
        for (var j = 0; j < defaults.length; j++) {
          if (defaults[j].action == "Leads") {
            var newArr = defaults[j].category;
            def = _.concat(def, newArr);
          }
        }
      }
    }

    res.status(200).json({
      responseCode: 200,
      responseMessage: "navigation",
      responseData: _.uniq(def),
    });
  }
);

router.get(
  "/lead/tabs/get",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var business = req.headers["business"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    var loggedInDetails = await User.findById(decoded.user).exec();
    var plans = await BusinessPlan.find({ business: business })
      .populate("suite")
      .exec();
    var suite = _.map(plans, "suite");
    var def = [];
    for (var i = 0; i < plans.length; i++) {
      var serverTime = moment.tz(new Date(), req.headers["tz"]);
      var bar = plans[i].created_at;
      bar.setDate(bar.getDate() + plans[i].validity);
      var e = bar;
      bar = moment.tz(bar, req.headers["tz"]);

      var baz = bar.diff(serverTime);
      if (baz > 0) {
        var defaults = suite[i].default;
        for (var j = 0; j < defaults.length; j++) {
          if (defaults[j].action == "Leads") {
            var newArr = defaults[j].activityTab;
            def = _.concat(def, newArr);
          }
        }
      }
    }

    var def = _.uniqBy(def, function (o) {
      return o.activity;
    });

    res.status(200).json({
      responseCode: 200,
      responseMessage: "navigation",
      responseData: def,
    });
  }
);

router.post("/lead/add", xAccessToken.token, async function (req, res, next) {
  // console.log("Body= ", JSON.stringify(req.body));
  var token = req.headers["x-access-token"];
  var business = req.headers["business"];
  var secret = config.secret;
  var decoded = jwt.verify(token, secret);
  // console.log("Lead addd ")
  var loggedInDetails = await User.findById(decoded.user).exec();
  var role = await Management.findOne({
    user: decoded.user,
    business: business,
  }).exec();

  if (req.body.contact_no) {
    var last = await Lead.findOne({
      contact_no: req.body.contact_no,
      business: business,
      "remark.status": { $in: ["Open", "Follow-Up"] },
    })
      .sort({ updated_at: -1 })
      .exec();
  } else {
    var last = null;
  }
  // async function getAssignee(user, business) {
  //     var role = await Management.findOne({ user: user, business: business }).exec();
  //     if (role.role == "CRE") {
  //         advisor = role.user;
  //     } else {
  //         var assigneeLead = [];
  //         await Management.find({ business: business, role: "CRE" })
  //             .cursor().eachAsync(async (a) => {
  //                 var d = await Lead.find({ business: business, assignee: a.user }).count().exec();
  //                 assigneeLead.push({
  //                     user: a.user,
  //                     count: d
  //                 })
  //             });

  //         if (assigneeLead.length != 0) {
  //             assigneeLead.sort(function (a, b) {
  //                 return a.count > b.count;
  //             });

  //             advisor = assigneeLead[0].user;

  //         } else {
  //             advisor = role.business;
  //         }
  //     }

  //     return advisor;
  // }
  var assignee = await q.all(
    businessFunctions.getAssignee(decoded.user, business)
  );

  if (last) {
    return res.status(422).json({
      responseCode: 422,
      responseMessage:
        "Lead already exist #" + last.lead_id + " [" + last.remark.status + "]",
      responseData: {},
    });
  } else {
    var data = {};
    var status = await LeadStatus.findOne({ status: req.body.status }).exec();
    var follow_up = {};
    var advisor = null;

    if (req.body.status == "Follow-Up") {
      if (req.body.date) {
        var follow_up = {
          date: new Date(req.body.date).toISOString(),
          time: req.body.time,
          created_at: new Date(),
          updated_at: new Date(),
        };
      }
    }

    var contacted = false;

    if (req.body.contacted) {
      contacted = true;
    }
    var priority = 2;
    if (req.body.priority) {
      if (parseInt(req.body.priority)) {
        priority = req.body.priority;
      } else {
        priority = 2;
      }
    }
    //Abhinav Tygai :: Update Status in LeadGen Collection To be Tested
    var st_update = await LeadGen.findOne({
      contact_no: req.body.contact_no,
    }).exec();

    if (st_update) {
      // // console.log("Inside LeadGen")
      st_update.remark.status = "Converted";
      st_update.converted = true;
      st_update.save();
    }
    //End By Abhinav
    var checkUser = await User.findOne({
      contact_no: req.body.contact_no,
      "account_info.type": "user",
    }).exec();
    if (checkUser) {
      var user = checkUser._id;
      var name = checkUser.name;
      var contact_no = checkUser.contact_no;
      var email = checkUser.email;
    } else {
      var user = null;
      var name = req.body.name;
      var contact_no = req.body.contact_no;
      var email = req.body.email;
    }

    var remark = {
      assignee: assignee,
      status: req.body.status,
      reason: req.body.reason,
      customer_remark: req.body.remark,
      assignee_remark: req.body.remark,
      color_code: "",
      created_at: new Date(),
      updated_at: new Date(),
    };
    //Abhinav Alternate
    var variant = null;
    if (req.body.variant) {
      variant = req.body.variant;
    }
    // // console.log("Variant  body = " + req.body.variant)
    // // console.log("Variant  = " + variant)

    var alternate_no = "";
    if (req.body.alternate_no) {
      alternate_no = req.body.alternate_no;
    }
    var additional_info = {
      variant: variant,
      alternate_no: alternate_no,
    };
    // if (req.body.alternate_no) {
    //     "additional_info.alternate_no" = req.body.alternate_no;
    // }
    var category = "Booking";
    if (req.body.category) {
      category = req.body.category;
    }
    var isStared = false;
    if (req.body.isStared) {
      isStared = req.body.isStared;
    }

    var lead = {
      user: user,
      name: name,
      contact_no: contact_no,
      email: email,
      type: req.body.type,
      follow_up: follow_up,
      business: req.headers["business"],
      assignee: assignee,
      source: req.body.source,
      model: req.body.model,
      remark: remark,
      priority: priority,
      category: category,
      additional_info: additional_info,
      isStared: isStared,
      created_at: new Date(),
      updated_at: new Date(),
    };
    await Lead.create(lead).then(async function (l) {
      var count = await Lead.find({
        _id: { $lt: l._id },
        business: business,
      }).count();
      var lead_id = count + 10000;

      Lead.findOneAndUpdate(
        { _id: l._id },
        { $set: { lead_id: lead_id } },
        { new: true },
        async function (err, doc) {}
      );

      LeadRemark.create({
        lead: l._id,
        source: l.source,
        type: l.type,
        status: l.remark.status,
        reason: req.body.reason,
        customer_remark: req.body.remark,
        assignee_remark: req.body.remark,
        assignee: assignee,
        color_code: "",
        created_at: new Date(),
        updated_at: new Date(),
      }).then(function (newRemark) {
        Lead.findOneAndUpdate(
          { _id: l._id },
          { $push: { remarks: newRemark._id } },
          { new: true },
          async function (err, doc) {}
        );
      });

      var lead = await Lead.findById(l._id).populate("assignee").exec();

      var logs = [];
      await LeadRemark.find({ lead: lead._id })
        .populate("assignee")
        .sort({ created_at: -1 })
        .cursor()
        .eachAsync(async (l) => {
          var assignee = {};
          if (l.assignee) {
            assignee = {
              _id: l.assignee._id,
              id: l.assignee._id,
              name: l.assignee.name,
              email: l.assignee.email,
              contact_no: l.assignee.contact_no,
            };
          }

          logs.push({
            source: l.source,
            type: l.type,
            reason: l.reason,
            status: l.status,
            customer_remark: l.customer_remark,
            assignee_remark: l.assignee_remark,
            assignee: assignee,
            color_code: l.color_code,
            created_at: moment(l.created_at)
              .tz(req.headers["tz"])
              .format("lll"),
            updated_at: moment(l.updated_at)
              .tz(req.headers["tz"])
              .format("lll"),
          });
        });

      var push = {
        user: lead.user,
        name: lead.name,
        contact_no: lead.contact_no,
        email: lead.email,
        _id: lead._id,
        id: lead.id,
        priority: lead.priority,
        contacted: lead.contacted,
        type: lead.type,
        lead_id: lead.lead_id,
        date: moment(lead.updated_at).tz(req.headers["tz"]).format("lll"),
        source: lead.source,
        status: lead.status,
        important: lead.important,
        follow_up: lead.follow_up,
        remark: lead.remark,

        assignee: {
          _id: lead.assignee._id,
          name: lead.assignee.name,
          contact_no: lead.assignee.contact_no,
          email: lead.assignee.email,
          id: lead.assignee.id,
        },

        logs: logs,
        created_at: moment(lead.created_at).tz(req.headers["tz"]).format("lll"),
        updated_at: moment(lead.updated_at).tz(req.headers["tz"]).format("lll"),
      };

      if (role.role != "CRE") {
        var notify = {
          receiver: [lead.assignee._id],
          activity: "lead",
          tag: "assigned",
          source: lead._id,
          sender: loggedInDetails._id,
          points: 0,
        };
        // Vinay testing the lead generation
        fun.newNotification(notify);
      }

      var activity = "Lead";

      fun.webNotification(activity, l);

      await whatsAppEvent.leadGenerate(l._id, business);
      event.leadCre(l._id, business);
      await whatsAppEvent.leadCre(l._id, business);

      res.status(200).json({
        responseCode: 200,
        responseMessage: "Lead Added ",
        responseData: push,
      });
    });
  }
});

// router.put("/lead/edit", xAccessToken.token, async function (req, res, next) {
//   var token = req.headers["x-access-token"];
//   var secret = config.secret;
//   var decoded = jwt.verify(token, secret);
//   var user = decoded.user;
//   var business = req.headers["business"];
//   var bookings = [];
//   var totalResult = 0;
//   var check = await Lead.findById(req.body.lead).exec();
//   if (check) {
//     var last = await Lead.findOne({
//       contact_no: req.body.contact_no,
//       _id: { $ne: req.body.lead },
//       business: business,
//       "remark.status": { $in: ["Open", "Follow-Up"] },
//     })
//       .sort({ updated_at: -1 })
//       .exec();

//     if (last) {
//       return res.status(422).json({
//         responseCode: 422,
//         responseMessage:
//           "Lead already exist #" +
//           last.lead_id +
//           " [" +
//           last.remark.status +
//           "]",
//         responseData: {},
//       });
//     } else {
//       var token = req.headers["x-access-token"];
//       var secret = config.secret;
//       var decoded = jwt.verify(token, secret);

//       var checkUser = await User.findOne({
//         contact_no: req.body.contact_no,
//         "account_info.type": "user",
//       }).exec();
//       if (checkUser) {
//         var user = checkUser._id;
//         var name = checkUser.name;
//         var contact_no = checkUser.contact_no;
//         var email = req.body.email;
//       } else {
//         var user = null;
//         var name = req.body.name;
//         var contact_no = req.body.contact_no;
//         var email = req.body.email;
//       }

//       var leads = {};

//       var data = {
//         user: user,
//         name: name,
//         contact_no: contact_no,
//         email: email,
//         updated_at: new Date(),
//       };

//       Lead.findOneAndUpdate(
//         { _id: check._id },
//         { $set: data },
//         { new: true },
//         async function (err, doc) {
//           var lead = await Lead.findById(req.body.lead)
//             .populate("assignee")
//             .exec();

//           var a = await User.findById(lead.advisor).exec();
//           var remark = await LeadRemark.findOne({ lead: lead._id })
//             .sort({ created_at: -1 })
//             .exec();
//           var assignee = {
//             name: lead.assignee.name,
//             email: lead.assignee.email,
//             contact_no: lead.assignee.contact_no,
//             _id: lead.assignee._id,
//             _id: lead.assignee._id,
//           };

//           if (a) {
//             var advisor = {
//               name: a.name,
//               email: a.email,
//               contact_no: a.contact_no,
//               _id: a._id,
//               _id: a._id,
//             };
//           } else {
//             var advisor = null;
//           }

//           var push = {
//             _id: lead._id,
//             id: lead.id,
//             user: lead.user,
//             name: lead.name,
//             contact_no: lead.contact_no,
//             email: lead.email,
//             _id: lead._id,
//             id: lead.id,
//             priority: lead.priority,
//             contacted: lead.contacted,
//             type: lead.type,
//             lead_id: lead.lead_id,
//             date: moment(lead.updated_at).tz(req.headers["tz"]).format("lll"),
//             source: lead.source,
//             status: lead.status,
//             important: lead.important,
//             follow_up: lead.follow_up,
//             remark: lead.remark,
//             assignee: assignee,
//             advisor: advisor,
//             created_at: moment(lead.created_at)
//               .tz(req.headers["tz"])
//               .format("lll"),
//             updated_at: moment(lead.updated_at)
//               .tz(req.headers["tz"])
//               .format("lll"),
//           };

//           res.status(200).json({
//             responseCode: 200,
//             responseMessage: "Lead Added ",
//             responseData: push,
//           });
//         }
//       );
//     }
//   } else {
//     res.status(400).json({
//       responseCode: 400,
//       responseMessage: "Lead not found",
//       responseData: {},
//     });
//   }
// });

router.put("/lead/edit", xAccessToken.token, async function (req, res, next) {
  // console.log("Lead Edit ")
  var token = req.headers["x-access-token"];
  var secret = config.secret;
  var decoded = jwt.verify(token, secret);
  var user = decoded.user;
  var business = req.headers["business"];
  var bookings = [];
  var totalResult = 0;
  var name = "";
  var user = "";
  var contact_no = "";
  var email = "";
  // console.log("Lead ID= " + req.body.lead)
  var check = await Lead.findById(req.body.lead).exec();
  if (check) {
    var last = await Lead.findOne({
      contact_no: req.body.contact_no,
      _id: { $ne: req.body.lead },
      business: business,
      "remark.status": { $in: ["Open", "Follow-Up"] },
    })
      .sort({ updated_at: -1 })
      .exec();

    if (last) {
      return res.status(422).json({
        responseCode: 422,
        responseMessage:
          "Lead already exist #" +
          last.lead_id +
          " [" +
          last.remark.status +
          "]",
        responseData: {},
      });
    } else {
      // console.log("Last Is False")
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);

      //Abhinav :-Alternate Mobile number
      var alternate_no = req.body.alternate_no;
      // console.log(req.body.alternate_no)
      if (req.body.alternate_no) {
        alternate_no = req.body.alternate_no;
      }

      var car = null;
      if (req.body.variant) {
        car = req.body.variant;
      }

      var assignee = check.assignee;
      if (req.body.assignee) {
        assignee = req.body.assignee;
      }
      var checkUser = await User.findOneAndUpdate(
        { contact_no: req.body.contact_no, "account_info.type": "user" },
        {
          $set: {
            name: req.body.name,
            // email: req.body.email,
          },
        }
      ).exec();
      if (checkUser) {
        user = checkUser._id;
        name = req.body.name;
        // name = checkUser.name;
        contact_no = checkUser.contact_no;
        email = req.body.email;
      } else {
        user = null;
        name = req.body.name;
        contact_no = req.body.contact_no;
        email = req.body.email;
      }

      var leads = {};
      var data = {};

      // if (check.additional_info) {
      //     // console.log("Additional info exist");
      //     data = {
      //         user: user,
      //         name: req.body.name,
      //         contact_no: contact_no,
      //         email: req.body.email,
      //         "additional_info.alternate_no": alternate_no,                //Abhinav
      //         "additional_info.variant": alternate_no,                //Abhinav
      //         updated_at: new Date()
      //     }
      // } else {
      // console.log("Additional info not exist");

      // console.log("Name = " + name)
      data = {
        user: user,
        name: req.body.name,
        assignee: assignee,
        "additional_info.alternate_no": alternate_no,
        "additional_info.variant": car,
        contact_no: contact_no,
        email: req.body.email,
        // additional_info: additional_info,                //Abhinav
        updated_at: new Date(),
      };
      // }

      await Lead.findOneAndUpdate(
        { _id: check._id },
        { $set: data },
        { new: true },
        async function (err, doc) {
          var lead = await Lead.findById(req.body.lead)
            .populate("assignee")
            .exec();

          var a = await User.findById(lead.advisor).exec();
          var remark = await LeadRemark.findOne({ lead: lead._id })
            .sort({ created_at: -1 })
            .exec();
          var assignee = {
            name: lead.assignee.name,
            email: lead.assignee.email,
            contact_no: lead.assignee.contact_no,
            _id: lead.assignee._id,
            _id: lead.assignee._id,
          };

          if (a) {
            var advisor = {
              name: a.name,
              email: a.email,
              contact_no: a.contact_no,
              _id: a._id,
              _id: a._id,
            };
          } else {
            var advisor = null;
          }

          var push = {
            _id: lead._id,
            id: lead.id,
            user: lead.user,
            name: lead.name,
            contact_no: lead.contact_no,
            email: lead.email,
            _id: lead._id,
            id: lead.id,
            priority: lead.priority,
            contacted: lead.contacted,
            type: lead.type,
            lead_id: lead.lead_id,
            date: moment(lead.updated_at).tz(req.headers["tz"]).format("lll"),
            source: lead.source,
            status: lead.status,
            important: lead.important,
            follow_up: lead.follow_up,
            remark: lead.remark,
            assignee: assignee,
            advisor: advisor,
            // additional_info:{
            //     alternate_no:alternate_no

            // },
            created_at: moment(lead.created_at)
              .tz(req.headers["tz"])
              .format("lll"),
            updated_at: moment(lead.updated_at)
              .tz(req.headers["tz"])
              .format("lll"),
          };

          res.status(200).json({
            responseCode: 200,
            responseMessage: "Lead Updated ",
            responseData: push,
          });
        }
      );
    }
  } else {
    res.status(400).json({
      responseCode: 400,
      responseMessage: "Lead not found",
      responseData: {},
    });
  }
});

router.put(
  "/lead/assignee/update",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      lead: "required",
      assignee: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Label required",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var user = decoded.user;
      var business = req.headers["business"];
      var bookings = [];
      var totalResult = 0;
      var loggedInDetails = await User.findById(decoded.user).exec();
      var check = await Lead.findById(req.body.lead).exec();
      if (check) {
        var management = await Management.findOne({
          user: req.body.assignee,
          business: business,
        })
          .populate("user")
          .exec();
        if (management) {
          var leads = {};

          var data = {
            assignee: management.user._id,
            updated_at: new Date(),
          };

          Lead.findOneAndUpdate(
            { _id: check._id },
            { $set: data },
            { new: false },
            async function (err, doc) {
              if (err) {
                res.status(422).json({
                  responseCode: 422,
                  responseMessage: "Server Error",
                  responseData: err,
                });
              } else {
                var booking = await Booking.findOne({ lead: check._id })
                  .populate("manager")
                  .exec();
                if (booking) {
                  Booking.findOneAndUpdate(
                    { _id: booking._id },
                    {
                      $set: {
                        manager: management.user._id,
                        updated_at: new Date(),
                      },
                    },
                    { new: false },
                    async function (err, doc) {
                      if (err) {
                        return res.status(422).json({
                          responseCode: 422,
                          responseMessage: "Server Error",
                          responseData: err,
                        });
                      } else {
                        var activity =
                          management.user.name + " has been assigned";
                        if (booking.manager) {
                          activity =
                            booking.manager.name +
                            " has been replaced by " +
                            management.user.name;
                        }

                        var activity = {
                          user: loggedInDetails._id,
                          name: loggedInDetails.name,
                          stage: "Updates",
                          activity: activity,
                        };

                        fun.bookingLog(booking._id, activity);
                      }
                    }
                  );
                }

                LeadRemark.create({
                  lead: check._id,
                  status: check.remark.status,
                  assignee: loggedInDetails._id,
                  customer_remark: "Lead assigned to - " + management.user.name,
                  assignee_remark: "Lead assigned to - " + management.user.name,
                  created_at: new Date(),
                  updated_at: new Date(),
                }).then(function (newRemark) {
                  Lead.findOneAndUpdate(
                    { _id: check._id },
                    { $push: { remarks: newRemark._id } },
                    { new: true },
                    async function (err, doc) {}
                  );
                });

                var lead = await Lead.findById(req.body.lead)
                  .populate("assignee")
                  .exec();
                var a = await User.findById(lead.advisor).exec();
                var remark = await LeadRemark.findOne({ lead: lead._id })
                  .sort({ created_at: -1 })
                  .exec();
                var assignee = {
                  name: lead.assignee.name,
                  email: lead.assignee.email,
                  contact_no: lead.assignee.contact_no,
                  _id: lead.assignee._id,
                  _id: lead.assignee._id,
                };

                if (a) {
                  var advisor = {
                    name: a.name,
                    email: a.email,
                    contact_no: a.contact_no,
                    _id: a._id,
                    _id: a._id,
                  };
                } else {
                  var advisor = null;
                }

                var push = {
                  _id: lead._id,
                  id: lead.id,
                  user: lead.user,
                  name: lead.name,
                  contact_no: lead.contact_no,
                  email: lead.email,
                  _id: lead._id,
                  id: lead.id,
                  priority: lead.priority,
                  contacted: lead.contacted,
                  type: lead.type,
                  lead_id: lead.lead_id,
                  date: moment(lead.updated_at)
                    .tz(req.headers["tz"])
                    .format("lll"),
                  source: lead.source,
                  status: lead.status,
                  important: lead.important,
                  follow_up: lead.follow_up,
                  remark: lead.remark,
                  assignee: assignee,
                  advisor: advisor,
                  created_at: moment(lead.created_at)
                    .tz(req.headers["tz"])
                    .format("lll"),
                  updated_at: moment(lead.updated_at)
                    .tz(req.headers["tz"])
                    .format("lll"),
                };

                res.status(200).json({
                  responseCode: 200,
                  responseMessage: "Lead Added ",
                  responseData: push,
                });
              }
            }
          );
        } else {
          res.status(400).json({
            responseCode: 400,
            responseMessage: "User not found",
            responseData: {},
          });
        }
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Lead not found",
          responseData: {},
        });
      }
    }
  }
);

router.put(
  "/lead/remark/update",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers["business"];
    var bookings = [];
    var totalResult = 0;
    var rules = {
      lead: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Label required",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var role = await Management.findOne({
        user: user,
        business: business,
      }).exec();

      var lead = await Lead.findOne({
        business: business,
        _id: req.body.lead,
      }).exec();
      var loggedInDetails = await User.findById(decoded.user).exec();
      if (lead) {
        var advisor = null;
        if (lead.advisor) {
          advisor = lead.advisor;
        }
        var data = {};
        var follow_up = {};
        var status = await LeadStatus.findOne({
          status: req.body.status,
        }).exec();

        if (req.body.reason) {
          var reason = req.body.reason;
        } else {
          if (req.body.status == "Closed") {
            var reason = "Info Only";
          } else {
            var reason = "";
          }
        }

        if (req.body.status == "Follow-Up" || req.body.status == "PSF") {
          if (req.body.date) {
            var follow_up = {
              date: new Date(req.body.date).toISOString(),
              time: req.body.time,
              created_at: new Date(),
              updated_at: new Date(),
            };
          }
        }

        if (req.body.status == "Follow-Up") {
          if (req.body.date) {
            var follow_up = {
              date: new Date(req.body.date).toISOString(),
              time: req.body.time,
              created_at: new Date(),
              updated_at: new Date(),
            };
          }
        }

        if (req.body.advisor) {
          var checkAdvisor = await Management.findOne({
            user: req.body.advisor,
            business: business,
          }).exec();
          if (checkAdvisor) {
            var advisor = checkAdvisor.user;
          } else {
            return res.status(400).json({
              responseCode: 400,
              responseMessage: "Unauthorized",
              responseData: {},
            });
          }
        }

        data = {
          updated_at: new Date(),
          remark: {
            lead: lead._id,
            status: req.body.status,
            reason: reason,
            color_code: "",
            assignee: user,
            customer_remark: req.body.remark,
            assignee_remark: req.body.remark,
            created_at: new Date(),
            updated_at: new Date(),
          },
          advisor: advisor,
          follow_up: follow_up,
        };

        Lead.findOneAndUpdate(
          { _id: req.body.lead },
          { $set: data },
          { new: false },
          async function (err, doc) {
            if (err) {
              res.status(422).json({
                responseCode: 422,
                responseMessage: "Server Error",
                responseData: err,
              });
            } else {
              data.remark.lead = req.body.lead;
              data.created_at = new Date();

              LeadRemark.create(data.remark).then(function (newRemark) {
                Lead.findOneAndUpdate(
                  { _id: req.body.lead },
                  { $push: { remarks: newRemark._id } },
                  { new: true },
                  async function (err, doc) {}
                );
              });

              /*if(!loggedInDetails._id.equals(lead.assignee))
                    {
                        var notify = {
                            receiver: [lead.assignee],
                            activity: "lead",
                            tag: "RemarkUpdate",
                            source: req.body.lead,
                            sender: loggedInDetails._id,
                            points: 0
                        }

                        fun.newNotification(notify);
                    }*/

              var lead = await Lead.findById(req.body.lead)
                .populate("assignee")
                .exec();
              var a = await User.findById(lead.advisor).exec();

              var assignee = {
                name: lead.assignee.name,
                email: lead.assignee.email,
                contact_no: lead.assignee.contact_no,
                _id: lead.assignee._id,
                _id: lead.assignee._id,
              };

              if (a) {
                var advisor = {
                  name: a.name,
                  email: a.email,
                  contact_no: a.contact_no,
                  _id: a._id,
                  _id: a._id,
                };
              } else {
                var advisor = null;
              }

              var push = {
                user: lead.user,
                name: lead.name,
                contact_no: lead.contact_no,
                email: lead.email,
                _id: lead._id,
                id: lead.id,
                priority: lead.priority,
                contacted: lead.contacted,
                type: lead.type,
                lead_id: lead.lead_id,
                date: moment(lead.updated_at)
                  .tz(req.headers["tz"])
                  .format("lll"),
                source: lead.source,
                status: lead.status,
                important: lead.important,
                follow_up: lead.follow_up,
                remark: lead.remark,
                assignee: assignee,
                advisor: advisor,
                created_at: moment(lead.created_at)
                  .tz(req.headers["tz"])
                  .format("lll"),
                updated_at: moment(lead.updated_at)
                  .tz(req.headers["tz"])
                  .format("lll"),
              };

              res.status(200).json({
                responseCode: 200,
                responseMessage: "Lead Updated",
                responseData: push,
              });
            }
          }
        );
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Lead not found",
          responseData: {},
        });
      }
    }
  }
);

router.put(
  "/lead/priority/update",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers["business"];
    var bookings = [];
    var totalResult = 0;
    var rules = {
      lead: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Label required",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var check = await Lead.findOne({
        business: business,
        _id: req.body.lead,
      }).exec();
      if (check) {
        var data = {
          updated_at: new Date(),
          priority: parseInt(req.body.priority),
        };

        Lead.findOneAndUpdate(
          { _id: req.body.lead },
          { $set: data },
          { new: false },
          async function (err, doc) {
            if (err) {
              res.status(422).json({
                responseCode: 422,
                responseMessage: "Server Error",
                responseData: err,
              });
            } else {
              if (parseInt(req.body.priority) == 1) {
                var tag = "Low";
              } else if (parseInt(req.body.priority) == 2) {
                var tag = "Medium";
              } else if (parseInt(req.body.priority) == 3) {
                var tag = "High";
              }

              LeadRemark.create({
                lead: check._id,
                reason: check.remark.reason,
                status: check.remark.status,
                color_code: check.remark.color_code,
                assignee: user,
                customer_remark: "Priority changes to - " + tag,
                assignee_remark: "Priority changes to - " + tag,
                created_at: new Date(),
                updated_at: new Date(),
              }).then(function (newRemark) {
                Lead.findOneAndUpdate(
                  { _id: check._id },
                  { $push: { remarks: newRemark._id } },
                  { new: true },
                  async function (err, doc) {}
                );
              });

              res.status(200).json({
                responseCode: 200,
                responseMessage: "Lead Updated",
                responseData: {},
              });
            }
          }
        );
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Lead not found",
          responseData: {},
        });
      }
    }
  }
);

router.put(
  "/lead/category/update",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers["business"];
    var bookings = [];
    var totalResult = 0;
    var rules = {
      lead: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Label required",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var check = await Lead.findOne({
        business: business,
        _id: req.body.lead,
      }).exec();
      if (check) {
        var data = {
          updated_at: new Date(),
          category: req.body.category,
        };

        Lead.findOneAndUpdate(
          { _id: req.body.lead },
          { $set: data },
          { new: false },
          async function (err, doc) {
            if (err) {
              res.status(422).json({
                responseCode: 422,
                responseMessage: "Server Error",
                responseData: err,
              });
            } else {
              LeadRemark.create({
                lead: check._id,
                reason: check.remark.reason,
                status: check.remark.status,
                color_code: check.remark.color_code,
                assignee: user,
                customer_remark: "Category changes to - " + req.body.category,
                assignee_remark: "Category changes to - " + req.body.category,
                created_at: new Date(),
                updated_at: new Date(),
              }).then(function (newRemark) {
                Lead.findOneAndUpdate(
                  { _id: check._id },
                  { $push: { remarks: newRemark._id } },
                  { new: true },
                  async function (err, doc) {}
                );
              });

              res.status(200).json({
                responseCode: 200,
                responseMessage: "Lead Updated",
                responseData: {},
              });
            }
          }
        );
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Lead not found",
          responseData: {},
        });
      }
    }
  }
);

router.put(
  "/lead/contacted/update",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers["business"];
    var bookings = [];
    var totalResult = 0;
    var rules = {
      lead: "required",
      contacted: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Label required",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var check = await Lead.findOne({
        business: business,
        _id: req.body.lead,
      }).exec();
      if (check) {
        var data = {
          updated_at: new Date(),
          contacted: JSON.parse(req.body.contacted),
        };

        Lead.findOneAndUpdate(
          { _id: req.body.lead },
          { $set: data },
          { new: false },
          async function (err, doc) {
            if (err) {
              res.status(422).json({
                responseCode: 422,
                responseMessage: "Server Error",
                responseData: err,
              });
            } else {
              if (req.body.contacted == true) {
                var tag = "Contacted";
              } else {
                var tag = "Not Contacted";
              }

              LeadRemark.create({
                lead: check._id,
                reason: check.remark.reason,
                status: check.remark.status,
                color_code: check.remark.color_code,
                assignee: user,
                customer_remark: tag,
                assignee_remark: tag,
                created_at: new Date(),
                updated_at: new Date(),
              }).then(function (newRemark) {
                Lead.findOneAndUpdate(
                  { _id: check._id },
                  { $push: { remarks: newRemark._id } },
                  { new: true },
                  async function (err, doc) {}
                );
              });

              res.status(200).json({
                responseCode: 200,
                responseMessage: "Lead Updated",
                responseData: {},
              });
            }
          }
        );
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Lead not found",
          responseData: {},
        });
      }
    }
  }
);
router.get(
  "/leads/get/old",
  xAccessToken.token,
  async function (req, res, next) {
    // console.log('Route is called...', req.query.query, req.query.by);
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers["business"];
    // console.log('User = ', user, business);

    var bookings = [];
    var totalResult = 0;

    var role = await Management.findOne({
      user: user,
      business: business,
    }).exec();
    if (req.query.page == undefined) {
      var page = 0;
    } else {
      var page = req.query.page;
    }

    var page = Math.max(0, parseInt(page));
    var leads = [];
    var filters = [];
    var queries = {};

    if (req.query.query) {
      var specification = {};
      specification["$lookup"] = {
        from: "LeadRemark",
        localField: "remarks",
        foreignField: "_id",
        as: "remarks",
      };
      filters.push(specification);

      req.query.query = req.query.query.replace(
        /([.?*+^$[\]\\(){}|-])/g,
        "\\$1"
      );

      var specification = {};
      specification["$match"] = {
        business: mongoose.Types.ObjectId(business),
        $or: [
          { name: { $regex: req.query.query, $options: "i" } },
          { contact_no: { $regex: req.query.query, $options: "i" } },
          {
            remarks: {
              $elemMatch: {
                status: { $regex: req.query.query, $options: "i" },
              },
            },
          },
          {
            remarks: {
              $elemMatch: {
                customer_remark: { $regex: req.query.query, $options: "i" },
              },
            },
          },
          {
            remarks: {
              $elemMatch: {
                assignee_remark: { $regex: req.query.query, $options: "i" },
              },
            },
          },
        ],
      };

      filters.push(specification);
      var specification = {};
      specification["$skip"] = config.perPage * page;
      filters.push(specification);

      var specification = {};
      specification["$limit"] = config.perPage;
      filters.push(specification);

      await Lead.aggregate(filters)
        .allowDiskUse(true)
        .cursor({ batchSize: 20 })
        .exec()
        .eachAsync(async function (lead) {
          var remark = await LeadRemark.findOne({ lead: lead._id })
            .sort({ created_at: -1 })
            .exec();
          var assignee = await User.findById(lead.assignee).exec();

          if (assignee) {
            var a = {
              name: assignee.name,
              email: assignee.email,
              contact_no: assignee.contact_no,
              _id: assignee._id,
              _id: assignee._id,
            };
          } else {
            var a = {
              name: "",
              email: "",
              contact_no: "",
              _id: null,
              _id: null,
            };
          }

          if (lead.follow_up == null) {
            var follow_up = {};
          } else {
            follow_up = lead.follow_up;
          }

          var l = lead.remark;

          if (l) {
            if (l.assignee_remark == "") {
              l.assignee_remark = l.customer_remark;
            }
            var remark = {
              source: l.source,
              type: l.type,
              reason: l.reason,
              status: l.status,
              customer_remark: l.customer_remark,
              assignee_remark: l.assignee_remark,
              assignee: a,
              color_code: l.color_code,
              created_at: moment(l.created_at)
                .tz(req.headers["tz"])
                .format("lll"),
              updated_at: moment(l.updated_at)
                .tz(req.headers["tz"])
                .format("lll"),
            };
          }

          var b = await Booking.findOne({ lead: lead._id }).exec();
          var booking = null;
          if (b) {
            booking = b._id;
          }

          var category = "";
          if (lead.category) {
            category = lead.category;
          }

          var isStared = false;
          if (lead.isStared) {
            isStared = lead.isStared;
          } else {
            isStared = false;
          }
          // isStared : isStared,

          leads.push({
            booking: booking,
            user: lead.user,
            name: lead.name,
            contact_no: lead.contact_no,
            email: lead.email,
            _id: lead._id,
            id: lead.id,
            priority: lead.priority,
            contacted: lead.contacted,
            type: lead.type,
            lead_id: lead.lead_id,
            geometry: lead.geometry,
            date: moment(lead.updated_at).tz(req.headers["tz"]).format("lll"),
            status: lead.status,
            source: lead.source,
            important: lead.important,
            follow_up: follow_up,
            remark: remark,
            assignee: a,
            category: category,
            isStared: isStared,
            created_at: moment(lead.created_at)
              .tz(req.headers["tz"])
              .format("lll"),
            updated_at: moment(lead.updated_at)
              .tz(req.headers["tz"])
              .format("lll"),
          });
        });

      return res.status(200).json({
        responseCode: 200,
        responseInfo: {
          // filters: filters,
          msg: "Filter Leads",
          totalResult: leads.length,
        },
        responseMessage: "",
        totalLeads: leads.length,
        responseData: leads,
      });
    }

    filters = [];

    if (req.query.by == "filter") {
      if (role.role == "CRE") {
        var specification = {};
        specification["assignee"] = mongoose.Types.ObjectId(role.user);
        filters.push(specification);
        var specification = {};
        specification["business"] = mongoose.Types.ObjectId(business);
        filters.push(specification);
      }
      //Abhinav New Role
      else if (role.role == "cr_assignee") {
        var specification = {};
        specification["cr_assignee"] = mongoose.Types.ObjectId(role.user);
        filters.push(specification);
      }
      //End
      else {
        // console.log('checking the filter 2', business, role.user)

        var specification = {};
        specification["business"] = mongoose.Types.ObjectId(business);
        filters.push(specification);
      }

      if (req.query.status != "#") {
        if (req.query.status == "All") {
          var date = new Date();
          if (req.query.date) {
            date = new Date(req.query.date);
          }

          var specification = {};
          if (req.query.source) {
            specification["source"] = { $eq: req.query.source };
          }
          specification["created_at"] = { $lte: date };
          filters.push(specification);
        } else if (req.query.status == "Follow-Up") {
          var specification = {};
          specification["remark.status"] = req.query.status;

          specification["follow_up.date"] = { $lt: new Date() };

          if (req.query.source) {
            specification["source"] = { $eq: req.query.source };
          }

          if (req.query.date && req.query.endDate) {
            var date = new Date(req.query.date);
            //var newDate = moment(date, "DD-MM-YYYY").add(1, 'days').toDate();
            var endDate = new Date(req.query.endDate);
            // // console.log('Come inside follow-up status', date, endDate);
            specification["follow_up.date"] = {
              $gte: new Date(date),
              $lte: new Date(endDate),
            };
            // console.log('Checking the date filter', specification);
          } else {
          }
          // console.log("Follow ups")
          filters.push(specification);
        } else if (req.query.status == "Open") {
          var specification = {};
          specification["remark.status"] = req.query.status;
          // console.log('Created object ......', specification);
          if (req.query.source) {
            // console.log('Source testing', req.query.source)
            specification["source"] = { $eq: req.query.source };
          }
          if (req.query.date) {
            var date = new Date(req.query.date);
            //var newDate = moment(date, "DD-MM-YYYY").add(1, 'days').toDate();
            var endDate = new Date(req.query.endDate);
            // console.log('Come inside follow-up status', date, endDate);
            specification["updated_at"] = {
              $gte: new Date(date),
              $lte: new Date(endDate),
            };
            // console.log('Checking the open filter', specification);
          }

          filters.push(specification);
        } else if (req.query.status == "PSF") {
          var specification = {};
          specification["remark.status"] = req.query.status;
          if (req.query.source) {
            specification["source"] = { $eq: req.query.source };
          }
          var specification = {};
          // var dateString = moment(new Date()).tz(req.headers['tz']).format('YYYY-MM-DD , h:mm:ss a');
          // console.log("Dtae By Filter = " + dateString)
          specification["remark.status"] = req.query.status;
          specification["follow_up.date"] = { $lte: new Date() };
          // filters.push(specification);
          if (req.query.date && req.query.endDate) {
            var date = new Date(req.query.date);
            //var newDate = moment(date, "DD-MM-YYYY").add(1, 'days').toDate();
            var endDate = new Date(req.query.endDate);
            // specification['remark.created_at'] = { $gte: new Date(date), $lte: new Date(endDate) };
            specification["follow_up.date"] = {
              $gte: new Date(date),
              $lte: new Date(endDate),
            };
            // // console.log("PSF Date = " + date + " End Date = " + endDate)
          }

          filters.push(specification);
        } else if (req.query.status == "Closed") {
          // console.log('Close lead is called........', req.query.status)
          var specification = {};
          specification["remark.status"] = req.query.status;
          if (req.query.source) {
            specification["source"] = { $eq: req.query.source };
          }
          if (req.query.date) {
            var date = new Date(req.query.date);
            //var newDate = moment(date, "DD-MM-YYYY").add(1, 'days');
            var endDate = new Date(req.query.endDate);
            specification["remark.created_at"] = {
              $gte: new Date(date),
              $lt: new Date(endDate),
            };
          }

          if (req.query.reason) {
            // console.log('remark reason', req.query.reason)
            specification["remark.reason"] = req.query.reason;
          }

          filters.push(specification);
        } else if (req.query.status == "Rework") {
          // console.log('Close lead is called........', req.query.status)
          var specification = {};
          specification["remark.status"] = req.query.status;
          if (req.query.source) {
            specification["source"] = { $eq: req.query.source };
          }
          if (req.query.date) {
            var date = new Date(req.query.date);
            //var newDate = moment(date, "DD-MM-YYYY").add(1, 'days');
            var endDate = new Date(req.query.endDate);
            specification["remark.created_at"] = {
              $gte: new Date(date),
              $lt: new Date(endDate),
            };
          }

          if (req.query.reason) {
            // console.log('remark reason', req.query.reason)
            specification["remark.reason"] = req.query.reason;
          }

          filters.push(specification);
        } else if (req.query.status == "Dissatisfied") {
          // console.log('Close lead is called........', req.query.status)
          var specification = {};
          specification["remark.reason"] = req.query.status;
          specification["remark.status"] = "Closed";

          if (req.query.source) {
            specification["source"] = { $eq: req.query.source };
          }
          if (req.query.date) {
            var date = new Date(req.query.date);
            //var newDate = moment(date, "DD-MM-YYYY").add(1, 'days');
            var endDate = new Date(req.query.endDate);
            specification["remark.created_at"] = {
              $gte: new Date(date),
              $lt: new Date(endDate),
            };
          }

          filters.push(specification);
        } else if (req.query.status == "Satisfied") {
          // console.log('Close lead is called........', req.query.status)
          var specification = {};
          specification["remark.reason"] = req.query.status;
          specification["remark.status"] = "Closed";
          if (req.query.source) {
            specification["source"] = { $eq: req.query.source };
          }
          if (req.query.date) {
            var date = new Date(req.query.date);
            //var newDate = moment(date, "DD-MM-YYYY").add(1, 'days');
            var endDate = new Date(req.query.endDate);
            specification["remark.created_at"] = {
              $gte: new Date(date),
              $lt: new Date(endDate),
            };
          }

          filters.push(specification);
        } else if (req.query.status == "Lost") {
          // console.log('Lost date filter is called....')
          var specification = {};
          var date = new Date();
          specification["remark.status"] = req.query.status;
          if (req.query.source) {
            specification["source"] = { $eq: req.query.source };
          }
          if (req.query.date) {
            var date = new Date(req.query.date);
            //var newDate = moment(date, "DD-MM-YYYY").add(1, 'days');
            // Changes made by me
            var endDate = new Date(req.query.endDate);
            specification["remark.updated_at"] = {
              $gte: new Date(date),
              $lt: new Date(endDate),
            };
          }

          if (req.query.reason) {
            specification["remark.reason"] = req.query.reason;
          }
          if (req.query.source) {
            specification["source"] = req.query.source;
          }

          filters.push(specification);
        } else if (req.query.status == "EstimateRequested") {
          var specification = {};
          specification["remark.status"] = req.query.status;
          // console.log('Created object ......', specification);
          if (req.query.source) {
            // console.log('Source testing', req.query.source)
            specification["source"] = { $eq: req.query.source };
          }
          if (req.query.date) {
            var date = new Date(req.query.date);
            //var newDate = moment(date, "DD-MM-YYYY").add(1, 'days').toDate();
            var endDate = new Date(req.query.endDate);
            // console.log('Come inside follow-up status', date, endDate);
            specification["updated_at"] = {
              $gte: new Date(date),
              $lte: new Date(endDate),
            };
            // console.log('Checking the open filter', specification);
          }
          filters.push(specification);
        } else if (req.query.status == "Approval") {
          var specification = {};
          specification["remark.status"] = req.query.status;
          // console.log('Created object ......', specification);
          if (req.query.source) {
            // console.log('Source testing', req.query.source)
            specification["source"] = { $eq: req.query.source };
          }
          if (req.query.date) {
            var date = new Date(req.query.date);
            //var newDate = moment(date, "DD-MM-YYYY").add(1, 'days').toDate();
            var endDate = new Date(req.query.endDate);
            // console.log('Come inside follow-up status', date, endDate);
            specification["updated_at"] = {
              $gte: new Date(date),
              $lte: new Date(endDate),
            };
            // console.log('Checking the open filter', specification);
          }
          filters.push(specification);
        }
      }
      if (req.query.priority) {
        var priority = parseInt(req.query.priority);
        if (priority == 0) {
          var specification = {};
          specification["priority"] = { $in: [1, 2, 3] };
          filters.push(specification);
        } else {
          var specification = {};
          specification["priority"] = priority;
          filters.push(specification);
        }
      }

      var query = {
        $match: {
          $and: filters,
        },
      };
      // console.log('Filters', filters);
    } else {
      if (role.role == "CRE") {
        var specification = {};
        specification["assignee"] = mongoose.Types.ObjectId(role.user);
        filters.push(specification);
        var specification = {};
        specification["business"] = mongoose.Types.ObjectId(business);
        filters.push(specification);
      } else {
        var specification = {};
        specification["business"] = mongoose.Types.ObjectId(business);

        filters.push(specification);
      }

      if (req.query.status != "#") {
        var status = req.query.status;
        if (status == "All") {
          var specification = {};
          specification["business"] = mongoose.Types.ObjectId(business);
          var specification = {};
          var dateString = moment(new Date())
            .tz(req.headers["tz"])
            .format("YYYY-MM-DD");
          specification["follow_up.date"] = { $lt: new Date() };
          filters.push(specification);
          // console.log('Without filter query called......');
        } else if (status == "Follow-Up") {
          var specification = {};
          specification["business"] = mongoose.Types.ObjectId(business);
          var specification = {};
          var dateString = moment(new Date())
            .tz(req.headers["tz"])
            .format("YYYY-MM-DD");
          specification["remark.status"] = req.query.status;
          specification["follow_up.date"] = { $lt: new Date() };
          filters.push(specification);
          // console.log("Without filters")
        } else if (status == "PSF") {
          var specification = {};
          specification["business"] = mongoose.Types.ObjectId(business);

          var specification = {};
          var dateString = moment(new Date())
            .tz(req.headers["tz"])
            .format("YYYY-MM-DD");
          specification["remark.status"] = req.query.status;
          // console.log("Date  - = = =" + new Date().toISOString())
          specification["follow_up.date"] = { $lte: new Date() };
          filters.push(specification);
        } else {
          var specification = {};
          specification["business"] = mongoose.Types.ObjectId(business);
          var specification = {};
          specification["remark.status"] = status;
          filters.push(specification);
        }
      }

      var query = {
        $match: {
          $and: filters,
        },
      };
    }

    // console.log('Final status', req.query.status)

    var total = await Lead.aggregate([query]).exec();
    // console.log('Total Length of the leads...', total.length);
    // Changes by vinay
    var sortQuery = {};
    if (req.query.status == "Follow-Up") {
      sortQuery = { $sort: { "follow_up.date": -1 } };
    } else if (
      req.query.status == "Lost" ||
      req.query.status == "Closed" ||
      req.query.status == "PSF"
    ) {
      sortQuery = { $sort: { "remark.created_at": -1 } };
    } else if (req.query.status == "Open") {
      sortQuery = { $sort: { updated_at: -1 } };
    } else if (req.query.status == "All") {
      sortQuery = { $sort: { updated_at: -1 } };
    } else {
      sortQuery = { $sort: { created_at: -1 } };
    }

    await Lead.aggregate([query, sortQuery, { $skip: 5 * page }, { $limit: 5 }])
      .allowDiskUse(true)
      .cursor({ batchSize: 20 })
      .exec()
      .eachAsync(async function (lead) {
        var remark = await LeadRemark.findOne({ lead: lead._id })
          .sort({ created_at: -1 })
          .exec();
        var assignee = await User.findById(lead.assignee).exec();

        if (assignee) {
          var a = {
            name: assignee.name,
            email: assignee.email,
            contact_no: assignee.contact_no,
            _id: assignee._id,
            _id: assignee._id,
          };
        } else {
          var a = {
            name: "",
            email: "",
            contact_no: "",
            _id: null,
            _id: null,
          };
        }

        if (lead.follow_up == null) {
          var follow_up = {};
        } else {
          follow_up = lead.follow_up;
        }

        var l = lead.remark;

        if (l) {
          if (l.assignee_remark == "") {
            l.assignee_remark = l.customer_remark;
          }
          var remark = {
            source: l.source,
            type: l.type,
            reason: l.reason,
            status: l.status,
            customer_remark: l.customer_remark,
            assignee_remark: l.assignee_remark,
            assignee: a,
            color_code: l.color_code,
            created_at: moment(l.created_at)
              .tz(req.headers["tz"])
              .format("lll"),
            updated_at: moment(l.updated_at)
              .tz(req.headers["tz"])
              .format("lll"),
          };
        }

        var b = await Booking.findOne({ lead: lead._id }).exec();
        var booking = null;
        if (b) {
          booking = b._id;
        }

        var category = "";
        if (lead.category) {
          category = lead.category;
        }
        var isStared = false;
        if (lead.isStared) {
          isStared = lead.isStared;
        } else {
          isStared = false;
        }
        // isStared : isStared,
        leads.push({
          booking: booking,
          user: lead.user,
          name: lead.name,
          contact_no: lead.contact_no,
          email: lead.email,
          _id: lead._id,
          id: lead.id,
          priority: lead.priority,
          contacted: lead.contacted,
          type: lead.type,
          lead_id: lead.lead_id,
          geometry: lead.geometry,
          date: moment(lead.updated_at).tz(req.headers["tz"]).format("lll"),
          status: lead.status,
          source: lead.source,
          important: lead.important,
          follow_up: follow_up,
          remark: remark,
          assignee: a,
          // time: time,
          isStared: isStared,
          category: category,
          created_at: moment(lead.created_at)
            .tz(req.headers["tz"])
            .format("lll"),
          updated_at: moment(lead.updated_at)
            .tz(req.headers["tz"])
            .format("lll"),
        });
      });

    res.status(200).json({
      responseCode: 200,
      responseInfo: {
        filters: filters,
        totalResult: total.length,
      },
      responseMessage: role.role + " Leads",
      totalLeads: leads.length,
      responseData: leads,
    });
  }
);
router.get("/leads/get", xAccessToken.token, async function (req, res, next) {
  // console.log('Route is called...', req.query.query, req.query.by);
  var token = req.headers["x-access-token"];
  var secret = config.secret;
  var decoded = jwt.verify(token, secret);
  var user = decoded.user;
  var business = req.headers["business"];
  // console.log('User = ', user, business);

  var bookings = [];
  var totalResult = 0;

  var role = await Management.findOne({
    user: user,
    business: business,
  }).exec();
  if (req.query.page == undefined) {
    var page = 0;
  } else {
    var page = req.query.page;
  }

  var page = Math.max(0, parseInt(page));
  var leads = [];
  var filters = [];
  var queries = {};

  if (req.query.query) {
    var specification = {};
    specification["$lookup"] = {
      from: "LeadRemark",
      localField: "remarks",
      foreignField: "_id",
      as: "remarks",
    };
    filters.push(specification);

    req.query.query = req.query.query.replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1");

    var specification = {};
    specification["$match"] = {
      business: mongoose.Types.ObjectId(business),
      $or: [
        { name: { $regex: req.query.query, $options: "i" } },
        { contact_no: { $regex: req.query.query, $options: "i" } },
        {
          remarks: {
            $elemMatch: {
              status: { $regex: req.query.query, $options: "i" },
            },
          },
        },
        {
          remarks: {
            $elemMatch: {
              customer_remark: { $regex: req.query.query, $options: "i" },
            },
          },
        },
        {
          remarks: {
            $elemMatch: {
              assignee_remark: { $regex: req.query.query, $options: "i" },
            },
          },
        },
      ],
    };

    filters.push(specification);

    await Lead.aggregate(filters)
      .allowDiskUse(true)
      .cursor({ batchSize: 20 })
      .exec()
      .eachAsync(async function (lead) {
        var remark = await LeadRemark.findOne({ lead: lead._id })
          .sort({ created_at: -1 })
          .exec();
        var assignee = await User.findById(lead.assignee).exec();

        if (assignee) {
          var a = {
            name: assignee.name,
            email: assignee.email,
            contact_no: assignee.contact_no,
            _id: assignee._id,
            _id: assignee._id,
          };
        } else {
          var a = {
            name: "",
            email: "",
            contact_no: "",
            _id: null,
            _id: null,
          };
        }

        if (lead.follow_up == null) {
          var follow_up = {};
        } else {
          follow_up = lead.follow_up;
        }

        var l = lead.remark;

        if (l) {
          if (l.assignee_remark == "") {
            l.assignee_remark = l.customer_remark;
          }
          var remark = {
            source: l.source,
            type: l.type,
            reason: l.reason,
            status: l.status,
            customer_remark: l.customer_remark,
            assignee_remark: l.assignee_remark,
            assignee: a,
            color_code: l.color_code,
            created_at: moment(l.created_at)
              .tz(req.headers["tz"])
              .format("lll"),
            updated_at: moment(l.updated_at)
              .tz(req.headers["tz"])
              .format("lll"),
          };
        }

        var b = await Booking.findOne({ lead: lead._id }).exec();
        var booking = null;
        if (b) {
          booking = b._id;
        }

        var category = "";
        if (lead.category) {
          category = lead.category;
        }

        var isStared = false;
        if (lead.isStared) {
          isStared = lead.isStared;
        } else {
          isStared = false;
        }
        // isStared : isStared,
        var date = "";
        if (follow_up.date != null) {
          date = moment(follow_up.date)
            .tz(req.headers["tz"])
            .format("DD-MM-YYYY");
        }

        leads.push({
          // booking: booking,
          // user: lead.user,
          name: lead.name,
          contact_no: lead.contact_no,
          // email: lead.email,
          _id: lead._id,
          // id: lead.id,
          priority: lead.priority,
          // contacted: lead.contacted,
          // type: lead.type,
          lead_id: lead.lead_id,
          // geometry: lead.geometry,
          // date: moment(lead.updated_at).tz(req.headers['tz']).format('lll'),
          status: remark.status,
          source: lead.source,
          manager: a.name,
          // important: lead.important,
          // follow_up: date + " " + follow_up.time,
          follow_up_date: date,
          // follow_up_time: follow_up.time,
          // remark: remark,
          // assignee: a,
          // time: time,
          // isStared: isStared,
          // category: category,
          isOutbound: isOutbound,
          created_at: moment(lead.created_at)
            .tz(req.headers["tz"])
            .format("DD-MM-YYYY"),
          // updated_at: moment(lead.updated_at).tz(req.headers['tz']).format('lll'),
        });
      });

    return res.status(200).json({
      responseCode: 200,
      responseInfo: {
        // filters: filters,
        msg: "Filter Leads",
        totalResult: leads.length,
      },
      responseMessage: "",
      totalLeads: leads.length,
      responseData: leads,
    });
  }

  filters = [];

  if (req.query.by == "filter") {
    if (role.role == "CRE") {
      var specification = {};
      specification["assignee"] = mongoose.Types.ObjectId(role.user);
      filters.push(specification);
      var specification = {};
      specification["business"] = mongoose.Types.ObjectId(business);
      filters.push(specification);
    } else if (role.role == "Admin" || role.role == "Manager") {
      // console.log('checking the filter 2', business, role.user)
      var specification = {};
      specification["business"] = mongoose.Types.ObjectId(business);
      filters.push(specification);
    } else {
      var specification = {};
      specification["assignee"] = mongoose.Types.ObjectId(role.user);
      filters.push(specification);
      var specification = {};
      specification["business"] = mongoose.Types.ObjectId(business);
      filters.push(specification);
    }

    if (req.query.status != "#") {
      if (req.query.status == "All") {
        var date = new Date();
        if (req.query.date) {
          date = new Date(req.query.date);
        }

        var specification = {};
        if (req.query.source) {
          specification["source"] = { $eq: req.query.source };
        }
        specification["created_at"] = { $lte: date };
        filters.push(specification);
      } else if (req.query.status == "Follow-Up") {
        var specification = {};
        specification["remark.status"] = req.query.status;
        // else if (status == "Follow-Up") {
        // var specification = {};
        // specification["business"] = mongoose.Types.ObjectId(business)
        // var specification = {};
        // var dateString = moment(new Date()).tz(req.headers['tz']).format('YYYY-MM-DD');
        // specification["remark.status"] = req.query.status;
        specification["follow_up.date"] = { $lt: new Date() };
        // filters.push(specification);
        // }
        // console.log('Created object ......', specification);
        /*
                    Code made by vinay
                    Update: Add date range filter
                    updatedVariables: endDate
                    updatedQuery: $lt: new Date(endDate)
                */
        if (req.query.source) {
          specification["source"] = { $eq: req.query.source };
        }

        if (req.query.date && req.query.endDate) {
          var date = new Date(req.query.date);
          //var newDate = moment(date, "DD-MM-YYYY").add(1, 'days').toDate();
          var endDate = new Date(req.query.endDate);
          // console.log('Come inside follow-up status', date, endDate);
          specification["follow_up.date"] = {
            $gte: new Date(date),
            $lte: new Date(endDate),
          };
          // console.log('Checking the date filter', specification);
        } else {
          // let todayDate = new Date();
          // let futureDate = new Date();
          // futureDate.setDate(futureDate.getDate() + 1)
          // // todayDate.setDate(todayDate.getDate() - 1)
          // // specification['follow_up.date'] = { $gte: todayDate, $lt: futureDate };
          // specification['follow_up.date'] = { $lte: futureDate };
        }
        // console.log("Follow ups")
        filters.push(specification);
      } else if (req.query.status == "Open") {
        var specification = {};
        specification["remark.status"] = req.query.status;
        // console.log('Created object ......', specification);
        if (req.query.source) {
          // console.log('Source testing', req.query.source)
          specification["source"] = { $eq: req.query.source };
        }
        if (req.query.date) {
          var date = new Date(req.query.date);
          //var newDate = moment(date, "DD-MM-YYYY").add(1, 'days').toDate();
          var endDate = new Date(req.query.endDate);
          // console.log('Come inside follow-up status', date, endDate);
          specification["updated_at"] = {
            $gte: new Date(date),
            $lte: new Date(endDate),
          };
          // console.log('Checking the open filter', specification);
        }

        filters.push(specification);
      } else if (req.query.status == "PSF") {
        var specification = {};
        specification["remark.status"] = req.query.status;
        if (req.query.source) {
          specification["source"] = { $eq: req.query.source };
        }
        var specification = {};
        // var dateString = moment(new Date()).tz(req.headers['tz']).format('YYYY-MM-DD , h:mm:ss a');
        // console.log("Dtae By Filter = " + dateString)
        specification["remark.status"] = req.query.status;
        specification["follow_up.date"] = { $lte: new Date() };
        // filters.push(specification);
        if (req.query.date && req.query.endDate) {
          var date = new Date(req.query.date);
          //var newDate = moment(date, "DD-MM-YYYY").add(1, 'days').toDate();
          var endDate = new Date(req.query.endDate);
          // specification['remark.created_at'] = { $gte: new Date(date), $lte: new Date(endDate) };
          specification["follow_up.date"] = {
            $gte: new Date(date),
            $lte: new Date(endDate),
          };
          // console.log("PSF Date = " + date + " End Date = " + endDate)
        }

        filters.push(specification);
      } else if (req.query.status == "Closed") {
        // console.log('Close lead is called........', req.query.status)
        var specification = {};
        specification["remark.status"] = req.query.status;
        if (req.query.source) {
          specification["source"] = { $eq: req.query.source };
        }
        if (req.query.date) {
          var date = new Date(req.query.date);
          //var newDate = moment(date, "DD-MM-YYYY").add(1, 'days');
          var endDate = new Date(req.query.endDate);
          specification["remark.created_at"] = {
            $gte: new Date(date),
            $lt: new Date(endDate),
          };
        }

        if (req.query.reason) {
          // console.log('remark reason', req.query.reason)
          specification["remark.reason"] = req.query.reason;
        }

        filters.push(specification);
      } else if (req.query.status == "Lost") {
        // console.log('Lost date filter is called....')
        var specification = {};
        var date = new Date();
        specification["remark.status"] = req.query.status;
        if (req.query.source) {
          specification["source"] = { $eq: req.query.source };
        }
        if (req.query.date) {
          var date = new Date(req.query.date);
          //var newDate = moment(date, "DD-MM-YYYY").add(1, 'days');
          // Changes made by me
          var endDate = new Date(req.query.endDate);
          specification["remark.updated_at"] = {
            $gte: new Date(date),
            $lt: new Date(endDate),
          };
        }

        if (req.query.reason) {
          specification["remark.reason"] = req.query.reason;
        }
        if (req.query.source) {
          specification["source"] = req.query.source;
        }

        filters.push(specification);
      } else if (req.query.status == "EstimateRequested") {
        var specification = {};
        specification["remark.status"] = req.query.status;

        // console.log('Created object ......', specification);
        if (req.query.source) {
          // console.log('Source testing', req.query.source)
          specification["source"] = { $eq: req.query.source };
        }
        if (req.query.date) {
          var date = new Date(req.query.date);
          //var newDate = moment(date, "DD-MM-YYYY").add(1, 'days').toDate();
          var endDate = new Date(req.query.endDate);
          // console.log('Come inside follow-up status', date, endDate);
          specification["updated_at"] = {
            $gte: new Date(date),
            $lte: new Date(endDate),
          };
          // console.log('Checking the open filter', specification);
        }
        filters.push(specification);
      } else if (req.query.status == "Approval") {
        var specification = {};
        specification["remark.status"] = req.query.status;
        // console.log('Created object ......', specification);
        if (req.query.source) {
          // console.log('Source testing', req.query.source)
          specification["source"] = { $eq: req.query.source };
        }
        if (req.query.date) {
          var date = new Date(req.query.date);
          //var newDate = moment(date, "DD-MM-YYYY").add(1, 'days').toDate();
          var endDate = new Date(req.query.endDate);
          // console.log('Come inside follow-up status', date, endDate);
          specification["updated_at"] = {
            $gte: new Date(date),
            $lte: new Date(endDate),
          };
          // console.log('Checking the open filter', specification);
        }
        filters.push(specification);
      }
      //  else if (req.query.status == "Confirmed") {
      //     var specification = {};
      //     specification["remark.status"] = req.query.status;
      //     // console.log('Created object ......', specification);
      //     if (req.query.source) {
      //         // console.log('Source testing', req.query.source)
      //         specification['source'] = { $eq: req.query.source }
      //     }
      //     if (req.query.date) {
      //         var date = new Date(req.query.date);
      //         //var newDate = moment(date, "DD-MM-YYYY").add(1, 'days').toDate();
      //         var endDate = new Date(req.query.endDate);
      //         // console.log('Come inside follow-up status', date, endDate);
      //         specification['updated_at'] = { $gte: new Date(date), $lte: new Date(endDate) };
      //         // console.log('Checking the open filter', specification);
      //     }
      //     filters.push(specification);
      // } else if (req.query.status == "Missed") {
      //     var specification = {};
      //     specification["remark.status"] = 'Confirmed';
      //     // console.log('Created object ......', specification);
      //     if (req.query.source) {
      //         // console.log('Source testing', req.query.source)
      //         specification['source'] = { $eq: req.query.source }
      //     }
      //     if (req.query.date) {
      //         var date = new Date(req.query.date);
      //         //var newDate = moment(date, "DD-MM-YYYY").add(1, 'days').toDate();
      //         var endDate = new Date(req.query.endDate);
      //         // console.log('Come inside follow-up status', date, endDate);
      //         specification['updated_at'] = { $gte: new Date(date), $lte: new Date(endDate) };
      //         // console.log('Checking the open filter', specification);
      //     }
      //     filters.push(specification);
      // }
    }
    if (req.query.priority) {
      var priority = parseInt(req.query.priority);
      if (priority == 0) {
        var specification = {};
        specification["priority"] = { $in: [1, 2, 3] };
        filters.push(specification);
      } else {
        var specification = {};
        specification["priority"] = priority;
        filters.push(specification);
      }
    }

    var query = {
      $match: {
        $and: filters,
      },
    };
    // console.log('Filters', filters);
  } else {
    if (role.role == "CRE") {
      var specification = {};
      specification["assignee"] = mongoose.Types.ObjectId(role.user);
      filters.push(specification);
      var specification = {};
      specification["business"] = mongoose.Types.ObjectId(business);
      filters.push(specification);
    } else if (role.role == "Admin" || role.role == "Manager") {
      var specification = {};
      specification["business"] = mongoose.Types.ObjectId(business);
      filters.push(specification);
    } else {
      var specification = {};
      specification["assignee"] = mongoose.Types.ObjectId(role.user);
      filters.push(specification);
    }

    if (req.query.status != "#") {
      var status = req.query.status;
      if (status == "All") {
        var specification = {};
        specification["business"] = mongoose.Types.ObjectId(business);
        var specification = {};
        var dateString = moment(new Date())
          .tz(req.headers["tz"])
          .format("YYYY-MM-DD");
        specification["follow_up.date"] = { $lt: new Date() };
        filters.push(specification);
        // console.log('Without filter query called......');
      } else if (status == "Follow-Up") {
        var specification = {};
        specification["business"] = mongoose.Types.ObjectId(business);
        var specification = {};
        var dateString = moment(new Date())
          .tz(req.headers["tz"])
          .format("YYYY-MM-DD");
        specification["remark.status"] = req.query.status;
        specification["follow_up.date"] = { $lt: new Date() };
        filters.push(specification);
        // console.log("Without filters")
      } else if (status == "PSF") {
        var specification = {};
        specification["business"] = mongoose.Types.ObjectId(business);

        var specification = {};
        var dateString = moment(new Date())
          .tz(req.headers["tz"])
          .format("YYYY-MM-DD");
        specification["remark.status"] = req.query.status;
        // console.log("Date  - = = =" + new Date().toISOString())
        specification["follow_up.date"] = { $lte: new Date() };
        filters.push(specification);
      } else {
        var specification = {};
        specification["business"] = mongoose.Types.ObjectId(business);
        var specification = {};
        specification["remark.status"] = status;
        filters.push(specification);
      }
    }

    var query = {
      $match: {
        $and: filters,
      },
    };
  }

  // console.log('Final status', req.query.status)

  var total = await Lead.aggregate([query]).exec();
  // console.log('Total Length of the leads...', total.length);
  // Changes by vinay
  var sortQuery = {};
  if (req.query.status == "Follow-Up") {
    sortQuery = { $sort: { "follow_up.date": -1 } };
  } else if (req.query.status == "PSF") {
    sortQuery = { $sort: { "follow_up.date": -1 } };
  } else if (req.query.status == "Lost" || req.query.status == "Closed") {
    sortQuery = { $sort: { "remark.created_at": -1 } };
  } else if (req.query.status == "Open") {
    sortQuery = { $sort: { updated_at: -1 } };
  } else if (req.query.status == "All") {
    sortQuery = { $sort: { updated_at: -1 } };
  } else {
    sortQuery = { $sort: { created_at: -1 } };
  }
  var totalCounts = 0;
  await Lead.aggregate([query, sortQuery, { $skip: 10 * page }, { $limit: 10 }])
    .allowDiskUse(true)
    .cursor({ batchSize: 20 })
    .exec()
    .eachAsync(async function (lead) {
      var remark = await LeadRemark.findOne({ lead: lead._id })
        .sort({ created_at: -1 })
        .exec();
      var assignee = await User.findById(lead.assignee).exec();

      if (assignee) {
        var a = {
          name: assignee.name,
          email: assignee.email,
          contact_no: assignee.contact_no,
          _id: assignee._id,
          _id: assignee._id,
        };
      } else {
        var a = {
          name: "",
          email: "",
          contact_no: "",
          _id: null,
          _id: null,
        };
      }

      if (lead.follow_up == null) {
        var follow_up = {};
      } else {
        follow_up = lead.follow_up;
      }

      var l = lead.remark;

      if (l) {
        if (l.assignee_remark == "") {
          l.assignee_remark = l.customer_remark;
        }
        var remark = {
          source: l.source,
          type: l.type,
          reason: l.reason,
          status: l.status,
          customer_remark: l.customer_remark,
          assignee_remark: l.assignee_remark,
          assignee: a,
          color_code: l.color_code,
          created_at: moment(l.created_at).tz(req.headers["tz"]).format("lll"),
          updated_at: moment(l.updated_at).tz(req.headers["tz"]).format("lll"),
        };
      }

      var b = await Booking.findOne({ lead: lead._id }).exec();

      var booking = null;
      var isOutbound = false;
      if (b) {
        booking = b._id;
        isOutbound = b.isOutbound;
        // console.log("Booking Outbound = " + b.isOutbound)
      }

      var category = "";
      if (lead.category) {
        category = lead.category;
      }
      var isStared = false;
      if (lead.isStared) {
        isStared = lead.isStared;
      } else {
        isStared = false;
      }
      // isStared : isStared,

      var outbound = await Booking.find({
        isOutbound: true,
        status: "EstimateRequested",
      })
        .count()
        .exec();
      totalCounts = total.length - outbound;
      // || req.query.status == "Missed"

      // if (req.query.status == "Confirmed" || req.query.status == "Missed") {
      //     if (b) {
      //         var serverTime = moment.tz(new Date(), req.headers['tz']);
      //         var bar = moment.tz(new Date(b.date), req.headers['tz']);
      //         var baz = bar.diff(serverTime);
      //         // console.log('Server Time = ' + serverTime)
      //         // console.log('bar Time = ' + bar)
      //         // console.log('baz Time = ' + baz)
      //         var manager = { $ne: null }
      //         if (role.role == "CRE") {
      //             manager = assignee._id
      //         }
      //         if (baz > 0 && req.query.status == "Confirmed" && !b.isOutbound) {
      //             // new Date().getDate() - 1
      //             totalCounts = await Booking.find({ status: 'Confirmed', business: business, isOutbound: false, manager: manager, date: { $lt: new Date() } }).count().exec();
      //             // console.log("Status Updated  = " + b.status)
      //             // var confirmedBooking = await Booking.find({ status: 'Confirmed', business: business, isOutbound: false, manager: manager, date: { $lt: new Date() } }).exec()
      //             // for (var bb = 0; bb < confirmedBooking.length; bb++) {

      //             //     // console.log("Lead Upadted " + confirmedBooking[bb].lead)
      //             //     if (confirmedBooking[bb].status == 'Confirmed') {
      //             //         await Lead.findOneAndUpdate({ _id: confirmedBooking[bb].lead }, { $set: { 'remark.status': 'Confirmed' } }).exec();
      //             //     }
      //             // }

      //             // console.log("ToataL Confiremd Result = " + totalCounts)
      //             leads.push({
      //                 booking: booking,
      //                 user: lead.user,
      //                 name: lead.name,
      //                 contact_no: lead.contact_no,
      //                 email: lead.email,
      //                 _id: lead._id,
      //                 id: lead.id,
      //                 priority: lead.priority,
      //                 contacted: lead.contacted,
      //                 type: lead.type,
      //                 lead_id: lead.lead_id,
      //                 geometry: lead.geometry,
      //                 date: moment(lead.updated_at).tz(req.headers['tz']).format('lll'),
      //                 status: lead.status,
      //                 source: lead.source,
      //                 important: lead.important,
      //                 follow_up: follow_up,
      //                 remark: remark,
      //                 assignee: a,
      //                 // time: time,
      //                 isStared: isStared,
      //                 category: category,
      //                 isOutbound: isOutbound,
      //                 created_at: moment(lead.created_at).tz(req.headers['tz']).format('lll'),
      //                 updated_at: moment(lead.updated_at).tz(req.headers['tz']).format('lll'),
      //             });
      //         } else if (baz <= 0 && req.query.status == "Missed" && !b.isOutbound) {
      //             totalCounts = await Booking.find({ status: 'Confirmed', business: business, isOutbound: false, manager: manager, date: { $gt: new Date() } }).count().exec();
      //             // console.log("ToataL Missed Result = " + totalCounts)

      //             // baz <= 0 &&
      //             leads.push({
      //                 booking: booking,
      //                 user: lead.user,
      //                 name: lead.name,
      //                 contact_no: lead.contact_no,
      //                 email: lead.email,
      //                 _id: lead._id,
      //                 id: lead.id,
      //                 priority: lead.priority,
      //                 contacted: lead.contacted,
      //                 type: lead.type,
      //                 lead_id: lead.lead_id,
      //                 geometry: lead.geometry,
      //                 date: moment(lead.updated_at).tz(req.headers['tz']).format('lll'),
      //                 status: lead.status,
      //                 source: lead.source,
      //                 important: lead.important,
      //                 follow_up: follow_up,
      //                 remark: remark,
      //                 assignee: a,
      //                 // time: time,
      //                 isStared: isStared,
      //                 category: category,
      //                 isOutbound: isOutbound,
      //                 created_at: moment(lead.created_at).tz(req.headers['tz']).format('lll'),
      //                 updated_at: moment(lead.updated_at).tz(req.headers['tz']).format('lll'),
      //             });
      //         }
      //     }
      // } else {
      var date = "";
      if (follow_up.date != null) {
        date = moment(follow_up.date)
          .tz(req.headers["tz"])
          .format("DD-MM-YYYY");
      }
      leads.push({
        // booking: booking,
        // user: lead.user,
        name: lead.name,
        contact_no: lead.contact_no,
        // email: lead.email,
        _id: lead._id,
        // id: lead.id,
        priority: lead.priority,
        // contacted: lead.contacted,
        // type: lead.type,
        lead_id: lead.lead_id,
        // geometry: lead.geometry,
        // date: moment(lead.updated_at).tz(req.headers['tz']).format('lll'),
        status: remark.status,
        source: lead.source,
        manager: a.name,
        // important: lead.important,
        // follow_up: date + " " + follow_up.time,
        follow_up_date: date,
        // follow_up_time: follow_up.time,
        // remark: remark,
        // assignee: a,
        // time: time,
        // isStared: isStared,
        // category: category,
        isOutbound: isOutbound,
        created_at: moment(lead.created_at)
          .tz(req.headers["tz"])
          .format("DD-MM-YYYY"),
        // updated_at: moment(lead.updated_at).tz(req.headers['tz']).format('lll'),
      });
      // }
    });
  leads = _.filter(leads, (x) => !x.isOutbound && x.status != "PSF");
  // leads = _.filter(leads, x => !x.isOutbound);

  // console.log("ToataL Toatl Result = " + totalCounts)

  res.status(200).json({
    responseCode: 200,
    // responseInfo: {
    //     // filters: filters,
    //     totalResult: totalCounts
    // },
    responseMessage: role.role + " Leads",
    totalLeads: leads.length,
    responseData: leads,
  });
});

router.get(
  "/lead/details/get/new",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      lead: "required",
    };

    var validation = new Validator(req.query, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "lead required",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var user = decoded.user;
      var business = req.headers["business"];
      var bookings = [];
      var totalResult = 0;

      var lead = await Lead.findById(req.query.lead)
        .populate("assignee")
        .populate("advisor")
        .exec();

      if (lead) {
        var a = lead.advisor;
        var logs = [];
        await LeadRemark.find({ lead: lead._id })
          .populate("assignee")
          .sort({ created_at: -1 })
          .cursor()
          .eachAsync(async (l) => {
            if (l.assignee_remark == "") {
              l.assignee_remark = l.customer_remark;
            }

            if (l.assignee) {
              var assignee = {
                _id: l.assignee._id,
                id: l.assignee._id,
                name: l.assignee.name,
                email: l.assignee.email,
                contact_no: l.assignee.contact_no,
              };
            } else {
              var assignee = {
                _id: "",
                id: "",
                name: "",
                email: "",
                contact_no: "",
              };
            }

            logs.push({
              source: l.source,
              type: l.type,
              status: l.status,
              reason: l.reason,
              isRemark: l.isRemark,
              customer_remark: l.customer_remark,
              assignee_remark: l.assignee_remark,
              assignee: assignee,
              color_code: l.color_code,
              created_at: moment(l.created_at)
                .tz(req.headers["tz"])
                .format("lll"),
              updated_at: moment(l.updated_at)
                .tz(req.headers["tz"])
                .format("lll"),
            });
          });

        if (lead.assignee) {
          var assignee = {
            name: lead.assignee.name,
            email: lead.assignee.email,
            contact_no: lead.assignee.contact_no,
            _id: lead.assignee._id,
            id: lead.assignee._id,
          };
        } else {
          var assignee = {
            name: "",
            email: "",
            contact_no: "",
            _id: null,
            id: null,
          };
        }

        if (lead.follow_up == null) {
          var follow_up = {};
        } else {
          follow_up = lead.follow_up;
        }

        var last_active = "";
        if (lead.user) {
          var get_last_active = await User.findById(lead.user).exec();
          if (get_last_active) {
            last_active = moment(get_last_active.updated_at)
              .tz(req.headers["tz"])
              .format("lll");
          }
        }

        var b = await Booking.findOne({ lead: lead._id })
          .sort({ updated_at: -1 })
          .exec();
        var booking = null;
        if (b) {
          booking = b._id;
        }
        //Abhinav Tyagi
        var alternate_no = "";
        var variantDetails = null;
        if (lead.additional_info) {
          if (lead.additional_info.alternate_no) {
            alternate_no = lead.additional_info.alternate_no;
          }

          if (lead.additional_info.variant) {
            variantDetails = await Variant.findOne({
              _id: lead.additional_info.variant,
            }).exec();
          }
        }

        var push = {
          booking: booking,
          user: lead.user,
          name: lead.name,
          contact_no: lead.contact_no,
          email: lead.email,
          _id: lead._id,
          id: lead.id,
          priority: lead.priority,
          category: lead.category,
          type: lead.type,
          lead_id: lead.lead_id,
          date: moment(lead.updated_at).tz(req.headers["tz"]).format("lll"),
          source: lead.source,
          status: lead.status,
          important: lead.important,
          follow_up: follow_up,
          remark: lead.remark,
          psf: lead.psf,
          assignee: assignee,
          logs: logs,
          last_active: last_active,
          alternate_no: alternate_no,
          isStared: lead.isStared,
          variantDetails: variantDetails,
          created_at: moment(lead.created_at)
            .tz(req.headers["tz"])
            .format("lll"),
          updated_at: moment(lead.updated_at)
            .tz(req.headers["tz"])
            .format("lll"),
        };

        res.status(200).json({
          responseCode: 200,
          responseMessage: "Lead Added ",
          responseData: push,
        });
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Lead Not found",
          responseData: {},
        });
      }
    }
  }
);
router.get(
  "/lead/details/get/old",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      lead: "required",
    };

    var validation = new Validator(req.query, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "lead required",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var user = decoded.user;
      var business = req.headers["business"];
      var bookings = [];
      var totalResult = 0;

      var lead = await Lead.findById(req.query.lead)
        .populate("assignee")
        .populate("advisor")
        .exec();

      if (lead) {
        var a = lead.advisor;
        var logs = [];
        await LeadRemark.find({ lead: lead._id })
          .populate("assignee")
          .sort({ created_at: -1 })
          .cursor()
          .eachAsync(async (l) => {
            if (l.assignee_remark == "") {
              l.assignee_remark = l.customer_remark;
            }

            if (l.assignee) {
              var assignee = {
                _id: l.assignee._id,
                id: l.assignee._id,
                name: l.assignee.name,
                email: l.assignee.email,
                contact_no: l.assignee.contact_no,
              };
            } else {
              var assignee = {
                _id: "",
                id: "",
                name: "",
                email: "",
                contact_no: "",
              };
            }

            logs.push({
              source: l.source,
              type: l.type,
              status: l.status,
              reason: l.reason,
              customer_remark: l.customer_remark,
              assignee_remark: l.assignee_remark,
              assignee: assignee,
              color_code: l.color_code,
              created_at: moment(l.created_at)
                .tz(req.headers["tz"])
                .format("lll"),
              updated_at: moment(l.updated_at)
                .tz(req.headers["tz"])
                .format("lll"),
            });
          });

        if (lead.assignee) {
          var assignee = {
            name: lead.assignee.name,
            email: lead.assignee.email,
            contact_no: lead.assignee.contact_no,
            _id: lead.assignee._id,
            id: lead.assignee._id,
          };
        } else {
          var assignee = {
            name: "",
            email: "",
            contact_no: "",
            _id: null,
            id: null,
          };
        }

        if (lead.follow_up == null) {
          var follow_up = {};
        } else {
          follow_up = lead.follow_up;
        }

        var last_active = "";
        if (lead.user) {
          var get_last_active = await User.findById(lead.user).exec();
          if (get_last_active) {
            last_active = moment(get_last_active.updated_at)
              .tz(req.headers["tz"])
              .format("lll");
          }
        }

        var b = await Booking.findOne({ lead: lead._id })
          .sort({ updated_at: -1 })
          .populate({ path: "advisor", select: "name email contact_no" })
          .populate({ path: "address" })
          .populate({ path: "car" })
          .exec();
        // console.log("isstared", lead.user)
        var booking = null;
        var car = "";
        var advisor = null;
        var address = {};

        if (b) {
          booking = b._id;
          car = b.car.title;
          address = b.address;
          advisor = {
            name: b.advisor.name,
            contact_no: b.advisor.contact_no,
          };
        }

        // console.log("car",b.car)
        var push = {
          booking: booking,
          user: lead.user,
          name: lead.name,
          contact_no: lead.contact_no,
          email: lead.email,
          car: car,
          address: address,
          advisor: advisor,
          _id: lead._id,
          id: lead.id,
          priority: lead.priority,
          category: lead.category,
          type: lead.type,
          lead_id: lead.lead_id,
          date: moment(lead.updated_at).tz(req.headers["tz"]).format("lll"),
          source: lead.source,
          status: lead.status,
          important: lead.important,
          follow_up: follow_up,
          remark: lead.remark,
          psf: lead.psf,
          assignee: assignee,
          isStared: lead.isStared,
          logs: logs,
          last_active: last_active,
          created_at: moment(lead.created_at)
            .tz(req.headers["tz"])
            .format("lll"),
          updated_at: moment(lead.updated_at)
            .tz(req.headers["tz"])
            .format("lll"),
        };

        res.status(200).json({
          responseCode: 200,
          responseMessage: "Lead Added ",
          responseData: push,
        });
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Lead Not found",
          responseData: {},
        });
      }
    }
  }
);
router.get(
  "/lead/details/get/",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      lead: "required",
    };

    var validation = new Validator(req.query, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "lead required",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var user = decoded.user;
      var business = req.headers["business"];
      var bookings = [];
      var totalResult = 0;

      var lead = await Lead.findById(req.query.lead)
        .populate("assignee")
        .populate("advisor")
        .exec();

      if (lead) {
        var a = lead.advisor;
        var logs = [];
        await LeadRemark.find({ lead: lead._id })
          .populate("assignee")
          .sort({ created_at: -1 })
          .cursor()
          .eachAsync(async (l) => {
            if (l.assignee_remark == "") {
              l.assignee_remark = l.customer_remark;
            }

            if (l.assignee) {
              var assignee = {
                _id: l.assignee._id,
                id: l.assignee._id,
                name: l.assignee.name,
                email: l.assignee.email,
                contact_no: l.assignee.contact_no,
              };
            } else {
              var assignee = {
                _id: "",
                id: "",
                name: "",
                email: "",
                contact_no: "",
              };
            }

            logs.push({
              source: l.source,
              type: l.type,
              status: l.status,
              reason: l.reason,
              isRemark: l.isRemark,
              customer_remark: l.customer_remark,
              assignee_remark: l.assignee_remark,
              assignee: assignee,
              color_code: l.color_code,
              created_at: moment(l.created_at)
                .tz(req.headers["tz"])
                .format("lll"),
              updated_at: moment(l.updated_at)
                .tz(req.headers["tz"])
                .format("lll"),
            });
          });

        if (lead.assignee) {
          var assignee = {
            name: lead.assignee.name,
            email: lead.assignee.email,
            contact_no: lead.assignee.contact_no,
            _id: lead.assignee._id,
            id: lead.assignee._id,
          };
        } else {
          var assignee = {
            name: "",
            email: "",
            contact_no: "",
            _id: null,
            id: null,
          };
        }

        if (lead.follow_up == null) {
          var follow_up = {};
        } else {
          follow_up = lead.follow_up;
        }

        var last_active = "";
        if (lead.user) {
          var get_last_active = await User.findById(lead.user).exec();
          if (get_last_active) {
            last_active = moment(get_last_active.updated_at)
              .tz(req.headers["tz"])
              .format("lll");
          }
        }

        //if (Log_Level == 4 || Log_Level == 6 || Log_Level == 8 || Log_Level == 10 || Log_Level == 0) {
        //   businessFunctions.logs("DEBUG: Fatching Booking Details for the Lead, LeadId:" + lead._id);
        // }
        var b = await Booking.findOne({ lead: lead._id })
          .populate({ path: "advisor", select: "name email contact_no" })
          .populate({ path: "address" })
          .populate({ path: "car" })
          .sort({ updated_at: -1 })
          .exec();
        // console.log(JSON.stringify(b));
        var booking = null;
        var car = "";
        var booking_slot = null;
        var advisor = null;
        var address = {};

        if (b) {
          car = b.car.title;
          address = b.address;
          advisor = {
            name: b.advisor.name,
            contact_no: b.advisor.contact_no,
          };
          booking = b._id;
          booking_slot = {
            date: b.date,
            time_slot: b.time_slot,
            status: b.status,
          };
        }
        //Abhinav Tyagi
        var alternate_no = "";
        var variantDetails = null;
        if (lead.additional_info) {
          if (lead.additional_info.alternate_no) {
            alternate_no = lead.additional_info.alternate_no;
          }

          if (lead.additional_info.variant) {
            variantDetails = await Variant.findOne({
              _id: lead.additional_info.variant,
            }).exec();
          }
        }

        // console.log("car",b.car)
        var push = {
          booking: booking,
          user: lead.user,
          name: lead.name,
          contact_no: lead.contact_no,
          email: lead.email,
          car: car,
          address: address,
          advisor: advisor,
          _id: lead._id,
          id: lead.id,
          priority: lead.priority,
          category: lead.category,
          type: lead.type,
          lead_id: lead.lead_id,
          date: moment(lead.updated_at).tz(req.headers["tz"]).format("lll"),
          source: lead.source,
          status: lead.status,
          important: lead.important,
          follow_up: follow_up,
          remark: lead.remark,
          psf: lead.psf,
          assignee: assignee,
          logs: logs,
          last_active: last_active,
          alternate_no: alternate_no,
          isStared: lead.isStared,
          booking_slot: booking_slot,
          variantDetails: variantDetails,
          created_at: moment(lead.created_at)
            .tz(req.headers["tz"])
            .format("lll"),
          updated_at: moment(lead.updated_at)
            .tz(req.headers["tz"])
            .format("lll"),
        };

        res.status(200).json({
          responseCode: 200,
          responseMessage: "Lead Added ",
          responseData: push,
        });
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Lead Not found",
          responseData: {},
        });
      }
    }
  }
);

router.post(
  "/lead/booking/add/",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers["business"];

    var loggedInDetails = await User.findById(decoded.user).exec();
    var role = await Management.findOne({
      user: decoded.user,
      business: business,
    }).exec();

    var advisor = await q.all(getAdvisor(loggedInDetails._id, business));

    var estimation_requested = false;
    if (req.body.estimation_requested == "Yes") {
      estimation_requested = true;
    }

    var date = null;
    if (req.body.date) {
      date = new Date(req.body.date).toISOString();
    }

    var time_slot = "";
    if (req.body.time_slot) {
      time_slot = req.body.time_slot;
    }

    var convenience = "";
    if (req.body.convenience) {
      convenience = req.body.convenience;
    }

    var address = null;
    if (req.body.address) {
      address = req.body.address;
    }

    var role = await Management.findOne({
      user: user,
      business: business,
    }).exec();
    if (role.role == "CRE") {
      var lead = await Lead.findOne({
        assignee: user,
        _id: req.body.lead,
      }).exec();
    } else {
      var lead = await Lead.findOne({
        business: business,
        _id: req.body.lead,
      }).exec();
    }

    if (lead) {
      if (lead.contact_no) {
        var leadUser = {
          name: lead.name,
          contact_no: lead.contact_no,
          email: lead.email,
          user: lead.user,
        };
        var user = await q.all(getUser(leadUser));
        if (user) {
          var rg = req.body.registration_no;
          req.body.registration_no = rg.replace(/ /g, "");

          var leadCar = {
            user: user,
            car: req.body.car,
            variant: req.body.variant,
            registration_no: req.body.registration_no,
          };
          var car = await q.all(getCar(leadCar));
          if (car) {
            var booking = await Booking.findOne({
              car: car._id,
              user: user,
              status: {
                $nin: [
                  "Completed",
                  "CompleteWork",
                  "QC",
                  "Closed",
                  "Ready",
                  "Rejected",
                  "Cancelled",
                  "Inactive",
                ],
              },
              is_services: true,
            }).exec();

            if (booking) {
              return res.status(422).json({
                responseCode: 422,
                responseMessage:
                  "Booking already exists for the same registration no. [" +
                  booking.status +
                  "]",
                responseData: {},
              });
            } else {
              var bookingService = [];
              var customer_requirements = [];

              if (req.body.requirement) {
                customer_requirements.push({
                  requirement: req.body.requirement,
                });
              }

              if (req.body.advisor) {
                advisor = req.body.advisor;
              } else {
                if (lead.advisor) {
                  advisor = lead.advisor;
                } else {
                  return res.status(422).json({
                    responseCode: 422,
                    responseMessage: "Advisor Needed",
                    responseData: {},
                  });
                }
              }

              var payment = {
                payment_mode: "",
                payment_status: "Pending",
                discount_type: "",
                coupon: "",
                coupon_type: "",
                discount: 0,
                discount_total: 0,
                part_cost: 0,
                labour_cost: 0,
                paid_total: 0,
                total: 0,
                discount_applied: false,
                transaction_id: "",
                transaction_date: "",
                transaction_status: "",
                transaction_response: "",
              };

              var bookingData = {
                package: null,
                car: car,
                advisor: advisor,
                manager: lead.assignee,
                business: business,
                user: user,
                services: bookingService,
                customer_requirements: customer_requirements,
                booking_no: Math.round(+new Date() / 1000),
                date: date,
                time_slot: time_slot,
                estimation_requested: estimation_requested,
                convenience: convenience,
                status: "EstimateRequested",
                payment: payment,
                address: address,
                lead: lead,
                is_services: true,
                converted: true,
                created_at: new Date(),
                updated_at: new Date(),
              };

              Booking.create(bookingData).then(async function (b) {
                var activity = {
                  user: loggedInDetails._id,
                  name: loggedInDetails.name,
                  stage: "Approval",
                  activity: "Booking",
                };

                fun.bookingLog(b._id, activity);

                if (role.role == "CRE") {
                  if (estimation_requested) {
                    var notify = {
                      receiver: [b.advisor],
                      sender: loggedInDetails._id,
                      activity: "booking",
                      source: b._id,
                      tag: "EstimateRequested",
                      points: 0,
                    };

                    fun.newNotification(notify);
                  } else {
                    var notify = {
                      source: b._id,
                      receiver: [b.advisor],
                      sender: loggedInDetails._id,
                      activity: "booking",
                      tag: "leadBooking",
                      points: 0,
                    };
                    fun.newNotification(notify);
                  }
                } else {
                  if (estimation_requested) {
                    var notify = {
                      receiver: [b.manager],
                      sender: loggedInDetails._id,
                      activity: "booking",
                      source: b._id,
                      tag: "EstimateInitiated",
                      points: 0,
                    };

                    fun.newNotification(notify);
                  } else {
                    var notify = {
                      source: b._id,
                      receiver: [b.manager],
                      sender: loggedInDetails._id,
                      activity: "booking",
                      tag: "EstimateInitiated",
                      points: 0,
                    };
                    fun.newNotification(notify);
                  }
                }

                var data = {
                  user: user,
                  follow_up: {},
                  converted: true,
                  remark: {
                    lead: lead._id,
                    status: "EstimateRequested",
                    color_code: lead.remark.color_code,
                    assignee: user,
                    customer_remark: "Estimate requested",
                    assignee_remark: "Estimate requested",
                    created_at: new Date(),
                    updated_at: new Date(),
                  },
                  created_at: new Date(),
                  updated_at: new Date(),
                };

                Lead.findOneAndUpdate(
                  { _id: lead._id },
                  { $set: data },
                  { new: false },
                  async function (err, doc) {
                    if (err) {
                      return res.status(422).json({
                        responseCode: 422,
                        responseMessage: "Server Error",
                        responseData: err,
                      });
                    } else {
                      LeadRemark.create(data.remark).then(function (newRemark) {
                        Lead.findOneAndUpdate(
                          { _id: lead._id },
                          { $push: { remarks: newRemark._id } },
                          { new: true },
                          async function (err, doc) {}
                        );
                      });
                    }
                  }
                );

                var bookings = [];
                var booking = await Booking.findById(b._id)
                  .populate({
                    path: "user",
                    populate: {
                      path: "user",
                      select: "_id id name contact_no email business_info",
                    },
                  })
                  .populate({
                    path: "manager",
                    populate: {
                      path: "user",
                      select: "_id id name contact_no email",
                    },
                  })
                  .populate({
                    path: "car",
                    select: "_id id title registration_no ic rc",
                    populate: { path: "thumbnails" },
                  })
                  .exec();

                if (booking.address) {
                  var address = await Address.findOne({
                    _id: booking.address,
                  }).exec();
                } else {
                  var address = {};
                }
                if (booking.car) {
                  var car = {
                    title: booking.car.title,
                    _id: booking.car._id,
                    id: booking.car.id,
                    rc_address: booking.car.rc_address,
                    ic_address: booking.car.ic_address,
                    ic: booking.car.ic,
                    rc: booking.car.rc,
                    registration_no: booking.car.registration_no,
                  };
                }

                var manager = null;
                if (booking.manager) {
                  manager = {
                    name: booking.manager.name,
                    _id: booking.manager._id,
                    id: booking.manager.id,
                    contact_no: booking.manager.contact_no,
                    email: booking.manager.email,
                  };
                }
                bookings.push({
                  _id: booking._id,
                  id: booking._id,
                  car: car,
                  user: {
                    name: booking.user.name,
                    _id: booking.user._id,
                    id: booking.user.id,
                    contact_no: booking.user.contact_no,
                    email: booking.user.email,
                    business_info: booking.user.business_info,
                  },
                  manager: manager,
                  services: booking.services,
                  convenience: booking.convenience,
                  date: moment(booking.date).tz(req.headers["tz"]).format("ll"),
                  time_slot: booking.time_slot,
                  status: booking.status,
                  booking_no: booking.booking_no,
                  job_no: booking.job_no,
                  estimation_requested: booking.estimation_requested,
                  address: address,
                  remarks: booking.remarks,
                  customer_requirements: booking.customer_requirements,
                  payment: booking.payment,
                  txnid: booking.txnid,
                  __v: booking.__v,
                  created_at: moment(booking.created_at)
                    .tz(req.headers["tz"])
                    .format("lll"),
                  updated_at: moment(booking.updated_at)
                    .tz(req.headers["tz"])
                    .format("lll"),
                });

                Lead.findOneAndUpdate(
                  { _id: lead._id },
                  { $set: { user: user, converted: true } },
                  { new: false },
                  async function (err, doc) {
                    if (err) {
                      res.status(422).json({
                        responseCode: 422,
                        responseMessage: "Server Error",
                        responseData: err,
                      });
                    } else {
                      event.zohoLead(b._id);

                      res.status(200).json({
                        responseCode: 200,
                        responseMessage: "Booking",
                        responseData: bookings,
                      });
                    }
                  }
                );
              });
            }
          } else {
            res.status(422).json({
              responseCode: 400,
              responseMessage: "Car required",
              responseData: {},
            });
          }
        } else {
          res.status(422).json({
            responseCode: 400,
            responseMessage: "User required",
            responseData: {},
          });
        }
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Contact No required",
          responseData: {},
        });
      }
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Lead not found",
        responseData: {},
      });
    }
  }
);

router.get(
  "/lead/contact-history/get",
  xAccessToken.token,
  async function (req, res, next) {
    var leads = [];
    var leadId = [];

    await Lead.find({ contact_no: req.query.contact_no })
      .sort({ created_at: -1 })
      .cursor()
      .eachAsync(async (l) => {
        leadId.push(l._id);
      });

    leadId = Array.from(new Set(leadId));

    await LeadRemark.find({ lead: { $in: leadId } })
      .populate({
        path: "assignee",
        select: "name username avatar avatar_address",
      })
      .sort({ created_at: -1 })
      .cursor()
      .eachAsync(async (lead) => {
        leads.push({
          lead: lead.lead,
          _id: lead._id,
          id: lead.id,
          type: lead.type,
          source: lead.source,
          color_code: lead.color_code,
          assignee: lead.assignee,
          assignee_remark: lead.assignee_remark,
          customer_remark: lead.customer_remark,
          status: lead.status,
          created_at: moment(lead.created_at)
            .tz(req.headers["tz"])
            .format("lll"),
          updated_at: moment(lead.updated_at)
            .tz(req.headers["tz"])
            .format("lll"),
        });
      });

    res.status(200).json({
      responseCode: 200,
      responseMessage: "success",
      responseData: leads,
    });
  }
);

router.post(
  "/job/review/add",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      booking: "required",
      rating: "required",
      recommendation: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Error",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var user = decoded.user;
      var businessReview = new Object();

      var booking = await Booking.findOne({ _id: req.body.booking }).exec();
      if (booking) {
        var status = req.body.status;

        req.body.status = false;
        req.body.user = booking.user;
        req.body.business = booking.business;
        req.body.created_at = new Date();
        req.body.updated_at = new Date();

        Review.create(req.body).then(async function (data) {
          if (status == "Dissatisfied") {
            event.zohoCustomStatus(booking._id, "Dissatisfied");
          } else if (status == "Satisfied") {
            event.zohoCustomStatus(booking._id, "Satisfied");
          } else if (status == "Rework") {
            event.zohoCustomStatus(booking._id, "Rework");
          }

          Review.findOneAndUpdate(
            { booking: booking._id },
            { $set: { status: false } },
            { new: true },
            async function (err, doc) {}
          );
          Booking.findOneAndUpdate(
            { _id: booking._id },
            { $set: { is_reviewed: true } },
            { new: true },
            async function (err, doc) {}
          );

          var point = {
            user: booking.user,
            activity: "coin",
            tag: "businessReview",
            source: booking._id,
            points: 25,
            title: "",
            body: "",
            status: true,
          };
          fun.addPoints(point);

          var notify = {
            receiver: [data.business],
            sender: data.user,
            activity: "profile",
            tag: "review",
            source: booking._id,
            points: data.rating,
          };

          fun.newNotification(notify);

          await Review.find({ _id: data._id })
            .populate({
              path: "user",
              select: "name username avatar avatar_address account_info",
            })
            .cursor()
            .eachAsync(async (review) => {
              businessReview = {
                _id: review._id,
                id: review._id,
                business: review.business,
                booking: review.booking,
                review_points: review.review_points,
                rating: review.rating,
                review: review.review,
                recommendation: review.recommendation,
                type: review.type,
                created_at: moment(review.created_at)
                  .tz(req.headers["tz"])
                  .format("ll"),
                updated_at: moment(review.updated_at)
                  .tz(req.headers["tz"])
                  .format("ll"),
                user: review.user,
              };
            });

          res.status(200).json({
            responseCode: 200,
            responseMessage: "Thank You For Your Review",
            responseData: businessReview,
          });
        });
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Booking not found",
          responseData: {},
        });
      }
    }
  }
);

router.get(
  "/user/search/",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      query: "required",
    };

    var validation = new Validator(req.query, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Error",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var user = decoded.user;
      var business = req.headers["business"];
      var peoples = [];
      var filters = [];

      /*var specification = {};        
        specification['$lookup']= {
            from: "Booking",
            localField: "bookings",
            foreignField: "_id",
            as: "bookings",
        };
        filters.push(specification); */

      var specification = {};
      specification["$lookup"] = {
        from: "Car",
        localField: "cars",
        foreignField: "_id",
        as: "cars",
      };
      filters.push(specification);

      if (req.query.query) {
        var specification = {};
        specification["$match"] = {
          $or: [
            { name: { $regex: req.query.query, $options: "i" } },
            { contact_no: { $regex: req.query.query, $options: "i" } },
            {
              cars: {
                $elemMatch: {
                  title: { $regex: req.query.query, $options: "i" },
                },
              },
            },
            {
              cars: {
                $elemMatch: {
                  registration_no: { $regex: req.query.query, $options: "i" },
                },
              },
            },
          ],
        };
        filters.push(specification);

        var specification = {};
        specification["$sort"] = {
          updated_at: -1,
        };
        filters.push(specification);
      }

      await User.aggregate(filters)
        .allowDiskUse(true)
        .cursor({ batchSize: 10 })
        .exec()
        .eachAsync(async function (user) {
          var b = await Booking.find({
            business: business,
            user: user._id,
          }).count();
          var l = await Lead.find({
            business: business,
            user: user._id,
          }).count();
          var o = await BusinessOrder.find({
            business: business,
            user: user._id,
          }).count();
          if (b > 0 || l > 0 || o > 0) {
            peoples.push({
              _id: user._id,
              id: user._id,
              name: user.name,
              username: user.username,
              email: user.email,
              contact_no: user.contact_no,
              avatar: user.avatar,
              avatar_address:
                "https://s3.ap-south-1.amazonaws.com/" +
                config.BUCKET_NAME +
                "/avatar/" +
                user.avatar,
              account_info: user.account_info,
              business_info: user.business_info,
              created_at: user.created_at,
              updated_at: user.updated_at,
              joined: moment(user.created_at)
                .tz(req.headers["tz"])
                .format("ll"),
            });
          }
        });

      res.status(200).json({
        responseCode: 200,
        responseMessage: "",
        responseInfo: {
          //filters:filters
        },
        responseData: peoples,
      });
    }
  }
);

router.get(
  "/user/details",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      query: "required",
    };

    var validation = new Validator(req.query, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Error",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var user = decoded.user;
      var business = req.headers["business"];
      var peoples = [];

      if (req.query.page == undefined) {
        var page = 0;
      } else {
        var page = req.query.page;
      }
      var page = Math.max(0, parseInt(page));

      var query = req.query.query;

      await User.find({ _id: req.query.query })
        .select(
          "name username avatar avatar_address contact_no email careager_cash account_info"
        )
        .sort({ created_at: -1 })
        .limit(config.perPage)
        .skip(config.perPage * page)
        .cursor()
        .eachAsync(async (user) => {
          var date = new Date();
          date.setDate(date.getDate() - 1);
          var bookings = [];
          await Booking.find({
            user: user._id,
            status: { $nin: ["Cancelled", "Inactive", "EstimatePrepared"] },
            is_services: true,
          })
            .populate({
              path: "manager",
              populate: {
                path: "user",
                select: "_id id name contact_no email",
              },
            })
            .populate({
              path: "advisor",
              populate: {
                path: "user",
                select: "_id id name contact_no email",
              },
            })
            .populate({
              path: "user",
              populate: {
                path: "user",
                select: "_id id name contact_no email",
              },
            })
            .populate({
              path: "business",
              populate: {
                path: "user",
                select: "_id id name contact_no email",
              },
            })
            .populate({
              path: "car",
              select: "_id id title registration_no ic rc",
            })
            .sort({ date: 1 })
            .cursor()
            .eachAsync(async (booking) => {
              var car = null;
              var manager = null;
              var advisor = null;
              var address = null;
              if (booking.car) {
                car = {
                  title: booking.car.title,
                  _id: booking.car._id,
                  id: booking.car.id,
                  registration_no: booking.car.registration_no,
                  ic_address: booking.car.ic_address,
                  rc_address: booking.car.rc_address,
                };
              }

              if (booking.manager) {
                manager = {
                  name: booking.manager.name,
                  _id: booking.manager._id,
                  id: booking.manager.id,
                  contact_no: booking.manager.contact_no,
                  email: booking.manager.email,
                };
              }

              if (booking.advisor) {
                advisor = {
                  name: booking.advisor.name,
                  _id: booking.advisor._id,
                  id: booking.advisor.id,
                  contact_no: booking.advisor.contact_no,
                  email: booking.advisor.email,
                };
              }

              if (booking.address) {
                var address = await Address.findOne({
                  _id: booking.address,
                }).exec();
              }

              bookings.push({
                _id: booking._id,
                id: booking._id,
                car: car,
                user: {
                  name: booking.user.name,
                  _id: booking.user._id,
                  id: booking.user.id,
                  contact_no: booking.user.contact_no,
                  email: booking.user.email,
                },
                business: {
                  name: booking.business.name,
                  _id: booking.business._id,
                  id: booking.business.id,
                  contact_no: booking.business.contact_no,
                  email: booking.business.email,
                },
                advisor: advisor,
                manager: manager,
                services: booking.services,
                convenience: booking.convenience,
                date: moment(booking.date).tz(req.headers["tz"]).format("ll"),
                time_slot: booking.time_slot,
                status: _.startCase(booking.status),
                booking_no: booking.booking_no,
                estimation_requested: booking.estimation_requested,
                address: address,
                payment: booking.payment,
                due: booking.due,
                __v: booking.__v,
                updated_at: booking.updated_at,
                updated_at: booking.updated_at,
              });
            });

          var cars = [];
          await Car.find({ user: user._id, status: true })
            .select("_id id title registration_no rc ic")
            .cursor()
            .eachAsync(async (car) => {
              if (car) {
                cars.push({
                  _id: car._id,
                  id: car._id,
                  title: car.title,
                  registration_no: car.registration_no,
                  rc: car.rc,
                  rc_address: car.rc_address,
                  ic: car.ic,
                  ic_address: car.ic_address,
                });
              }
            });

          var leadId = [];
          var leads = [];

          await Lead.find({ contact_no: user.contact_no, business: business })
            .populate({ path: "assignee", select: "id name contact_no email" })
            .sort({ updated_at: -1 })
            .skip(config.perPage * page)
            .limit(config.perPage)
            .cursor()
            .eachAsync(async (lead) => {
              if (lead) {
                var remark = await LeadRemark.findOne({ lead: lead._id })
                  .sort({ created_at: -1 })
                  .exec();
                leads.push({
                  user: lead.user,
                  name: lead.name,
                  contact_no: lead.contact_no,
                  email: lead.email,
                  _id: lead._id,
                  id: lead.id,
                  type: lead.type,
                  date: moment(lead.updated_at)
                    .tz(req.headers["tz"])
                    .format("lll"),
                  status: lead.status,
                  important: lead.important,
                  follow_up: lead.follow_up,
                  remark: lead.remark,
                  assignee: lead.assignee,
                  created_at: moment(lead.created_at)
                    .tz(req.headers["tz"])
                    .format("lll"),
                  updated_at: moment(lead.updated_at)
                    .tz(req.headers["tz"])
                    .format("lll"),
                });
              }
            });
          peoples = {
            _id: user._id,
            id: user._id,
            name: user.name,
            username: user.username,
            email: user.email,
            contact_no: user.contact_no,
            avatar_address:
              "https://s3.ap-south-1.amazonaws.com/" +
              config.BUCKET_NAME +
              "/avatar/" +
              user.avatar,
            account_info: user.account_info,
            careager_cash: user.careager_cash,
            cars: cars,
            bookings: bookings,
            leads: leads,
            created_at: user.created_at,
            updated_at: user.updated_at,
            joined: moment(user.created_at).tz(req.headers["tz"]).format("ll"),
          };
        });

      res.status(200).json({
        responseCode: 200,
        responseMessage: "",
        responseData: peoples,
      });
    }
  }
);

router.get(
  "/lead/user/cars/get",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers["business"];

    var lead = await Lead.findOne({
      business: business,
      _id: req.query.lead,
    }).exec();

    if (lead) {
      if (lead.contact_no) {
        var leadUser = {
          name: lead.name,
          contact_no: lead.contact_no,
          email: lead.email,
          user: lead.user,
        };
        var user = await q.all(getUser(leadUser));
        if (user) {
          Lead.findOneAndUpdate(
            { _id: lead._id },
            { $set: { user: user } },
            { new: false },
            async function (err, doc) {
              var car = [];

              await Car.find({ user: user, status: true })
                .populate("bookmark")
                .populate("thumbnails")
                .populate({
                  path: "user",
                  select: "name username avatar avatar_address address",
                })
                .populate({ path: "variant", populate: { path: "model" } })
                .sort({ created_at: -1 })
                .cursor()
                .eachAsync(async (doc) => {
                  car.push({
                    __v: 0,
                    _id: doc._id,
                    id: doc.id,
                    title: doc.title,
                    variant: doc.variant._id,
                    model: doc.model,
                    modelName: doc.variant.model.model,
                    price: doc.price,
                    numericPrice: doc.price,
                    accidental: doc.accidental,
                    body_style: doc.body_style,
                    description: doc.description,
                    driven: doc.driven,
                    carId: doc.carId,
                    fuel_type: doc.fuel_type,
                    insurance: doc.insurance,
                    location: doc.location,
                    manufacture_year: doc.manufacture_year,
                    mileage: doc.mileage,
                    owner: doc.owner,
                    registration_no: doc.registration_no,
                    transmission: doc.transmission,
                    vehicle_color: doc.vehicle_color,
                    vehicle_status: doc.vehicle_status,
                    geometry: doc.geometry,
                    fuel_level: doc.fuel_level,
                    engine_no: doc.engine_no,
                    vin: doc.vin,
                    ic: doc.ic,
                    rc: doc.rc,
                    ic_address: doc.ic_address,
                    rc_address: doc.rc_address,
                    publish: doc.publish,
                    status: doc.status,
                    premium: doc.premium,
                    is_bookmarked: doc.is_bookmarked,
                    thumbnails: doc.thumbnails,
                    user: doc.user,
                    insurance_info: doc.insurance_info,
                    created_at: doc.created_at,
                    updated_at: doc.updated_at,
                  });
                });

              res.status(200).json({
                responseCode: 200,
                responseMessage: "User added",
                responseData: car,
              });
            }
          );
        } else {
          res.status(422).json({
            responseCode: 400,
            responseMessage: "User information incomplete",
            responseData: {},
          });
        }
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Contact No required",
          responseData: {},
        });
      }
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Lead not found",
        responseData: {},
      });
    }
  }
);

router.get(
  "/service-reminder/get",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers["business"];
    var bookings = [];
    var filters = [];
    var totalResult = 0;

    var role = await Management.findOne({
      user: user,
      business: business,
    }).exec();
    if (req.query.page == undefined) {
      var page = 0;
    } else {
      var page = req.query.page;
    }

    var specification = {};
    specification["$lookup"] = {
      from: "User",
      localField: "user",
      foreignField: "_id",
      as: "user",
    };
    filters.push(specification);

    var specification = {};
    specification["$unwind"] = {
      path: "$user",
      preserveNullAndEmptyArrays: false,
    };
    filters.push(specification);

    var specification = {};
    specification["$lookup"] = {
      from: "Car",
      localField: "car",
      foreignField: "_id",
      as: "car",
    };
    filters.push(specification);

    var specification = {};
    specification["$unwind"] = {
      path: "$car",
      preserveNullAndEmptyArrays: true,
    };

    var bar = new Date();
    bar.setDate(bar.getDate() + 20);

    if (req.query.query) {
      var specification = {};
      specification["$match"] = {
        business: mongoose.Types.ObjectId(business),
        service_reminder: { $lte: bar },
        $or: [
          { "user.name": { $regex: req.query.query, $options: "i" } },
          { "user.contact_no": { $regex: req.query.query, $options: "i" } },
          { "car.title": { $regex: req.query.query, $options: "i" } },
          { "car.registration_no": { $regex: req.query.query, $options: "i" } },
          {
            "car.insurance_info.policy_holder": {
              $regex: req.query.query,
              $options: "i",
            },
          },
        ],
      };
      filters.push(specification);
    } else {
      var specification = {};
      specification["$match"] = {
        business: mongoose.Types.ObjectId(business),
        service_reminder: { $lte: bar },
      };
      filters.push(specification);
    }

    filters.push(specification);

    totalResult = await Booking.aggregate(filters);

    var specification = {};
    specification["$sort"] = {
      service_reminder: 1,
    };
    filters.push(specification);

    var specification = {};
    specification["$skip"] = config.perPage * page;
    filters.push(specification);

    var specification = {};
    specification["$limit"] = config.perPage;
    filters.push(specification);

    await Booking.aggregate(filters)
      .allowDiskUse(true)
      .cursor({ batchSize: 10 })
      .exec()
      .eachAsync(async function (booking) {
        var remarks = booking.remarks;
        var remarksData = [];
        if (remarks) {
          for (var i = 0; i < remarks.length; i++) {
            var added_by = await User.findById(remarks[i].added_by).exec();
            remarksData.push({
              added_by: remarks[i].user,
              name: added_by.name,
              remark: remarks[i].remark,
              created_at: moment(remarks[i].created_at)
                .tz(req.headers["tz"])
                .format("lll"),
              updated_at: moment(remarks[i].updated_at)
                .tz(req.headers["tz"])
                .format("lll"),
            });
          }
        }

        bookings.push({
          _id: booking._id,
          id: booking._id,
          car: {
            title: booking.car[0].title,
            _id: booking.car[0]._id,
            id: booking.car[0].id,
            vin: booking.car[0].vin,
            engine_no: booking.car[0].engine_no,
            registration_no: booking.car[0].registration_no,
            variant: booking.car[0].variant,
            manufacture_year: booking.car[0].manufacture_year,
            purchased_year: booking.car[0].purchased_year,
          },
          user: {
            name: booking.user.name,
            _id: booking.user._id,
            id: booking.user.id,
            contact_no: booking.user.contact_no,
            email: booking.user.email,
            business_info: booking.user.business_info,
            account_info: booking.user.account_info,
          },
          insurance_info: booking.insurance_info,
          odometer: booking.odometer,
          convenience: booking.convenience,
          date: moment(booking.date).tz(req.headers["tz"]).format("ll"),
          time_slot: booking.time_slot,
          status: _.startCase(booking.status),
          _status: booking.status,
          sub_status: booking.sub_status,
          booking_no: booking.booking_no,
          job_no: booking.job_no,
          remarks: remarks,
          service_reminder: moment(booking.service_reminder)
            .tz(req.headers["tz"])
            .format("lll"),
          created_at: moment(booking.created_at)
            .tz(req.headers["tz"])
            .format("lll"),
          updated_at: moment(booking.updated_at)
            .tz(req.headers["tz"])
            .format("lll"),
        });
      });

    res.status(200).json({
      responseCode: 200,
      responseMessage: "",
      responseInfo: {
        totalResult: totalResult.length,
      },
      responseData: bookings,
    });
  }
);

router.put(
  "/booking/info/update",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers["business"];
    var loggedInDetails = await User.findById(decoded.user).exec();
    var booking = await Booking.findOne({ _id: req.body.booking }).exec();

    if (booking) {
      var estimation_requested = false;
      if (req.body.estimation_requested == "Yes") {
        estimation_requested = true;
      }

      var date = null;
      var status = booking.status;

      if (req.body.date) {
        status = "Confirmed";
        date = new Date(req.body.date).toISOString();
      }

      var time_slot = booking.time_slot;
      if (req.body.time_slot) {
        time_slot = req.body.time_slot;
      }

      var convenience = booking.convenience;
      if (req.body.convenience) {
        convenience = req.body.convenience;
      }

      var address = null;
      if (req.body.address) {
        address = req.body.address;
      }

      var pick_up_charges = booking.payment.pick_up_charges;
      if (req.body.pick_up_charges >= 0) {
        pick_up_charges = parseFloat(req.body.pick_up_charges);
      }

      var policy_clause = booking.payment.policy_clause;
      if (req.body.policy_clause >= 0 && req.body.policy_clause != null) {
        policy_clause = parseFloat(req.body.policy_clause);
      }

      var salvage = booking.payment.salvage;
      if (req.body.salvage >= 0 && req.body.salvage != null) {
        salvage = parseFloat(req.body.salvage);
      }

      var bookingService = booking.services;

      var approved = _.filter(
        bookingService,
        (customer_approval) => customer_approval.customer_approval == true
      );

      var labour_cost = _.sumBy(bookingService, (x) => x.labour_cost);
      var part_cost = _.sumBy(bookingService, (x) => x.part_cost);
      var of_cost = _.sumBy(bookingService, (x) => x.of_cost);
      var discount_total = _.sumBy(bookingService, (x) => x.discount);
      var pick_up_charges = pick_up_charges;
      var paid_total = booking.payment.paid_total;

      var careager_cash = await q.all(fun.getBookingCarEagerCash(booking._id));

      var payment_total =
        labour_cost +
        part_cost +
        of_cost +
        discount_total +
        policy_clause +
        salvage +
        pick_up_charges;

      var estimate_cost =
        labour_cost +
        part_cost +
        of_cost +
        policy_clause +
        salvage +
        pick_up_charges -
        careager_cash;
      var due_amount =
        _.sumBy(approved, (x) => x.labour_cost) +
        _.sumBy(approved, (x) => x.part_cost) +
        _.sumBy(approved, (x) => x.of_cost) +
        policy_clause +
        salvage +
        pick_up_charges -
        (paid_total + careager_cash);

      var due = {
        due: Math.ceil(due_amount.toFixed(2)),
      };

      var payment = {
        total: payment_total,
        estimate_cost: estimate_cost,
        careager_cash: careager_cash,
        of_cost: of_cost,
        labour_cost: labour_cost,
        part_cost: part_cost,
        payment_mode: booking.payment.payment_mode,
        payment_status: booking.payment.payment_status,
        coupon: booking.payment.coupon,
        coupon_type: booking.payment.coupon_type,
        discount_by: booking.payment.discount_by,
        discount_type: booking.payment.discount_type,
        discount: discount_total,
        discount_total: discount_total,
        policy_clause: policy_clause,
        salvage: salvage,
        terms: booking.payment.terms,
        pick_up_limit: booking.payment.pick_up_limit,
        pick_up_charges: pick_up_charges,
        paid_total: parseFloat(booking.payment.paid_total),
        discount_applied: booking.payment.discount_applied,
        transaction_id: booking.payment.transaction_id,
        transaction_date: booking.payment.transaction_date,
        transaction_status: booking.payment.transaction_status,
        transaction_response: booking.payment.transaction_response,
      };

      Booking.findOneAndUpdate(
        { _id: booking._id },
        {
          $set: {
            status: status,
            date: date,
            time_slot: time_slot,
            convenience: convenience,
            address: address,
            payment: payment,
            due: due,
            updated_at: new Date(),
          },
        },
        { new: false },
        async function (err, doc) {
          if (err) {
            res.status(400).json({
              responseCode: 400,
              responseMessage: "Error Occurred Try again",
              responseData: err,
            });
          } else {
            if (req.body.requirements) {
              var customer_requirement = {
                added_by: loggedInDetails.name,
                requirement: req.body.requirements,
                user: loggedInDetails._id,
                created_at: new Date(),
                updated_at: new Date(),
              };

              Booking.findOneAndUpdate(
                { _id: booking._id },
                { $push: { customer_requirements: customer_requirement } },
                { new: false },
                async function (err, doc) {}
              );
            }

            if (date) {
              var notify = {
                receiver: [booking.user],
                activity: "booking",
                tag: "bookingConfirmation",
                source: booking._id,
                sender: booking.user,
                points: 0,
              };
              fun.newNotification(notify);
            }

            var updated = await Booking.findById(booking._id).exec();

            res.status(200).json({
              responseCode: 200,
              responseMessage: "Booking Updated",
              responseData: updated,
            });
          }
        }
      );
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Booking not found",
        responseData: {},
      });
    }
  }
);

router.post(
  "/booking/add",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      registration_no: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Error",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var business = req.headers["business"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var loggedInDetails = await User.findById(decoded.user).exec();
      var customer_requirements = [];
      var advisor = await q.all(getAdvisor(loggedInDetails._id, business));

      var check = await User.findOne({ _id: req.body.user }).exec();
      if (check) {
        var date = null;
        if (req.body.date) {
          date = new Date(req.body.date).toISOString();
        }

        if (req.body.requirement) {
          customer_requirements.push({
            user: loggedInDetails._id,
            added_by: loggedInDetails.name,
            requirement: req.body.requirement,
            created_at: new Date(),
            updated_at: new Date(),
          });
        }

        var rg = req.body.registration_no;
        req.body.registration_no = rg.replace(/ /g, "");

        var insurance_info = {
          driver: null,
          accident_place: "",
          accident_date: null,
          accident_time: "",
          accident_cause: "",
          fir: "",
          branch: "",
          cashless: "true",
          claim: "false",
          contact_no: "",
          claim_no: "",
          driver_accident: "",
          expire: null,
          gstin: "",
          insurance_company: "",
          manufacture_year: "",
          policy_holder: "",
          policy_no: "",
          policy_type: "",
          premium: 0,
          spot_survey: "",
          state: "",
        };

        var getCar = await Car.findOne({
          registration_no: req.body.registration_no,
          status: true,
        }).exec();
        if (getCar) {
          /*if(!getCar.user.equals(check._id))
                {
                    res.status(422).json({
                        responseCode: 422,
                        responseMessage: "Registration no authentication error",
                        responseData: {}
                    })
                }
                else
                {*/
          var booking = await Booking.findOne({
            car: getCar._id,
            status: {
              $nin: [
                "Completed",
                "CompleteWork",
                "QC",
                "Closed",
                "Ready",
                "Rejected",
                "Cancelled",
                "Inactive",
              ],
            },
            is_services: true,
          }).exec();

          if (booking) {
            res.status(422).json({
              responseCode: 422,
              responseMessage:
                "Booking already exists for the same registration no. [" +
                booking.status +
                "]",
              responseData: {},
            });
          } else {
            var pick_up_charges = 0;
            var bookingService = [];

            var countBooking = await Booking.find({}).count().exec();

            if (req.body.charges) {
              pick_up_charges = parseFloat(req.body.charges);
            }

            var due = {
              due: pick_up_charges,
            };

            var payment = {
              payment_mode: "",
              payment_status: "Pending",
              discount_type: "",
              coupon: "",
              coupon_type: "",
              discount: 0,
              discount_total: 0,
              part_cost: 0,
              labour_cost: 0,
              paid_total: 0,
              pick_up_charges: pick_up_charges,
              total: pick_up_charges,
              discount_applied: false,
              transaction_id: "",
              transaction_date: "",
              transaction_status: "",
              transaction_response: "",
            };

            var bookingData = {
              package: null,
              car: getCar._id,
              advisor: advisor,
              manager: null,
              business: business,
              user: check.id,
              services: bookingService,
              customer_requirements: customer_requirements,
              booking_no: Math.round(+new Date() / 1000),
              date: date,
              time_slot: req.body.time_slot,
              convenience: "",
              status: "EstimateRequested",
              payment: payment,
              due: due,
              address: req.body.address,
              lead: null,
              insurance_info: insurance_info,
              is_services: true,
              created_at: new Date(),
              updated_at: new Date(),
            };

            Booking.create(bookingData).then(async function (b) {
              var bookings = [];
              var booking = await Booking.findById(b._id)
                .populate({
                  path: "user",
                  populate: {
                    path: "user",
                    select: "_id id name contact_no email business_info",
                  },
                })
                .populate({
                  path: "manager",
                  populate: {
                    path: "user",
                    select: "_id id name contact_no email",
                  },
                })
                .populate({
                  path: "car",
                  select: "_id id title registration_no ic rc",
                  populate: { path: "thumbnails" },
                })
                .exec();

              if (booking.address) {
                var address = await Address.findOne({
                  _id: booking.address,
                }).exec();
              } else {
                var address = {};
              }
              if (booking.car) {
                var car = {
                  title: booking.car.title,
                  _id: booking.car._id,
                  id: booking.car.id,
                  rc_address: booking.car.rc_address,
                  ic_address: booking.car.ic_address,
                  ic: booking.car.ic,
                  rc: booking.car.rc,
                  registration_no: booking.car.registration_no,
                };
              }

              var manager = null;
              if (booking.manager) {
                manager = {
                  name: booking.manager.name,
                  _id: booking.manager._id,
                  id: booking.manager.id,
                  contact_no: booking.manager.contact_no,
                  email: booking.manager.email,
                };
              }
              bookings.push({
                _id: booking._id,
                id: booking._id,
                car: car,
                user: {
                  name: booking.user.name,
                  _id: booking.user._id,
                  id: booking.user.id,
                  contact_no: booking.user.contact_no,
                  email: booking.user.email,
                  business_info: booking.user.business_info,
                },
                manager: manager,
                services: booking.services,
                convenience: booking.convenience,
                date: moment(booking.date).tz(req.headers["tz"]).format("ll"),
                time_slot: booking.time_slot,
                status: booking.status,
                booking_no: booking.booking_no,
                job_no: booking.job_no,
                estimation_requested: booking.estimation_requested,
                address: address,
                remarks: booking.remarks,
                customer_requirements: booking.customer_requirements,
                payment: booking.payment,
                txnid: booking.txnid,
                __v: booking.__v,
                created_at: moment(booking.created_at)
                  .tz(req.headers["tz"])
                  .format("lll"),
                updated_at: moment(booking.updated_at)
                  .tz(req.headers["tz"])
                  .format("lll"),
              });

              event.zohoLead(b._id);

              var activity = {
                user: loggedInDetails._id,
                name: loggedInDetails.name,
                stage: "New Booking",
                activity: "New Booking",
              };

              fun.bookingLog(booking._id, activity);

              var notify = {
                receiver: [booking.user],
                activity: "booking",
                tag: "newBooking",
                source: booking._id,
                sender: booking.business,
                points: 0,
                tz: req.headers["tz"],
              };
              fun.newNotification(notify);

              res.status(200).json({
                responseCode: 200,
                responseMessage: "Booking",
                responseData: bookings,
              });
            });
          }
          /*}*/
        } else {
          var variant = await Variant.findOne({ _id: req.body.variant })
            .populate("model")
            .select("-service_schedule")
            .exec();
          if (variant) {
            var rg = req.body.registration_no;
            req.body.registration_no = rg.replace(/ /g, "");

            var reg = await Car.find({
              registration_no: req.body.registration_no,
              status: true,
            })
              .count()
              .exec();
            if (reg == 0) {
              var automaker = await Automaker.findById(
                variant.model.automaker
              ).exec();
              var data = {
                geometry: [0, 0],
                registration_no: rg.replace(/ /g, ""),
                reg_no_copy: rg.replace(/ /g, ""),
                created_at: new Date(),
                updated_at: new Date(),
                title: variant.variant,
                variant: variant._id,
                _variant: variant.value,
                automaker: automaker._id,
                _automaker: automaker.maker,
                model: variant.model._id,
                _model: variant.model.value,
                segment: variant.model.segment,
                user: check._id,
                vin: req.body.vin,
                engine_no: req.body.engine_no,
                fuel_type: variant.specification.fuel_type,
                transmission: variant.specification.type,
                carId:
                  Math.round(new Date() / 1000) +
                  Math.round(Math.random() * 9999 + 1),
              };

              Car.create(data).then(async function (car) {
                var bookingService = [];
                var countBooking = await Booking.find({}).count().exec();

                var payment = {
                  payment_mode: "",
                  payment_status: "Pending",
                  discount_type: "",
                  coupon: "",
                  coupon_type: "",
                  discount: 0,
                  discount_total: 0,
                  part_cost: 0,
                  labour_cost: 0,
                  paid_total: 0,
                  total: 0,
                  discount_applied: false,
                  transaction_id: "",
                  transaction_date: "",
                  transaction_status: "",
                  transaction_response: "",
                };

                var bookingData = {
                  package: null,
                  car: car,
                  advisor: advisor,
                  business: business,
                  user: check.id,
                  services: bookingService,
                  customer_requirements: customer_requirements,
                  booking_no: Math.round(+new Date() / 1000),
                  date: new Date(),
                  time_slot: "",
                  convenience: "",
                  status: "EstimateRequested",
                  payment: payment,
                  address: null,
                  lead: null,
                  insurance_info: insurance_info,
                  is_services: true,
                  created_at: new Date(),
                  updated_at: new Date(),
                };

                Booking.create(bookingData).then(async function (b) {
                  var bookings = [];
                  var booking = await Booking.findById(b._id)
                    .populate({
                      path: "user",
                      populate: {
                        path: "user",
                        select: "_id id name contact_no email business_info",
                      },
                    })
                    .populate({
                      path: "manager",
                      populate: {
                        path: "user",
                        select: "_id id name contact_no email",
                      },
                    })
                    .populate({
                      path: "car",
                      select: "_id id title registration_no ic rc",
                      populate: { path: "thumbnails" },
                    })
                    .exec();

                  if (booking.address) {
                    var address = await Address.findOne({
                      _id: booking.address,
                    }).exec();
                  } else {
                    var address = {};
                  }
                  if (booking.car) {
                    var car = {
                      title: booking.car.title,
                      _id: booking.car._id,
                      id: booking.car.id,
                      rc_address: booking.car.rc_address,
                      ic_address: booking.car.ic_address,
                      ic: booking.car.ic,
                      rc: booking.car.rc,
                      registration_no: booking.car.registration_no,
                    };
                  } else {
                    var car = {
                      title: "",
                      _id: null,
                      id: null,
                      rc_address: "",
                      ic_address: "",
                      ic: "",
                      rc: "",
                      registration_no: "",
                    };
                  }
                  var manager = null;
                  if (booking.manager) {
                    manager = {
                      name: booking.manager.name,
                      _id: booking.manager._id,
                      id: booking.manager.id,
                      contact_no: booking.manager.contact_no,
                      email: booking.manager.email,
                    };
                  }
                  bookings.push({
                    _id: booking._id,
                    id: booking._id,
                    car: car,
                    user: {
                      name: booking.user.name,
                      _id: booking.user._id,
                      id: booking.user.id,
                      contact_no: booking.user.contact_no,
                      email: booking.user.email,
                      business_info: booking.user.business_info,
                    },
                    manager: manager,
                    services: booking.services,
                    convenience: booking.convenience,
                    date: moment(booking.date)
                      .tz(req.headers["tz"])
                      .format("ll"),
                    time_slot: booking.time_slot,
                    status: booking.status,
                    booking_no: booking.booking_no,
                    job_no: booking.job_no,
                    estimation_requested: booking.estimation_requested,
                    address: address,
                    remarks: booking.remarks,
                    customer_requirements: booking.customer_requirements,
                    payment: booking.payment,
                    txnid: booking.txnid,
                    __v: booking.__v,
                    created_at: moment(booking.created_at)
                      .tz(req.headers["tz"])
                      .format("lll"),
                    updated_at: moment(booking.updated_at)
                      .tz(req.headers["tz"])
                      .format("lll"),
                  });

                  event.zohoLead(b._id);

                  var activity = {
                    user: loggedInDetails._id,
                    name: loggedInDetails.name,
                    stage: "New Booking",
                    activity: "New Booking",
                  };

                  fun.bookingLog(booking._id, activity);

                  var notify = {
                    receiver: [booking.user],
                    activity: "booking",
                    tag: "newBooking",
                    source: booking._id,
                    sender: booking.business,
                    points: 0,
                    tz: req.headers["tz"],
                  };
                  fun.newNotification(notify);

                  res.status(200).json({
                    responseCode: 200,
                    responseMessage: "Booking",
                    responseData: bookings,
                  });
                });
              });
            } else {
              res.status(422).json({
                responseCode: 422,
                responseMessage: "registration no already exist",
                responseData: {},
              });
            }
          } else {
            return res.status(400).json({
              responseCode: 400,
              responseMessage: "Car variant not found",
              responseData: {},
            });
          }
        }
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "User not found",
          responseData: {},
        });
      }
    }
  }
);

router.post("/job/add", xAccessToken.token, async function (req, res, next) {
  var rules = {
    registration_no: "required",
  };

  var validation = new Validator(req.body, rules);

  if (validation.fails()) {
    res.status(422).json({
      responseCode: 422,
      responseMessage: "Error",
      responseData: {
        res: validation.errors.all(),
      },
    });
  } else {
    var token = req.headers["x-access-token"];
    var business = req.headers["business"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var loggedInDetails = await User.findById(decoded.user).exec();
    var customer_requirements = [];
    var advisor = await q.all(getAdvisor(loggedInDetails._id, business));

    var check = await User.findOne({ _id: req.body.user }).exec();
    if (check) {
      var date = null;
      if (req.body.date) {
        date = new Date(req.body.date).toISOString();
      }

      if (req.body.requirement) {
        customer_requirements.push({
          user: loggedInDetails._id,
          added_by: loggedInDetails.name,
          requirement: req.body.requirement,
          created_at: new Date(),
          updated_at: new Date(),
        });
      }

      var insurance_info = {
        driver: null,
        accident_place: "",
        accident_date: null,
        accident_time: "",
        accident_cause: "",
        fir: "",
        branch: "",
        cashless: "true",
        claim: "false",
        contact_no: "",
        claim_no: "",
        driver_accident: "",
        expire: null,
        gstin: "",
        insurance_company: "",
        manufacture_year: "",
        policy_holder: "",
        policy_no: "",
        policy_type: "",
        premium: 0,
        spot_survey: "",
        state: "",
      };

      var rg = req.body.registration_no;
      req.body.registration_no = rg.replace(/ /g, "");

      var getCar = await Car.findOne({
        registration_no: req.body.registration_no,
        status: true,
      }).exec();
      if (getCar) {
        /*if(!getCar.user.equals(check._id))
                {
                    res.status(422).json({
                        responseCode: 422,
                        responseMessage: "Registration no authentication error",
                        responseData: {}
                    })
                }
                else
                {*/
        var booking = await Booking.findOne({
          car: getCar._id,
          status: {
            $nin: [
              "Completed",
              "CompleteWork",
              "QC",
              "Closed",
              "Ready",
              "Rejected",
              "Cancelled",
              "Inactive",
            ],
          },
          is_services: true,
        }).exec();

        if (booking) {
          res.status(422).json({
            responseCode: 422,
            responseMessage:
              "Booking already exists for the same registration no. [" +
              booking.status +
              "]",
            responseData: {},
          });
        } else {
          var pick_up_charges = 0;
          var bookingService = [];

          var countBooking = await Booking.find({}).count().exec();

          if (req.body.charges) {
            pick_up_charges = parseFloat(req.body.charges);
          }

          var due = {
            due: pick_up_charges,
          };

          var payment = {
            payment_mode: "",
            payment_status: "Pending",
            discount_type: "",
            coupon: "",
            coupon_type: "",
            discount: 0,
            discount_total: 0,
            part_cost: 0,
            labour_cost: 0,
            paid_total: 0,
            pick_up_charges: pick_up_charges,
            total: pick_up_charges,
            discount_applied: false,
            transaction_id: "",
            transaction_date: "",
            transaction_status: "",
            transaction_response: "",
          };

          var bookingData = {
            package: null,
            car: getCar._id,
            advisor: advisor,
            manager: null,
            business: business,
            user: check.id,
            services: bookingService,
            customer_requirements: customer_requirements,
            booking_no: Math.round(+new Date() / 1000),
            date: date,
            time_slot: req.body.time_slot,
            convenience: "",
            status: "EstimateRequested",
            payment: payment,
            due: due,
            address: req.body.address,
            lead: null,
            insurance_info: insurance_info,
            is_services: true,
            created_at: new Date(),
            updated_at: new Date(),
          };

          Booking.create(bookingData).then(async function (b) {
            var bookings = [];
            var booking = await Booking.findById(b._id)
              .populate({
                path: "user",
                populate: {
                  path: "user",
                  select: "_id id name contact_no email business_info",
                },
              })
              .populate({
                path: "manager",
                populate: {
                  path: "user",
                  select: "_id id name contact_no email",
                },
              })
              .populate({
                path: "car",
                select: "_id id title registration_no ic rc",
                populate: { path: "thumbnails" },
              })
              .exec();

            if (booking.address) {
              var address = await Address.findOne({
                _id: booking.address,
              }).exec();
            } else {
              var address = {};
            }
            if (booking.car) {
              var car = {
                title: booking.car.title,
                _id: booking.car._id,
                id: booking.car.id,
                rc_address: booking.car.rc_address,
                ic_address: booking.car.ic_address,
                ic: booking.car.ic,
                rc: booking.car.rc,
                registration_no: booking.car.registration_no,
              };
            }

            var manager = null;
            if (booking.manager) {
              manager = {
                name: booking.manager.name,
                _id: booking.manager._id,
                id: booking.manager.id,
                contact_no: booking.manager.contact_no,
                email: booking.manager.email,
              };
            }
            bookings.push({
              _id: booking._id,
              id: booking._id,
              car: car,
              user: {
                name: booking.user.name,
                _id: booking.user._id,
                id: booking.user.id,
                contact_no: booking.user.contact_no,
                email: booking.user.email,
                business_info: booking.user.business_info,
              },
              manager: manager,
              services: booking.services,
              convenience: booking.convenience,
              date: moment(booking.date).tz(req.headers["tz"]).format("ll"),
              time_slot: booking.time_slot,
              status: booking.status,
              booking_no: booking.booking_no,
              job_no: booking.job_no,
              estimation_requested: booking.estimation_requested,
              address: address,
              remarks: booking.remarks,
              customer_requirements: booking.customer_requirements,
              payment: booking.payment,
              txnid: booking.txnid,
              __v: booking.__v,
              created_at: moment(booking.created_at)
                .tz(req.headers["tz"])
                .format("lll"),
              updated_at: moment(booking.updated_at)
                .tz(req.headers["tz"])
                .format("lll"),
            });

            event.zohoLead(b._id);

            res.status(200).json({
              responseCode: 200,
              responseMessage: "Booking",
              responseData: bookings,
            });
          });
        }
        /*}*/
      } else {
        var variant = await Variant.findOne({ _id: req.body.variant })
          .populate("model")
          .select("-service_schedule")
          .exec();
        if (variant) {
          var rg = req.body.registration_no;
          req.body.registration_no = rg.replace(/ /g, "");

          var reg = await Car.find({
            registration_no: req.body.registration_no,
            status: true,
          })
            .count()
            .exec();
          if (reg == 0) {
            var automaker = await Automaker.findById(
              variant.model.automaker
            ).exec();
            var data = {
              geometry: [0, 0],
              registration_no: rg.replace(/ /g, ""),
              reg_no_copy: rg.replace(/ /g, ""),
              created_at: new Date(),
              updated_at: new Date(),
              title: variant.variant,
              variant: variant._id,
              _variant: variant.value,
              automaker: automaker._id,
              _automaker: automaker.maker,
              model: variant.model._id,
              _model: variant.model.value,
              segment: variant.model.segment,
              user: check._id,
              vin: req.body.vin,
              engine_no: req.body.engine_no,
              fuel_type: variant.specification.fuel_type,
              transmission: variant.specification.type,
              carId:
                Math.round(new Date() / 1000) +
                Math.round(Math.random() * 9999 + 1),
            };

            Car.create(data).then(async function (car) {
              var bookingService = [];
              var customer_requirements = [];
              var countBooking = await Booking.find({}).count().exec();

              var payment = {
                payment_mode: "",
                payment_status: "Pending",
                discount_type: "",
                coupon: "",
                coupon_type: "",
                discount: 0,
                discount_total: 0,
                part_cost: 0,
                labour_cost: 0,
                paid_total: 0,
                total: 0,
                discount_applied: false,
                transaction_id: "",
                transaction_date: "",
                transaction_status: "",
                transaction_response: "",
              };

              var bookingData = {
                package: null,
                car: car,
                advisor: advisor,
                business: business,
                user: check.id,
                services: bookingService,
                customer_requirements: customer_requirements,
                booking_no: Math.round(+new Date() / 1000),
                date: new Date(),
                time_slot: "",
                convenience: "",
                status: "EstimateRequested",
                payment: payment,
                address: null,
                lead: null,
                insurance_info: insurance_info,
                is_services: true,
                created_at: new Date(),
                updated_at: new Date(),
              };

              Booking.create(bookingData).then(async function (b) {
                var bookings = [];
                var booking = await Booking.findById(b._id)
                  .populate({
                    path: "user",
                    populate: {
                      path: "user",
                      select: "_id id name contact_no email business_info",
                    },
                  })
                  .populate({
                    path: "manager",
                    populate: {
                      path: "user",
                      select: "_id id name contact_no email",
                    },
                  })
                  .populate({
                    path: "car",
                    select: "_id id title registration_no ic rc",
                    populate: { path: "thumbnails" },
                  })
                  .exec();

                if (booking.address) {
                  var address = await Address.findOne({
                    _id: booking.address,
                  }).exec();
                } else {
                  var address = {};
                }
                if (booking.car) {
                  var car = {
                    title: booking.car.title,
                    _id: booking.car._id,
                    id: booking.car.id,
                    rc_address: booking.car.rc_address,
                    ic_address: booking.car.ic_address,
                    ic: booking.car.ic,
                    rc: booking.car.rc,
                    registration_no: booking.car.registration_no,
                  };
                } else {
                  var car = {
                    title: "",
                    _id: null,
                    id: null,
                    rc_address: "",
                    ic_address: "",
                    ic: "",
                    rc: "",
                    registration_no: "",
                  };
                }
                var manager = null;
                if (booking.manager) {
                  manager = {
                    name: booking.manager.name,
                    _id: booking.manager._id,
                    id: booking.manager.id,
                    contact_no: booking.manager.contact_no,
                    email: booking.manager.email,
                  };
                }
                bookings.push({
                  _id: booking._id,
                  id: booking._id,
                  car: car,
                  user: {
                    name: booking.user.name,
                    _id: booking.user._id,
                    id: booking.user.id,
                    contact_no: booking.user.contact_no,
                    email: booking.user.email,
                    business_info: booking.user.business_info,
                  },
                  manager: manager,
                  services: booking.services,
                  convenience: booking.convenience,
                  date: moment(booking.date).tz(req.headers["tz"]).format("ll"),
                  time_slot: booking.time_slot,
                  status: booking.status,
                  booking_no: booking.booking_no,
                  job_no: booking.job_no,
                  estimation_requested: booking.estimation_requested,
                  address: address,
                  remarks: booking.remarks,
                  customer_requirements: booking.customer_requirements,
                  payment: booking.payment,
                  txnid: booking.txnid,
                  __v: booking.__v,
                  created_at: moment(booking.created_at)
                    .tz(req.headers["tz"])
                    .format("lll"),
                  updated_at: moment(booking.updated_at)
                    .tz(req.headers["tz"])
                    .format("lll"),
                });

                event.zohoLead(b._id);

                res.status(200).json({
                  responseCode: 200,
                  responseMessage: "Booking",
                  responseData: bookings,
                });
              });
            });
          } else {
            res.status(422).json({
              responseCode: 422,
              responseMessage: "registration no already exist",
              responseData: {},
            });
          }
        } else {
          return res.status(400).json({
            responseCode: 400,
            responseMessage: "Car variant not found",
            responseData: {},
          });
        }
      }
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "User not found",
        responseData: {},
      });
    }
  }
});

router.put(
  "/booking/rework",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      id: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Lead required",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var booking = await Booking.findOne({ lead: req.body.id }).exec();
      if (booking) {
        var data = {
          is_rework: true,
          is_reviewed: false,
          updated_at: new Date(),
        };
        Booking.findOneAndUpdate(
          { _id: booking._id },
          { $set: data },
          { new: true },
          async function (err, doc) {
            if (err) {
              var json = {
                responseCode: 422,
                responseMessage: "Error occured",
                responseData: {},
              };
              res.status(422).json(json);
            } else {
              var activity = {
                user: booking.business,
                model: "Booking",
                activity: "bookingReschedule",
                source: booking._id,
                modified: "",
                created_at: data.updated_at,
                updated_at: data.updated_at,
              };
              fun.bookingLog(activity);

              //event.assignedBookingMail(booking._id);
              var notify = {
                receiver: [booking.business],
                activity: "booking",
                tag: "rework",
                source: booking._id,
                sender: booking.user,
                points: 0,
              };

              fun.newNotification(notify);

              if (booking.advisor) {
                var notify = {
                  receiver: [booking.advisor],
                  activity: "booking",
                  tag: "rework",
                  source: booking._id,
                  sender: booking.user,
                  points: 0,
                };
                fun.newNotification(notify);
              }

              res.status(200).json({
                responseCode: 200,
                responseMessage: "Assigned",
                responseData: booking._id,
              });
            }
          }
        );
      } else {
        var json = {
          responseCode: 400,
          responseMessage: "Not eligible for rework",
          responseData: {},
        };
        res.status(400).json(json);
      }
    }
  }
);

/*router.get('/bookings/get', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers['business'];
    var bookings = [];
    var totalResult = 0;


    var role = await Management.findOne({user:user,business:business}).exec();
    if(req.query.page == undefined)
    {
        var page = 0;
    }
    else
    {
        var page = req.query.page;
    }

    var date= new Date();
    var to = moment(date, "YYYY-MM-DD").subtract(1, 'days');

    var page = Math.max(0, parseInt(page));
    var queries = new Object();
    var sortBy = new Object();

    if(req.query.query)
    {
        if(role.role=="Service Advisor")
        {
            queries = {
                advisor: user,
                business: business,
                status: {$in:["Confirmed","Pending","Cancelled","EstimateRequested"]},
                is_services: true,
                $or:[
                    {'booking_no': { $eq: parseInt(req.query.query)}},
                    {'user.name': { $regex: req.query.query ,$options:'i'}},
                    {'user.contact_no': { $regex: req.query.query ,$options:'i'}},
                    {'car.title': { $regex: req.query.query ,$options:'i'}},
                    {'car.registration_no': { $regex: req.query.query ,$options:'i'}},
                    {'advisor.name': { $regex: req.query.query ,$options:'i'}},
                    {'advisor.contact_no': { $regex: req.query.query ,$options:'i'}},
                    {'insurance_info.insurance_company': { $regex: req.query.query ,$options:'i'}},
                    { 
                        "logs": { 
                            $elemMatch: {
                                "status": {$regex: req.query.query ,$options:'i'}
                            }  
                        } 
                    },
                    { 
                        "services": { 
                            $elemMatch: {
                                "service": {$regex: req.query.query ,$options:'i'}
                            }  
                        } 
                    },
                    { 
                        "services": { 
                            $elemMatch: {
                                "parts": {
                                    $elemMatch: {
                                        "item": {$regex: req.query.query ,$options:'i'},
                                    }  
                                }
                            }  
                        } 
                    },
                    { 
                        "services": { 
                            $elemMatch: {
                                "parts": {
                                    $elemMatch: {
                                        "part_no": {$regex: req.query.query ,$options:'i'},
                                    }  
                                }
                            }  
                        } 
                    },
                ]
            };
            sortBy = {date: 1}
        }
        else
        {
            queries = {
                business: business,
                status: {$in:["Confirmed","Pending","Cancelled","EstimateRequested"]},
                is_services: true,
                $or:[
                    {'booking_no': { $eq: parseInt(req.query.query)}},
                    {'user.name': { $regex: req.query.query ,$options:'i'}},
                    {'user.contact_no': { $regex: req.query.query ,$options:'i'}},
                    {'car.title': { $regex: req.query.query ,$options:'i'}},
                    {'car.registration_no': { $regex: req.query.query ,$options:'i'}},
                    {'advisor.name': { $regex: req.query.query ,$options:'i'}},
                    {'advisor.contact_no': { $regex: req.query.query ,$options:'i'}},
                    {'insurance_info.insurance_company': { $regex: req.query.query ,$options:'i'}},
                    { 
                        "logs": { 
                            $elemMatch: {
                                "status": {$regex: req.query.query ,$options:'i'}
                            }  
                        } 
                    },
                    { 
                        "services": { 
                            $elemMatch: {
                                "service": {$regex: req.query.query ,$options:'i'}
                            }  
                        } 
                    },
                    { 
                        "services": { 
                            $elemMatch: {
                                "parts": {
                                    $elemMatch: {
                                        "item": {$regex: req.query.query ,$options:'i'},
                                    }  
                                }
                            }  
                        } 
                    },
                    { 
                        "services": { 
                            $elemMatch: {
                                "parts": {
                                    $elemMatch: {
                                        "part_no": {$regex: req.query.query ,$options:'i'},
                                    }  
                                }
                            }  
                        } 
                    },
                ]
            };
            sortBy = {date: 1}
        }
    }
    else
    {
        if(role.role=="Service Advisor")
        {
            if(req.query.status=="Missed")
            {
                queries = {
                    advisor: user,
                    business: business,
                    status: "Confirmed",
                    is_services: true,
                    date: {"$lte": to}
                };
                sortBy = {date: 1}
            }
            else if(req.query.status=="Approval")
            {
                queries = {
                    advisor: user,
                    business: business,
                    is_services: true,
                    status: {$in: ["Approval","EstimateRequested","Approved","Rework","Pending"]},
                };

                sortBy = {updated_at: -1}
            }
            else if(req.query.status=="Cancelled")
            {
                queries = {
                    advisor: user,
                    business: business,
                    is_services: true,
                    status: {$in: ["Cancelled"]},
                };

                sortBy = {updated_at: -1}
            }
            else
            {
                queries = {
                    advisor: user,
                    business: business,
                    is_services: true,
                    status: {$in: ["Confirmed"]},
                    date: {"$gt": to}
                };
            }
        }
        else
        {
            if(req.query.status=="Missed")
            {
                queries = {
                    business: business,
                    status: "Confirmed",
                    is_services: true,
                    date: {"$lt": to}
                };
                sortBy = {date: 1}
            }
            else if(req.query.status=="Approval")
            {
                queries = {
                    business: business,
                    is_services: true,
                    status: {$in: ["Approval","EstimateRequested","Approved","Rework","Pending"]},
                };

                sortBy = {updated_at: -1}
            }
            else if(req.query.status=="Cancelled")
            {
                queries = {
                    business: business,
                    is_services: true,
                    status: {$in: ["Cancelled"]},
                };

                sortBy = {updated_at: -1}
            }
            else 
            {
                queries = {
                    business: business,
                    is_services: true,
                    status: req.query.status,
                    date: {"$gt": to}
                };

                sortBy = {updated_at: -1}
            }
        }  
    }

    var thumbnail = []

    var totalResult = await Booking.find(queries).count().exec();

    await Booking.find(queries)
    .populate({path: 'user',populate:{ path: 'user',select: "_id id name contact_no email business_info"}})
    .populate({path: 'manager',populate:{ path: 'user',select: "_id id name contact_no email"}})
    .populate({path: 'car',select:'_id id title registration_no ic rc _automaker _model', populate:{ path: 'thumbnails'}})
    .sort(sortBy).skip(config.perPage * page).limit(config.perPage)
    .cursor().eachAsync(async(booking) => {
        if(booking.address)
        {
            var address = await Address.findOne({_id: booking.address}).exec();
        }
        else{
            var address = {};
        }
        if(booking.car)
        {
            var car = {
                title: booking.car._automaker+" "+booking.car._model,
                _id: booking.car._id,
                id: booking.car.id,
                rc_address: booking.car.rc_address,
                ic_address: booking.car.ic_address,
                ic: booking.car.ic,
                rc: booking.car.rc,
                registration_no: booking.car.registration_no,
            }
        }
        else{
            var car = {
                title: "",
                _id:null,
                id: null,
                rc_address: "",
                ic_address:"",
                ic: "",
                rc: "",
                registration_no: "",
            }

        }
        var manager = null;
        if(booking.manager){
            manager = {
                name: booking.manager.name,
                _id: booking.manager._id,
                id: booking.manager.id,
                contact_no: booking.manager.contact_no,
                email: booking.manager.email
            }
        }
        bookings.push({
            _id: booking._id,
            id: booking._id,
            car: car,
            user:{
                name: booking.user.name,
                _id: booking.user._id,
                id: booking.user.id,
                contact_no: booking.user.contact_no,
                email: booking.user.email,
                business_info: booking.user.business_info
            },
            manager: manager,
            services: booking.services,
            convenience: booking.convenience,
            date: moment(booking.date).tz(req.headers['tz']).format('ll'),
            time_slot: booking.time_slot,
            status: booking.status,
            booking_no: booking.booking_no,
            job_no: booking.job_no,
            estimation_requested: booking.estimation_requested,
            address: address,
            remarks: booking.remarks,
            customer_requirements: booking.customer_requirements,
            payment: booking.payment,
            txnid: booking.txnid,
            __v: booking.__v,
            created_at: moment(booking.created_at).tz(req.headers['tz']).format('lll'),
            updated_at: moment(booking.updated_at).tz(req.headers['tz']).format('lll'),
        });
    });

    res.status(200).json({
        responseCode: 200,
        responseMessage: to,
        responseData: bookings,
        responseInfo: {
            totalResult:totalResult
        }
    });
});*/

router.get(
  "/leads/booking/get",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers["business"];
    var bookings = [];
    var totalResult = 0;
    var lead = {};
    // console.log('startDate', req.query.date, req.query.endDate)

    // console.log("Query Status = " + req.query.status)

    var role = await Management.findOne({
      user: user,
      business: business,
    }).exec();
    // console.log("Role  = " + role.role)
    user = null;
    // if (role.role == 'CRE') {
    //     user = role.user
    // } else

    if (role.role == "Admin" || role.role == "Manager") {
      user = { $ne: null };
    } else {
      user = role.user;
    }
    if (req.query.status == "Converted") {
      // console.log("Converted")
      // if (role.role == "CRE") {
      //     var query = { isOutbound: false, manager: user, business: business, converted: true, status: { $nin: ["Rejected", "Cancelled", "Inactive", "EstimateRequested", 'Confirmed'] } }
      // }
      // else
      if (role.role == "Admin" || role.role == "Manager") {
        var query = {
          isOutbound: false,
          business: business,
          converted: true,
          status: {
            $nin: [
              "Rejected",
              "Cancelled",
              "Inactive",
              "EstimateRequested",
              "Confirmed",
            ],
          },
        };
      } else {
        var query = {
          isOutbound: false,
          manager: user,
          business: business,
          converted: true,
          status: {
            $nin: [
              "Rejected",
              "Cancelled",
              "Inactive",
              "EstimateRequested",
              "Confirmed",
            ],
          },
        };
      }
    } else if (req.query.status == "EstimateRequested") {
      // console.log("EstimateRequested")

      // if (role.role == "CRE") {
      //     var query = { manager: user, status: { $in: ["EstimateRequested"] } }
      // }
      // else
      if (role.role == "Admin" || role.role == "Manager") {
        var query = {
          business: business,
          status: { $in: ["EstimateRequested"] },
        };
      } else {
        var query = { manager: user, status: { $in: ["EstimateRequested"] } };
      }
    } else if (req.query.status == "Approval") {
      // console.log("Approval")

      // if (role.role == "CRE") {
      //     var query = { manager: user, converted: true, status: { $in: ["Approval"] } }
      // }
      // else
      if (role.role == "Admin" || role.role == "Manager") {
        var query = {
          business: business,
          converted: true,
          status: { $nin: ["Approval"] },
        };
      } else {
        var query = {
          manager: user,
          converted: true,
          status: { $in: ["Approval"] },
        };
      }
    } else if (req.query.status == "Confirmed") {
      // console.log("Approval")
      // if (role.role == "CRE") {
      //     var query = { isOutbound: false, manager: user, date: { $gte: new Date() }, status: { $in: ["Confirmed"] } }
      // }
      // else
      if (role.role == "Admin" || role.role == "Manager") {
        var query = {
          isOutbound: false,
          business: business,
          date: { $gte: new Date() },
          status: { $in: ["Confirmed"] },
        };
      } else {
        var query = {
          isOutbound: false,
          manager: user,
          date: { $gte: new Date() },
          status: { $in: ["Confirmed"] },
        };
      }
    } else if (req.query.status == "Missed") {
      // console.log("Approval")
      // if (role.role == "CRE") {
      //     var query = { isOutbound: false, manager: user, date: { $lt: new Date() }, status: { $in: ["Confirmed"] } }
      // }
      // else
      if (role.role == "Admin" || role.role == "Manager") {
        var query = {
          isOutbound: false,
          business: business,
          date: { $lt: new Date() },
          status: { $in: ["Confirmed"] },
        };
      } else {
        var query = {
          isOutbound: false,
          manager: user,
          date: { $lt: new Date() },
          status: { $in: ["Confirmed"] },
        };
      }
    } else {
      // console.log("Elsee")
      // if (role.role == "CRE") {
      //     console.log("Convetred " + user)
      //     var query = { isOutbound: false, manager: user, business: business, converted: true, status: { $nin: ["Rejected", "Cancelled", "Inactive", "EstimateRequested", 'Confirmed'] } }
      // }
      // else
      if (role.role == "Admin" || role.role == "Manager") {
        var query = {
          isOutbound: false,
          business: business,
          converted: true,
          status: {
            $nin: [
              "Rejected",
              "Cancelled",
              "Inactive",
              "EstimateRequested",
              "Confirmed",
            ],
          },
        };
      } else {
        var query = {
          isOutbound: false,
          manager: user,
          business: business,
          converted: true,
          status: {
            $nin: [
              "Rejected",
              "Cancelled",
              "Inactive",
              "EstimateRequested",
              "Confirmed",
            ],
          },
        };
      }
    }
    if (req.query.date) {
      query["created_at"] = {
        $gte: new Date(req.query.date),
        $lte: new Date(req.query.endDate),
      };
    }

    if (req.query.page == undefined) {
      var page = 0;
    } else {
      var page = req.query.page;
    }

    var page = Math.max(0, parseInt(page));

    var totalResult = await Booking.find(query).count().exec();
    // console.log('booking find query.....', JSON.stringify(query, null, '\t'))
    await Booking.find(query)
      .populate({
        path: "user",
        populate: {
          path: "user",
          select: "_id id name contact_no email business_info",
        },
      })
      .populate({
        path: "manager",
        populate: { path: "user", select: "_id id name contact_no email" },
      })
      .populate({
        path: "lead",
        populate: { path: "lead", select: "_id id name contact_no email" },
      })
      .populate({
        path: "car",
        select: "_id id title registration_no ic rc",
        populate: { path: "thumbnails" },
      })
      .sort({ updated_at: -1 })
      .skip(config.perPage * page)
      .limit(config.perPage)
      .cursor()
      .eachAsync(async (booking) => {
        if (booking.address) {
          var address = await Address.findOne({ _id: booking.address }).exec();
        } else {
          var address = {};
        }

        if (booking.car) {
          var car = {
            title: booking.car.title,
            _id: booking.car._id,
            id: booking.car.id,
            rc_address: booking.car.rc_address,
            ic_address: booking.car.ic_address,
            ic: booking.car.ic,
            rc: booking.car.rc,
            registration_no: booking.car.registration_no,
          };
        } else {
          var car = {
            title: "",
            _id: null,
            id: null,
            rc_address: "",
            ic_address: "",
            ic: "",
            rc: "",
            registration_no: "",
          };
        }
        var manager = null;
        if (booking.manager) {
          manager = {
            name: booking.manager.name,
            _id: booking.manager._id,
            id: booking.manager.id,
            contact_no: booking.manager.contact_no,
            email: booking.manager.email,
          };
        }
        var status = booking.status;
        if (booking.lead) {
          lead = {
            name: booking.lead.name,
            _id: booking.lead._id,
            id: booking.lead.id,
            contact_no: booking.lead.contact_no,
            source: booking.lead.source,
            email: booking.lead.email,
          };
          status = booking.lead.remark.status;
        }
        if (req.query.status == "Confirmed" || req.query.status == "Missed") {
          status = req.query.status;
        }

        bookings.push({
          _id: booking._id,
          id: booking._id,
          car: car,
          user: {
            name: booking.user.name,
            _id: booking.user._id,
            id: booking.user.id,
            contact_no: booking.user.contact_no,
            email: booking.user.email,
            business_info: booking.user.business_info,
          },
          manager: manager,
          lead: lead,
          services: booking.services,
          convenience: booking.convenience,
          date: moment(booking.date).tz(req.headers["tz"]).format("ll"),
          time_slot: booking.time_slot,
          status: status,
          // status: req.query.status,
          booking_no: booking.booking_no,
          job_no: booking.job_no,
          estimation_requested: booking.estimation_requested,
          address: address,
          remarks: booking.remarks,
          customer_requirements: booking.customer_requirements,
          payment: booking.payment,
          txnid: booking.txnid,
          __v: booking.__v,
          created_at: moment(booking.created_at)
            .tz(req.headers["tz"])
            .format("lll"),
          updated_at: moment(booking.updated_at)
            .tz(req.headers["tz"])
            .format("lll"),
        });
      });

    res.status(200).json({
      responseCode: 200,
      responseMessage: "to",
      responseData: bookings,
      responseInfo: {
        totalResult: totalResult,
        // query: query
      },
    });
  }
);

router.get(
  "/leads/booking/get/old",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers["business"];
    var bookings = [];
    var totalResult = 0;
    var lead = {};
    // console.log('startDate', req.query.date, req.query.endDate)
    var role = await Management.findOne({
      user: user,
      business: business,
    }).exec();
    if (req.query.status == "Converted") {
      // console.log("Converted")
      if (role.role == "CRE") {
        var query = {
          manager: user,
          converted: true,
          status: { $nin: ["Rejected", "Cancelled", "Inactive"] },
        };
      } else {
        var query = {
          business: business,
          converted: true,
          status: {
            $nin: ["Rejected", "Cancelled", "Inactive", "EstimateRequested"],
          },
        };
      }
    } else if (req.query.status == "EstimateRequested") {
      // // console.log("EstimateRequested")

      if (role.role == "CRE") {
        var query = { manager: user, status: { $in: ["EstimateRequested"] } };
      } else {
        var query = {
          business: business,
          status: { $in: ["EstimateRequested"] },
        };
      }
    } else if (req.query.status == "Approval") {
      // // console.log("Approval")

      if (role.role == "CRE") {
        var query = {
          manager: user,
          converted: true,
          status: { $in: ["Approval"] },
        };
      } else {
        var query = {
          business: business,
          converted: true,
          status: { $nin: ["Approval"] },
        };
      }
    } else {
      // // console.log("Elsee")
      if (role.role == "CRE") {
        var query = {
          manager: user,
          converted: true,
          status: {
            $nin: ["Rejected", "Cancelled", "Inactive", "EstimateRequested"],
          },
        };
      } else {
        var query = {
          business: business,
          converted: true,
          status: {
            $nin: ["Rejected", "Cancelled", "Inactive", "EstimateRequested"],
          },
        };
      }
    }
    if (req.query.date) {
      query["created_at"] = {
        $gte: new Date(req.query.date),
        $lte: new Date(req.query.endDate),
      };
    }

    if (req.query.page == undefined) {
      var page = 0;
    } else {
      var page = req.query.page;
    }

    var page = Math.max(0, parseInt(page));

    var totalResult = await Booking.find(query).count().exec();
    // console.log('booking find query.....', query)
    await Booking.find(query)
      .populate({
        path: "user",
        populate: {
          path: "user",
          select: "_id id name contact_no email business_info",
        },
      })
      .populate({
        path: "manager",
        populate: { path: "user", select: "_id id name contact_no email" },
      })
      .populate({
        path: "lead",
        populate: { path: "lead", select: "_id id name contact_no email" },
      })

      .populate({
        path: "car",
        select: "_id id title registration_no ic rc",
        populate: { path: "thumbnails" },
      })
      .sort({ updated_at: -1 })
      .skip(5 * page)
      .limit(5)
      .cursor()
      .eachAsync(async (booking) => {
        if (booking.address) {
          var address = await Address.findOne({ _id: booking.address }).exec();
        } else {
          var address = {};
        }

        if (booking.car) {
          var car = {
            title: booking.car.title,
            _id: booking.car._id,
            id: booking.car.id,
            rc_address: booking.car.rc_address,
            ic_address: booking.car.ic_address,
            ic: booking.car.ic,
            rc: booking.car.rc,
            registration_no: booking.car.registration_no,
          };
        } else {
          var car = {
            title: "",
            _id: null,
            id: null,
            rc_address: "",
            ic_address: "",
            ic: "",
            rc: "",
            registration_no: "",
          };
        }
        var manager = null;
        if (booking.manager) {
          manager = {
            name: booking.manager.name,
            _id: booking.manager._id,
            id: booking.manager.id,
            contact_no: booking.manager.contact_no,
            email: booking.manager.email,
          };
        }
        if (booking.lead) {
          lead = {
            name: booking.lead.name,
            _id: booking.lead._id,
            id: booking.lead.id,
            contact_no: booking.lead.contact_no,
            source: booking.lead.source,
            email: booking.lead.email,
          };
        }
        bookings.push({
          _id: booking._id,
          id: booking._id,
          car: car,
          user: {
            name: booking.user.name,
            _id: booking.user._id,
            id: booking.user.id,
            contact_no: booking.user.contact_no,
            email: booking.user.email,
            business_info: booking.user.business_info,
          },
          manager: manager,
          lead: lead,
          services: booking.services,
          convenience: booking.convenience,
          date: moment(booking.date).tz(req.headers["tz"]).format("ll"),
          time_slot: booking.time_slot,
          status: booking.status,
          booking_no: booking.booking_no,
          job_no: booking.job_no,
          estimation_requested: booking.estimation_requested,
          address: address,
          remarks: booking.remarks,
          customer_requirements: booking.customer_requirements,
          payment: booking.payment,
          txnid: booking.txnid,
          __v: booking.__v,
          created_at: moment(booking.created_at)
            .tz(req.headers["tz"])
            .format("lll"),
          updated_at: moment(booking.updated_at)
            .tz(req.headers["tz"])
            .format("lll"),
        });
      });

    res.status(200).json({
      responseCode: 200,
      responseMessage: "to",
      responseData: bookings,
      responseInfo: {
        totalResult: totalResult,
        query: query,
      },
    });
  }
);

router.get(
  "/converted/bookings/get",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers["business"];
    var bookings = [];
    var totalResult = 0;
    var date = new Date();
    if (req.query.type == "range") {
      if (req.query.query) {
        var query = req.query.query;
        var ret = query.split("to");

        var from = new Date(ret[0]);
        var to = new Date(ret[1]);
      } else {
        var from = new Date(date.getFullYear(), date.getMonth(), 1);
        var to = new Date(
          date.getFullYear(),
          date.getMonth(),
          date.getDate() + 1
        );
      }
    } else if (req.query.type == "period") {
      if (req.query.query) {
        var query = parseInt(req.query.query);
      } else {
        var query = 7;
      }

      var from = new Date(
        date.getFullYear(),
        date.getMonth(),
        date.getDate() - query
      );
      var to = new Date(
        date.getFullYear(),
        date.getMonth(),
        date.getDate() + 1
      );
    } else {
      var from = new Date(date.getFullYear(), date.getMonth(), 1);
      var to = new Date(
        date.getFullYear(),
        date.getMonth(),
        date.getDate() + 1
      );
    }

    if ((req.query.role = "CRE")) {
      var converted = await Lead.find({
        business: business,
        assignee: req.query.user,
        converted: true,
        updated_at: { $gte: from, $lte: to },
      }).exec();

      var id = _.map(converted, "_id");

      var query = {
        lead: { $in: id },
        status: {
          $nin: ["Rejected", "Cancelled", "Inactive", "EstimateRequested"],
        },
        updated_at: { $gte: from, $lte: to },
      };
    } else if ((req.query.role = "Service Advisor")) {
      var query = {
        business: business,
        advisor: req.query.user,
        converted: true,
        status: {
          $nin: ["Rejected", "Cancelled", "Inactive", "EstimateRequested"],
        },
        updated_at: { $gte: from, $lte: to },
      };
    } else {
      var query = {
        business: business,
        converted: true,
        status: {
          $nin: ["Rejected", "Cancelled", "Inactive", "EstimateRequested"],
        },
        updated_at: { $gte: from, $lte: to },
      };
    }

    await Booking.find(query)
      .populate({
        path: "user",
        populate: {
          path: "user",
          select: "_id id name contact_no email business_info",
        },
      })
      .populate({
        path: "manager",
        populate: { path: "user", select: "_id id name contact_no email" },
      })
      .populate({
        path: "car",
        select: "_id id title registration_no ic rc _automaker _model",
        populate: { path: "thumbnails" },
      })
      .sort({ updated_at: -1 })
      .cursor()
      .eachAsync(async (booking) => {
        if (booking.address) {
          var address = await Address.findOne({ _id: booking.address }).exec();
        } else {
          var address = {};
        }

        var approved = _.filter(
          booking.services,
          (customer_approval) => customer_approval.customer_approval == true
        );

        var labour_cost = _.sumBy(approved, (x) => x.labour_cost);
        var part_cost = _.sumBy(approved, (x) => x.part_cost);
        var of_cost = _.sumBy(approved, (x) => x.of_cost);
        var discount_total = _.sumBy(approved, (x) => x.discount);

        var careager_cash = booking.payment.careager_cash;
        var pick_up_charges = booking.payment.pick_up_charges;
        var policy_clause = booking.payment.policy_clause;
        var salvage = booking.payment.salvage;
        var paid_total = booking.payment.paid_total;

        var payment_total =
          labour_cost +
          part_cost +
          of_cost +
          discount_total +
          policy_clause +
          salvage +
          pick_up_charges;

        var estimate_cost =
          labour_cost +
          part_cost +
          of_cost +
          policy_clause +
          salvage +
          pick_up_charges -
          careager_cash;

        var due_amount =
          labour_cost +
          part_cost +
          of_cost +
          policy_clause +
          salvage +
          pick_up_charges -
          (paid_total + careager_cash);

        var due = {
          due: Math.ceil(due_amount.toFixed(2)),
        };

        var payment = {
          total: parseFloat(payment_total.toFixed(2)),
          estimate_cost: parseFloat(estimate_cost.toFixed(2)),
          careager_cash: careager_cash,
          of_cost: of_cost,
          labour_cost: labour_cost,
          part_cost: part_cost,
          payment_mode: booking.payment.payment_mode,
          payment_status: booking.payment.payment_status,
          discount_type: booking.payment.discount_type,
          coupon: booking.payment.coupon,
          coupon_type: booking.payment.coupon_type,
          discount_by: booking.payment.discount_by,
          discount: discount_total,
          discount_total: discount_total,
          policy_clause: policy_clause,
          salvage: salvage,
          terms: booking.payment.terms,
          pick_up_limit: booking.payment.pick_up_limit,
          pick_up_charges: pick_up_charges,
          paid_total: booking.payment.paid_total,
          discount_applied: booking.payment.discount_applied,
          transaction_id: booking.payment.coupon,
          transaction_date: booking.payment.transaction_date,
          transaction_status: booking.payment.transaction_status,
          transaction_response: booking.payment.transaction_response,
        };

        if (booking.car) {
          var car = {
            title: booking.car._automaker + " " + booking.car._model,
            _id: booking.car._id,
            id: booking.car.id,
            rc_address: booking.car.rc_address,
            ic_address: booking.car.ic_address,
            ic: booking.car.ic,
            rc: booking.car.rc,
            registration_no: booking.car.registration_no,
          };
        } else {
          var car = {
            title: "",
            _id: null,
            id: null,
            rc_address: "",
            ic_address: "",
            ic: "",
            rc: "",
            registration_no: "",
          };
        }
        var manager = null;
        if (booking.manager) {
          manager = {
            name: booking.manager.name,
            _id: booking.manager._id,
            id: booking.manager.id,
            contact_no: booking.manager.contact_no,
            email: booking.manager.email,
          };
        }
        bookings.push({
          _id: booking._id,
          id: booking._id,
          car: car,
          user: {
            name: booking.user.name,
            _id: booking.user._id,
            id: booking.user.id,
            contact_no: booking.user.contact_no,
            email: booking.user.email,
            business_info: booking.user.business_info,
          },
          manager: manager,
          services: booking.services,
          convenience: booking.convenience,
          date: moment(booking.date).tz(req.headers["tz"]).format("ll"),
          time_slot: booking.time_slot,
          status: booking.status,
          booking_no: booking.booking_no,
          job_no: booking.job_no,
          estimation_requested: booking.estimation_requested,
          address: address,
          remarks: booking.remarks,
          customer_requirements: booking.customer_requirements,
          payment: payment,
          txnid: booking.txnid,
          __v: booking.__v,
          created_at: moment(booking.created_at)
            .tz(req.headers["tz"])
            .format("lll"),
          updated_at: moment(booking.updated_at)
            .tz(req.headers["tz"])
            .format("lll"),
        });
      });

    res.status(200).json({
      responseCode: 200,
      responseMessage: id,
      responseData: bookings,
      responseInfo: {
        totalResult: totalResult,
      },
    });
  }
);

router.get(
  "/booking/activities/get",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      id: "required",
    };

    var validation = new Validator(req.query, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Booking required",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var booking = await Booking.findOne({ _id: req.query.id }).exec();
      var activities = [];

      if (booking) {
        await bookingLog
          .find({ source: booking._id })
          .populate({
            path: "user",
            populate: { path: "user", select: "_id id name contact_no" },
          })
          .cursor()
          .eachAsync(async (activity) => {
            activities.push({
              user: {
                name: activity.user.name,
                _id: activity.user._id,
                id: activity.user.id,
                contact_no: activity.user.contact_no,
              },
              activity: _.startCase(activity.activity),
              modified: activity.modified,
              created_at: activity.created_at,
              updated_at: activity.updated_at,
            });
          });

        res.status(200).json({
          responseCode: 200,
          responseMessage: "",
          responseData: activities,
        });
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Booking required",
          responseData: {},
        });
      }
    }
  }
);

router.get(
  "/user/bookings/get",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers["business"];
    var bookings = [];
    var totalResult = 0;

    var role = await Management.findOne({
      user: user,
      business: business,
    }).exec();
    //////////////console.log(role)
    if (req.query.page == undefined) {
      var page = 0;
    } else {
      var page = req.query.page;
    }

    var page = Math.max(0, parseInt(page));
    var queries = new Object();
    var sortBy = new Object();

    if (req.query.by == "user") {
      queries = {
        user: req.query.query,
        status: {
          $in: [
            "Cancelled",
            "Confirmed",
            "Pending",
            "Rejected",
            "Closed",
            "Completed",
            "Failure",
            "EstimateRequested",
            "In-Process",
            "Dissatisfied",
            "Approval",
            "Approved",
            "Failed",
            "JobInitiated",
            "JobOpen",
            "EstimatePrepared",
            "ApprovalAwaited",
            "StartWork",
            "CloseWork",
            "CompleteWork",
            "QC",
            "Rework",
          ],
        },
      };
    }

    if (req.query.by == "contact") {
      var user = await User.findOne({ contact_no: req.query.query }).exec();
      queries = {
        user: user._id,
        status: {
          $in: [
            "Cancelled",
            "Confirmed",
            "Pending",
            "Rejected",
            "Closed",
            "Completed",
            "Failure",
            "EstimateRequested",
            "In-Process",
            "Dissatisfied",
            "Approval",
            "Approved",
            "Failed",
            "JobInitiated",
            "JobOpen",
            "EstimatePrepared",
            "ApprovalAwaited",
            "StartWork",
            "CloseWork",
            "CompleteWork",
            "QC",
            "Rework",
          ],
        },
      };
    }

    totalResult = await Booking.find(queries).count().exec();

    await Booking.find(queries)
      .populate({
        path: "user",
        populate: { path: "user", select: "_id id name contact_no" },
      })
      .populate({
        path: "manager",
        populate: { path: "user", select: "_id id name contact_no" },
      })
      .populate({
        path: "car",
        select: "_id id title registration_no ic rc _automaker _model",
        populate: { path: "thumbnails" },
      })
      .sort({ updated_at: -1 })
      .skip(config.perPage * page)
      .limit(config.perPage)
      .cursor()
      .eachAsync(async (booking) => {
        if (booking.address) {
          var address = await Address.findOne({ _id: booking.address }).exec();
        } else {
          var address = {};
        }
        if (booking.car.thumbnails[0]) {
          var thumbnail = [booking.car.thumbnails[0]];
        } else {
          var thumbnail = [];
        }
        bookings.push({
          _id: booking._id,
          id: booking._id,
          car: {
            title: booking.car._automaker + " " + booking.car._model,
            _id: booking.car._id,
            id: booking.car.id,
            ic: booking.car.ic,
            rc: booking.car.rc,
            rc_address: booking.car.rc_address,
            ic_address: booking.car.ic_address,
            registration_no: booking.car.registration_no,
            thumbnails: thumbnail,
          },
          user: {
            name: booking.user.name,
            _id: booking.user._id,
            id: booking.user.id,
            contact_no: booking.user.contact_no,
          },
          manager: booking.manager,
          services: booking.services,
          convenience: booking.convenience,
          date: moment(booking.date).tz(req.headers["tz"]).format("ll"),
          time_slot: booking.time_slot,
          status: booking.status,
          booking_no: booking.booking_no,
          estimation_requested: booking.estimation_requested,
          address: address,
          payment: booking.payment,
          customer_requirements: booking.customer_requirements,
          txnid: booking.txnid,
          __v: booking.__v,
          updated_at: booking.updated_at,
          updated_at: booking.updated_at,
        });
      });

    res.status(200).json({
      responseCode: 200,
      responseMessage: "",
      responseData: bookings,
      responseInfo: {
        totalResult: totalResult,
      },
    });
  }
);

router.post(
  "/user/car/add",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers["business"];

    var currentDate = new Date();

    /*var booking = await Booking.findOne({_id:req.body.id}).populate('model').select('-service_schedule').exec();*/
    var user = await User.findOne({ _id: req.body.user }).exec();
    var variant = await Variant.findOne({ _id: req.body.variant })
      .populate("model")
      .select("-service_schedule")
      .exec();

    if (user) {
      if (variant != null && variant) {
        var rg = req.body.registration_no;
        req.body.registration_no = rg.replace(/ /g, "");

        var reg = await Car.find({
          registration_no: req.body.registration_no,
          status: true,
        })
          .count()
          .exec();
        if (reg == 0) {
          var count = await Car.find({}).count().exec();
          var automaker = await Automaker.findById(
            variant.model.automaker
          ).exec();
          req.body.geometry = [0, 0];

          req.body.created_at = currentDate;
          req.body.updated_at = currentDate;

          req.body.title = variant.variant;
          req.body._variant = variant.value;
          req.body.automaker = variant.model.automaker;
          req.body._automaker = automaker.maker;
          req.body.model = variant.model._id;
          req.body._model = variant.model.value;
          req.body.segment = variant.model.segment;
          req.body.user = req.body.user;
          req.body.vin = req.body.vin;
          req.body.engine_no = req.body.engine_no;
          req.body.fuel_type = variant.specification.fuel_type;
          req.body.transmission = variant.specification.type;
          (req.body.carId =
            Math.round(+new Date() / 1000) +
            Math.round(Math.random() * 9999 + 1)),
            Car.create(req.body).then(async function (car) {
              User.findOneAndUpdate(
                { _id: user._id },
                {
                  $push: {
                    cars: car._id,
                  },
                },
                { new: true },
                async function (err, doc) {
                  if (err) {
                    ////////////console.log(err)
                  } else {
                    ////////////console.log(err)
                  }
                }
              );

              fun.addMember(req.body.user, variant.model);

              /*Booking.findOneAndUpdate({_id: booking._id}, {$set:{car:car._id}},{new: false}, async function(err, doc){*/

              await Car.find({ _id: car._id })
                .populate("bookmark")
                .populate("thumbnails")
                .populate({
                  path: "user",
                  select: "name username avatar avatar_address address",
                })
                .populate({ path: "variant", populate: { path: "model" } })
                .cursor()
                .eachAsync(async (doc) => {
                  result = {
                    __v: 0,
                    _id: doc._id,
                    id: doc.id,
                    title: doc.title,
                    variant: doc.variant._id,
                    model: doc.model,
                    modelName: doc.variant.model.model,
                    price: 0,
                    numericPrice: doc.price,
                    vin: doc.vin,
                    engine_no: doc.engine_no,
                    accidental: doc.accidental,
                    body_style: doc.body_style,
                    description: doc.description,
                    driven: doc.driven,
                    carId: doc.carId,
                    fuel_type: doc.fuel_type,
                    insurance: doc.insurance,
                    location: doc.location,
                    manufacture_year: doc.manufacture_year,
                    mileage: doc.mileage,
                    owner: doc.owner,
                    registration_no: doc.registration_no,
                    service_history: doc.service_history,
                    transmission: doc.transmission,
                    vehicle_color: doc.vehicle_color,
                    vehicle_status: doc.vehicle_status,
                    geometry: doc.geometry,
                    //link: "/car/"+slugify(doc.title+" "+doc._id),
                    publish: doc.publish,
                    status: doc.status,
                    premium: doc.premium,
                    is_bookmarked: doc.is_bookmarked,
                    thumbnails: doc.thumbnails,
                    user: doc.user,
                    created_at: doc.created_at,
                    updated_at: doc.updated_at,
                  };
                });

              res.status(200).json({
                responseCode: 200,
                responseMessage: "Car has been added",
                responseData: {
                  item: result,
                },
              });
              /*});*/
            });
        } else {
          res.status(422).json({
            responseCode: 422,
            responseMessage: "registration no already exist",
            responseData: {},
          });
        }
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Unprocessable Entity",
          responseData: {},
        });
      }
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "user not found",
        responseData: {},
      });
    }
  }
);

router.post(
  "/booking/user/car/add",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers["business"];

    var currentDate = new Date();
    var booking = await Booking.findOne({ _id: req.body.booking }).exec();
    if (booking) {
      var car = await Car.findOne({ _id: req.body.car }).exec();
      if (car) {
        Booking.findOneAndUpdate(
          { _id: booking._id },
          { $set: { car: car._id } },
          { new: false },
          async function (err, doc) {
            if (err) {
              res.status(422).json({
                responseCode: 422,
                responseMessage: "Unprocessable Entity",
                responseData: {},
              });
            } else {
              var booking = await Booking.findOne({
                _id: req.body.booking,
              }).exec();
              res.status(200).json({
                responseCode: 200,
                responseMessage: "Car has been added",
                responseData: booking,
              });
            }
          }
        );
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Car not found",
          responseData: {},
        });
      }
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Booking not found",
        responseData: {},
      });
    }
  }
);

router.get(
  "/services/category/get",
  xAccessToken.token,
  async function (req, res, next) {
    var data = [];
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;

    await BookingCategory.find({})
      .sort({ position: 1 })
      .cursor()
      .eachAsync(async (d) => {
        data.push({
          _id: d._id,
          id: d._id,
          tag: d.tag,
          position: d.position,
          icon: d.icon,
          title: d.title,
          image: d.image,
          video: d.video,
          home_visibility: d.home_visibility,
          id: d._id,
          nested: d.nested,
          enable: true,
          features: d.features,
        });
      });

    res.status(200).json({
      responseCode: 200,
      responseMessage: "",
      responseData: data,
    });
  }
);

router.put(
  "/booking/remarks/edit",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      booking: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Booking required",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var user = decoded.user;
      var business = req.headers["business"];
      var booking = await Booking.findOne({
        _id: req.body.booking,
        business: business,
      }).exec();
      var loggedInDetails = await User.findById(decoded.user).exec();
      if (booking) {
        var remarks = [];
        if (booking.remarks) {
          remarks = booking.remarks;
        }

        remarks.push({
          remark: req.body.remark,
          added_by: loggedInDetails._id,
          date: moment().format("YYYY-MM-DD"),
          created_at: new Date(),
          updated_at: new Date(),
        });

        var service_reminder = null;
        if (req.body.date) {
          service_reminder = new Date(req.body.date).toISOString();
        }

        var data = {
          remarks: remarks,
          service_reminder: service_reminder,
          updated_at: new Date(),
        };

        Booking.findOneAndUpdate(
          { _id: booking._id },
          { $set: data },
          { new: false },
          async function (err, doc) {
            if (err) {
              res.status(422).json({
                responseCode: 422,
                responseMessage: "Server Error",
                responseData: err,
              });
            } else {
              var updated = await Booking.findOne({
                _id: req.body.booking,
              }).exec();
              res.status(200).json({
                responseCode: 200,
                responseMessage: "Remark has been added",
                responseData: updated,
              });
            }
          }
        );
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Booking not found",
          responseData: {},
        });
      }
    }
  }
);

router.get(
  "/bookings/count",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers["business"];
    var status = [];

    var pending = await Booking.find({
      business: business,
      is_services: true,
      status: "Pending",
    })
      .count()
      .exec();

    status.push({
      status: "Pending",
      count: pending,
    });

    var confirmed = await Booking.find({
      business: business,
      is_services: true,
      status: "Confirmed",
    })
      .count()
      .exec();
    status.push({
      status: "Confirmed",
      count: confirmed,
    });

    var completed = await Booking.find({
      business: business,
      is_services: true,
      status: "Completed",
    })
      .count()
      .exec();
    status.push({
      status: "Completed",
      count: completed,
    });

    var rejected = await Booking.find({
      business: business,
      is_services: true,
      status: "Rejected",
    })
      .count()
      .exec();
    status.push({
      status: "Rejected",
      count: rejected,
    });

    var cancelled = await Booking.find({
      business: business,
      is_services: true,
      status: "Cancelled",
    })
      .count()
      .exec();
    status.push({
      status: "Cancelled",
      count: cancelled,
    });

    var date = new Date();
    date.setDate(date.getDate() - 1);
    queries = {
      business: business,
      status: { $ne: "Inactive" },

      $or: [
        {
          status: { $ne: "Rejected" },
        },
        {
          status: { $ne: "Cancelled" },
        },
        {
          status: { $ne: "Completed" },
        },
      ],
      is_services: true,
      date: { $lte: date },
    };

    var missed = await Booking.find(queries).count().exec();
    status.push({
      status: "Missed",
      count: missed,
    });

    res.status(200).json({
      responseCode: 200,
      responseMessage: "success",
      responseData: status,
    });
  }
);

router.put("/booking/status",xAccessToken.token,async function (req, res) {
    var rules = {
      id: "required",
      status: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Error",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var user = decoded.user;
      var business = req.headers["business"];

      var loggedInDetails = await User.findById(user).exec();
      var check = await Booking.findOne({
        _id: req.body.id,
        business: business,
        is_services: true,
      }).exec();
      var role = await Management.findOne({
        business: business,
        user: loggedInDetails._id,
      }).exec();

      if (!check) {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Booking not found",
          responseData: {},
        });
      } else {
        var status = check.status;
        var data = {
          status: req.body.status,
          status: req.body.status,
          is_rework: false,
          is_reviewed: false,
          updated_at: new Date(),
        };

        if (check.status != req.body.status) {
          Booking.findOneAndUpdate(
            { _id: req.body.id },
            { $set: data },
            { new: true },
            async function (err, doc) {
              if (err) {
                var json = {
                  responseCode: 422,
                  responseMessage: "Error occured",
                  responseData: {},
                };
                res.status(422).json(json);
              } else {
                var booking = await Booking.findOne({ _id: check._id }).exec();
                var activity = {
                  user: user,
                  model: "Booking",
                  activity: "updateBookingStatus",
                  source: booking._id,
                  modified: check.status + " to " + data.status,
                  created_at: data.updated_at,
                  updated_at: data.updated_at,
                };

                fun.bookingLog(activity);

                if (req.body.status == "Confirmed") {
                  var notify = {
                    receiver: [booking.user],
                    activity: "booking",
                    tag: "bookingConfirmation",
                    source: check._id,
                    sender: user,
                    points: 0,
                  };
                  fun.newNotification(notify);
                  event.bookingStatusMail(booking.user, booking._id);
                }

                if (req.body.status == "Cancelled") {
                  if (req.body.remark) {
                    var remark = {
                      remark: req.body.remark,
                      added_by: decoded.user,
                      created_at: data.updated_at,
                      updated_at: data.updated_at,
                    };

                    Booking.findOneAndUpdate(
                      { _id: booking._id },
                      { $push: { remarks: remark } },
                      { new: false },
                      async function (err, doc) {}
                    );
                  }

                  if (booking.payment.coupon) {
                    var checkCouponUsed = await CouponUsed.find({
                      booking: booking._id,
                    })
                      .count()
                      .exec();
                    if (checkCouponUsed == 1) {
                      await CouponUsed.remove({ booking: booking._id }).exec();
                    }
                  }

                  if (role.role == "Service Advisor") {
                    if (booking.converted) {
                      if (booking.manager) {
                        var notify = {
                          receiver: [booking.manager],
                          activity: "booking",
                          tag: "BookingCancelled",
                          source: check._id,
                          sender: loggedInDetails._id,
                          points: 0,
                        };

                        fun.newNotification(notify);
                      }
                    }
                  } else if (role.role == "CRE") {
                    var notify = {
                      receiver: [booking.advisor],
                      activity: "booking",
                      tag: "BookingCancelled",
                      source: check._id,
                      sender: loggedInDetails._id,
                      points: 0,
                    };

                    fun.newNotification(notify);
                  } else {
                    if (booking.converted) {
                      if (booking.manager) {
                        var notify = {
                          receiver: [booking.manager],
                          activity: "booking",
                          tag: "BookingCancelled",
                          source: check._id,
                          sender: loggedInDetails._id,
                          points: 0,
                        };

                        fun.newNotification(notify);
                      }
                    }

                    var notify = {
                      receiver: [booking.advisor],
                      activity: "booking",
                      tag: "BookingCancelled",
                      source: check._id,
                      sender: loggedInDetails._id,
                      points: 0,
                    };

                    fun.newNotification(notify);
                  }

                  var notify = {
                    receiver: [booking.user],
                    activity: "booking",
                    tag: "BookingCancelled",
                    source: check._id,
                    sender: loggedInDetails._id,
                    points: 0,
                  };

                  fun.newNotification(notify);

                  if (booking.payment.careager_cash > 0) {
                    var point = {
                      user: booking.user,
                      activity: "coin",
                      tag: "BookingCancelled",
                      source: booking._id,
                      sender: null,
                      title: "",
                      body: "",
                      points: booking.payment.careager_cash,
                      status: true,
                    };

                    fun.addPoints(point);
                  }
                } else if (
                  req.body.status == "Completed" &&
                  status != "Completed"
                ) {
                  var point = {
                    user: check.user,
                    activity: "coin",
                    tag: "bookingCompleted",
                    source: check._id,
                    sender: null,
                    points: 50,
                    title: "",
                    body: "",
                    status: true,
                  };

                  fun.addPoints(point);

                  if (booking.payment.labour_cost >= 5000) {
                    var getRefree = await User.findById(booking.user).exec();

                    if (getRefree.account_info.added_by) {
                      var refree = await User.findById(
                        getRefree.account_info.added_by
                      ).exec();
                      if (refree) {
                        if ((refree.account_info.type = "driver")) {
                          var commission = booking.payment.labour_cost * 0.05;
                          var cashInterest = refree.careager_cash * 0.05;

                          var cash =
                            parseFloat(cashInterest) + parseFloat(commission);

                          var point = {
                            user: refree._id,
                            points: parseFloat(cash),
                            activity: "coin",
                            tag: "commission",
                            source: booking._id,
                            title: "",
                            body: "",
                            status: true,
                          };
                          fun.addPoints(point);
                        }
                      }
                    }
                  }

                  if (booking.manager) {
                    var notify = {
                      receiver: [booking.manager],
                      activity: "booking",
                      tag: "bookingCompleted",
                      source: check._id,
                      sender: null,
                      points: 0,
                    };

                    fun.newNotification(notify);
                  }

                  if (booking.due) {
                    var paid_total =
                      booking.payment.paid_total + booking.due.due;
                    Booking.findOneAndUpdate(
                      { _id: req.body.id },
                      {
                        $set: {
                          "payment.payment_status": "Success",
                          "payment.paid_total": paid_total,
                          due: null,
                        },
                      },
                      { new: false },
                      async function (err, doc) {}
                    );
                  }
                }

                var activity = {
                  user: loggedInDetails._id,
                  name: loggedInDetails.name,
                  stage: "Booking",
                  activity: req.body.status,
                };

                fun.bookingLog(booking._id, activity);
                event.zohoLead(booking._id);

                var json = {
                  responseCode: 200,
                  responseMessage: "Booking has been " + req.body.status,
                  responseData: {},
                };

                res.status(200).json(json);
              }
            }
          );
        } else {
          res.status(200).json({
            responseCode: 200,
            responseMessage: "Booking has been " + req.body.status,
            responseData: {},
          });
        }
      }
    }
  }
);

router.put("/booking/reschedule/",xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      id: "required",
      date: "required",
      time_slot: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Error",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      if (req.body.package == "") {
        req.body.package = null;
      }
      // console.log("Common.js ")
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var user = decoded.user;
      var total = 0;
      var labour_cost = 0;
      var part_cost = 0;
      var bookingService = [];
      var services = req.body.services;
      var loggedInDetails = await User.findById(user).exec();
      if (loggedInDetails.account_info.type == "user") {
        var booking = await Booking.findOne({
          _id: req.body.id,
          user: user,
          is_services: true,
        }).exec();
      } else {
        var booking = await Booking.findOne({
          _id: req.body.id,
          business: user,
          is_services: true,
        }).exec();
      }

      if (booking) {
        var d1 = new Date(req.body.date);
        var date = new Date();
        var d2 = new Date(date.getFullYear(), date.getMonth(), date.getDate());
        var seconds = (d1.getTime() - d2.getTime()) / 1000;
        // console.log(seconds)
        if (seconds >= 172800) {
          var status = "Confirmed";
        } else {
          var status = "Pending";
        }

        var data = {
          date: new Date(req.body.date).toISOString(),
          time_slot: req.body.time_slot,
          status: status,
          updated_at: new Date(),
        };

        Booking.findOneAndUpdate(
          { _id: booking._id },
          { $set: data },
          { new: false },
          async function (err, doc) {
            if (err) {
              var json = {
                responseCode: 400,
                responseMessage: "Error occured",
                responseData: {},
              };
              res.status(400).json(json);
            } else {
              if (loggedInDetails.account_info.type == "user") {
                var notify = {
                  receiver: [booking.business],
                  activity: "booking",
                  tag: "bookingReschedule",
                  source: booking._id,
                  sender: user,
                  points: 0,
                  tz: req.headers["tz"],
                };
                fun.newNotification(notify);
                var activity = {
                  user: loggedInDetails._id,
                  name: loggedInDetails.name,
                  stage: "Booking",
                  activity: "BookingReschedule",
                };

                fun.bookingLog(booking._id, activity);
              } else {
                var notify = {
                  receiver: [booking.user],
                  activity: "booking",
                  tag: "bookingReschedule",
                  source: booking._id,
                  sender: user,
                  points: 0,
                  tz: req.headers["tz"],
                };
                fun.newNotification(notify);

                var activity = {
                  user: loggedInDetails._id,
                  name: loggedInDetails.name,
                  stage: "Booking",
                  activity: "BookingReschedule",
                };

                fun.bookingLog(booking._id, activity);
              }

              event.rescheduleMail(
                booking._id,
                loggedInDetails.account_info.type
              );

              var activity = {
                user: user,
                model: "Booking",
                activity: "bookingReschedule",
                source: booking._id,
                modified:
                  moment(booking.date).tz(req.headers["tz"]).format("ll") +
                  " (" +
                  booking.time_slot +
                  ")" +
                  " to " +
                  moment(data.date).tz(req.headers["tz"]).format("ll") +
                  " (" +
                  data.time_slot +
                  ")",
                created_at: data.updated_at,
                updated_at: data.updated_at,
              };
              fun.activityLog(activity);

              var json = {
                responseCode: 200,
                responseMessage: "Booking rescheduled",
                responseData: {
                  date: moment(data.date).tz(req.headers["tz"]).format("ll"),
                  time_slot: data.time_slot,
                  updated_at: data.updated_at,
                },
              };
              res.status(200).json(json);
            }
          }
        );
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Unauthorized",
          responseData: {},
        });
      }
    }
  }
);

router.get("/product/category/get",xAccessToken.token,async function (req, res, next) {
    const productCategories = await ProductCategory.find({
      parent_id: null,
    }).exec();
    res.status(200).json({
      responseCode: 200,
      responseMessage: "success",
      responseData: productCategories,
    });
  }
);

router.get(
  "/product/subcategory/get",
  xAccessToken.token,
  async function (req, res, next) {
    const productCategories = await ProductCategory.find({
      parent_id: req.query.id,
    }).exec();
    res.status(200).json({
      responseCode: 200,
      responseMessage: "success",
      responseData: productCategories,
    });
  }
);

router.get(
  "/product/brands/get",
  xAccessToken.token,
  async function (req, res, next) {
    if (req.query.by == "category") {
      var data = await ProductBrand.find({ category: req.query.query }).exec();
    } else if (req.query.by == "tag") {
      var data = await ProductBrand.find({ tag: req.query.query }).exec();
    } else if (req.query.by == "id") {
      var data = await ProductBrand.findOne({ _id: req.query.query }).exec();
    } else {
      var data = await ProductBrand.find({}).exec();
    }
    res.status(200).json({
      responseCode: 200,
      responseMessage: "success",
      responseData: data,
    });
  }
);

router.get(
  "/product/models/get",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      id: "required",
    };

    var validation = new Validator(req.query, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Error",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      res.status(200).json({
        responseCode: 200,
        responseMessage: "success",
        responseData: await ProductModel.find({ brand: req.query.id }).exec(),
      });
    }
  }
);

router.get(
  "/products/master/get",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      id: "required",
    };

    var validation = new Validator(req.query, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Error",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      res.status(200).json({
        responseCode: 200,
        responseMessage: "success",
        responseData: await Product.find({
          product_model: req.query.id /*common: true*/,
        }).exec(),
      });
    }
  }
);

router.get(
  "/business/category/get",
  xAccessToken.token,
  async function (req, res, next) {
    const categories = await Category.find({}).exec();
    res.status(200).json({
      responseCode: 200,
      responseMessage: "success",
      responseData: categories,
    });
  }
);

router.delete(
  "/vendor/delete",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      vendor: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Business is required!",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var user = decoded.user;
      var business = req.headers["business"];

      var user = await User.findById(req.body.vendor).exec();

      if (user) {
        BusinessVendor.remove({ vendor: user._id, business: business }).exec();
        res.status(200).json({
          responseCode: 200,
          responseMessage: "Vendor has been removed from list",
          responseData: {},
        });
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Business not found",
          responseData: {},
        });
      }
    }
  }
);

router.get("/vendors/get", xAccessToken.token, async function (req, res, next) {
  var token = req.headers["x-access-token"];
  var secret = config.secret;
  var decoded = jwt.verify(token, secret);
  var user = decoded.user;
  var business = req.headers["business"];
  var product = new Object();
  var result = [];

  if (req.query.page == undefined) {
    var page = 0;
  } else {
    var page = req.query.page;
  }
  var page = Math.max(0, parseInt(page));

  if (req.query.limit == undefined) {
    var limit = 50;
  } else {
    var limit = parseInt(req.query.limit);
  }

  var list = [];
  await BusinessVendor.find({ business: business })
    .cursor()
    .eachAsync(async (p) => {
      list.push(mongoose.Types.ObjectId(p.vendor));
    });

  if (req.query.query) {
    var query = {
      $and: [
        { _id: { $in: list } },
        {
          $or: [
            {
              name: { $regex: req.query.query, $options: "i" },
            },
            {
              contact_no: { $regex: req.query.query, $options: "i" },
            },
            {
              "business_info.gstin": { $regex: req.query.query, $options: "i" },
            },
          ],
        },
      ],
    };
  } else {
    var query = {
      _id: { $in: list },
    };
  }

  await User.find(query)
    .skip(limit * page)
    .limit(limit)
    .cursor()
    .eachAsync(async (p) => {
      result.push({
        _id: p._id,
        name: p.name,
        email: p.email,
        contact_no: p.contact_no,
        address: p.address,
        bank_details: p.bank_details,
        business_info: p.business_info,
        account_info: p.account_info,
      });
    });
  res.status(200).json({
    responseCode: 200,
    responseQuery: query,
    responseMessage: "success",
    responseData: result,
  });
});

router.post(
  "/products/type/update",
  xAccessToken.token,
  async function (req, res, next) {
    await Product.find({})
      .cursor()
      .eachAsync(async (product) => {
        BusinessProduct.findOneAndUpdate(
          { product: product._id },
          { $set: { type: product.type } },
          { new: false },
          function (err, doc) {}
        );
      });

    res.status(200).json({
      responseCode: 200,
      responseMessage: "Product has been update",
      responseData: {},
    });
  }
);

router.put(
  "/product/update",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      id: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Error",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var business = req.headers["business"];
      var product = [];
      var check = await BusinessProduct.find({
        _id: req.body.id,
        business: business,
      })
        .count()
        .exec();
      if (check == 1) {
        var data = {
          title: req.body.title,
          product: req.body.product,
          description: req.body.description,
          discount: req.body.discount,
          model_no: req.body.model_no,
          models: req.body.models,
          detail: req.body.detail,
          updated_at: new Date(),
        };

        BusinessProduct.findOneAndUpdate(
          { _id: req.body.id, business: business },
          { $set: data },
          { new: false },
          async function (err, doc) {
            if (err) {
              var json = {
                responseCode: 400,
                responseMessage: "Error occured",
                responseData: {},
              };

              res.status(400).json(json);
            } else {
              await BusinessProduct.findOne({
                _id: req.body.id,
                business: business,
              })
                .populate("thumbnails")
                .cursor()
                .eachAsync(async (p) => {
                  res.status(200).json({
                    responseCode: 200,
                    responseMessage: "Product has been edited",
                    responseData: {
                      item: {
                        _id: p._id,
                        id: p.id,
                        title: p.title,
                        description: p.description,
                        price: p.price,
                        discount: p.discount,
                        category: p.category,
                        model_no: p.model_no,
                        models: p.models,
                        thumbnails: p.thumbnails,
                        business: p.business,
                        bookmark: p.bookmark,
                        created_at: moment(p.created_at)
                          .tz(req.headers["tz"])
                          .format("LL"),
                        updated_at: moment(p.updated_at)
                          .tz(req.headers["tz"])
                          .format("LL"),
                      },
                    },
                  });
                });
            }
          }
        );
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Unauthorized",
          responseData: {},
        });
      }
    }
  }
);

router.put(
  "/product/stock/update",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      product: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Error",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var business = req.headers["business"];
      var product = [];
      var loggedInDetails = await User.findById(decoded.user).exec();
      var check = await BusinessProduct.find({
        _id: req.body.product,
        business: business,
      })
        .count()
        .exec();
      if (check == 1) {
        var total = req.body.total;
        var available = req.body.available;

        BusinessProduct.findOneAndUpdate(
          {
            _id: req.body.product,
            business: business,
          },
          {
            $set: {
              stock: {
                total: parseFloat(total.toFixed(2)),
                available: parseFloat(available.toFixed(2)),
                consumed:
                  parseFloat(total.toFixed(2)) -
                  parseFloat(available.toFixed(2)),
              },
            },
          },
          { new: false },
          async function (err, doc) {
            if (err) {
              var json = {
                responseCode: 400,
                responseMessage: "Error occured",
                responseData: {},
              };

              res.status(400).json(json);
            } else {
              var activity = {
                user: loggedInDetails._id,
                name: loggedInDetails.name,
                stage: "Stock Update",
                activity:
                  "Stock Change Total: " +
                  parseFloat(total.toFixed(2)) +
                  " Available: " +
                  parseFloat(available.toFixed(2)),
              };

              fun.productLog(req.body.product, activity);

              res.status(200).json({
                responseCode: 200,
                responseMessage: "Successfully updated",
                responseData: {},
              });
            }
          }
        );
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Product not found",
          responseData: {},
        });
      }
    }
  }
);

router.put(
  "/product/sku/update",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      product: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Error",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var business = req.headers["business"];
      var product = [];
      var loggedInDetails = await User.findById(decoded.user).exec();
      var check = await BusinessProduct.find({
        _id: req.body.product,
        business: business,
      })
        .count()
        .exec();
      if (check == 1) {
        BusinessProduct.findOneAndUpdate(
          {
            _id: req.body.product,
            business: business,
            sku: {
              $elemMatch: {
                _id: req.body.id,
              },
            },
          },
          {
            $set: {
              "sku.$.sku": req.body.sku,
              "sku.$.total": req.body.total,
              "sku.$.available": req.body.available,
            },
          },
          { new: false },
          async function (err, doc) {
            if (err) {
              var json = {
                responseCode: 400,
                responseMessage: "Error occured",
                responseData: {},
              };

              res.status(400).json(json);
            } else {
              var activity = {
                user: loggedInDetails._id,
                name: loggedInDetails.name,
                stage: "SKU Update",
                activity:
                  "SKU Update SKU: " +
                  req.body.sku +
                  " Total: " +
                  parseFloat(req.body.total.toFixed(2)) +
                  " Available: " +
                  parseFloat(req.body.available.toFixed(2)),
              };

              fun.productLog(req.body.product, activity);

              res.status(200).json({
                responseCode: 200,
                responseMessage: "Successfully updated",
                responseData: {},
              });
            }
          }
        );
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Unauthorized",
          responseData: {},
        });
      }
    }
  }
);

router.delete(
  "/product/sku/delete",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      product: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Error",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var business = req.headers["business"];
      var product = await BusinessProduct.findOne({
        _id: req.body.product,
        business: business,
      }).exec();
      if (product) {
        var totalSKU = product.sku;
        if (totalSKU.length > 1) {
          BusinessProduct.findOneAndUpdate(
            {
              _id: req.body.product,
              business: business,
              sku: {
                $elemMatch: {
                  _id: req.body.id,
                },
              },
            },
            {
              $pull: {
                sku: { _id: req.body.id },
              },
            },
            function (err, doc) {
              if (err) {
                res.status(400).json({
                  responseCode: 400,
                  responseMessage: "Server Error",
                  responseData: err,
                });
              } else {
                res.status(200).json({
                  responseCode: 200,
                  responseMessage: "SKU updated",
                  responseData: {},
                });
              }
            }
          );
        } else {
          res.status(400).json({
            responseCode: 400,
            responseMessage:
              "You cannot delete this SKU location. Permission to edit only",
            responseData: {},
          });
        }
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Unauthorized",
          responseData: {},
        });
      }
    }
  }
);

router.get(
  "/vertical/products/get",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var business = req.headers["business"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    //paginate
    if (req.query.page == undefined) {
      var page = 0;
    } else {
      var page = req.query.page;
    }

    var page = Math.max(0, parseInt(page));
    var result = [];

    await Product.find({
      $or: [
        { part_no: new RegExp(req.query.query, "i") },
        { title: new RegExp(req.query.query, "i") },
      ],
    })
      .cursor()
      .eachAsync(async (p) => {
        result.push({
          _id: p._id,
          id: p._id,
          product: p.product,
          part_no: p.part_no,
          hsn_sac: p.hsn_sac,
          specification: p.specification,
          long_description: p.long_description,
          unit: p.unit,
        });
      });

    res.status(200).json({
      responseCode: 200,
      responseMessage: "success",
      responseData: result,
    });
  }
);

router.get(
  "/products/search/get",
  xAccessToken.token,
  async function (req, res, next) {
    // console.log("Api Inver-------------------- ")
    businessFunctions.logs(
      "INFO:/products/search/get Api Called from inventory.js," +
        " " +
        "Request Headers:" +
        JSON.stringify(req.headers) +
        ", " +
        "Request Query:" +
        JSON.stringify(req.query)
    );
    // console.log("Api Inver-------------------- ")

    var token = req.headers["x-access-token"];
    var business = req.headers["business"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = await User.findById(decoded.user).exec();

    if (req.query.page == undefined) {
      var page = 0;
    } else {
      var page = req.query.page;
    }

    var page = Math.max(0, parseInt(page));
    var result = [];

    var regex = req.query.query;

    if (regex.length >= 3) {
      regex = regex.replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1");
      // console.log("Query = " + regex)
      if (
        Log_Level == 4 ||
        Log_Level == 6 ||
        Log_Level == 8 ||
        Log_Level == 10 ||
        Log_Level == 0
      ) {
        businessFunctions.logs(
          "DEBUG: Fatching Search query details, Query:" +
            req.query.query +
            ", " +
            "User:" +
            user.name
        );
      }
      await BusinessProduct.find({
        business: business,
        $or: [
          // { part_no: new RegExp(regex, "i") },
          // { title: new RegExp(regex, "i") }
          { part_no: { $regex: regex, $options: "i" } },
          { title: { $regex: regex, $options: "i" } },
        ],
      })
        .cursor()
        .eachAsync(async (p) => {
          result.push({
            _id: p._id,
            id: p._id,
            product: p.title,
            part_no: p.part_no,
            hsn_sac: p.hsn_sac,
            // specification: p.specification,
            //long_description: p.long_description,
            base: p.price.base,
            price: p.price.purchase_price,
            // price: p.price.unit_price,
            unit: p.unit,
            part_category: p.part_category,
            margin: p.price.margin,
            // sku: p.sku

            // item_details: p
          });
        });

      if (
        Log_Level == 4 ||
        Log_Level == 6 ||
        Log_Level == 8 ||
        Log_Level == 10 ||
        Log_Level == 0
      ) {
        businessFunctions.logs(
          "DEBUG: Sending Search item details in Response, User:" + user.name
        );
      }
      res.status(200).json({
        responseCode: 200,
        responseMessage: "success",
        responseData: result,
      });
      if (
        Log_Level == 3 ||
        Log_Level == 7 ||
        Log_Level == 9 ||
        Log_Level == 10 ||
        Log_Level == 0
      ) {
        businessFunctions.logs(
          "INFO: Search item details send in Response Successfully, User:" +
            user.name
        );
      }
    }
  }
);

router.get(
  "/product/detail/get",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var business = req.headers["business"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    var product = {};

    await BusinessProduct.findOne({ _id: req.query.id, business: business })
      .cursor()
      .eachAsync(async (p) => {
        product = {
          product: p.product,
          _id: p._id,
          id: p._id,
          product_brand: p.product_brand,
          _product_brand: p.product_brand,
          product_model: p.product_model,
          _product_model: p._product_model,
          category: p.category,
          _category: p._category,
          subcategory: p.subcategory,
          _subcategory: p._subcategory,
          business: p.business,
          title: p.title,
          part_no: p.part_no,
          hsn_sac: p.hsn_sac,
          price: p.price,
          stock: p.stock,
          sku: p.sku,
          list_type: p.list_type,
          tax: p.tax,
          amount_is_tax: p.amount_is_tax,
          specification: p.specification,
          product_id: p.product_id,
          short_description: p.short_description,
          long_description: p.long_description,
          thumbnail: p.preview,
          models: p.models,
          services: p.services,
          unit: p.unit,
          warranty: p.warranty,
          quantity: p.quantity,
          logs: p.logs,
        };
      });

    res.status(200).json({
      responseCode: 200,
      responseMessage: "success",
      responseData: product,
    });
  }
);

router.get(
  "/expense/category/get",
  xAccessToken.token,
  async function (req, res, next) {
    businessFunctions.logs(
      "INFO:/expense/category/get Api Called from order.js," +
        " " +
        "Request Headers:" +
        JSON.stringify(req.headers)
    );

    if (
      Log_Level == 4 ||
      Log_Level == 6 ||
      Log_Level == 8 ||
      Log_Level == 10 ||
      Log_Level == 0
    ) {
      businessFunctions.logs("DEBUG: Fatching Expense Category.");
    }
    const expenseCategory = await ExpenseCategory.find({})
      .sort({ category: 1 })
      .exec();
    res.status(200).json({
      responseCode: 200,
      responseMessage: "success",
      responseData: expenseCategory,
    });
    if (
      Log_Level == 3 ||
      Log_Level == 7 ||
      Log_Level == 9 ||
      Log_Level == 10 ||
      Log_Level == 0
    ) {
      businessFunctions.logs(
        "INFO: Expense Category send in Response Successfully."
      );
    }
  }
);

router.post(
  "/expense/add",
  xAccessToken.token,
  async function (req, res, next) {
    businessFunctions.logs(
      "INFO: /expense/add Api Called from order.js," +
        " " +
        "Request Headers:" +
        JSON.stringify(req.headers) +
        ", " +
        "Request Query:" +
        JSON.stringify(req.query)
    );

    var rules = {
      category: "required",
      name: "required",
      contact_no: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      if (
        Log_Level == 1 ||
        Log_Level == 5 ||
        Log_Level == 6 ||
        Log_Level == 7 ||
        Log_Level == 0
      ) {
        businessFunctions.logs(
          "ERROR: Validation failed, Payee Info required to Add Expense."
        );
      }
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Payee Info required",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var user = decoded.user;
      var business = req.headers["business"];
      var loggedInDetails = await User.findById(decoded.user).exec();
      var product = new Object();
      var result = [];
      var tax = [];
      var total = 0;

      var newDate = new Date();

      var vendor = null;
      var bill = {
        name: req.body.name,
        contact_no: req.body.contact_no,
        category: req.body.category,
        reference: req.body.reference,
        date: null,
        due_date: null,
        payee: null,
        items: [],
        business: business,
        total: 0,
        status: "Completed",
        created_at: newDate,
        updated_at: newDate,
      };
      if (
        Log_Level == 4 ||
        Log_Level == 6 ||
        Log_Level == 8 ||
        Log_Level == 10 ||
        Log_Level == 0
      ) {
        businessFunctions.logs(
          "DEBUG: Creating New Expense Bill, Name:" +
            req.body.name +
            ", Contact_no:" +
            req.body.contact_no +
            ", User:" +
            loggedInDetails.name
        );
      }
      Expense.create(bill).then(async function (expense) {
        var count = await Expense.find({
          _id: { $lt: expense._id },
          business: business,
        }).count();
        var expense_no = count + 1;

        Expense.findOneAndUpdate(
          { _id: expense._id },
          { $set: { expense_no: expense_no } },
          { new: true },
          async function (err, doc) {
            res.status(200).json({
              responseCode: 200,
              responseMessage: "Expense has been added.",
              responseData: expense,
            });
            if (
              Log_Level == 3 ||
              Log_Level == 7 ||
              Log_Level == 9 ||
              Log_Level == 10 ||
              Log_Level == 0
            ) {
              businessFunctions.logs(
                "INFO: Expense has been added Successfully, Name:" +
                  req.body.name +
                  ", contact_no:" +
                  req.body.contact_no
              );
            }
          }
        );
      });
    }
  }
);

router.delete(
  "/expense/cancel",
  xAccessToken.token,
  async function (req, res, next) {
    businessFunctions.logs(
      "INFO: /expense/cancel Api Called from order.js," +
        " " +
        "Request Headers:" +
        JSON.stringify(req.headers) +
        ", " +
        "Request Body:" +
        JSON.stringify(req.body)
    );

    var rules = {
      expense: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      if (
        Log_Level == 1 ||
        Log_Level == 5 ||
        Log_Level == 6 ||
        Log_Level == 7 ||
        Log_Level == 0
      ) {
        businessFunctions.logs(
          "ERROR: Validation failed, Expense is required to cancel Expense."
        );
      }
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Error",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var user = decoded.user;
      var business = req.headers["business"];
      var loggedInDetails = await User.findById(decoded.user).exec();
      var product = new Object();
      var result = [];
      var tax = [];
      var total = 0;
      if (
        Log_Level == 4 ||
        Log_Level == 6 ||
        Log_Level == 8 ||
        Log_Level == 10 ||
        Log_Level == 0
      ) {
        businessFunctions.logs(
          "DEBUG: Fatching Expense Detail, ExpenseId:" + req.body.expense
        );
      }
      var expense = await Expense.findOne({ _id: req.body.expense }).exec();
      if (expense) {
        if (
          Log_Level == 4 ||
          Log_Level == 6 ||
          Log_Level == 8 ||
          Log_Level == 10 ||
          Log_Level == 0
        ) {
          businessFunctions.logs(
            "DEBUG: Updating Expense Status as Cancelled, ExpenseId:" +
              req.body.expense
          );
        }
        Expense.findOneAndUpdate(
          { _id: expense._id },
          { $set: { status: "Cancelled" } },
          { new: false },
          async function (err, doc) {
            if (err) {
              if (
                Log_Level == 1 ||
                Log_Level == 5 ||
                Log_Level == 6 ||
                Log_Level == 7 ||
                Log_Level == 0
              ) {
                businessFunctions.logs(
                  "ERROR: Error Occured while updating Expense status, ExpenseId:" +
                    req.body.expense +
                    ", User:" +
                    loggedInDetails.name
                );
              }
              res.status(422).json({
                responseCode: 422,
                responseMessage: "Server Error...",
                responseData: err,
              });
            } else {
              res.status(200).json({
                responseCode: 200,
                responseMessage: "Removed Successfully",
                responseData: {},
              });
              if (
                Log_Level == 3 ||
                Log_Level == 7 ||
                Log_Level == 9 ||
                Log_Level == 10 ||
                Log_Level == 0
              ) {
                businessFunctions.logs(
                  "INFO: Expense Removed Successfully, ExpenseId:" +
                    req.body.expense +
                    ", User:" +
                    loggedInDetails.name
                );
              }
            }
          }
        );
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Expense not found",
          responseData: {},
        });
      }
    }
  }
);

router.put(
  "/expense/date/update",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      expense: "required",
      date: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Due Date required",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var business = req.headers["business"];
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var date = new Date();
      var loggedInDetails = decoded.user;
      var items = [];
      var data = [];

      var item_total = 0;
      var discount = 0;
      var item_total = 0;
      var total = 0;

      var expense = await Expense.findById(req.body.expense).exec();
      var loggedInDetails = await User.findById(decoded.user).exec();
      if (expense) {
        var date = new Date(req.body.date).toISOString();

        Expense.findOneAndUpdate(
          { _id: expense._id },
          { $set: { date: date, updated_at: new Date() } },
          { new: false },
          async function (err, doc) {
            if (err) {
              res.status(422).json({
                responseCode: 422,
                responseMessage: "Server Error",
                responseData: err,
              });
            } else {
              res.status(200).json({
                responseCode: 200,
                responseMessage: "Saved",
                responseData: {
                  due_date: moment(date)
                    .tz(req.headers["tz"])
                    .format("YYYY-MM-DD"),
                },
              });
            }
          }
        );
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Expense not found",
          responseData: {},
        });
      }
    }
  }
);

router.put(
  "/expense/category/update",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      expense: "required",
      category: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Due Date required",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var business = req.headers["business"];
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var date = new Date();
      var loggedInDetails = decoded.user;
      var items = [];
      var data = [];

      var item_total = 0;
      var discount = 0;
      var item_total = 0;
      var total = 0;

      var expense = await Expense.findById(req.body.expense).exec();
      var loggedInDetails = await User.findById(decoded.user).exec();
      if (expense) {
        Expense.findOneAndUpdate(
          { _id: expense._id },
          { $set: { category: req.body.category, updated_at: new Date() } },
          { new: false },
          async function (err, doc) {
            if (err) {
              res.status(422).json({
                responseCode: 422,
                responseMessage: "Server Error",
                responseData: err,
              });
            } else {
              res.status(200).json({
                responseCode: 200,
                responseMessage: "Saved",
                responseData: {
                  category: req.body.category,
                },
              });
            }
          }
        );
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Expense not found",
          responseData: {},
        });
      }
    }
  }
);

router.put(
  "/expense/payee/update",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      expense: "required",
      payee_name: "required",
      payee_contact_no: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Payee Info required",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var business = req.headers["business"];
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var date = new Date();
      var loggedInDetails = decoded.user;
      var items = [];
      var data = [];

      var item_total = 0;
      var discount = 0;
      var item_total = 0;
      var total = 0;

      var expense = await Expense.findById(req.body.expense).exec();
      var loggedInDetails = await User.findById(decoded.user).exec();
      if (expense) {
        var payee = await User.findById(req.body.payee).exec();
        if (payee) {
          Expense.findOneAndUpdate(
            { _id: expense._id },
            {
              $set: {
                payee: null,
                payee_name: req.body.payee_name,
                updated_at: new Date(),
              },
            },
            { new: false },
            async function (err, doc) {
              if (err) {
                res.status(422).json({
                  responseCode: 422,
                  responseMessage: "Server Error",
                  responseData: err,
                });
              } else {
                res.status(200).json({
                  responseCode: 200,
                  responseMessage: "Saved",
                  responseData: {},
                });
              }
            }
          );
        } else {
          res.status(400).json({
            responseCode: 400,
            responseMessage: "User not found",
            responseData: {},
          });
        }
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Expense not found",
          responseData: {},
        });
      }
    }
  }
);

router.put(
  "/expense/update",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      reference: "required",
      date: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Date is required",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var user = decoded.user;
      var business = req.headers["business"];
      var product = new Object();
      var result = [];

      var total = 0;
      var expense = await Expense.findById(req.body.expense).exec();
      if (expense) {
        var date = new Date();
        if (req.body.date) {
          date = new Date(req.body.date).toISOString();
        }

        var newDate = new Date();

        var items = [];
        var products = req.body.items;

        if (products.length > 0) {
          for (var p = 0; p < products.length; p++) {
            if (products[p].quantity) {
              var tax_info = await Tax.findOne({ tax: products[p].tax }).exec();
              if (tax_info) {
                var tax = [];
                var rate =
                  parseFloat(products[p].rate) *
                  parseFloat(products[p].quantity);
                var amount =
                  parseFloat(products[p].rate) *
                  parseFloat(products[p].quantity);
                var tax_rate = tax_info.detail;
                var base = amount;

                if (products[p].amount_is_tax == "exclusive") {
                  var tax_on_amount = amount;
                  if (tax_rate.length > 0) {
                    for (var r = 0; r < tax_rate.length; r++) {
                      if (tax_rate[r].rate != tax_info.rate) {
                        var t = tax_on_amount * (tax_rate[r].rate / 100);
                        amount = amount + t;
                        tax.push({
                          tax: tax_rate[r].tax,
                          rate: tax_rate[r].rate,
                          amount: parseFloat(t.toFixed(2)),
                        });
                      } else {
                        var t = tax_on_amount * (tax_info.rate / 100);
                        amount = amount + t;
                        tax.push({
                          tax: tax_info.tax,
                          tax_rate: tax_info.rate,
                          rate: tax_info.rate,
                          amount: parseFloat(t.toFixed(2)),
                        });
                      }
                    }
                  }

                  total = total + amount;
                }

                if (products[p].amount_is_tax == "inclusive") {
                  amount = amount;
                  var x = (100 + tax_info.rate) / 100;
                  var tax_on_amount = amount / x;
                  if (tax_rate.length > 0) {
                    for (var r = 0; r < tax_rate.length; r++) {
                      if (tax_rate[r].rate != tax_info.rate) {
                        var t = tax_on_amount * (tax_rate[r].rate / 100);
                        base = base - t;
                        tax.push({
                          tax: tax_rate[r].tax,
                          rate: tax_rate[r].rate,
                          amount: parseFloat(t.toFixed(2)),
                        });
                      } else {
                        var t = amount - tax_on_amount;
                        base = base - t;
                        tax.push({
                          tax: tax_info.tax,
                          rate: tax_info.rate,
                          amount: parseFloat(t.toFixed(2)),
                        });
                      }
                    }
                  }
                  total = total + amount;
                }

                var tax_details = {
                  tax: tax_info.tax,
                  rate: tax_info.rate,
                  amount: total,
                  detail: tax,
                };

                items.push({
                  part_no: products[p].part_no,
                  hsn_sac: products[p].hsn_sac,
                  title: products[p].title,
                  quantity: products[p].quantity,
                  unit: products[p].unit,
                  sku: products[p].sku,
                  mrp: products[p].mrp,
                  rate: products[p].rate,
                  base: base,
                  amount: parseFloat(amount.toFixed(2)),
                  tax_amount: _.sumBy(tax, (x) => x.amount),
                  models: products[p].models,
                  amount_is_tax: products[p].amount_is_tax,
                  unit_price: products[p].unit_price,
                  sell_price: products[p].rate,
                  margin: products[p].margin,
                  discount: "0",
                  discount_total: 0,
                  tax: tax_info.tax,
                  tax_rate: tax_info.rate,
                  tax_info: tax,
                });
              } else {
                return res.status(422).json({
                  responseCode: 422,
                  responseMessage: "Please check tax",
                  responseData: {},
                });
              }
            } else {
              return res.status(422).json({
                responseCode: 422,
                responseMessage: "Quantity required",
                responseData: {},
              });
            }
          }

          var total = _.sumBy(items, (x) => x.amount);

          var data = {
            name: req.body.name,
            contact_no: req.body.contact_no,
            reference: req.body.reference,
            category: req.body.category,
            items: items,
            date: date,
            total: parseFloat(total.toFixed(2)),
            updated_at: new Date(),
          };

          Expense.findOneAndUpdate(
            { _id: expense._id },
            { $set: data },
            { new: false },
            async function (err, doc) {
              if (err) {
                res.status(422).json({
                  responseCode: 422,
                  responseMessage: "Server Error...",
                  responseData: err,
                });
              } else {
                res.status(200).json({
                  responseCode: 200,
                  responseMessage: "Successfully Saved",
                  responseData: await Expense.findById(req.body.expense)
                    .populate({
                      path: "vendor",
                      select:
                        "name contact_no email account_info business_info",
                    })
                    .exec(),
                });
              }
            }
          );
        } else {
          res.status(400).json({
            responseCode: 400,
            responseMessage: "Items not found",
            responseData: {},
          });
        }
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Expense not found",
          responseData: {},
        });
      }
    }
  }
);

router.get(
  "/expenses/get",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var business = req.headers["business"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    //paginate
    if (req.query.page == undefined) {
      var page = 0;
    } else {
      var page = req.query.page;
    }

    var page = Math.max(0, parseInt(page));

    var orders = [];

    var filters = [];
    var match = [];
    var queries = {};

    if (req.query.query) {
      var specification = {};
      specification["$lookup"] = {
        from: "User",
        localField: "payee",
        foreignField: "_id",
        as: "payee",
      };
      filters.push(specification);

      var specification = {};
      specification["$unwind"] = {
        path: "$payee",
        preserveNullAndEmptyArrays: true,
      };
      filters.push(specification);

      var specification = {};
      specification["$match"] = {
        business: mongoose.Types.ObjectId(business),
        $or: [
          { status: { $regex: req.query.query, $options: "i" } },
          { category: { $regex: req.query.query, $options: "i" } },
          { reference: { $regex: req.query.query, $options: "i" } },
          { expense_no: { $regex: req.query.query, $options: "i" } },
          { name: { $regex: req.query.query, $options: "i" } },
          { contact_no: { $regex: req.query.query, $options: "i" } },
          { "payee.name": { $regex: req.query.query, $options: "i" } },
          { "payee.contact_no": { $regex: req.query.query, $options: "i" } },
        ],
      };
      filters.push(specification);

      var specification = {};
      specification["$sort"] = {
        updated_at: -1,
      };
      filters.push(specification);

      var specification = {};
      specification["$skip"] = config.perPage * page;
      filters.push(specification);

      var specification = {};
      specification["$limit"] = config.perPage;
      filters.push(specification);
    } else {
      var specification = {};
      specification["$match"] = {
        business: mongoose.Types.ObjectId(business),
      };
      filters.push(specification);

      var specification = {};
      specification["$sort"] = {
        updated_at: -1,
      };
      filters.push(specification);

      var specification = {};
      specification["$skip"] = config.perPage * page;
      filters.push(specification);

      var specification = {};
      specification["$limit"] = config.perPage;
      filters.push(specification);
    }

    var query = filters;

    var totalResult = await Expense.aggregate(query);

    var allExpense = _.filter(totalResult, (x) => x.status != "Cancelled");

    await Expense.aggregate(query)
      .allowDiskUse(true)
      .cursor({ batchSize: 20 })
      .exec()
      .eachAsync(async function (p) {
        orders.push({
          _id: p._id,
          id: p._id,
          payee: {
            _id: null,
            id: null,
            name: p.name,
            contact_no: p.contact_no,
          },
          date: moment(p.date).tz(req.headers["tz"]).format("lll"),
          expense_no: p.expense_no,
          category: p.category,
          total: p.total,
          status: p.status,
          reference: p.reference,
          created_at: moment(p.created_at).tz(req.headers["tz"]).format("lll"),
          updated_at: moment(p.updated_at).tz(req.headers["tz"]).format("lll"),
        });
      });

    res.status(200).json({
      responseCode: 200,
      responseMessage: "success",
      responseInfo: {
        totalExpense: _.sumBy(allExpense, (x) => x.total),
        totalResult: totalResult.length,
      },
      responseData: orders,
    });
  }
);

router.get(
  "/expense/details/get",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      expense: "required",
    };

    var validation = new Validator(req.query, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Expense is required",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var p = await Expense.findById(req.query.expense)
        .populate({
          path: "vendor",
          select: "name contact_no email account_info business_info",
        })
        .exec();

      if (p) {
        var expense = {
          _id: p._id,
          id: p._id,
          items: p.items,
          category: p.category,
          expense_no: p.expense_no,
          reference: p.reference,
          date: moment(p.date).tz(req.headers["tz"]).format("YYYY-MM-DD"),
          due_date: moment(p.due_date)
            .tz(req.headers["tz"])
            .format("YYYY-MM-DD"),
          payee: {
            _id: null,
            id: null,
            name: p.name,
            contact_no: p.contact_no,
          },
          business: p.business,
          total: p.total,
          status: p.status,
          created_at: moment(p.created_at).tz(req.headers["tz"]).format("lll"),
          updated_at: moment(p.updated_at).tz(req.headers["tz"]).format("lll"),
        };

        res.status(200).json({
          responseCode: 200,
          responseMessage: "Success",
          responseData: expense,
        });
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Expense not found",
          responseData: {},
        });
      }
    }
  }
);

router.put("/bill/update", xAccessToken.token, async function (req, res, next) {
  businessFunctions.logs(
    "INFO: /bill/update Api Called from 3.0.js," +
      " " +
      "Request Headers:" +
      JSON.stringify(req.headers) +
      ", " +
      "Request Body:" +
      JSON.stringify(req.body)
  );

  let reference_no = req.body.reference_no;
  // console.log("Refrence no 12673 = " + reference_no)
  var rules = {
    bill: "required",
    // reference_no: 'required',
    // address: 'required',
    // date: 'required',
  };

  var validation = new Validator(req.body, rules);

  if (validation.fails()) {
    if (
      Log_Level == 1 ||
      Log_Level == 5 ||
      Log_Level == 6 ||
      Log_Level == 7 ||
      Log_Level == 0
    ) {
      businessFunctions.logs(
        "ERROR: Validation failed, Bill is required to update bill details."
      );
    }
    res.status(422).json({
      responseCode: 422,
      responseMessage: "Bill is required",
      responseData: {
        res: validation.errors.all(),
      },
    });
  } else {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers["business"];
    var loggedInDetails = await User.findById(decoded.user).exec();
    var product = new Object();
    var result = [];
    var tax = [];
    var total = 0;
    var purchase = await Purchase.findById(req.body.bill).exec();
    if (purchase) {
      // var date = new Date(req.body.date).toISOString();
      if (req.body.due) {
        var due = new Date(req.body.due).toISOString();
      } else {
        var due = null;
      }

      var vendor = await User.findById(req.body.vendor).exec();

      var newDate = new Date();
      if (vendor) {
        var items = [];
        var products = req.body.items;
        if (products.length > 0) {
          // console.log("products.length = " + products.length)
          for (var p = 0; p < products.length; p++) {
            if (products[p].lot != null && products[p].quantity != null) {
              // console.log("Come inside business product finding condition....")
              var product = await BusinessProduct.findOne({
                part_no: products[p].part_no,
                business: business,
              }).exec();

              var tax_info = await Tax.findOne({ tax: products[p].tax }).exec();
              if (tax_info) {
                if (product) {
                  // var rate = products[p].mrp;
                  // var amount = products[p].mrp;
                  // var tax_rate = tax_info.detail;
                  var quantity = parseInt(products[p].quantity); //Qantity     10
                  var unit_base_price = parseFloat(products[p].unit_base_price); //Unit_base  100
                  var base = parseFloat(products[p].base); //Unit_base  100 *10 =1000
                  var tax_slab = parseFloat(products[p].tax); //28% GST
                  var amount_is_tax = products[p].amount_is_tax;
                  var amount = parseFloat(products[p].amount);
                  var tax_amount = parseFloat(amount) - parseFloat(base); //280
                  // var tax_amount = parseFloat(products[p].tax_amount);   //280
                  //1280
                  var rate =
                    parseFloat(unit_base_price) +
                    parseFloat(products[p].margin); //unit_base_price+margin
                  // var purchase_price = amount / quantity;
                  var unit_price = parseFloat(products[p].unit_price);
                  var discount = parseFloat(products[p].discount);
                  var tax = products[p].tax_details;
                  // var unit_price = products[p].unit_price
                  // console.log("Discount prints here...", discount)
                  /*  if (discount.indexOf("%") >= 0) {
                                          // console.log("602 - Discount If Condition = " + discount)
                                          discount = parseFloat(discount);
                                          if (!isNaN(discount) && discount > 0) {
                                              var discount_total = amount * (discount / 100);
                                              amount = amount - parseFloat(discount_total.toFixed(2))
  
                                          }
                                      }
                                      else {
                                          // console.log("610 - Discount ELSE Condition= " + discount)
  
  
                                          discount = parseFloat(discount);
                                          if (!isNaN(discount) && discount > 0) {
                                              amount = amount - parseFloat(discount.toFixed(2))
  
                                          }
                                      }
  */
                  //amount after discount
                  // console.log("Ammount after discount= " + amount)
                  var amount_is_tax = "exclusive";

                  // if (products[p].amount_is_tax == "exclusive") {
                  /*   if (amount_is_tax == "exclusive") {
                                           var tax_on_amount = amount;
                                           if (tax_rate.length > 0) {
                                               for (var r = 0; r < tax_rate.length; r++) {
                                                   if (tax_rate[r].rate != tax_info.rate) {
                                                       var t = tax_on_amount * (tax_rate[r].rate / 100);
                                                       amount = amount + t;
                                                       tax.push({
                                                           tax: tax_rate[r].tax,
                                                           rate: tax_rate[r].rate,
                                                           amount: parseFloat(t.toFixed(2))
                                                       })
                                                   }
                                                   else {
                                                       var t = tax_on_amount * (tax_info.rate / 100);
                                                       amount = amount + t;
                                                       tax.push({
                                                           tax: tax_info.tax, tax_rate: tax_info.rate,
                                                           rate: tax_info.rate,
                                                           amount: parseFloat(t.toFixed(2))
                                                       })
                                                   }
                                               }
                                           }
                                           total = total + amount;
                                       }
                                       */
                  /*
                                                                        if (products[p].amount_is_tax == "inclusive") {
                                                                            var x = (100 + tax_info.rate) / 100;
                                                                            var tax_on_amount = amount / x;
                                                                            if (tax_rate.length > 0) {
                                                                                for (var r = 0; r < tax_rate.length; r++) {
                                                                                    if (tax_rate[r].rate != tax_info.rate) {
                                                                                        var t = tax_on_amount * (tax_rate[r].rate / 100);
                                                                                        base = base - t;
                                                                                        tax.push({
                                                                                            tax: tax_rate[r].tax,
                                                                                            rate: tax_rate[r].rate,
                                                                                            amount: parseFloat(t.toFixed(2))
                                                                                        });
                                                                                    }
                                                                                    else {
                                                                                        var t = amount - tax_on_amount;
                                                                                        base = base - t;
                                                                                        tax.push({
                                                                                            tax: tax_info.tax,
                                                                                            rate: tax_info.rate,
                                                                                            amount: parseFloat(t.toFixed(2))
                                                                                        });
                                                                                    }
                                                                                }
                                                                            }
                                                                            total = total + amount;
                                                                        }
                                    */
                  // var tax_details = {
                  //     tax: tax_info.tax,
                  //     rate: tax_info.rate,
                  //     // amount: total,
                  //     amount: amount,
                  //     detail: tax
                  // }

                  // console.log("Items....", products[p].models)
                  // console.log("Product " + product.product)
                  var lot = 1;
                  items.push({
                    item_status: products[p].item_status,
                    product: product.product,
                    part_no: products[p].part_no,
                    hsn_sac: products[p].hsn_sac,
                    part_category: products[p].part_category, //OEM OR OES
                    title: products[p].title,
                    quantity: quantity,
                    stock: products[p].quantity * lot,
                    sku: products[p].sku,
                    unit_base_price: unit_base_price,
                    unit_price: unit_price,
                    // purchase_price: purchase_price,
                    unit: products[p].unit,
                    lot: lot,
                    mrp: products[p].mrp,
                    rate: rate,
                    base: base,
                    // tax_amount: _.sumBy(tax, x => x.amount),
                    tax_amount: tax_amount,
                    amount: amount,
                    models: products[p].models,
                    amount_is_tax: amount_is_tax,
                    sell_price: rate,
                    margin: products[p].margin,
                    discount: discount,
                    discount_type: products[p].discount_type,
                    discount_total: products[p].discount_total,
                    tax: tax_info.tax,
                    tax_rate: tax_info.rate,
                    tax_info: tax,
                    isProduct: true,
                    isOrderItem: products[p].isOrderItem,
                  });

                  tax = [];
                } /*else {
                                    // console.log("item is not found in stock = " + products[p].part_no)
                                    return res.status(422).json({
                                        responseCode: 422,
                                        responseMessage: "item is not found in stock = " + products[p].part_no,
                                        responseData: {}
                                    });
                                } }*/ else {
                  var quantity = parseInt(products[p].quantity); //Qantity     10
                  var unit_base_price = parseFloat(products[p].unit_base_price); //Unit_base  100
                  var base = parseFloat(products[p].base); //Unit_base  100 *10 =1000
                  var tax_slab = parseFloat(products[p].tax); //28% GST
                  var amount_is_tax = products[p].amount_is_tax;
                  var amount = parseFloat(products[p].amount);
                  var tax_amount = parseFloat(amount) - parseFloat(base); //280
                  // var tax_amount = parseFloat(products[p].tax_amount);   //280
                  //1280
                  var rate =
                    parseFloat(unit_base_price) +
                    parseFloat(products[p].margin); //unit_base_price+margin
                  // var purchase_price = amount / quantity;
                  var unit_price = parseFloat(products[p].unit_price);
                  var discount = parseFloat(products[p].discount);
                  var tax = products[p].tax_details;
                  // var unit_price = products[p].unit_price
                  // console.log("Discount prints here...", discount)
                  /*  if (discount.indexOf("%") >= 0) {
                                          // console.log("602 - Discount If Condition = " + discount)
                                          discount = parseFloat(discount);
                                          if (!isNaN(discount) && discount > 0) {
                                              var discount_total = amount * (discount / 100);
                                              amount = amount - parseFloat(discount_total.toFixed(2))
  
                                          }
                                      }
                                      else {
                                          // console.log("610 - Discount ELSE Condition= " + discount)
  
  
                                          discount = parseFloat(discount);
                                          if (!isNaN(discount) && discount > 0) {
                                              amount = amount - parseFloat(discount.toFixed(2))
  
                                          }
                                      }
  */
                  //amount after discount
                  // console.log("Ammount after discount= " + amount)
                  var amount_is_tax = "exclusive";

                  // if (products[p].amount_is_tax == "exclusive") {
                  /*   if (amount_is_tax == "exclusive") {
                                           var tax_on_amount = amount;
                                           if (tax_rate.length > 0) {
                                               for (var r = 0; r < tax_rate.length; r++) {
                                                   if (tax_rate[r].rate != tax_info.rate) {
                                                       var t = tax_on_amount * (tax_rate[r].rate / 100);
                                                       amount = amount + t;
                                                       tax.push({
                                                           tax: tax_rate[r].tax,
                                                           rate: tax_rate[r].rate,
                                                           amount: parseFloat(t.toFixed(2))
                                                       })
                                                   }
                                                   else {
                                                       var t = tax_on_amount * (tax_info.rate / 100);
                                                       amount = amount + t;
                                                       tax.push({
                                                           tax: tax_info.tax, tax_rate: tax_info.rate,
                                                           rate: tax_info.rate,
                                                           amount: parseFloat(t.toFixed(2))
                                                       })
                                                   }
                                               }
                                           }
                                           total = total + amount;
                                       }
                                       */
                  /*
                                                                        if (products[p].amount_is_tax == "inclusive") {
                                                                            var x = (100 + tax_info.rate) / 100;
                                                                            var tax_on_amount = amount / x;
                                                                            if (tax_rate.length > 0) {
                                                                                for (var r = 0; r < tax_rate.length; r++) {
                                                                                    if (tax_rate[r].rate != tax_info.rate) {
                                                                                        var t = tax_on_amount * (tax_rate[r].rate / 100);
                                                                                        base = base - t;
                                                                                        tax.push({
                                                                                            tax: tax_rate[r].tax,
                                                                                            rate: tax_rate[r].rate,
                                                                                            amount: parseFloat(t.toFixed(2))
                                                                                        });
                                                                                    }
                                                                                    else {
                                                                                        var t = amount - tax_on_amount;
                                                                                        base = base - t;
                                                                                        tax.push({
                                                                                            tax: tax_info.tax,
                                                                                            rate: tax_info.rate,
                                                                                            amount: parseFloat(t.toFixed(2))
                                                                                        });
                                                                                    }
                                                                                }
                                                                            }
                                                                            total = total + amount;
                                                                        }
                                    */
                  // var tax_details = {
                  //     tax: tax_info.tax,
                  //     rate: tax_info.rate,
                  //     // amount: total,
                  //     amount: amount,
                  //     detail: tax
                  // }

                  // console.log("Items....", products[p].models)
                  // console.log("Product " + product.product)
                  var lot = 1;
                  items.push({
                    item_status: products[p].item_status,
                    product: null,
                    part_no: products[p].part_no,
                    hsn_sac: products[p].hsn_sac,
                    part_category: products[p].part_category, //OEM OR OES
                    title: products[p].title,
                    quantity: quantity,
                    stock: products[p].quantity * lot,
                    sku: products[p].sku,
                    unit_base_price: unit_base_price,
                    unit_price: unit_price,
                    // purchase_price: purchase_price,
                    unit: products[p].unit,
                    lot: lot,
                    mrp: products[p].mrp,
                    rate: rate,
                    base: base,
                    // tax_amount: _.sumBy(tax, x => x.amount),
                    tax_amount: tax_amount,
                    amount: amount,
                    models: products[p].models,
                    amount_is_tax: amount_is_tax,
                    sell_price: rate,
                    margin: products[p].margin,
                    discount: discount,
                    discount_type: products[p].discount_type,
                    discount_total: products[p].discount_total,
                    tax: tax_info.tax,
                    tax_rate: tax_info.rate,
                    tax_info: tax,
                    isProduct: false,
                    isOrderItem: products[p].isOrderItem,
                  });

                  tax = [];
                }
              } else {
                res.status(422).json({
                  responseCode: 422,
                  responseMessage: "Please check tax",
                  responseData: {},
                });
              }
            }
          }

          var address = null;
          if (req.body.address) {
            address = req.body.address;
          }

          var log_details = {
            business: business,
            activity_by: loggedInDetails.name,
            activity: "Update",

            remark: "",
            created_at: new Date(),
          };
          var logs = [];
          if (purchase.logs) {
            logs = purchase.logs;
          } else {
            logs.push(log_details);
          }
          var total = _.sumBy(items, (x) => x.amount);

          var discount_total = 0;
          var discount = 0;
          var total_amount = total.toFixed(2);
          if (req.body.bill_discount > 0) {
            discount = parseFloat(req.body.bill_discount);
            total_amount = total.toFixed(2);

            if (!isNaN(discount) && discount > 0) {
              discount_total = total * (discount / 100);
              total_amount =
                total_amount - parseFloat(discount_total.toFixed(2));
            }
          }

          var transaction_log = await TransactionLog.find({
            source: purchase._id,
            payment_status: "Success",
          }).exec();
          var paid_total = _.sumBy(transaction_log, (x) => x.paid_total);
          var due_amount = Math.ceil(total_amount) - paid_total;

          var bill = {
            due_date: due,
            due: due_amount,
            vendor: vendor._id,
            items: items,
            bill_discount: discount,
            paid_total: paid_total,
            total_discount: discount_total,
            business: business,
            total: total_amount,
            subTotal: total.toFixed(2),
            logs: logs,
            updated_at: new Date(),
          };
          await Purchase.findOneAndUpdate(
            { _id: purchase._id },
            { $set: bill },
            { new: false },
            async function (err, doc) {
              if (err) {
                res.status(422).json({
                  responseCode: 422,
                  responseMessage: "Server Error...",
                  responseData: err,
                });
              } else {
                res.status(200).json({
                  responseCode: 200,
                  responseMessage: "Successfully Saved",
                  responseData: await Purchase.findById(req.body.bill).exec(),
                });
                if (
                  Log_Level == 4 ||
                  Log_Level == 6 ||
                  Log_Level == 8 ||
                  Log_Level == 10 ||
                  Log_Level == 0
                ) {
                  businessFunctions.logs(
                    "DEBUG: Bill Successfully Saved, BillId:" + req.body.bill
                  );
                }
              }
            }
          );
        } else {
          res.status(400).json({
            responseCode: 400,
            responseMessage: "Items not found",
            responseData: {},
          });
        }
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Vendor not found",
          responseData: {},
        });
      }
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Purchase not found",
        responseData: {},
      });
    }
  }
});

router.put(
  "/bill/status/update",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers["business"];
    var product = new Object();
    var result = [];
    var tax = [];
    var total = 0;
    // console.log("Bill No To Complete = " + req.body.bill)
    var purchase = await Purchase.findOne({ _id: req.body.bill }).exec();
    var loggedInDetails = await User.findById(user).exec();
    let vendor = await User.findOne({
      _id: mongoose.Types.ObjectId(purchase.vendor),
    }).exec();

    // return res.json({
    //     data: purchase
    // })

    if (purchase) {
      var products = purchase.items;
      for (var p = 0; p < products.length; p++) {
        // console.log(" 13101 Loop iteration = " + p + " Item name " + purchase.items[p].title)
        // await q.all(stockEntry(purchase._id, products[p], business));
        // stockEntry(purchase._id, products[p], business);
        /*  // Abhinav Tyagi 05-04-21*/
        // console.log("1328 item_status = " + purchase.items[p].item_status + "\n products[p].item_status= " + products[p].item_status + " -Item name- " + purchase.items[p].title)

        // var checkSku = await q.all(businessFunctions.stockEntry(purchase._id, products[p], business, vendor, loggedInDetails));
        // return res.status(200).json({
        //     responseCode: 200,
        //     responseMessage: "checkSku...",
        //     responseData: checkSku
        // });
        if (purchase.items[p].item_status != "Completed") {
          // console.log("Loop = " + p)
          var stockAdded = await q.all(
            businessFunctions.stockEntry(
              purchase._id,
              products[p],
              business,
              vendor,
              loggedInDetails
            )
          );
          // console.log("Stock Added = " + stockAdded)
          if (stockAdded) {
            purchase.items[p].item_status = "Completed";
            await purchase.markModified("items");
            await purchase
              .save()
              .then(async function (ress) {
                // console.log(" 1341 Item Saved = " + p + "\n ress= " + ress.items[p].item_status)
                // var checkSku =
                // await q.all(businessFunctions.stockEntry(purchase._id, products[p], business, vendor, loggedInDetails));
              })
              .catch((err) => {
                // console.log("Error...", err)
              });
          }
        } else {
          // console.log("Item Already Exists  = " + p)
        }
      }
      var log_details = {
        business: business,
        activity_by: loggedInDetails.name,
        activity: "Completed",
        // time: new Date().getTime.toLocaleTimeString(),
        remark: "",
        created_at: new Date(),
      };
      var logs = [];
      if (purchase.logs) {
        logs = purchase.logs;
        logs.push(log_details);
      } else {
        logs.push(log_details);
      }
      await Purchase.findOneAndUpdate(
        { _id: purchase._id },
        { $set: { status: "Completed", logs: logs, updated_at: new Date() } },
        { new: true },
        async function (err, doc) {
          // console.log("Working ....")
          // console.log("Log  = " + purchase._id)
          var purchaseDetails = await Purchase.findOne({
            _id: purchase._id,
          }).exec();
          var transactionData = {
            user: purchaseDetails.vendor,
            business: purchaseDetails.business,
            status: "Purchase",
            type: "Purchase",
            paid_by: "-",
            activity: "Purchase",
            source: purchaseDetails._id,
            bill_id: purchaseDetails.reference_no,
            bill_amount: purchaseDetails.total,
            transaction_amount: purchaseDetails.total,
            balance: purchaseDetails.total,
            total: purchaseDetails.total,
            paid_total: purchaseDetails.total,
            due: 0,
            payment_status: "Pending",
            payment_mode: "-",
            received_by: loggedInDetails.name,
            transaction_id: "-",
            transaction_date: new Date(),
            transaction_status: "Success",
            transaction_response: "-",
            transaction_type: "Purchase",
          };
          q.all(businessFunctions.addTransaction(transactionData));

          res.status(200).json({
            responseCode: 200,
            responseMessage: "Updated...",
            responseData: {},
          });
        }
      );
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Purchase not found",
        responseData: {},
      });
    }
  }
);

router.post("/stock/import", async function (req, res, next) {
  var token = req.headers["x-access-token"];
  var secret = config.secret;
  var decoded = jwt.verify(token, secret);
  var user = decoded.user;
  var business = req.headers["business"];
  var not_inserted = [];
  var storage = multer.diskStorage({
    destination: function (req, file, cb) {
      cb(null, "/home/ubuntu/CarEager/uploads");
    },
    filename: function (req, file, cb) {
      var datetimestamp = Date.now();
      cb(
        null,
        uuidv1() +
          "." +
          file.originalname.split(".")[file.originalname.split(".").length - 1]
      );
    },
  });

  var upload = multer({
    storage: storage,
    fileFilter: function (req, file, callback) {
      if (
        ["xls", "xlsx"].indexOf(
          file.originalname.split(".")[file.originalname.split(".").length - 1]
        ) === -1
      ) {
        return callback(new Error("Wrong extension type"));
      }
      callback(null, true);
    },
  }).single("media");

  upload(req, res, function (err) {
    if (err) {
      return res.status(422).json({
        responseCode: 422,
        responseMessage: "Server Error",
        responseData: err,
      });
    }

    if (!req.file) {
      return res.status(422).json({
        responseCode: 422,
        responseMessage: "No File Passed",
        responseData: {},
      });
    }

    if (
      req.file.originalname.split(".")[
        req.file.originalname.split(".").length - 1
      ] === "xlsx"
    ) {
      exceltojson = xlsxtojson;
    } else {
      return res.status(422).json({
        responseCode: 422,
        responseMessage: "Error",
        responseData: {},
      });
    }

    exceltojson(
      {
        input: req.file.path,
        output: null,
        lowerCaseHeaders: true,
      },
      async function (err, result) {
        if (err) {
          return res.status(422).json({
            responseCode: 422,
            responseMessage: "Error",
            responseData: err,
          });
        } else {
          var invalid_data = _.filter(
            result,
            (x) =>
              x.title == "" ||
              x.part_no == "" ||
              parseFloat(x.purchase_price) < 0 ||
              parseFloat(x.selling_price) < 0 ||
              parseFloat(x.tax_rate) <= 0 ||
              x.total == "" ||
              x.consumed == "" ||
              x.available == "" ||
              x.hsn_sac == "" ||
              x.amount_is_tax == "" ||
              x.unit == ""
          );

          if (invalid_data.length > 0) {
            res.status(422).json({
              responseCode: 422,
              responseMessage: "Unformatted Data! Please check & upload again.",
              responseData: {},
            });
          } else {
            for (var i = 0; i < result.length; i++) {
              var product = result[i];

              var part_no = product.part_no;
              part_no = part_no.replace(/,/g, ", ");
              part_no = part_no.toUpperCase();

              var businessProduct = await BusinessProduct.findOne({
                part_no: part_no,
                unit: product.unit,
                business: business,
              })
                .sort({ updated_at: -1 })
                .exec();

              var margin_total = 0;
              if (businessProduct) {
                var tax = [];
                var tax_info = await Tax.findOne({
                  rate: parseFloat(product.tax_rate),
                  type: "GST",
                }).exec();
                var rate = parseFloat(product.selling_price);
                var amount = parseFloat(product.selling_price);
                var tax_rate = tax_info.detail;
                var base = amount;

                if (product.amount_is_tax == "exclusive") {
                  var tax_on_amount = amount;
                  if (tax_rate.length > 0) {
                    for (var r = 0; r < tax_rate.length; r++) {
                      if (tax_rate[r].rate != tax_info.rate) {
                        var t = tax_on_amount * (tax_rate[r].rate / 100);
                        amount = amount + t;
                        tax.push({
                          tax: tax_rate[r].tax,
                          rate: tax_rate[r].rate,
                          amount: parseFloat(t.toFixed(2)),
                        });
                      } else {
                        var t = tax_on_amount * (tax_info.rate / 100);
                        amount = amount + t;
                        tax.push({
                          tax: tax_info.tax,
                          tax_rate: tax_info.rate,
                          rate: tax_info.rate,
                          amount: parseFloat(t.toFixed(2)),
                        });
                      }
                    }
                  }
                }

                if (product.amount_is_tax == "inclusive") {
                  var x = (100 + tax_info.rate) / 100;
                  var tax_on_amount = amount / x;
                  if (tax_rate.length > 0) {
                    for (var r = 0; r < tax_rate.length; r++) {
                      if (tax_rate[r].rate != tax_info.rate) {
                        var t = tax_on_amount * (tax_rate[r].rate / 100);
                        base = base - t;
                        tax.push({
                          tax: tax_rate[r].tax,
                          rate: tax_rate[r].rate,
                          amount: parseFloat(t.toFixed(2)),
                        });
                      } else {
                        var t = amount - tax_on_amount;
                        base = base - t;
                        tax.push({
                          tax: tax_info.tax,
                          rate: tax_info.rate,
                          amount: parseFloat(t.toFixed(2)),
                        });
                      }
                    }
                  }
                }

                var tax_details = {
                  tax: tax_info.tax,
                  rate: tax_info.rate,
                  amount: amount,
                  detail: tax,
                };

                var sku = {
                  sku: product.sku,
                  total: parseFloat(product.total),
                  available: parseFloat(product.available),
                };

                var stock = {
                  total: parseFloat(product.total),
                  consumed: parseFloat(product.consumed),
                  available: parseFloat(product.available),
                };

                var list_type = [];
                list_type = _.concat(
                  businessProduct.list_type,
                  "Offline",
                  "Import"
                );
                list_type = _.uniq(list_type);

                var models = [];
                if (product.models) {
                  models = product.models.split(",");
                }
                models = _.concat(businessProduct.models, models);
                models = _.uniq(models);

                margin_total = amount - parseFloat(product.purchase_price);

                var data = {
                  purchase: null,
                  purchases: [],
                  business: business,
                  product: businessProduct.product,
                  product_id: businessProduct.product_id,
                  part_no: businessProduct.part_no,
                  product_brand: businessProduct.product_brand,
                  product_model: businessProduct.product_model,
                  model: businessProduct.model,
                  category: businessProduct.category,
                  subcategory: businessProduct.subcategory,
                  title: _.startCase(_.lowerCase(businessProduct.title)),
                  short_description: businessProduct.short_description,
                  long_description: businessProduct.long_description,
                  thumbnail: businessProduct.thumbnail,
                  specification: businessProduct.specification,
                  hsn_sac: product.hsn_sac,
                  unit: product.unit,
                  quantity: parseFloat(product.total),
                  models: models,
                  stock: stock,
                  list_type: list_type,
                  sku: sku,
                  price: {
                    mrp: parseFloat(product.purchase_price),
                    rate: parseFloat(amount),
                    amount: amount,
                    sell_price: amount,
                    margin_total: margin_total,
                    margin: margin_total,
                  },
                  amount_is_tax: "inclusive",
                  tax: tax_info.tax,
                  tax_rate: tax_info.rate,
                  tax_type: "GST",
                  tax_info: tax_details,
                  created_at: new Date(),
                  updated_at: new Date(),
                };

                BusinessProduct.create(data).then(async function (bp) {});
              } else {
                var tax = [];
                var tax_info = await Tax.findOne({
                  rate: parseFloat(product.tax_rate),
                  type: "GST",
                }).exec();
                var rate = parseFloat(product.selling_price);
                var amount = parseFloat(product.selling_price);
                var tax_rate = tax_info.detail;
                var base = amount;
                /* if(product.margin){
                                 var margin = product.margin;
                                 margin = margin.toString();
                                 if(margin.indexOf("%")>=0)
                                 {
                                     margin = parseFloat(margin);
                                     if(!isNaN(margin) && margin>0)
                                     {
                                         margin_total = amount*(margin/100);
                                         amount = amount+margin_total
                                     }
                                 }
                                 else
                                 {
                                     margin_total = parseFloat(margin);
                                     amount = amount+margin_total
                                 }
                             }     */

                if (product.amount_is_tax == "exclusive") {
                  var tax_on_amount = amount;
                  if (tax_rate.length > 0) {
                    for (var r = 0; r < tax_rate.length; r++) {
                      if (tax_rate[r].rate != tax_info.rate) {
                        var t = tax_on_amount * (tax_rate[r].rate / 100);
                        amount = amount + t;
                        tax.push({
                          tax: tax_rate[r].tax,
                          rate: tax_rate[r].rate,
                          amount: parseFloat(t.toFixed(2)),
                        });
                      } else {
                        var t = tax_on_amount * (tax_info.rate / 100);
                        amount = amount + t;
                        tax.push({
                          tax: tax_info.tax,
                          tax_rate: tax_info.rate,
                          rate: tax_info.rate,
                          amount: parseFloat(t.toFixed(2)),
                        });
                      }
                    }
                  }
                }

                if (product.amount_is_tax == "inclusive") {
                  var x = (100 + tax_info.rate) / 100;
                  var tax_on_amount = amount / x;
                  if (tax_rate.length > 0) {
                    for (var r = 0; r < tax_rate.length; r++) {
                      if (tax_rate[r].rate != tax_info.rate) {
                        var t = tax_on_amount * (tax_rate[r].rate / 100);
                        base = base - t;
                        tax.push({
                          tax: tax_rate[r].tax,
                          rate: tax_rate[r].rate,
                          amount: parseFloat(t.toFixed(2)),
                        });
                      } else {
                        var t = amount - tax_on_amount;
                        base = base - t;
                        tax.push({
                          tax: tax_info.tax,
                          rate: tax_info.rate,
                          amount: parseFloat(t.toFixed(2)),
                        });
                      }
                    }
                  }
                }

                var tax_details = {
                  tax: tax_info.tax,
                  rate: tax_info.rate,
                  amount: amount,
                  detail: tax,
                };

                var sku = {
                  sku: product.sku,
                  total: parseFloat(product.total),
                  available: parseFloat(product.available),
                };

                var stock = {
                  total: parseFloat(product.total),
                  consumed: parseFloat(product.consumed),
                  available: parseFloat(product.available),
                };

                var list_type = ["Offline", "Import"];

                var models = [];
                if (product.models) {
                  models = product.models.split(",");
                }

                margin_total = amount - parseFloat(product.purchase_price);

                var data = {
                  purchase: null,
                  purchases: [],
                  business: business,
                  product: null,
                  product_id:
                    Math.round(+new Date() / 1000) +
                    Math.round(Math.random() * 9999 + 1),
                  part_no: part_no,
                  product_brand: null,
                  product_model: null,
                  model: null,
                  category: null,
                  subcategory: null,
                  title: _.startCase(_.lowerCase(product.title)),
                  short_description: "",
                  long_description: "",
                  thumbnail: "",
                  specification: "",
                  hsn_sac: product.hsn_sac,
                  quantity: parseFloat(product.total),
                  unit: product.unit,
                  models: models,
                  stock: stock,
                  sku: sku,
                  list_type: list_type,
                  price: {
                    mrp: parseFloat(product.purchase_price),
                    rate: parseFloat(amount),
                    amount: amount,
                    sell_price: amount,
                    margin_total: margin_total,
                    margin: margin_total,
                  },
                  amount_is_tax: "inclusive",
                  tax: tax_info.tax,
                  tax_rate: tax_info.rate,
                  tax_type: "GST",
                  tax_info: tax_details,
                  list_type: list_type,
                  created_at: new Date(),
                  updated_at: new Date(),
                };

                BusinessProduct.create(data).then(async function (bp) {});
              }
            }

            res.status(200).json({
              responseCode: 200,
              responseMessage: "Successfully Import",
              responseData: {},
            });
          }
        }
      }
    );
  });
});

router.delete(
  "/bill/delete",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      query: "required",
    };

    var validation = new Validator(req.query, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Error",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var user = decoded.user;
      var business = req.headers["business"];
      var product = new Object();
      var result = [];
      var tax = [];
      var total = 0;
      var purchase = await Purchase.findOne({
        _id: req.query.query,
        status: "Incomplete",
      }).exec();
      if (purchase) {
        Purchase.findOneAndUpdate(
          { _id: purchase._id },
          { $set: { status: "Deleted" } },
          { new: false },
          async function (err, doc) {
            if (err) {
              res.status(422).json({
                responseCode: 422,
                responseMessage: "Server Error...",
                responseData: err,
              });
            } else {
              res.status(200).json({
                responseCode: 200,
                responseMessage: "Removed Successfully",
                responseData: {},
              });
            }
          }
        );
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Purchase not found",
          responseData: {},
        });
      }
    }
  }
);

router.post(
  "/purchase-return/add",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers["business"];
    var product = new Object();
    var result = [];
    var tax = [];
    var total = 0;

    var purchase = await Purchase.findById(req.body.bill).exec();
    var newDate = new Date();
    if (purchase) {
      var purchase_return = await PurchaseReturn.find({
        purchase: req.body.bill,
        status: "Closed",
      })
        .count()
        .exec();
      if (purchase_return == 0) {
        var bill = {
          purchase: purchase._id,
          reference_no: purchase.reference_no,
          bill_no: purchase.bill_no,
          date: purchase.date,
          due_date: purchase.due_date,
          vendor: purchase.vendor,
          vendor_address: purchase.vendor_address,
          items: purchase.items,
          business: purchase.business,
          total: purchase.total,
          status: "Active",
          created_at: newDate,
          updated_at: newDate,
        };

        PurchaseReturn.create(bill).then(async function (purchase) {
          var count = await PurchaseReturn.find({
            _id: { $lt: purchase._id },
            business: business,
          }).count();
          var bill_no = count + 10000;

          PurchaseReturn.findOneAndUpdate(
            { _id: purchase._id },
            { $set: { return_no: bill_no } },
            { new: true },
            async function (err, doc) {
              res.status(200).json({
                responseCode: 200,
                responseMessage: "Bill is ready for return",
                responseData: await PurchaseReturn.findById(
                  purchase._id
                ).exec(),
              });
            }
          );
        });
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Bill not found",
          responseData: {},
        });
      }
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Bill not found",
        responseData: {},
      });
    }
  }
);

router.put(
  "/purchase-return",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers["business"];
    var product = new Object();
    var result = [];
    var tax = [];
    var total = 0;

    var purchase = await PurchaseReturn.findOne({
      _id: req.body.purchase,
      status: "Active",
    }).exec();
    var newDate = new Date();
    if (purchase) {
      var items = [];
      var products = purchase.items;

      if (products.length > 0) {
        for (var p = 0; p < products.length; p++) {
          if (products[p].status == true) {
            if (products[p].lot != null && products[p].quantity != null) {
              var quantity = products[p].quantity * products[p].lot;
              var businessProduct = await BusinessProduct.findById(
                products[p].product
              ).exec();
              if (businessProduct) {
                var stockTotal =
                  parseFloat(businessProduct.stock.total) - quantity;
                var stockAvailable =
                  parseFloat(businessProduct.stock.available) - quantity;
                var stockConsumed = parseFloat(businessProduct.stock.consumed);

                if (stockAvailable < 0) {
                  stockAvailable = 0;
                }

                var stock = {
                  total: stockTotal,
                  available: stockAvailable,
                  consumed: stockConsumed,
                };

                BusinessProduct.findOneAndUpdate(
                  { _id: businessProduct._id },
                  { $set: { stock: stock } },
                  { new: false },
                  async function () {}
                );
              }
            }
          }
        }

        var bill = {
          updated_at: new Date(),
          status: "Closed",
        };

        PurchaseReturn.findOneAndUpdate(
          { _id: purchase._id },
          { $set: bill },
          { new: false },
          async function (err, doc) {
            if (err) {
              res.status(422).json({
                responseCode: 422,
                responseMessage: "Server Error...",
                responseData: {},
              });
            } else {
              res.status(200).json({
                responseCode: 200,
                responseMessage: "Successfully Saved",
                responseData: await PurchaseReturn.findById(
                  purchase._id
                ).exec(),
              });
            }
          }
        );
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Items not found",
          responseData: {},
        });
      }
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Purchase not found",
        responseData: {},
      });
    }
  }
);

router.delete(
  "/purchase-return/delete",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      query: "required",
    };

    var validation = new Validator(req.query, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Error",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var user = decoded.user;
      var business = req.headers["business"];
      var product = new Object();
      var result = [];
      var tax = [];
      var total = 0;
      var purchase = await PurchaseReturn.findOne({
        _id: req.query.query,
        status: "Incomplete",
      }).exec();
      if (purchase) {
        await PurchaseReturn.findByIdAndRemove(purchase._id).exec();
        res.status(200).json({
          responseCode: 200,
          responseMessage: "File has been deleted",
          responseData: {},
        });
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Purchase not found",
          responseData: {},
        });
      }
    }
  }
);

router.post(
  "/tax/calculator",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      tax: "required",
      quantity: "required",
      rate: "required",
      amount_is_tax: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Error",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var tax = [];
      var tax_info = await Tax.findOne({ tax: req.body.tax }).exec();

      if (tax_info) {
        var rate = req.body.rate;
        var amount = req.body.rate * req.body.quantity;
        var tax_rate = tax_info.detail;

        if (req.body.discount) {
          var discount = req.body.discount;
          if (discount.indexOf("%") >= 0) {
            discount = parseFloat(discount);
            if (!isNaN(discount) && discount > 0) {
              var discount_total = amount * (discount / 100);
              amount = amount - parseFloat(discount_total.toFixed(2));
            }
          } else {
            discount = parseFloat(discount);
            if (!isNaN(discount) && discount > 0) {
              var discount_total = discount.toFixed(2);
              amount = amount - parseFloat(discount.toFixed(2));
            }
          }
        }

        if (req.body.amount_is_tax == "exclusive") {
          var tax_on_amount = amount;
          if (tax_rate.length > 0) {
            for (var r = 0; r < tax_rate.length; r++) {
              if (tax_rate[r].rate != tax_info.rate) {
                var t = tax_on_amount * (tax_rate[r].rate / 100);
                amount = amount + t;
                tax.push({
                  tax: tax_rate[r].tax,
                  rate: tax_rate[r].rate,
                  amount_is_tax: req.body.amount_is_tax,
                  amount: parseFloat(t.toFixed(2)),
                });
              } else {
                var t = tax_on_amount * (tax_info.rate / 100);
                amount = amount + t;
                tax.push({
                  tax: tax_info.tax,
                  tax_rate: tax_info.rate,
                  rate: tax_info.rate,
                  amount_is_tax: req.body.amount_is_tax,
                  amount: parseFloat(t.toFixed(2)),
                });
              }
            }
          }
        }

        if (req.body.amount_is_tax == "inclusive") {
          var x = (100 + tax_info.rate) / 100;
          var tax_on_amount = amount / x;
          if (tax_rate.length > 0) {
            for (var r = 0; r < tax_rate.length; r++) {
              if (tax_rate[r].rate != tax_info.rate) {
                var t = tax_on_amount * (tax_rate[r].rate / 100);

                tax.push({
                  tax: tax_rate[r].tax,
                  rate: tax_rate[r].rate,
                  amount_is_tax: req.body.amount_is_tax,
                  amount: parseFloat(t.toFixed(2)),
                });
              } else {
                var t = amount - tax_on_amount;
                tax.push({
                  tax: tax_info.tax,
                  tax_rate: tax_info.rate,
                  rate: tax_info.rate,
                  amount_is_tax: req.body.amount_is_tax,
                  amount: parseFloat(t.toFixed(2)),
                });
              }
            }
          }
        }

        var data = {
          rate: rate,
          quantity: req.body.quantity,
          amount: amount,
          tax_amount: parseFloat(_.sumBy(tax, (x) => x.amount).toFixed(2)),
          discount: discount_total,
          tax: tax_info.tax,
          tax_rate: tax_info.rate,
          tax_info: tax,
        };

        res.status(200).json({
          responseCode: 200,
          responseMessage: "success",
          responseData: data,
        });
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Invalid Tax Slab",
          responseData: {},
        });
      }
    }
  }
);

router.get(
  "/margin/calculator",
  xAccessToken.token,
  async function (req, res, next) {
    var margin = req.query.margin;
    var amount = parseFloat(req.query.amount);
    margin = margin.toString();
    if (margin.indexOf("%") >= 0) {
      margin = parseFloat(margin);
      if (!isNaN(margin) && margin > 0) {
        margin_total = amount * (margin / 100);
        amount = amount + margin_total;
      }
    } else {
      margin_total = parseFloat(margin);
      amount = amount + margin_total;
    }

    res.status(200).json({
      responseCode: 200,
      responseMessage: "Margin",
      responseData: {
        sell_price: amount,
      },
    });
  }
);

router.put(
  "/product/publish",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      id: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Error",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);

      var business = decoded.user;

      var product = await BusinessProduct.findOne({
        _id: req.body.id,
        business: business,
      }).exec();
      if (product) {
        if (product.publish == false) {
          var data = {
            publish: true,
            updated_at: new Date(),
          };
        } else {
          var data = {
            publish: false,
            updated_at: new Date(),
          };
        }

        BusinessProduct.findOneAndUpdate(
          { _id: req.body.id, business: business },
          { $set: data },
          { new: true },
          function (err, doc) {}
        );

        if (data.publish == true) {
          var status = "published";
          var isPublished = true;
        } else {
          var status = "unpublished";
          var isPublished = false;
        }

        const totalProductCount = await BusinessProduct.count({
          business: business,
        }).exec();
        const publishedProductCount = await BusinessProduct.count({
          business: business,
          publish: true,
        }).exec();

        res.status(200).json({
          responseCode: 200,
          responseMessage: "Product has been " + status,
          responseData: {
            total: totalProductCount,
            published: publishedProductCount,
            publish: isPublished,
          },
        });
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Unauthorized",
          responseData: {},
        });
      }
    }
  }
);

router.post(
  "/product/image/add",
  xAccessToken.token,
  function (req, res, next) {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    var upload = multer({
      storage: multerS3({
        s3: s3,
        bucket: config.BUCKET_NAME + "/product",
        acl: "public-read",
        contentType: multerS3.AUTO_CONTENT_TYPE,
        // contentDisposition: 'attachment',
        key: function (req, file, cb) {
          let extArray = file.mimetype.split("/");
          let extension = extArray[extArray.length - 1];
          var filename = uuidv1() + "." + extension;
          if (
            extension == "png" ||
            extension == "jpg" ||
            extension == "jpeg" ||
            extension == "gif"
          ) {
            cb(null, filename);
          } else {
            var params = {
              Bucket: config.BUCKET_NAME + "/product",
              Key: filename,
            };
            s3.deleteObject(params, async function (err, data) {
              var json = {
                responseCode: 422,
                responseMessage: "Invalid extension",
                responseData: {},
              };
              res.status(422).json(json);
            });
          }
        },
      }),
    }).array("media", 1);

    upload(req, res, function (error) {
      if (error) {
        var json = {
          responseCode: 400,
          responseMessage: "Error occured",
          responseData: {},
        };
        res.status(400).json(json);
      }

      if (req.files.length == 0) {
        var json = {
          responseCode: 400,
          responseMessage: "Media is required",
          responseData: {},
        };
        res.status(400).json(json);
      } else {
        var rules = {
          id: "required",
        };

        var validation = new Validator(req.body, rules);

        if (validation.fails()) {
          res.status(422).json({
            responseCode: 422,
            responseMessage: "Error",
            responseData: {
              res: validation.errors.all(),
            },
          });
        } else {
          var data = {
            product: req.body.id,
            file: req.files[0].key,
            created_at: new Date(),
            updated_at: new Date(),
          };

          var productImage = new ProductImage(data);
          productImage.save();

          res.status(200).json({
            responseCode: 200,
            responseMessage: "File has been uploaded",
            responseData: {
              item: productImage,
            },
          });
        }
      }
    });
  }
);

router.post(
  "/product/image/add",
  xAccessToken.token,
  function (req, res, next) {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    var upload = multer({
      storage: multerS3({
        s3: s3,
        bucket: config.BUCKET_NAME + "/product",
        acl: "public-read",
        contentType: multerS3.AUTO_CONTENT_TYPE,
        // contentDisposition: 'attachment',
        key: function (req, file, cb) {
          let extArray = file.mimetype.split("/");
          let extension = extArray[extArray.length - 1];

          var filename = uuidv1() + "." + extension;
          if (
            extension == "png" ||
            extension == "jpg" ||
            extension == "jpeg" ||
            extension == "gif"
          ) {
            cb(null, filename);
          } else {
            var params = {
              Bucket: config.BUCKET_NAME + "/product",
              Key: filename,
            };
            s3.deleteObject(params, async function (err, data) {
              var json = {
                responseCode: 422,
                responseMessage: "Invalid extension",
                responseData: {},
              };
              res.status(422).json(json);
            });
          }
        },
      }),
    }).array("media", 1);

    upload(req, res, function (error) {
      if (error) {
        var json = {
          responseCode: 400,
          responseMessage: "Error occured",
          responseData: {},
        };
        res.status(400).json(json);
      }

      if (req.files.length == 0) {
        var json = {
          responseCode: 400,
          responseMessage: "Media is required",
          responseData: {},
        };
        res.status(400).json(json);
      } else {
        var rules = {
          id: "required",
        };

        var validation = new Validator(req.body, rules);

        if (validation.fails()) {
          res.status(422).json({
            responseCode: 422,
            responseMessage: "Error",
            responseData: {
              res: validation.errors.all(),
            },
          });
        } else {
          var data = {
            product: req.body.id,
            file: req.files[0].key,
            created_at: new Date(),
            updated_at: new Date(),
          };

          var productImage = new ProductImage(data);
          productImage.save();

          res.status(200).json({
            responseCode: 200,
            responseMessage: "File has been uploaded",
            responseData: {
              item: productImage,
            },
          });
        }
      }
    });
  }
);

router.delete(
  "/product/image/delete",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      id: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Error",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);

      var image_id = req.body.id;
      const media = await ProductImage.findById(image_id).exec();

      if (media) {
        var params = {
          Bucket: config.BUCKET_NAME + "/product",
          Key: media.file,
        };
        s3.deleteObject(params, async function (err, data) {
          if (err) {
            res.status(400).json({
              responseCode: 400,
              responseMessage: "Error occured",
              responseData: {},
            });
          } else {
            var deleteImage = ProductImage.findByIdAndRemove(image_id).exec();
            if (deleteImage) {
              res.status(200).json({
                responseCode: 200,
                responseMessage: "File has been deleted",
                responseData: {},
              });
            } else {
              res.status(400).json({
                responseCode: 400,
                responseMessage: "Error occured",
                responseData: {},
              });
            }
          }
        });
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Wrong image",
          responseData: {},
        });
      }
    }
  }
);

router.get(
  "/stocks/export",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    var business = decoded.user;

    var product = [];

    if (req.query.page == undefined) {
      var page = 0;
    } else {
      var page = req.query.page;
    }

    var page = Math.max(0, parseInt(page));

    var product = [];
    var array = [];

    if (req.query.by == "category") {
      var query = {
        $match: {
          category: mongoose.Types.ObjectId(req.query.query),
          business: mongoose.Types.ObjectId(business),
        },
      };
    } else if (req.query.by == "subcategory") {
      var query = {
        $match: { subcategory: mongoose.Types.ObjectId(req.query.query) },
        business: mongoose.Types.ObjectId(business),
      };
    } else if (req.query.by == "brand") {
      var query = {
        $match: {
          product_brand: mongoose.Types.ObjectId(req.query.query),
          business: mongoose.Types.ObjectId(business),
        },
      };
    } else if (req.query.by == "model") {
      var query = {
        $match: {
          product_model: mongoose.Types.ObjectId(req.query.query),
          business: mongoose.Types.ObjectId(business),
        },
      };
    } else if (req.query.by == "id") {
      var query = {
        $match: {
          product: mongoose.Types.ObjectId(req.query.query),
          business: mongoose.Types.ObjectId(business),
        },
      };
    } else if (req.query.by == "filter") {
      var specification = {};
      var subcategory = req.query.subcategory;
      specification["business"] = business;
      array.push(specification);

      if (req.query.subcategory) {
        var specification = {};
        var subcategory = req.query.subcategory;
        specification["_subcategory"] = { $in: subcategory.split(",") };
        array.push(specification);
      }

      if (req.query.brand) {
        var specification = {};
        var brand = req.query.brand;
        specification["_product_brand"] = { $in: brand.split(",") };
        array.push(specification);
      }

      if (req.query.type) {
        var specification = {};
        var type = req.query.type;
        specification["type"] = { $in: type.split(",") };
        array.push(specification);
      }

      if (req.query.size) {
        var specification = {};
        var size = req.query.size;
        specification["specification.size"] = { $in: size.split(",") };
        array.push(specification);
      }

      if (req.query.material) {
        var specification = {};
        var material = req.query.material;
        specification["specification.specification"] = {
          $in: material.split(","),
        };
        array.push(specification);
      }

      if (req.query.variants) {
        var specification = {};
        var variants = req.query.variants;
        specification["specification.type"] = { $in: variants.split(",") };
        array.push(specification);
      }

      if (req.query.price) {
        var specification = {};
        var price = req.query.price;
        var min = price.split(",")[0];
        var max = price.split(",")[1];
        specification["price.sell_price"] = {
          $gte: parseInt(min),
          $lte: parseInt(max),
        };
        array.push(specification);
      }

      if (req.query.car) {
        var specification = {};
        var models = req.query.car;
        specification["models"] = { $in: models.split(",") };
        array.push(specification);
      }

      var specification = {};
      var list_type = req.query.list_type;
      specification["list_type"] = { $in: list_type.split(",") };
      array.push(specification);

      var query = {
        $match: {
          $and: array,
        },
      };
    } else {
      var list_type = req.query.list_type;
      var query = {
        $match: {
          business: mongoose.Types.ObjectId(business),
          list_type: { $in: list_type.split(",") },
          $or: [
            { type: { $regex: req.query.query, $options: "i" } },
            { models: { $regex: req.query.query, $options: "i" } },
            { title: { $regex: req.query.query, $options: "i" } },
            { part_no: { $regex: req.query.query, $options: "i" } },
            { keywords: { $regex: req.query.query, $options: "i" } },
            {
              sku: {
                $elemMatch: {
                  sku: { $regex: req.query.query, $options: "i" },
                },
              },
            },
          ],
        },
      };
    }

    await BusinessProduct.aggregate([
      query,
      { $sort: { "price.sell_price": -1 } },
    ])
      .allowDiskUse(true)
      .cursor({})
      .exec()
      .eachAsync(async function (p) {
        var title = p.title;
        if (_.includes(title, ",")) {
          title = title.replace(/,/g, ", ");
        }

        product.push({
          product: p.product,
          _id: p._id,
          id: p._id,
          product_brand: await ProductBrand.findById(p.product_brand).exec(),
          product_model: await ProductCategory.findById(p.product_model).exec(),
          category: await ProductCategory.findById(p.category).exec(),
          subcategory: await ProductCategory.findById(p.subcategory).exec(),
          business: p.business,
          title: title,
          price: p.price,
          stock: p.stock,
          part_no: p.part_no,
          hsn_sac: p.hsn_sac,
          tax: p.tax,
          sku: p.sku,
          specification: p.specification,
          product_id: p.product_id,
          short_description: p.short_description,
          long_description: p.long_description,
          thumbnail: p.preview,
          models: p.models,
          services: p.services,
          unit: p.unit,
          warranty: p.warranty,
          quantity: p.quantity,
        });
      });

    const totalProductCount = await BusinessProduct.aggregate([
      query,
      { $sort: { "price.sell_price": -1 } },
    ]).exec();

    const publishedProductCount = await BusinessProduct.count({
      business: business,
      publish: true,
      list_type: { $in: ["Offline"] },
    }).exec();

    res.status(200).json({
      responseCode: 200,
      //responseQuery: query,
      responseMessage: "success",
      responseData: {
        total: totalProductCount.length,
        published: publishedProductCount,
        products: product,
      },
    });
  }
);

router.get(
  "/order/items/get",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    var business = decoded.user;

    var page = Math.max(0, parseInt(page));
    var convenience = "";
    var orders = [];
    var order = await Order.findById(req.query.order)
      .populate({ path: "user" })
      .populate({ path: "address" })
      .exec();
    if (order) {
      await OrderLine.find({ order: order._id, business: business })
        .populate({ path: "product", select: "stock" })
        .cursor()
        .eachAsync(async (p) => {
          convenience = p.convenience;

          orders.push({
            product: p.product.product,
            order_no: p.order_no,
            tracking_no: p.tracking_no,
            _category: p._category,
            category: p.category,
            source: p.source,
            cost: p.cost,
            total: p.total,
            discount: p.discount,
            discount_type: p.discount_type,
            discount_total: p.discount_total,
            paid_cost: p.paid_cost,
            title: p.title,
            description: p.description,
            quantity: p.quantity,
            stock: p.product.stock,
            tax_info: p.tax_info,
            services: p.services,
            log: p.log,
            status: p.status,
            created_at: p.created_at,
            updated_at: p.updated_at,
          });
        });

      var data = {
        items: orders,
        payment: order.payment,
        due: order.due,
        address: order.address,
        convenience: convenience,
        status: order.status,
        user: {
          _id: order.user._id,
          id: order.user.id,
          name: order.user.name,
          contact_no: order.user.contact_no,
        },
      };
      res.status(200).json({
        responseCode: 200,
        responseMessage: "success",
        responseData: data,
      });
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "success",
        responseData: orders,
      });
    }
  }
);

router.get(
  "/customers/orders/get",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    var business = req.headers["business"];

    if (req.query.page == undefined) {
      var page = 0;
    } else {
      var page = req.query.page;
    }

    var page = Math.max(0, parseInt(page));

    var orders = [];
    if (business) {
      await OrderLine.aggregate([
        {
          $match: {
            business: mongoose.Types.ObjectId(business),
          },
        },
        { $unwind: "$user" },
        {
          $lookup: {
            from: "User",
            localField: "user",
            foreignField: "_id",
            as: "user",
          },
        },
        { $unwind: "$order" },
        {
          $lookup: {
            from: "Order",
            localField: "order",
            foreignField: "_id",
            as: "order",
          },
        },
        { $unwind: "$product" },
        {
          $lookup: {
            from: "BusinessProduct",
            localField: "product",
            foreignField: "_id",
            as: "product",
          },
        },
        { $group: { _id: "$order._id", data: { $push: "$$ROOT" } } },
        { $skip: config.perPage * page },
        { $limit: config.perPage },
      ])
        .allowDiskUse(true)
        .cursor({ batchSize: 10 })
        .exec()
        .eachAsync(async function (doc) {
          var data = doc.data;
          var stock = true;
          data.forEach(async function (d) {
            if (d.product[0].stock.available <= 0) {
              stock = false;
            }
          });

          var address = await Address.findById(
            doc.data[0].order[0].address
          ).exec();
          var time_left = moment(doc.data[0].date).endOf("day").fromNow();

          if (time_left.includes("ago")) {
            time_left = time_left;
          } else {
            time_left = time_left.replace("in ", "") + " left";
          }

          orders.push({
            _id: doc.data[0].order[0]._id,
            id: doc.data[0].order[0]._id,
            order_no: doc.data[0].order[0].order_no,
            name: doc.data[0].user[0].name,
            contact_no: doc.data[0].user[0].contact_no,
            stock: stock,
            address: address,
            convenience: doc.data[0].convenience,
            time_left: time_left,
            status: doc.data[0].order[0].status,
            created_at: moment(doc.data[0].order[0].created_at)
              .tz(req.headers["tz"])
              .format("lll"),
            delivered_by: moment(doc.data[0].date)
              .tz(req.headers["tz"])
              .format("ll"),
            time_slot: doc.data[0].time_slot,
          });
        });

      res.status(200).json({
        responseCode: 200,
        responseMessage: "success",
        responseData: orders,
      });
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Business not mention",
        responseData: {},
      });
    }
  }
);

router.put(
  "/offer/publish",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      id: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Error",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);

      var business = decoded.user;
      var check = await BusinessOffer.find({
        _id: req.body.id,
        business: business,
      })
        .count()
        .exec();
      if (check == 1) {
        var offer_id = req.body.id;

        BusinessOffer.findOne({ _id: offer_id, business: business })
          .exec()
          .then(async function (result) {
            return result;
          })
          .then(function (result) {
            if (result.publish == false) {
              var status = true;
            } else {
              var status = false;
            }
            var data = {
              publish: status,
            };

            BusinessOffer.findOneAndUpdate(
              { _id: req.body.id, business: business },
              { $set: data },
              { new: true },
              function (err, doc) {}
            );
            return status;
          })
          .then(function (result) {
            BusinessOffer.count(
              { business: business, publish: true },
              async function (err, count) {
                if (result == 1) {
                  var status = "published";
                  var isPublished = true;
                } else {
                  var status = "unpublished";
                  var isPublished = false;
                }

                const totalOfferCount = await BusinessOffer.count({
                  business: business,
                }).exec();

                const publishedOfferCount = await BusinessOffer.count({
                  business: business,
                  publish: true,
                }).exec();

                var json = {
                  responseCode: 200,
                  responseMessage: "Offer has been " + status,
                  responseData: {
                    total: totalOfferCount,
                    published: publishedOfferCount,
                    publish: isPublished,
                  },
                };
                res.status(200).json(json);
              }
            );
          });
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Unauthorized",
          responseData: {},
        });
      }
    }
  }
);

router.get("/offer", xAccessToken.token, async function (req, res, next) {
  var token = req.headers["x-access-token"];
  var secret = config.secret;
  var decoded = jwt.verify(token, secret);

  var business = decoded.user;

  //paginate
  if (req.query.page == undefined) {
    var page = 0;
  } else {
    var page = req.query.page;
  }

  var page = Math.max(0, parseInt(page));
  var offer = await BusinessOffer.find({ business: business })
    .populate("bookmark")
    .limit(config.perPage)
    .skip(config.perPage * page)
    .exec();
  const totalOfferCount = await BusinessOffer.count({
    business: business,
  }).exec();

  const publishedOfferCount = await BusinessOffer.count({
    business: business,
    publish: true,
  }).exec();

  res.status(200).json({
    responseCode: 200,
    responseMessage: "success",
    responseData: {
      total: totalOfferCount,
      published: publishedOfferCount,
      offers: offer,
    },
  });
});

router.post("/offer/image/add", xAccessToken.token, function (req, res, next) {
  var token = req.headers["x-access-token"];
  var secret = config.secret;
  var decoded = jwt.verify(token, secret);

  var upload = multer({
    storage: multerS3({
      s3: s3,
      bucket: config.BUCKET_NAME + "/offer",
      acl: "public-read",
      contentType: multerS3.AUTO_CONTENT_TYPE,
      // contentDisposition: 'attachment',
      key: function (req, file, cb) {
        let extArray = file.mimetype.split("/");
        let extension = extArray[extArray.length - 1];
        var filename = uuidv1() + "." + extension;
        if (
          extension == "png" ||
          extension == "jpg" ||
          extension == "jpeg" ||
          extension == "gif"
        ) {
          cb(null, filename);
        } else {
          var params = {
            Bucket: config.BUCKET_NAME + "/offer",
            Key: filename,
          };
          s3.deleteObject(params, async function (err, data) {
            var json = {
              responseCode: 422,
              responseMessage: "Invalid extension",
              responseData: {},
            };
            res.status(422).json(json);
          });
        }
      },
    }),
  }).array("media", 1);

  upload(req, res, async function (error) {
    if (error) {
      var json = {
        responseCode: 400,
        responseMessage: "Error occured",
        responseData: {},
      };
      res.status(400).json(json);
    }

    if (req.files.length == 0) {
      var json = {
        responseCode: 400,
        responseMessage: "Media is required",
        responseData: {},
      };
      res.status(400).json(json);
    } else {
      const media = await BusinessOffer.findById(req.body.id).exec();

      if (media) {
        var params = {
          Bucket: config.BUCKET_NAME + "/offer",
          Key: media.image,
        };
        s3.deleteObject(params, async function (err, data) {
          if (err) {
            res.status(400).json({
              responseCode: 400,
              responseMessage: "Error occured",
              responseData: err,
            });
          } else {
            var data = {
              image: req.files[0].key,
            };

            BusinessOffer.findOneAndUpdate(
              { _id: req.body.id },
              { $set: data },
              { new: true },
              function (err, doc) {
                res.status(200).json({
                  responseCode: 200,
                  responseMessage: "Offer image has been updated",
                  responseData: {
                    item: doc,
                  },
                });
              }
            );
          }
        });
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Wrong image",
          responseData: {},
        });
      }
    }
  });
});

router.post("/gallery/update", xAccessToken.token, function (req, res, next) {
  var token = req.headers["x-access-token"];
  var secret = config.secret;
  var decoded = jwt.verify(token, secret);

  var upload = multer({
    storage: multerS3({
      s3: s3,
      bucket: config.BUCKET_NAME + "/gallery",
      acl: "public-read",
      contentType: multerS3.AUTO_CONTENT_TYPE,
      // contentDisposition: 'attachment',
      key: function (req, file, cb) {
        let extArray = file.mimetype.split("/");
        let extension = extArray[extArray.length - 1];

        var filename = uuidv1() + "." + extension;
        if (
          extension == "png" ||
          extension == "jpg" ||
          extension == "jpeg" ||
          extension == "gif"
        ) {
          cb(null, filename);
        } else {
          var params = {
            Bucket: config.BUCKET_NAME + "/gallery",
            Key: filename,
          };
          s3.deleteObject(params, async function (err, data) {
            var json = {
              responseCode: 422,
              responseMessage: "Invalid extension",
              responseData: {},
            };
            res.status(422).json(json);
          });
        }
      },
    }),
  }).array("media", 1);

  upload(req, res, function (error) {
    if (error) {
      var json = {
        responseCode: 400,
        responseMessage: "Error occured",
        responseData: {},
      };
      res.status(400).json(json);
    }

    if (req.files.length == 0) {
      var json = {
        responseCode: 400,
        responseMessage: "Media is required",
        responseData: {},
      };
      res.status(400).json(json);
    } else {
      var data = {
        business: decoded.user,
        file: req.files[0].key,
        created_at: new Date(),
        updated_at: new Date(),
      };

      var businessGallery = new BusinessGallery(data);
      businessGallery.save();

      res.status(200).json({
        responseCode: 200,
        responseMessage: "File has been uploaded",
        responseData: {
          item: businessGallery,
        },
      });
    }
  });
});

router.delete(
  "/gallery/delete",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      id: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Error",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);

      var image_id = req.body.id;
      const media = await BusinessGallery.findById(image_id).exec();

      if (media) {
        var params = {
          Bucket: config.BUCKET_NAME + "/gallery",
          Key: media.file,
        };
        s3.deleteObject(params, async function (err, data) {
          if (err) {
            res.status(400).json({
              responseCode: 400,
              responseMessage: "Error occured",
              responseData: {},
            });
          } else {
            var deleteImage =
              BusinessGallery.findByIdAndRemove(image_id).exec();
            if (deleteImage) {
              res.status(200).json({
                responseCode: 200,
                responseMessage: "File has been deleted",
                responseData: {},
              });
            } else {
              res.status(400).json({
                responseCode: 400,
                responseMessage: "Error occured",
                responseData: {},
              });
            }
          }
        });
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Wrong image",
          responseData: {},
        });
      }
    }
  }
);

router.put(
  "/location/update",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    const count = await User.count({ _id: decoded.user }).exec();

    if (count == 1) {
      var data = {
        geometry: [req.body.latitude, req.body.longitude],
        address: {
          location: req.body.location,
        },
      };

      User.findOneAndUpdate(
        { _id: decoded.user },
        { $set: data },
        { new: true },
        function (err, doc) {
          if (err) {
            var json = {
              responseCode: 400,
              responseMessage: "Error Occurred",
              responseData: err,
            };

            res.status(400).json(json);
          } else {
            var json = {
              responseCode: 200,
              responseMessage: "Location has been updated",
              responseData: {},
            };
            res.status(200).json(json);
          }
        }
      );
    } else {
      var json = {
        responseCode: 400,
        responseMessage: "Invalid user",
        responseData: {},
      };

      res.status(400).json(json);
    }
  }
);

router.get("/search", xAccessToken.token, async function (req, res, next) {
  if (req.query.page == undefined) {
    var page = 0;
  } else {
    var page = req.query.page;
  }

  var page = Math.max(0, parseInt(page));

  var query = req.query.query;

  var business = await User.find({ name: new RegExp(query, "i") })
    .limit(config.perPage)
    .skip(config.perPage * page)
    .exec();

  res.status(200).json({
    responseCode: 200,
    responseMessage: "",
    responseData: business,
  });
});

router.get("/analytics", xAccessToken.token, async function (req, res, next) {
  var token = req.headers["x-access-token"];
  var secret = config.secret;
  var decoded = jwt.verify(token, secret);

  var business = req.headers["business"];
  var analytics = [];
  var paid_total = 0;
  var labour_cost = 0;
  var convenience = 0;
  var salvage = 0;
  var policy_clause = 0;
  var part_cost = 0;
  var of_cost = 0;
  var date = new Date();

  var country = await Country.findOne({
    timezone: { $in: req.headers["tz"] },
  }).exec();

  if (req.query.type == "range") {
    if (req.query.query) {
      var query = req.query.query;
      var ret = query.split("to");

      var from = new Date(ret[0]);
      var to = new Date(ret[1]);
    } else {
      var from = new Date(date.getFullYear(), date.getMonth(), 1);
      var to = new Date(
        date.getFullYear(),
        date.getMonth(),
        date.getDate() + 1
      );
    }
  } else if (req.query.type == "period") {
    if (req.query.query) {
      var query = parseInt(req.query.query);
    } else {
      var query = 7;
    }

    var from = new Date(
      date.getFullYear(),
      date.getMonth(),
      date.getDate() - query
    );
    var to = new Date(date.getFullYear(), date.getMonth(), date.getDate() + 1);
  } else {
    var from = new Date(date.getFullYear(), date.getMonth(), 1);
    var to = new Date(date.getFullYear(), date.getMonth(), date.getDate() + 1);
  }

  var totalLeads = await Lead.find({
    business: business,
    "remark.status": { $in: ["Open", "Follow-Up", "PSF", "Closed", "Lost"] },
    created_at: { $gte: from, $lte: to },
  })
    .count()
    .exec();

  var excludeLeads = await Lead.find({
    psf: false,
    converted: false,
    "remark.status": "Closed",
    business: business,
    created_at: { $gte: from, $lte: to },
  })
    .count()
    .exec();

  var converted = await Lead.find({
    business: business,
    psf: true,
    converted: true,
    "remark.status": "Closed",
    updated_at: { $gte: from, $lte: to },
  })
    .count()
    .exec();

  var calc = totalLeads - excludeLeads;

  var conversion = 0;
  conversion = (converted / calc) * 100;

  if (conversion) {
    conversion = parseFloat(conversion.toFixed(2));
  } else {
    conversion = 0;
  }

  var category = await q.all(businessPlanCategory(business));

  for (var i = 0; i < category.length; i++) {
    if (category[i] == "Workshop") {
      analytics.push({
        title: "Total Leads",
        count: totalLeads,
        group: "Customer Overview",
        category: "CRM",
      });

      analytics.push({
        title: "Conversion",
        count: conversion,
        group: "Customer Overview",
        category: "CRM",
      });

      var totalBooking = await Booking.find({
        business: business,
        is_services: true,
        status: { $ne: "Inactive" },
        created_at: { $gte: from, $lte: to },
      })
        .count()
        .exec();

      analytics.push({
        title: "Total Services",
        group: "General Overview",
        category: "WMS",
        count: totalBooking,
      });

      var totalPackage = await UserPackage.find({
        business: business,
        created_at: { $gte: from, $lte: to },
      })
        .count()
        .exec();

      analytics.push({
        title: "Total Packages",
        group: "General Overview",
        category: "WMS",
        count: totalPackage,
      });

      await Invoice.find({
        business: business,
        status: "Active",
        created_at: { $gte: from, $lte: to },
      })
        .cursor()
        .eachAsync(async (booking) => {
          paid_total = booking.payment.paid_total + paid_total;

          if (booking.payment.convenience_charges) {
            convenience =
              parseInt(booking.payment.convenience_charges) + convenience;
          }

          if (booking.payment.policy_clause) {
            policy_clause =
              parseInt(booking.payment.policy_clause) + policy_clause;
          }

          if (booking.payment.salvage) {
            salvage = parseInt(booking.payment.salvage) + salvage;
          }

          labour_cost =
            booking.payment.labour_cost + labour_cost + booking.payment.of_cost;
          part_cost = booking.payment.part_cost + part_cost;
        });

      var other = convenience + policy_clause + salvage;

      analytics.push({
        title: "Service Revenue",
        group: "General Overview",
        category: "WMS",
        count: price(paid_total),
      });

      analytics.push({
        title: "Labour",
        group: "General Overview",
        category: "WMS",
        count: price(labour_cost),
      });

      analytics.push({
        title: "Parts",
        group: "General Overview",
        category: "WMS",
        count: price(part_cost),
      });

      analytics.push({
        title: "Others",
        group: "General Overview",
        category: "WMS",
        count: price(other),
      });
    } else if (category[i] == "Dealer") {
      analytics.push({
        title: "Total Leads",
        count: totalLeads,
        group: "Customer Overview",
        category: "CRM",
      });

      analytics.push({
        title: "Conversion",
        count: conversion,
        group: "Customer Overview",
        category: "CRM",
      });

      var cars = await Car.find({ user: business }).exec();

      var carSold = await CarSell.find({
        seller: business,
        sold: true,
        created_at: { $gte: from, $lte: to },
      }).exec();

      var packageSold = await CarSell.find({
        seller: business,
        sold: true,
        package_sold: true,
        created_at: { $gte: from, $lte: to },
      }).exec();

      var carListed = await Car.find({
        user: business,
        publish: true,
        admin_approved: true,
        created_at: { $gte: from, $lte: to },
      }).exec();

      var packageSold = await CarSell.find({
        seller: business,
        sold: true,
        package_sold: true,
        created_at: { $gte: from, $lte: to },
      }).exec();

      var sold_price = _.sumBy(carSold, (x) => x.price);
      var package_cost = _.sumBy(carSold, (x) => x.package_cost);
      var refurbishment_cost = _.sumBy(carSold, (x) => x.refurbishment_cost);
      var purchase_price = _.sumBy(carSold, (x) => x.purchase_price);

      var profit =
        sold_price - (package_cost + refurbishment_cost + purchase_price);

      analytics.push({
        title: "Cars In Garage",
        count: cars.length,
        group: "General Overview",
        category: category[i],
      });

      analytics.push({
        title: "Car Listed",
        count: carListed.length,
        group: "General Overview",
        category: category[i],
      });

      analytics.push({
        title: "Revenue",
        count: sold_price,
        group: "Income Overview",
        category: category[i],
      });

      analytics.push({
        title: "Profit",
        count: profit,
        group: "Income Overview",
        category: category[i],
      });

      analytics.push({
        title: "Packages Sold",
        count: packageSold.length,
        group: "General Overview",
        category: category[i],
      });

      analytics.push({
        title: "Cars Sold",
        count: carSold.length,
        group: "General Overview",
        category: category[i],
      });
    } else if (category[i] == "Fleet") {
      var cars = await Car.find({ user: business }).exec();

      var carSold = await CarSell.find({
        seller: business,
        sold: true,
        created_at: { $gte: from, $lte: to },
      }).exec();

      var packageSold = await CarSell.find({
        seller: business,
        sold: true,
        package_sold: true,
        created_at: { $gte: from, $lte: to },
      }).exec();

      var carListed = await Car.find({
        user: business,
        publish: true,
        admin_approved: true,
        created_at: { $gte: from, $lte: to },
      }).exec();

      var packageSold = await CarSell.find({
        seller: business,
        sold: true,
        package_sold: true,
        created_at: { $gte: from, $lte: to },
      }).exec();

      var sold_price = _.sumBy(carSold, (x) => x.price);
      var package_cost = _.sumBy(carSold, (x) => x.package_cost);
      var refurbishment_cost = _.sumBy(carSold, (x) => x.refurbishment_cost);
      var purchase_price = _.sumBy(carSold, (x) => x.purchase_price);

      var profit =
        sold_price - (package_cost + refurbishment_cost + purchase_price);

      analytics.push({
        title: "Cars In Garage",
        group: "General Overview",
        count: cars.length,
        category: category[i],
      });

      var check = await Point.find({
        user: business,
        tag: "ReferralCommission",
      }).exec();

      var credit = _.filter(check, (type) => type.type == "credit");
      var credit_commission = _.sumBy(credit, (x) => x.points);

      var debit = _.filter(check, (type) => type.type == "debit");
      var debit_commission = _.sumBy(debit, (x) => x.points);

      analytics.push({
        title: "Commission Earned",
        group: "Income Overview",
        count: credit_commission - debit_commission,
        category: category[i],
      });

      analytics.push({
        title: "Car Listed",
        group: "General Overview",
        count: carListed.length,
        category: category[i],
      });

      /*analytics.push({
                title: "Revenue",
                count: sold_price,
                category: category[i]
            });

            analytics.push({
                title: "Profit",
                count: profit,
                category: category[i]
            });*/

      /* analytics.push({
                 title: "Package Sold",
                 count: packageSold.length,
                 category: category[i]
             });*/

      analytics.push({
        title: "Cars Sold",
        group: "General Overview",
        count: carSold.length,
        category: category[i],
      });
    }
  }

  analytics = _.uniqBy(analytics, "title");
  (analytics = _(analytics)
    .groupBy((x) => x.group)
    .map((value, key) => ({ group: key, data: value }))
    .value()),
    res.status(200).json({
      responseCode: 200,
      responseMessage: from + " - " + to,
      responseData: analytics,
    });
});

router.get(
  "/performance/analytic",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    var business = req.headers["business"];

    var managements = [];
    var paid_total = 0;
    var labour_cost = 0;
    var part_cost = 0;
    var date = new Date();
    if (req.query.type == "range") {
      if (req.query.query) {
        var query = req.query.query;
        var ret = query.split("to");

        var from = new Date(ret[0]).toISOString();
        var to = new Date(ret[1]).toISOString();
      } else {
        var from = new Date(date.getFullYear(), date.getMonth(), 1);
        var to = new Date(
          date.getFullYear(),
          date.getMonth(),
          date.getDate() + 1
        );
      }
    } else if (req.query.type == "period") {
      if (req.query.query) {
        var query = parseInt(req.query.query);
      } else {
        var query = 7;
      }

      var from = new Date(
        date.getFullYear(),
        date.getMonth(),
        date.getDate() - query
      );
      var to = new Date(
        date.getFullYear(),
        date.getMonth(),
        date.getDate() + 1
      );
    } else {
      var from = new Date(
        date.getFullYear(),
        date.getMonth(),
        date.getDate() - 30
      );
      var to = new Date(
        date.getFullYear(),
        date.getMonth(),
        date.getDate() + 1
      );
    }

    await Management.find({ business: business })
      .populate({
        path: "user",
        select: "_id id name contact_no avatar avatar_address email",
      })
      .cursor()
      .eachAsync(async (management) => {
        if (management.role != "Admin") {
          if (management.role == "Service Advisor") {
            var analytics = [];
            var totalBooking = await Booking.find({
              advisor: management.user._id,
              is_services: true,
              status: { $ne: "Inactive" },
              created_at: { $gte: from, $lte: to },
            })
              .count()
              .exec();

            analytics.push({
              title: "Total Booking",
              count: totalBooking,
            });

            var completed = await Booking.find({
              advisor: management.user._id,
              is_services: true,
              status: "Completed",
              created_at: { $gte: from, $lte: to },
            })
              .count()
              .exec();

            analytics.push({
              title: "Completed Booking",
              count: completed,
            });

            var inProcess = await Booking.find({
              advisor: management.user._id,
              is_services: true,
              status: "In-Process" /* created_at:{$gte: from, $lte: to}*/,
            })
              .count()
              .exec();

            analytics.push({
              title: "InProcess Booking",
              count: inProcess,
            });

            var rework = await Booking.find({
              advisor: management.user._id,
              is_services: true,
              is_rework: true,
            })
              .count()
              .exec();

            analytics.push({
              title: "Rework",
              count: rework,
            });

            managements.push({
              id: management.user._id,
              role: management.role,
              name: management.user.name,
              username: management.user.username,
              email: management.user.email,
              contact_no: management.user.contact_no,
              avatar: management.user.avatar,
              avatar_address: management.user.avatar_address,
              analytics: analytics,
            });
          } else if (management.role == "CRE") {
            var analytics = [];
            var leads = [];

            var totalLeads = await Lead.find({
              assignee: management.user._id,
              created_at: { $gte: from, $lte: to },
            })
              .count()
              .exec();

            var excludeLeads = await Lead.find({
              psf: false,
              converted: false,
              "remark.status": "Closed",
              assignee: management.user._id,
              created_at: { $gte: from, $lte: to },
            })
              .count()
              .exec();

            var c = await Lead.find({
              assignee: management.user._id,
              converted: true,
              updated_at: { $gte: from, $lte: to },
            }).exec();

            var id = _.map(c, "_id");

            var converted = await Booking.find({
              lead: { $in: id },
              status: {
                $nin: [
                  "Rejected",
                  "Cancelled",
                  "Inactive",
                  "EstimateRequested",
                ],
              },
              updated_at: { $gte: from, $lte: to },
            }).count();

            var calc = totalLeads - excludeLeads;

            var conversion = 0;
            conversion = (converted / calc) * 100;

            if (conversion) {
              conversion = parseFloat(conversion.toFixed(2));
            }

            analytics.push({
              title: "Total Leads",
              count: totalLeads,
            });

            analytics.push({
              title: "Converted",
              count: converted,
            });

            analytics.push({
              title: "Conversion",
              count: conversion,
            });

            var open = await Lead.find({
              assignee: management.user._id,
              "remark.status": "Open",
            })
              .count()
              .exec();
            analytics.push({
              title: "Open",
              count: open,
            });

            var follow_up = await Lead.find({
              assignee: management.user._id,
              "remark.status": "Follow-Up",
            })
              .count()
              .exec();
            analytics.push({
              title: "Follow Up",
              count: follow_up,
            });

            var pipeline = await Booking.find({
              manager: management.user._id,
              converted: true,
              status: {
                $nin: [
                  "Completed",
                  "CompleteWork",
                  "QC",
                  "Closed",
                  "Ready",
                  "Rejected",
                  "Cancelled",
                  "Inactive",
                ],
              },
            })
              .count()
              .exec();

            analytics.push({
              title: "Estimate",
              count: pipeline,
            });

            var totalClosedLeads = await Lead.find({
              assignee: management.user._id,
              "remark.status": "Closed",
            })
              .count()
              .exec();
            analytics.push({
              title: "Closed",
              count: totalClosedLeads,
            });

            managements.push({
              id: management.user._id,
              name: management.user.name,
              role: management.role,
              username: management.user.username,
              email: management.user.email,
              contact_no: management.user.contact_no,
              avatar: management.user.avatar,
              avatar_address: management.user.avatar_address,
              analytics: analytics,
            });
          }
        }
      });

    (managements = _(managements)
      .groupBy((x) => x.role)
      .map((value, key) => ({ role: key, data: value }))
      .value()),
      res.status(200).json({
        responseCode: 200,
        responseMessage: "Analytics",
        responseData: managements,
      });
  }
);

/*router.get('/teams/analytic/', xAccessToken.token,async function(req,res,next){
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    var business = req.headers['business'];
    
    var managements = [];
    var paid_total = 0;
    var labour_cost = 0;
    var part_cost = 0;
    var date =  new Date();
    if(req.query.type=="range")
    {
        if(req.query.query)
        { 
            var query = req.query.query;
            var ret = query.split("to");

            var from = new Date(ret[0]);
            var to = new Date(ret[1]);
        }
        else{
            var from = new Date(date.getFullYear(), date.getMonth(), 1);
            var to = new Date(date.getFullYear(), date.getMonth(),  date.getDate()+1);
        }
    }

    else if(req.query.type=="period")
    {
        if(parseInt(req.query.query)==0)
        {
            var query = parseInt(req.query.query);
            var from = new Date(date.getFullYear(), date.getMonth(), date.getDate());
            var to = new Date(date.getFullYear(), date.getMonth(),  date.getDate()+1);
        }
        else if(parseInt(req.query.query)>=1)
        {
            var query = parseInt(req.query.query);
            var from = new Date(date.getFullYear(), date.getMonth(), date.getDate()-query);
            var to = new Date(date.getFullYear(), date.getMonth(),  date.getDate());
        }
        else
        {
            var query = 7;
            var from = new Date(date.getFullYear(), date.getMonth(), date.getDate()-query);
            var to = new Date(date.getFullYear(), date.getMonth(),  date.getDate()+1);
        }
    }
    else{
        var from = new Date(date.getFullYear(), date.getMonth(), date.getDate());
        var to = new Date(date.getFullYear(), date.getMonth(),  date.getDate()+1);
    }

    await Management.find({business: business, role: "Service Advisor"})
    .populate({path: 'user', select:'_id id name contact_no avatar avatar_address email'})
    .cursor().eachAsync(async(management)=>{
        var analytics = [];
        var totalBooking = await Booking.find({advisor:management.user._id, is_services: true, status:{$ne : "Inactive"}, updated_at:{$gte: from, $lte: to}}).count().exec();

        analytics.push({
            title: "Total",
            count: totalBooking
        });

        var totalUpcoming = await Booking.find({advisor:management.user._id, is_services: true, status:{$in :["Confirmed","Pending"]} }).count().exec();

        analytics.push({
            title: "Upcoming",
            count: totalUpcoming
        });

        var totalEstimated = await Booking.find({advisor:management.user._id, is_services: true, status:{$in :["EstimateRequested"]} }).count().exec();

        analytics.push({
            title: "Estimated",
            count: totalEstimated
        });

        var inProcess = await Booking.find({advisor:management.user._id, is_services: true, status:{$in :["JobOpen","In-Process","QC","StoreApproval"]},}).count().exec();

        analytics.push({
            title: "In Process",
            count: inProcess
        });  
    

        var completed = await Booking.find({advisor:management.user._id, is_services: true, status:{$in :["Closed","Completed","Ready"]}, updated_at:{$gte: from, $lte: to}}).count().exec();

        analytics.push({
            title: "Completed",
            count: completed
        });  
      
        
        var rework = await Booking.find({advisor:management.user._id, is_services: true, is_rework: true}).count().exec();
        analytics.push({
            title: "Rework",
            count: rework
        });  

        managements.push({
            id : management.user._id,
            role : management.role,
            department : management.department,
            name : management.user.name,
            username : management.user.username,
            email : management.user.email,
            contact_no : management.user.contact_no,
            avatar : management.user.avatar,
            avatar_address: management.user.avatar_address,
            analytics: analytics
        });                                                                                         
        
    });

    await Management.find({business: business,role: "CRE"})
    .populate({path: 'user', select:'_id id name contact_no avatar avatar_address email'})
    .cursor().eachAsync(async(management)=>{
        
        var analytics =[];
        var leads =[];

        var totalLeads = await Lead.find({assignee:management.user._id, "remark.status": { $in : ["Open","Follow-Up","PSF","Closed","Lost"]}, updated_at:{$gte: from, $lte: to}}).count().exec();

        var excludeLeads = await Lead.find({psf: false, converted: false,"remark.status": "Closed", assignee:management.user._id, created_at:{$gte: from, $lte: to}}).count().exec();

        var c = await Lead.find({assignee:management.user._id, converted: true, updated_at:{$gte: from, $lte: to}}).exec();

        var id = _.map(c, '_id');

        var converted = await Booking.find({lead : {$in: id}, status: {$nin: ["Rejected","Cancelled","Inactive","EstimateRequested"]},updated_at:{$gte: from, $lte: to }}).count();

        var calc = totalLeads-excludeLeads;

        var conversion = 0;
        conversion = (converted/calc)*100;

        if(conversion)
        {
            conversion = parseFloat(conversion.toFixed(2))
        }

        analytics.push({
            title: "Total Leads",
            count: totalLeads
        });

        analytics.push({
            title: "Converted",
            count: converted
        });

        analytics.push({
            title: "Conversion",
            count: conversion
        });


        var open = await Lead.find({assignee:management.user._id, "remark.status": "Open"}).count().exec();
        analytics.push({
            title: "Open",
            count: open
        });

        var follow_up = await Lead.find({assignee:management.user._id, "remark.status": "Follow-Up", updated_at:{$gte: from, $lte: to}}).count().exec();
        analytics.push({
            title: "Follow Up",
            count: follow_up
        });

        var pipeline = await Booking.find({manager:management.user._id, converted:true, status: {$nin: ["Completed","CompleteWork","QC","Closed","Ready","Rejected","Cancelled","Inactive"]}, updated_at:{$gte: from, $lte: to} }).count().exec();

        
        var totalPSFLeads = await Lead.find({assignee:management.user._id, "remark.status": "PSF", updated_at:{$gte: from, $lte: to}}).count().exec();

        analytics.push({
            title: "PSF",
            count: totalPSFLeads
        });
        
        var totalClosedLeads = await Lead.find({assignee:management.user._id, "remark.status": "Closed", updated_at:{$gte: from, $lte: to}}).count().exec();

        analytics.push({
            title: "Closed",
            count: totalClosedLeads
        });

        var totalLostLeads = await Lead.find({assignee:management.user._id, "remark.status": "Lost", updated_at:{$gte: from, $lte: to}}).count().exec();
        analytics.push({
            title: "Lost",
            count: totalLostLeads
        });

        analytics.push({
            title: "Estimate",
            count: pipeline
        });

        managements.push({
            id : management.user._id,
            name : management.user.name,
            role : "CRE",
            department : management.department,
            username : management.user.username,
            email : management.user.email,
            contact_no : management.user.contact_no,
            avatar : management.user.avatar,
            avatar_address: management.user.avatar_address,
            analytics: analytics
        });                                                                                         
    });

    res.status(200).json({
        responseCode:200,
        responseMessage: from+" "+to,
        responseData: managements
    });
});
*/

router.get(
  "/teams/analytic/",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    var business = req.headers["business"];

    var managements = [];
    var paid_total = 0;
    var labour_cost = 0;
    var part_cost = 0;
    var date = new Date();
    if (req.query.type == "range") {
      if (req.query.query) {
        var query = req.query.query;
        var ret = query.split("to");

        var from = new Date(ret[0]);
        var to = new Date(ret[1]);
      } else {
        var from = new Date(date.getFullYear(), date.getMonth(), 1);
        var to = new Date(
          date.getFullYear(),
          date.getMonth(),
          date.getDate() + 1
        );
      }
    } else if (req.query.type == "period") {
      if (parseInt(req.query.query) == 0) {
        var query = parseInt(req.query.query);
        var from = new Date(
          date.getFullYear(),
          date.getMonth(),
          date.getDate()
        );
        var to = new Date(
          date.getFullYear(),
          date.getMonth(),
          date.getDate() + 1
        );
      } else if (parseInt(req.query.query) >= 1) {
        var query = parseInt(req.query.query);
        var from = new Date(
          date.getFullYear(),
          date.getMonth(),
          date.getDate() - query
        );
        var to = new Date(date.getFullYear(), date.getMonth(), date.getDate());
      } else {
        var query = 7;
        var from = new Date(
          date.getFullYear(),
          date.getMonth(),
          date.getDate() - query
        );
        var to = new Date(
          date.getFullYear(),
          date.getMonth(),
          date.getDate() + 1
        );
      }
    } else {
      var from = new Date(date.getFullYear(), date.getMonth(), date.getDate());
      var to = new Date(
        date.getFullYear(),
        date.getMonth(),
        date.getDate() + 1
      );
    }

    await Management.find({
      business: business,
      role: "Service Advisor" /* department: req.query.department*/,
    })
      .populate({
        path: "user",
        select: "_id id name contact_no avatar avatar_address email",
      })
      .cursor()
      .eachAsync(async (management) => {
        var analytics = [];

        var totalBooking = await Booking.find({
          advisor: management.user._id,
          is_services: true,
          status: { $ne: "Inactive" },
          updated_at: { $gte: from, $lte: to },
        })
          .populate({ path: "user", select: "name" })
          .populate({ path: "car", select: "title registration_no" })
          .exec();

        analytics.push({
          title: "Total",
          count: totalBooking.length,
          data: totalBooking,
        });

        var totalUpcoming = await Booking.find({
          advisor: management.user._id,
          is_services: true,
          status: { $in: ["Confirmed", "Pending"] },
        })
          .populate({ path: "user", select: "name" })
          .populate({ path: "car", select: "title registration_no" })
          .exec();

        analytics.push({
          title: "Upcoming",
          count: totalUpcoming.length,
          data: totalUpcoming,
        });

        var totalEstimated = await Booking.find({
          advisor: management.user._id,
          is_services: true,
          status: { $in: ["EstimateRequested"] },
        })
          .populate({ path: "user", select: "name" })
          .populate({ path: "car", select: "title registration_no" })
          .exec();

        analytics.push({
          title: "Estimated",
          count: totalEstimated.length,
          data: totalEstimated,
        });

        var inProcess = await Booking.find({
          advisor: management.user._id,
          is_services: true,
          status: {
            $in: ["JobOpen", "In-Process", "QC", "StoreApproval"],
          } /* created_at:{$gte: from, $lte: to}*/,
        })
          .populate({ path: "user", select: "name" })
          .populate({ path: "car", select: "title registration_no" })
          .exec();

        analytics.push({
          title: "In Process",
          count: inProcess.length,
          data: inProcess,
        });

        var completed = await Booking.find({
          advisor: management.user._id,
          is_services: true,
          status: { $in: ["Closed", "Completed", "Ready"] },
          updated_at: { $gte: from, $lte: to },
        })
          .populate({ path: "user", select: "name" })
          .populate({ path: "car", select: "title registration_no" })
          .exec();

        analytics.push({
          title: "Completed",
          count: completed.length,
          data: completed,
        });

        var rework = await Booking.find({
          advisor: management.user._id,
          is_services: true,
          is_rework: true,
        })
          .populate({ path: "user", select: "name" })
          .populate({ path: "car", select: "title registration_no" })
          .exec();
        analytics.push({
          title: "Rework",
          count: rework.length,
          data: rework,
        });

        managements.push({
          id: management.user._id,
          role: management.role,
          department: management.department,
          name: management.user.name,
          username: management.user.username,
          email: management.user.email,
          contact_no: management.user.contact_no,
          avatar: management.user.avatar,
          avatar_address: management.user.avatar_address,
          analytics: analytics,
        });
      });

    await Management.find({
      business: business,
      role: "CRE" /* department: req.query.department*/,
    })
      .populate({
        path: "user",
        select: "_id id name contact_no avatar avatar_address email",
      })
      .cursor()
      .eachAsync(async (management) => {
        var analytics = [];
        var leads = [];

        var totalLeads = await Lead.find({
          assignee: management.user._id,
          "remark.status": {
            $in: ["Open", "Follow-Up", "PSF", "Closed", "Lost"],
          },
          updated_at: { $gte: from, $lte: to },
        }).exec();

        var excludeLeads = await Lead.find({
          psf: false,
          converted: false,
          "remark.status": "Closed",
          assignee: management.user._id,
          created_at: { $gte: from, $lte: to },
        }).exec();

        var c = await Lead.find({
          assignee: management.user._id,
          converted: true,
          updated_at: { $gte: from, $lte: to },
        }).exec();

        var id = _.map(c, "_id");

        var converted = await Booking.find({
          lead: { $in: id },
          status: {
            $nin: ["Rejected", "Cancelled", "Inactive", "EstimateRequested"],
          },
          updated_at: { $gte: from, $lte: to },
        })
          .populate({ path: "user", select: "name" })
          .populate({ path: "car", select: "title registration_no" })
          .exec();

        var calc = totalLeads.length - excludeLeads.length;

        var conversion = 0;
        conversion = (converted.length / calc) * 100;

        if (conversion) {
          conversion = parseFloat(conversion.toFixed(2));
        }

        analytics.push({
          title: "Total Leads",
          count: totalLeads.length,
          data: totalLeads,
        });

        analytics.push({
          title: "Converted",
          count: converted.length,
          data: converted,
        });

        analytics.push({
          title: "Conversion",
          count: conversion,
          data: {},
        });

        var open = await Lead.find({
          assignee: management.user._id,
          "remark.status": "Open",
        }).exec();
        analytics.push({
          title: "Open",
          count: open.length,
          data: open,
        });

        var follow_up = await Lead.find({
          assignee: management.user._id,
          "remark.status": "Follow-Up",
          updated_at: { $gte: from, $lte: to },
        }).exec();
        analytics.push({
          title: "Follow Up",
          count: follow_up.length,
          data: follow_up,
        });

        var pipeline = await Booking.find({
          manager: management.user._id,
          converted: true,
          status: {
            $nin: [
              "Completed",
              "CompleteWork",
              "QC",
              "Closed",
              "Ready",
              "Rejected",
              "Cancelled",
              "Inactive",
            ],
          },
          updated_at: { $gte: from, $lte: to },
        })
          .populate({ path: "user", select: "name" })
          .populate({ path: "car", select: "title registration_no" })
          .exec();

        var totalPSFLeads = await Lead.find({
          assignee: management.user._id,
          "remark.status": "PSF",
          updated_at: { $gte: from, $lte: to },
        }).exec();

        analytics.push({
          title: "PSF",
          count: totalPSFLeads.length,
          data: totalPSFLeads,
        });

        var totalClosedLeads = await Lead.find({
          assignee: management.user._id,
          "remark.status": "Closed",
          updated_at: { $gte: from, $lte: to },
        }).exec();

        analytics.push({
          title: "Closed",
          count: totalClosedLeads.length,
          data: totalClosedLeads,
        });

        var totalLostLeads = await Lead.find({
          assignee: management.user._id,
          "remark.status": "Lost",
          updated_at: { $gte: from, $lte: to },
        }).exec();
        analytics.push({
          title: "Lost",
          count: totalLostLeads.length,
          data: totalLostLeads,
        });

        analytics.push({
          title: "Estimate",
          count: pipeline.length,
          data: pipeline,
        });

        managements.push({
          id: management.user._id,
          name: management.user.name,
          role: "CRE",
          department: management.department,
          username: management.user.username,
          email: management.user.email,
          contact_no: management.user.contact_no,
          avatar: management.user.avatar,
          avatar_address: management.user.avatar_address,
          analytics: analytics,
        });
      });

    res.status(200).json({
      responseCode: 200,
      responseMessage: from + " " + to,
      responseData: managements,
    });
  }
);

router.get(
  "/packages/get",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;

    var packages = [];

    if (req.query.page == undefined) {
      var page = 0;
    } else {
      var page = req.query.page;
    }

    var page = Math.max(0, parseInt(page));

    await UserPackage.find({})
      .populate({
        path: "user",
        select: "_id id name contact_no avatar avatar_address email",
      })
      .populate({ path: "car", select: "_id id title registration_no" })
      .sort({ created_at: -1 })
      .skip(config.perPage * page)
      .limit(config.perPage)
      .cursor()
      .eachAsync(async (package) => {
        var discounts = [];
        package.discount.forEach(async function (discount) {
          var remain = 0;

          if (discount.discount != 0) {
            if (discount.for == "specific") {
              var label = discount.label;
              var usedPackage = await PackageUsed.findOne({
                package: package._id,
                user: user,
                label: discount.label,
              })
                .count()
                .exec();
              remains = discount.limit - usedPackage;
            } else {
              var bookingCategory = await BookingCategory.findOne({
                tag: discount.label,
              }).exec();
              var label = bookingCategory.title;
            }

            discounts.push({
              _id: discount._id,
              for: discount.for,
              label: label,
              discount: discount.discount,
              type: discount.type,
              limit: discount.limit,
              remains: remains,
            });
          }
        });

        packages.push({
          user: package.user,
          name: package.name,
          _id: package._id,
          id: package._id,
          description: package.description,
          discount: discounts,
          car: package.car,
          payment: package.payment,
          created_at: moment(package.created_at)
            .tz(req.headers["tz"])
            .format("lll"),
          expired_at: moment(package.expired_at)
            .tz(req.headers["tz"])
            .format("lll"),
        });
      });

    res.status(200).json({
      responseCode: 200,
      responseMessage: "Packages",
      responseData: packages,
    });
  }
);

router.post(
  "/gallery/image/add",
  xAccessToken.token,
  function (req, res, next) {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    var upload = multer({
      storage: multerS3({
        s3: s3,
        bucket: config.BUCKET_NAME + "/gallery",
        acl: "public-read",
        contentType: multerS3.AUTO_CONTENT_TYPE,
        // contentDisposition: 'attachment',
        key: function (req, file, cb) {
          let extArray = file.mimetype.split("/");
          let extension = extArray[extArray.length - 1];

          var filename = uuidv1() + "." + extension;
          if (
            extension == "png" ||
            extension == "jpg" ||
            extension == "jpeg" ||
            extension == "gif"
          ) {
            cb(null, filename);
          } else {
            var params = {
              Bucket: config.BUCKET_NAME + "/gallery",
              Key: filename,
            };
            s3.deleteObject(params, async function (err, data) {
              var json = {
                responseCode: 422,
                responseMessage: "Invalid extension",
                responseData: {},
              };
              res.status(422).json(json);
            });
          }
        },
      }),
    }).array("media", 1);

    upload(req, res, async function (error) {
      if (error) {
        var json = {
          responseCode: 400,
          responseMessage: "Error occured",
          responseData: {},
        };
        res.status(400).json(json);
      }

      if (req.files.length == 0) {
        var json = {
          responseCode: 400,
          responseMessage: "Media is required",
          responseData: {},
        };
        res.status(400).json(json);
      } else {
        var rules = {
          source: "required",
        };

        var validation = new Validator(req.body, rules);

        if (validation.fails()) {
          res.status(422).json({
            responseCode: 422,
            responseMessage: "Error",
            responseData: {
              res: validation.errors.all(),
            },
          });
        } else {
          if (req.body.category == "service") {
            var check = await Service.findById(req.body.source).exec();
          } else if (req.body.category == "collision") {
            var check = await Collision.findById(req.body.source).exec();
          } else if (req.body.category == "washing") {
            var check = await Washing.findById(req.body.source).exec();
          } else if (req.body.category == "product") {
            var check = await Product.findById(req.body.source).exec();
          } else if (req.body.category == "customization") {
            var check = await Customization.findById(req.body.source).exec();
          } else {
            var check = {};
          }

          if (check) {
            var data = {
              source: req.body.source,
              file: req.files[0].key,
              type: req.body.type,
              category: req.body.category,
              created_at: new Date(),
              updated_at: new Date(),
            };

            var galleryImage = new Gallery(data);
            galleryImage.save();

            res.status(200).json({
              responseCode: 200,
              responseMessage: "File has been uploaded",
              responseData: {
                item: galleryImage,
              },
            });
          } else {
            res.status(400).json({
              responseCode: 400,
              responseMessage: "Source not found",
              responseData: {},
            });
          }
        }
      }
    });
  }
);

router.delete(
  "/gallery/image/delete",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      id: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Error",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);

      var image_id = req.body.id;
      const media = await Gallery.findById(image_id).exec();

      if (media) {
        var params = {
          Bucket: config.BUCKET_NAME + "/gallery",
          Key: media.file,
        };
        s3.deleteObject(params, async function (err, data) {
          if (err) {
            res.status(400).json({
              responseCode: 400,
              responseMessage: "Error occured",
              responseData: {},
            });
          } else {
            var deleteImage = Gallery.findByIdAndRemove(image_id).exec();
            if (deleteImage) {
              res.status(200).json({
                responseCode: 200,
                responseMessage: "File has been deleted",
                responseData: {},
              });
            } else {
              res.status(400).json({
                responseCode: 400,
                responseMessage: "Error occured",
                responseData: {},
              });
            }
          }
        });
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Wrong image",
          responseData: {},
        });
      }
    }
  }
);

router.get(
  "/users/list/get",
  xAccessToken.token,
  async function (req, res, next) {
    var carsFilter = [];
    var segment = [];
    var filterBy = [];
    var booking = [];

    if (req.query.page == undefined) {
      var page = 0;
    } else {
      var page = req.query.page;
    }
    var page = Math.max(0, parseInt(page));
    var peoples = [];
    var date = new Date();
    if (req.query.type == "range") {
      if (req.query.query) {
        var query = req.query.query;
        var ret = query.split("to");

        var from = new Date(ret[0]);
        var to = new Date(ret[1]);
      } else {
        var from = new Date(date.getFullYear(), date.getMonth(), 1);
        var to = new Date(
          date.getFullYear(),
          date.getMonth(),
          date.getDate() + 1
        );
      }
    } else if (req.query.type == "period") {
      if (req.query.query) {
        var query = parseInt(req.query.query);
      } else {
        var query = 7;
      }

      var from = new Date(
        date.getFullYear(),
        date.getMonth(),
        date.getDate() - query
      );
      var to = new Date(
        date.getFullYear(),
        date.getMonth(),
        date.getDate() + 1
      );
    } else {
      var from = new Date(
        date.getFullYear(),
        date.getMonth(),
        date.getDate() - 365
      );
      var to = new Date(
        date.getFullYear(),
        date.getMonth(),
        date.getDate() + 1
      );
    }

    filterBy["created_at"] = { $gte: from, $lte: to };

    if (req.query.segment) {
      var segment = req.query.segment;
      carsFilter["segment"] = { $in: segment.split(",") };
    }

    if (req.query.automaker) {
      var automaker = req.query.automaker;
      carsFilter["automaker"] = { $in: automaker.split(",") };
    }

    await User.find({
      "account_info.type": "user",
      created_at: { $gte: from, $lte: to },
    })
      .select(
        "name username email avatar avatar_address contact_no account_info created_at updated_at"
      )
      .sort({ created_at: -1 })
      .skip(100 * page)
      .limit(100)
      .cursor()
      .eachAsync(async (user) => {
        var booking_date = "";
        var last_booking = await Booking.findOne({
          user: user._id,
          status: { $ne: "Inactive" },
        })
          .sort({ created_at: -1 })
          .exec();
        if (last_booking) {
          booking_date = moment(last_booking.created_at)
            .tz(req.headers["tz"])
            .format("ll");
        }

        var feedback = null;

        var lead = await Lead.findOne({ user: user._id /*,type: "Feedback"*/ })
          .sort({ created_at: -1 })
          .exec();
        if (lead) {
          var assignee = await User.findById(lead.assignee).exec();

          if (assignee) {
            var a = {
              name: assignee.name,
              email: assignee.email,
              contact_no: assignee.contact_no,
              _id: assignee._id,
              _id: assignee._id,
            };
          } else {
            var a = null;
          }

          if (lead.follow_up == null) {
            var follow_up = {};
          } else {
            follow_up = lead.follow_up;
          }

          var l = lead.remark;

          if (l) {
            if (l.assignee_remark == "") {
              l.assignee_remark = l.customer_remark;
            }
            var remark = {
              source: l.source,
              type: l.type,
              status: l.status,
              customer_remark: l.customer_remark,
              assignee_remark: l.assignee_remark,
              assignee: a,
              color_code: l.color_code,
              created_at: moment(l.created_at)
                .tz(req.headers["tz"])
                .format("lll"),
              updated_at: moment(l.updated_at)
                .tz(req.headers["tz"])
                .format("lll"),
            };
          }

          feedback = {
            user: lead.user,
            name: lead.name,
            contact_no: lead.contact_no,
            email: lead.email,
            _id: lead._id,
            id: lead.id,
            priority: lead.priority,
            contacted: lead.contacted,
            type: lead.type,
            lead_id: lead.lead_id,
            geometry: lead.geometry,
            date: moment(lead.updated_at).tz(req.headers["tz"]).format("lll"),
            status: lead.status,
            source: lead.source,
            important: lead.important,
            follow_up: follow_up,
            remark: remark,
            assignee: a,
            created_at: moment(lead.created_at)
              .tz(req.headers["tz"])
              .format("lll"),
            updated_at: moment(lead.updated_at)
              .tz(req.headers["tz"])
              .format("lll"),
          };
        }

        var cars = [];
        var segment = [];

        peoples.push({
          _id: user._id,
          id: user._id,
          name: user.name,
          username: user.username,
          email: user.email,
          contact_no: user.contact_no,
          avatar_address:
            "https://s3.ap-south-1.amazonaws.com/" +
            config.BUCKET_NAME +
            "/avatar/" +
            user.avatar,
          account_info: user.account_info,
          created_at: user.created_at,
          updated_at: user.updated_at,
          last_booking: booking_date,
          feedback: feedback,
          agent: user.agent,
          joined: moment(user.updated_at).tz(req.headers["tz"]).format("ll"),
        });
      });

    res.status(200).json({
      responseCode: 200,
      responseMessage: "Success",
      responseData: peoples,
      responseInfo: {
        totalResult: await User.find({
          "account_info.type": "user",
          created_at: { $gte: from, $lte: to },
        })
          .count()
          .exec(),
      },
    });
  }
);

router.get("/users/get", async function (req, res, next) {
  var rules = {
    query: "required",
  };

  var validation = new Validator(req.query, rules);

  if (validation.fails()) {
    res.status(422).json({
      responseCode: 422,
      responseMessage: "Error",
      responseData: {
        res: validation.errors.all(),
      },
    });
  } else {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var data = [];
    // , business: business
    await User.find({ contact_no: req.query.query })
      .cursor()
      .eachAsync(async (user) => {
        var bookings = [];
        await Booking.find({
          status: {
            $in: [
              "Approved",
              "Confirmed",
              "Pending",
              "Approval",
              "Failure",
              "Failed",
              "EstimateRequested",
            ],
          },
          is_services: true,
          user: user._id,
        })
          .populate({
            path: "user",
            populate: {
              path: "user",
              select: "_id id name contact_no email address",
            },
          })
          .populate({
            path: "manager",
            populate: { path: "user", select: "_id id name contact_no" },
          })
          .populate({
            path: "car",
            select: "_id id title registration_no ic rc",
            populate: { path: "thumbnails" },
          })
          .cursor()
          .eachAsync(async (booking) => {
            var address = await Address.findOne({
              _id: booking.address,
            }).exec();
            if (booking.car) {
              if (booking.car.thumbnails[0]) {
                var thumbnail = [booking.car.thumbnails[0]];
              } else {
                var thumbnail = [];
              }

              var car = {
                title: booking.car.title,
                _id: booking.car._id,
                id: booking.car.id,
                rc_address: booking.car.rc_address,
                ic_address: booking.car.ic_address,
                ic: booking.car.ic,
                rc: booking.car.rc,
                registration_no: booking.car.registration_no,
              };
            } else {
              var car = null;
            }

            var manager = null;
            if (booking.manager) {
              manager = {
                name: booking.manager.name,
                _id: booking.manager._id,
                id: booking.manager.id,
                contact_no: booking.manager.contact_no,
                email: booking.manager.email,
              };
            }

            bookings.push({
              _id: booking._id,
              id: booking._id,
              car: car,
              user: {
                name: booking.user.name,
                _id: booking.user._id,
                id: booking.user.id,
                contact_no: booking.user.contact_no,
              },
              manager: manager,
              services: booking.services,
              convenience: booking.convenience,
              date: moment(booking.date).tz(req.headers["tz"]).format("ll"),
              time_slot: booking.time_slot,
              status: _.startCase(booking.status),
              booking_no: booking.booking_no,
              address: address,
              payment: booking.payment,
              customer_requirements: booking.customer_requirements,
              estimation_requested: booking.estimation_requested,
              txnid: booking.txnid,
              __v: booking.__v,
              created_at: booking.created_at,
              updated_at: booking.updated_at,
            });
          });

        data.push({
          _id: user._id,
          id: user.id,
          name: user.name,
          username: user.username,
          email: user.email,
          contact_no: user.contact_no,
          avatar_address: user.avatar_address,
          avatar: user.avatar,
          address: user.address,
          account_info: user.account_info,
          bookings: bookings,
        });
      });

    if (data.length > 0) {
      res.status(200).json({
        responseCode: 200,
        responseMessage: "success",
        responseData: data,
      });
    } else {
      res.status(200).json({
        responseCode: 200,
        responseMessage: data.length,
        responseData: [],
      });
    }
  }
});

router.post(
  "/products/offers/add",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var business = req.headers["business"];

    req.body.valid_till = new Date(req.body.valid_till).toISOString();
    req.body.business = business._id;
    req.body.isCarEager = business.isCarEager;
    req.body.created_at = new Date();
    req.body.updated_at = new Date();

    ProductOffer.create(req.body).then(function (offer) {
      res.status(200).json({
        responseCode: 200,
        responseMessage: "Offer has been added",
        responseData: {
          item: offer,
        },
      });
    });
  }
);

router.get("/booking/taxes/get", async function (req, res, next) {
  var tz = req.headers["tz"];
  if (tz) {
    var booking = await Booking.findById(req.query.booking).exec();
    if (booking) {
      var country = await Country.findOne({ timezone: { $in: tz } }).exec();
      if (country) {
        res.status(200).json({
          responseCode: 200,
          responseMessage: "Tax Slabs",
          responseData: await Tax.find({ country: country._id }).exec(),
        });
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Tax Slabs",
          responseData: {},
        });
      }
    }
  } else {
    res.status(400).json({
      responseCode: 400,
      responseMessage: "Tax Slabs",
      responseData: {},
    });
  }
});

router.post(
  "/owner/car/add",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var business = req.headers["business"];
    var loggedInDetails = await User.findById(decoded.user).exec();
    var currentDate = new Date();
    var booking = null;
    var user = await User.findOne({ _id: req.body.user }).exec();
    var advisor = await q.all(getAdvisor(loggedInDetails._id, business));
    if (user) {
      var customer_requirements = [];
      if (req.body.requirement) {
        customer_requirements.push({
          user: user,
          requirement: req.body.requirement,
        });
      }

      var expire = "";
      if (req.body.expire) {
        expire = new Date(req.body.expire).toISOString();
      }
      var insurance_info = {
        policy_holder: req.body.policy_holder,
        insurance_company: req.body.insurance_company,
        policy_no: req.body.policy_no,
        premium: req.body.premium,
        expire: expire,
        branch: "",
        gstin: "",
        claim: false,
        cashless: false,
        accident_place: "",
        accident_date: null,
        accident_time: "",
        accident_cause: "",
        driver_accident: "",
        spot_survey: "",
        fir: "",
        policy_type: "",
        claim_no: "",
      };

      var rg = req.body.registration_no;
      req.body.registration_no = rg.replace(/ /g, "");

      var checkCar = await Car.findOne({
        registration_no: req.body.registration_no,
        status: true,
      })
        .populate({
          path: "user",
          select: "name username avatar avatar_address account_info",
        })
        .exec();

      if (checkCar) {
        Car.findOneAndUpdate(
          {
            _id: checkCar._id,
          },
          {
            $set: {
              odometer: req.body.odometer,
              fuel_level: req.body.fuel_level,
              vin: req.body.vin,
              engine_no: req.body.engine_no,
              insurance_info: insurance_info,
            },
          },
          {
            new: false,
          },
          function (err, doc) {}
        );

        var checkBooking = await Booking.findOne({
          car: checkCar._id,
          status: {
            $nin: [
              "Completed",
              "CompleteWork",
              "QC",
              "Closed",
              "Ready",
              "Rejected",
              "Cancelled",
              "Inactive",
            ],
          },
        }).exec();

        if (checkBooking) {
          res.status(422).json({
            responseCode: 422,
            responseMessage:
              "This job already exists in " + checkBooking.status,
            responseData: {},
          });
        } else {
          var payment = {
            payment_mode: "",
            payment_status: "Pending",
            discount_type: "",
            coupon: "",
            coupon_type: "",
            discount: 0,
            discount_total: 0,
            part_cost: 0,
            labour_cost: 0,
            paid_total: 0,
            total: 0,
            discount_applied: false,
            transaction_id: "",
            transaction_date: "",
            transaction_status: "",
            transaction_response: "",
          };

          var bookingData = {
            package: null,
            car: checkCar._id,
            advisor: advisor,
            manager: null,
            business: business,
            user: user._id,
            odometer: req.body.odometer,
            fuel_level: req.body.fuel_level,
            services: [],
            job_no: new Date().valueOf(),
            customer_requirements: customer_requirements,
            booking_no:
              Math.round(+new Date() / 1000) +
              Math.round(Math.random() * 9999 + 1),
            date: new Date(),
            time_slot: "",
            convenience: "",
            status: "JobInitiated",
            sub_status: "JobInitiated",
            estimation_requested: false,
            insurance_info: insurance_info,
            payment: payment,
            lead: null,
            is_services: true,
            started_at: new Date(),
            created_at: new Date(),
            updated_at: new Date(),
          };

          Booking.create(bookingData).then(async function (b) {
            var activity = {
              user: loggedInDetails._id,
              name: loggedInDetails.name,
              stage: "NewJob",
              activity: "JobInititated",
            };

            fun.bookingLog(b._id, activity);

            var notify = {
              receiver: [b.user],
              activity: "jobcard",
              tag: "JobInititated",
              source: b._id,
              sender: b.business,
              points: 0,
            };

            fun.newNotification(notify);
            event.jobSms(notify);

            event.zohoLead(b._id);
            //console.log("sumit.jobP1")
            whatsAppEvent.jobInit(b);

            res.status(200).json({
              responseCode: 200,
              responseMessage: "Car has been added",
              responseData: {
                car: checkCar._id,
                user: user._id,
                booking: b._id,
              },
            });
          });
        }
      } else {
        if (req.body.variant == "" || req.body.variant == null) {
          return res.status(422).json({
            responseCode: 422,
            responseMessage: "Car not found. Please select a car.",
            responseData: {},
          });
        } else {
          var variant = await Variant.findOne({ _id: req.body.variant })
            .populate("model")
            .select("-service_schedule")
            .exec();
          if (variant) {
            var rg = req.body.registration_no;
            req.body.registration_no = rg.replace(/ /g, "");
            var reg = await Car.find({
              registration_no: req.body.registration_no,
              status: true,
            })
              .count()
              .exec();
            if (reg == 0) {
              var carData = {};
              var automaker = await Automaker.findById(
                variant.model.automaker
              ).exec();
              var rg = req.body.registration_no;
              carData.reg_no_copy = rg.replace(/\s/g, "");
              carData.geometry = [0, 0];
              carData.created_at = currentDate;
              carData.updated_at = currentDate;
              carData.variant = variant._id;
              carData._variant = variant.value;
              carData.title = variant.variant;
              carData.automaker = variant.model.automaker;
              carData._automaker = automaker._maker;
              carData.model = variant.model._id;
              carData._model = variant.model.value;
              carData.segment = variant.model.segment;
              carData.user = user._id;
              carData.registration_no = req.body.registration_no;
              carData.fuel_type = variant.specification.fuel_type;
              carData.transmission = variant.specification.type;
              carData.odometer = req.body.odometer;
              carData.fuel_level = req.body.fuel_level;
              carData.vin = req.body.vin;
              carData.engine_no = req.body.engine_no;
              carData.insurance_info = insurance_info;
              carData.carId =
                Math.round(+new Date() / 1000) +
                Math.round(Math.random() * 9999 + 1);

              Car.create(carData).then(async function (car) {
                User.findOneAndUpdate(
                  { _id: user._id },
                  {
                    $push: {
                      cars: car._id,
                    },
                  },
                  { new: true },
                  async function (err, doc) {
                    if (err) {
                      res.status(400).json({
                        responseCode: 400,
                        responseMessage: "Error Occurred",
                        responseData: err,
                      });
                    } else {
                      fun.addMember(user._id, variant.model);

                      var payment = {
                        payment_mode: "",
                        payment_status: "Pending",
                        discount_type: "",
                        coupon: "",
                        coupon_type: "",
                        discount: 0,
                        discount_total: 0,
                        part_cost: 0,
                        labour_cost: 0,
                        paid_total: 0,
                        total: 0,
                        discount_applied: false,
                        transaction_id: "",
                        transaction_date: "",
                        transaction_status: "",
                        transaction_response: "",
                      };

                      var bookingData = {
                        package: null,
                        car: car._id,
                        advisor: advisor,
                        manager: null,
                        business: business,
                        user: user._id,
                        services: [],
                        job_no: new Date().valueOf(),
                        customer_requirements: customer_requirements,
                        booking_no:
                          Math.round(+new Date() / 1000) +
                          Math.round(Math.random() * 9999 + 1),
                        date: new Date(),
                        time_slot: "",
                        convenience: "",
                        status: "JobInitiated",
                        sub_status: "JobInitiated",
                        odometer: req.body.odometer,
                        fuel_level: req.body.fuel_level,
                        estimation_requested: false,
                        payment: payment,
                        address: req.body.address,
                        lead: null,
                        is_services: true,
                        insurance_info: insurance_info,
                        started_at: new Date(),
                        created_at: new Date(),
                        updated_at: new Date(),
                      };

                      Booking.create(bookingData).then(async function (b) {
                        var activity = {
                          user: loggedInDetails._id,
                          name: loggedInDetails.name,
                          stage: "NewJob",
                          activity: "JobInititated",
                        };

                        fun.bookingLog(b._id, activity);

                        var notify = {
                          receiver: [b.user],
                          activity: "jobcard",
                          tag: "JobInititated",
                          source: b._id,
                          sender: b.business,
                          points: 0,
                        };

                        fun.newNotification(notify);
                        event.jobSms(notify);

                        event.zohoLead(b._id);
                        //sumit
                        //console.log("sumit.jobP2")
                        whatsAppEvent.jobInit(b);

                        res.status(200).json({
                          responseCode: 200,
                          responseMessage: "Car has been added",
                          responseData: {
                            car: car._id,
                            user: user._id,
                            booking: b._id,
                          },
                        });
                      });
                    }
                  }
                );
              });
            } else {
              res.status(422).json({
                responseCode: 422,
                responseMessage: "registration no already exist",
                responseData: {},
              });
            }
          } else {
            res.status(422).json({
              responseCode: 422,
              responseMessage: "Unprocessable Entity",
              responseData: {},
            });
          }
        }
      }
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "User Not Found",
        responseData: {},
      });
    }
  }
);

router.get(
  "/booking/car/get",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      booking: "required",
    };

    var validation = new Validator(req.query, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Booking required",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var user = decoded.user;
      var business = req.headers["business"];
      var currentDate = new Date();
      var car = [];

      var booking = await Booking.findById(req.query.booking).exec();

      if (booking) {
        var doc = await Car.findById(booking.car)
          .populate("bookmark")
          .populate("thumbnails")
          .populate({
            path: "user",
            select: "name username avatar avatar_address address",
          })
          .populate({ path: "variant", populate: { path: "model" } })
          .exec();

        car.push({
          __v: 0,
          _id: doc._id,
          id: doc.id,
          title: doc.title,
          variant: doc.variant._id,
          registration_no: doc.registration_no,
          insurance_info: doc.insurance_info,
          engine_no: doc.engine_no,
          vin: doc.vin,
          premium: doc.premium,
          is_bookmarked: doc.is_bookmarked,
          user: doc.user,
        });

        res.status(200).json({
          responseCode: 200,
          responseMessage: "success",
          responseData: car,
        });
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Booking not found",
          responseData: {},
        });
      }
    }
  }
);

router.get(
  "/booked/services/get",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      booking: "required",
    };

    var validation = new Validator(req.query, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Booking required",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var user = decoded.user;
      var business = req.headers["business"];
      var currentDate = new Date();
      var car = [];

      var booking = await Booking.findById(req.query.booking).exec();

      if (booking) {
        res.status(200).json({
          responseCode: 200,
          responseMessage: "success",
          responseData: booking.services,
        });
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Booking not found",
          responseData: {},
        });
      }
    }
  }
);

router.post(
  "/booking/job/add",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      booking: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Booking required",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var business = req.headers["business"];

      var loggedInDetails = await User.findById(decoded.user).exec();

      var currentDate = new Date();
      var booking = await Booking.findOne({
        _id: req.body.booking,
        business: business,
        status: {
          $nin: [
            "Completed",
            "CompleteWork",
            "QC",
            "Closed",
            "Ready",
            "Inactive",
            "Cancelled",
          ],
        },
      }).exec();

      if (booking) {
        var insurance_company = await InsuranceCompany.findOne({
          company: req.body.insurance_company,
        }).exec();
        if (insurance_company) {
          var expire = "";
          if (req.body.expire) {
            expire = new Date(req.body.expire).toISOString();
          }
          var insurance_info = {
            policy_holder: req.body.policy_holder,
            insurance_company: req.body.insurance_company,
            gstin: insurance_company.gstin,
            policy_no: req.body.policy_no,
            premium: req.body.premium,
            expire: expire,
          };
        } else {
          var insurance_info = {
            policy_holder: "",
            insurance_company: "",
            gstin: "",
            policy_no: "",
            premium: 0,
            expire: null,
          };
        }

        Booking.findOneAndUpdate(
          { _id: booking._id },
          {
            $set: {
              status: "JobInitiated",
              sub_status: "JobInitiated",
              odometer: req.body.odometer,
              fuel_level: req.body.fuel_level,
              insurance_info: insurance_info,
              started_at: new Date(),
              job_no: new Date().valueOf(),
            },
          },
          { new: false },
          async function (err, doc) {
            if (err) {
              res.status(422).json({
                responseCode: 422,
                responseMessage: "Server Error",
                responseData: err,
              });
            } else {
              Car.findOneAndUpdate(
                { _id: booking.car },
                {
                  $set: {
                    odometer: req.body.odometer,
                    fuel_level: req.body.fuel_level,
                    vin: req.body.vin,
                    engine_no: req.body.engine_no,
                    insurance_info: insurance_info,
                  },
                },
                { new: false },
                async function (err, doc) {
                  if (err) {
                    return res.status(422).json({
                      responseCode: 422,
                      responseMessage: "Server Error",
                      responseData: err,
                    });
                  } else {
                    var activity = {
                      user: loggedInDetails._id,
                      name: loggedInDetails.name,
                      stage: "NewJob",
                      activity: "JobInitiated",
                    };

                    fun.bookingLog(booking._id, activity);

                    var notify = {
                      receiver: [booking.user],
                      activity: "jobcard",
                      tag: "JobInititated",
                      source: booking._id,
                      sender: booking.business,
                      points: 0,
                    };

                    fun.newNotification(notify);
                    event.jobSms(notify);
                    event.zohoLead(booking._id);
                    //sumit.
                    // console.log("job p3");
                    whatsAppEvent.jobInit(booking);

                    var updated = await Booking.findById(booking._id).exec();

                    res.status(200).json({
                      responseCode: 200,
                      responseMessage: "Car has been added",
                      responseData: updated,
                    });
                  }
                }
              );
            }
          }
        );
      } else {
        res.status(422).json({
          responseCode: 422,
          responseMessage: "This job already exists " + booking.status,
          responseData: {},
        });
      }
    }
  }
);

router.put(
  "/job/inspection/add",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var loggedInDetails = await User.findById(decoded.user).exec();

    var file_type = "";

    var upload = multer({
      storage: multerS3({
        s3: s3,
        bucket: config.BUCKET_NAME + "/inspection",
        acl: "public-read",
        contentType: multerS3.AUTO_CONTENT_TYPE,
        // contentDisposition: 'attachment',
        key: function (req, file, cb) {
          let extArray = file.mimetype.split("/");
          let extension = extArray[extArray.length - 1];

          var filename = uuidv1() + "." + extension;
          if (
            extension == "png" ||
            extension == "jpg" ||
            extension == "jpeg" ||
            extension == "gif"
          ) {
            cb(null, filename);
          } else {
            var params = {
              Bucket: config.BUCKET_NAME + "/inspection",
              Key: filename,
            };
            s3.deleteObject(params, async function (err, data) {
              var json = {
                responseCode: 422,
                responseMessage: "Invalid extension",
                responseData: {},
              };
              return res.status(422).json(json);
            });
          }
        },
      }),
    }).array("media", 1);

    upload(req, res, async function (error) {
      if (error) {
        var json = {
          responseCode: 400,
          responseMessage: "Error occured",
          responseData: {},
        };
        return res.status(400).json(json);
      }

      if (req.files.length == 0) {
        var json = {
          responseCode: 400,
          responseMessage: "Media is required",
          responseData: {},
        };
        return res.status(400).json(json);
      } else {
        var rules = {
          booking: "required",
        };

        var validation = new Validator(req.body, rules);

        if (validation.fails()) {
          return res.status(422).json({
            responseCode: 422,
            responseMessage: "Error",
            responseData: {
              res: validation.errors.all(),
            },
          });
        } else {
          JobInspection.create({
            booking: req.body.booking,
            index: req.body.index,
            file: req.files[0].key,
            type: file_type,
            stage: "Job",
            created_at: new Date(),
            updated_at: new Date(),
          }).then(async function (jobInspection) {
            var count = await JobInspection.find({ booking: req.body.booking })
              .count()
              .exec();

            if (count >= 13) {
              Booking.findOneAndUpdate(
                { _id: req.body.booking },
                { $set: { sub_status: "Inspection" }, updated_at: new Date() },
                { new: true },
                async function (err, doc) {
                  var activity = {
                    user: loggedInDetails._id,
                    name: loggedInDetails.name,
                    stage: "NewJob",
                    activity: "Inspection",
                  };
                  fun.bookingLog(req.body.booking, activity);
                }
              );
              res.status(200).json({
                responseCode: 200,
                responseMessage: "File has been uploaded",
                responseData: jobInspection,
              });
            } else {
              res.status(200).json({
                responseCode: 200,
                responseMessage: "File has been uploaded",
                responseData: jobInspection,
              });
            }
          });
        }
      }
    });
  }
);

router.put(
  "/quality/inspection/add",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var loggedInDetails = await User.findById(decoded.user).exec();

    var file_type = "";

    var upload = multer({
      storage: multerS3({
        s3: s3,
        bucket: config.BUCKET_NAME + "/inspection",
        acl: "public-read",
        contentType: multerS3.AUTO_CONTENT_TYPE,
        // contentDisposition: 'attachment',
        key: function (req, file, cb) {
          let extArray = file.mimetype.split("/");
          let extension = extArray[extArray.length - 1];

          var filename = uuidv1() + "." + extension;
          if (
            extension == "png" ||
            extension == "jpg" ||
            extension == "jpeg" ||
            extension == "gif"
          ) {
            cb(null, filename);
          } else {
            var params = {
              Bucket: config.BUCKET_NAME + "/inspection",
              Key: filename,
            };
            s3.deleteObject(params, async function (err, data) {
              var json = {
                responseCode: 422,
                responseMessage: "Invalid extension",
                responseData: {},
              };
              res.status(422).json(json);
            });
          }
        },
      }),
    }).array("media", 1);

    upload(req, res, async function (error) {
      if (error) {
        var json = {
          responseCode: 400,
          responseMessage: "Error occured",
          responseData: {},
        };
        res.status(400).json(json);
      }

      if (req.files.length == 0) {
        var json = {
          responseCode: 400,
          responseMessage: "Media is required",
          responseData: {},
        };
        res.status(400).json(json);
      } else {
        var rules = {
          booking: "required",
        };

        var validation = new Validator(req.body, rules);

        if (validation.fails()) {
          res.status(422).json({
            responseCode: 422,
            responseMessage: "Error",
            responseData: {
              res: validation.errors.all(),
            },
          });
        } else {
          var data = {
            booking: req.body.booking,
            index: req.body.index,
            file: req.files[0].key,
            type: file_type,
            stage: "QC",
            created_at: new Date(),
            updated_at: new Date(),
          };

          var jobInspection = new JobInspection(data);
          jobInspection.save();

          res.status(200).json({
            responseCode: 200,
            responseMessage: "File has been uploaded",
            responseData: jobInspection,
          });
        }
      }
    });
  }
);

router.put(
  "/job/snaps/add",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var loggedInDetails = await User.findById(decoded.user).exec();

    var file_type = "";

    var upload = multer({
      storage: multerS3({
        s3: s3,
        bucket: config.BUCKET_NAME + "/inspection",
        acl: "public-read",
        contentType: multerS3.AUTO_CONTENT_TYPE,
        // contentDisposition: 'attachment',
        key: function (req, file, cb) {
          let extArray = file.mimetype.split("/");
          let extension = extArray[extArray.length - 1];

          var filename = uuidv1() + "." + extension;
          if (
            extension == "png" ||
            extension == "jpg" ||
            extension == "jpeg" ||
            extension == "gif"
          ) {
            cb(null, filename);
          } else {
            var params = {
              Bucket: config.BUCKET_NAME + "/inspection",
              Key: filename,
            };
            s3.deleteObject(params, async function (err, data) {
              var json = {
                responseCode: 422,
                responseMessage: "Invalid extension",
                responseData: {},
              };
              res.status(422).json(json);
            });
          }
        },
      }),
    }).array("media", 1);

    upload(req, res, async function (error) {
      if (error) {
        var json = {
          responseCode: 400,
          responseMessage: "Error occured",
          responseData: {},
        };
        res.status(400).json(json);
      }

      if (req.files.length == 0) {
        var json = {
          responseCode: 400,
          responseMessage: "Media is required",
          responseData: {},
        };
        res.status(400).json(json);
      } else {
        var rules = {
          booking: "required",
        };

        var validation = new Validator(req.body, rules);

        if (validation.fails()) {
          res.status(422).json({
            responseCode: 422,
            responseMessage: "Error",
            responseData: {
              res: validation.errors.all(),
            },
          });
        } else {
          var data = {
            booking: req.body.booking,
            index: req.body.index,
            file: req.files[0].key,
            type: file_type,
            stage: "Additional",
            created_at: new Date(),
            updated_at: new Date(),
          };

          var jobInspection = new JobInspection(data);
          jobInspection.save();

          res.status(200).json({
            responseCode: 200,
            responseMessage: "File has been uploaded",
            responseData: jobInspection,
          });
        }
      }
    });
  }
);

router.delete(
  "/job/snaps/delete",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var loggedInDetails = await User.findById(decoded.user).exec();

    var image_id = req.body.id;
    const media = await JobInspection.findById(image_id).exec();

    if (media) {
      var params = {
        Bucket: config.BUCKET_NAME + "/inspection",
        Key: media.file,
      };

      s3.deleteObject(params, async function (err, data) {
        if (err) {
          res.status(400).json({
            responseCode: 400,
            responseMessage: "Error occured",
            responseData: {},
          });
        } else {
          await JobInspection.findByIdAndRemove(image_id).exec();
          res.status(200).json({
            responseCode: 200,
            responseMessage: "File has been deleted",
            responseData: {},
          });
        }
      });
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Wrong image",
        responseData: {},
      });
    }
  }
);

router.get("/assets/get", xAccessToken.token, async function (req, res, next) {
  var rules = {
    booking: "required",
  };

  var validation = new Validator(req.query, rules);

  if (validation.fails()) {
    res.status(422).json({
      responseCode: 422,
      responseMessage: "Booking required",
      responseData: {
        res: validation.errors.all(),
      },
    });
  } else {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var business = req.headers["business"];

    var booking = await Booking.findById(req.query.booking).exec();
    if (booking) {
      var a = booking.assets;
      if (a.length > 0) {
        res.status(200).json({
          responseCode: 200,
          responseMessage: "Asset",
          responseData: booking.assets,
        });
      } else {
        var assets = [];
        await Asset.find({})
          .cursor()
          .eachAsync(async (v) => {
            assets.push({
              value: v.value,
              checked: false,
            });
          });

        res.status(200).json({
          responseCode: 200,
          responseMessage: "Asset",
          responseData: assets,
        });
      }
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Booking not found",
        responseData: {},
      });
    }
  }
});

router.put(
  "/assets/update",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      booking: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Booking required",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var loggedInDetails = await User.findById(decoded.user).exec();
      var business = await User.findById(req.headers["business"]).exec();

      var booking = await Booking.findById(req.body.booking).exec();
      if (booking) {
        var address = await Address.findOne({
          _id: req.body.address,
          user: booking.user,
        }).exec();
        if (address) {
          var status = booking.status;
          var sub_status = "Assets";

          if (req.body.web == true) {
            var status = "JobOpen";
            var sub_status = "JobOpen";
          }

          Booking.findOneAndUpdate(
            { _id: booking._id },
            {
              $set: {
                status: status,
                sub_status: sub_status,
                assets: req.body.assets,
                other_assets: req.body.other,
                convenience: req.body.convenience,
                address: req.body.address,
                updated_at: new Date(),
              },
            },
            { new: false },
            async function (err, doc) {
              if (err) {
                res.status(422).json({
                  responseCode: 422,
                  responseMessage: "Server",
                  responseData: err,
                });
              } else {
                if (req.body.web) {
                  var activity = {
                    user: loggedInDetails._id,
                    name: loggedInDetails.name,
                    stage: "JobOpen",
                    activity: "JobOpen",
                  };
                  fun.bookingLog(req.body.booking, activity);
                }

                var update = await Booking.findById(booking._id).exec();

                res.status(200).json({
                  responseCode: 200,
                  responseMessage: "Asset",
                  responseData: update.assets,
                });
              }
            }
          );
        } else {
          res.status(400).json({
            responseCode: 400,
            responseMessage: "Address not found",
            responseData: {},
          });
        }
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Booking not found",
          responseData: {},
        });
      }
    }
  }
);

router.put(
  "/job/surveyor/update",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      booking: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Booking required",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var business = req.headers["business"];
      var loggedInDetails = await User.findById(decoded.user).exec();
      var booking = await Booking.findById(req.body.booking).exec();
      if (booking) {
        if (req.body.surveyor) {
          var surveyor = await User.findById(req.body.surveyor).exec();
          if (surveyor) {
            User.findOneAndUpdate(
              { _id: surveyor._id },
              { $set: { email: req.body.surveyor_email } },
              { new: false },
              function (err, doc) {}
            );

            Booking.findOneAndUpdate(
              { _id: booking._id },
              { $set: { surveyor: surveyor._id, updated_at: new Date() } },
              { new: false },
              function (err, doc) {
                var activity = {
                  user: loggedInDetails._id,
                  name: loggedInDetails.name,
                  stage: "Estimation",
                  activity: "SurveyorAssigned",
                };

                fun.bookingLog(req.body.booking, activity);

                var notify = {
                  receiver: [booking.user],
                  activity: "jobcard",
                  tag: "SurveyorAssigned",
                  source: booking._id,
                  sender: loggedInDetails._id,
                  points: 0,
                };

                fun.newNotification(notify);
                event.jobSms(notify);

                res.status(200).json({
                  responseCode: 200,
                  responseMessage: "Surveyor details has been updated...",
                  responseData: {},
                });
              }
            );
          } else {
            res.status(400).json({
              responseCode: 400,
              responseMessage: "Surveyor not found",
              responseData: {},
            });
          }
        } else {
          var user = await User.findOne({
            contact_no: req.body.surveyor_contact_no,
            "account_info.type": "user",
          })
            .count()
            .exec();
          if (user == 0) {
            var data = {};
            var country = await Country.findOne({
              timezone: req.headers["tz"],
            }).exec();
            data.address = {
              country: country.countryName,
              timezone: req.headers["tz"],
              location: data.location,
            };

            data.account_info = {
              type: "user",
              added_by: null,
              status: "Complete",
            };

            /*var expired_at = new Date();
                    expired_at.setDate(expired_at.getDate() + 365);*/

            data.agent = {
              agent: false,
              commission: 0,
              started_at: new Date(),
              expired_at: null,
            };

            var name = req.body.surveyor_name;
            name = name.substring(0, 3);
            var rand = Math.floor(Math.random() * 100000 + 1);

            data.username = name + "" + shortid.generate();
            data.contact_no = req.body.surveyor_contact_no;
            data.email = req.body.surveyor_email;
            data.name = req.body.surveyor_name;

            var firstPart = (Math.random() * 46656) | 0;
            var secondPart = (Math.random() * 46656) | 0;
            firstPart = ("000" + firstPart.toString(36)).slice(-3);
            secondPart = ("000" + secondPart.toString(36)).slice(-3);
            data.referral_code =
              firstPart.toUpperCase() + secondPart.toUpperCase();

            data.geometry = [0, 0];
            data.device = [];
            data.otp = Math.floor(Math.random() * 90000) + 10000;

            data.careager_cash = 0;
            data.socialite = "";
            data.optional_info = "";
            data.business_info = "";
            req.body.uuid = uuidv1();

            User.create(data).then(async function (user) {
              event.signupSMS(user);
              //event.otpSms(user);
              Booking.findOneAndUpdate(
                { _id: booking._id },
                { $set: { surveyor: user._id, updated_at: new Date() } },
                { new: false },
                function (err, doc) {
                  var activity = {
                    user: loggedInDetails._id,
                    name: loggedInDetails.name,
                    stage: "Estimation",
                    activity: "SurveyorAssigned",
                  };
                  fun.bookingLog(req.body.booking, activity);

                  var notify = {
                    receiver: [booking.user],
                    activity: "jobcard",
                    tag: "SurveyorAssigned",
                    source: booking._id,
                    sender: loggedInDetails._id,
                    points: 0,
                  };

                  fun.newNotification(notify);

                  res.status(200).json({
                    responseCode: 200,
                    responseMessage: "Surveyor details has been update",
                    responseData: {},
                  });
                }
              );
            });
          } else {
            res.status(400).json({
              responseCode: 400,
              responseMessage: "Surveyor already exist",
              responseData: {},
            });
          }
        }
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Booking not found",
          responseData: {},
        });
      }
    }
  }
);

router.put(
  "/surveyor-info/update",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      user: "required",
      name: "required",
      contact_no: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "All field required",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var user = await User.findById(req.body.user).exec();
      if (user) {
        var check = await User.findOne({
          contact_no: req.body.contact_no,
          _id: { $ne: user._id },
          "account_info.type": user.account_info.type,
        }).exec();

        if (check) {
          res.status(400).json({
            responseCode: 400,
            responseMessage: "Contact no already exist",
            responseData: {},
          });
        } else {
          User.findOneAndUpdate(
            { _id: user._id },
            {
              $set: {
                name: req.body.name,
                contact_no: req.body.contact_no,
                email: req.body.email,
                "business_info.company_name": req.body.company_name,
                "business_info.gstin": req.body.gstin,
                updated_at: new Date(),
              },
            },
            { new: false },
            function (err, doc) {
              if (err) {
                res.status(422).json({
                  responseCode: 422,
                  responseMessage: "Error Occurred",
                  responseData: err,
                });
              } else {
                res.status(200).json({
                  responseCode: 200,
                  responseMessage: "User details updated...",
                  responseData: {},
                });
              }
            }
          );
        }
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "User not found",
          responseData: {},
        });
      }
    }
  }
);

router.get(
  "/technicians/get",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var business = req.headers["business"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    var loggedInDetails = await User.findById(decoded.user).exec();

    var technicians = [];
    await Management.find({
      business: business,
      role: {
        $in: [
          "Denter",
          "Painter",
          "Electrician",
          "Technician",
          "Washing Technician",
          "DryCleaner",
        ],
      },
    })
      .populate({ path: "user" })
      .cursor()
      .eachAsync(async (v) => {
        technicians.push({
          _id: v.user._id,
          id: v.user.id,
          name: v.user.name + " (" + v.role + ")",
          username: v.user.username,
          email: v.user.email,
          contact_no: v.user.contact_no,
        });
      });

    res.status(200).json({
      responseCode: 200,
      responseMessage: "Technicians",
      responseData: technicians,
    });
  }
);

router.get(
  "/service-advisors/get",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var business = req.headers["business"];

    var technicians = [];
    await Management.find({ business: business, role: "Service Advisor" })
      .populate({ path: "user" })
      .cursor()
      .eachAsync(async (v) => {
        technicians.push({
          _id: v.user._id,
          id: v.user.id,
          name: v.user.name,
          username: v.user.username,
          email: v.user.email,
          contact_no: v.user.contact_no,
        });
      });

    res.status(200).json({
      responseCode: 200,
      responseMessage: "Service Advisors",
      responseData: technicians,
    });
  }
);

router.get("/cre/get", xAccessToken.token, async function (req, res, next) {
  var token = req.headers["x-access-token"];
  var secret = config.secret;
  var decoded = jwt.verify(token, secret);
  var business = req.headers["business"];

  var technicians = [];
  await Management.find({ business: business, role: "CRE" })
    .populate({ path: "user" })
    .cursor()
    .eachAsync(async (v) => {
      technicians.push({
        _id: v.user._id,
        id: v.user.id,
        name: v.user.name,
        username: v.user.username,
        email: v.user.email,
        contact_no: v.user.contact_no,
      });
    });

  res.status(200).json({
    responseCode: 200,
    responseMessage: "Service Advisors",
    responseData: technicians,
  });
});

router.put(
  "/job/delivery-date/update",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      booking: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Booking required",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var loggedInDetails = await User.findById(decoded.user).exec();
      var business = await User.findById(req.headers["business"]).exec();
      var driver = null;

      var booking = await Booking.findById(req.body.booking).exec();
      if (booking) {
        var data = {
          delivery_date: new Date(req.body.delivery_date).toISOString(),
          delivery_time: req.body.delivery_time,
        };

        Booking.findOneAndUpdate(
          { _id: booking._id },
          { $set: data },
          { new: true },
          function (err, doc) {}
        );

        var activity = {
          user: loggedInDetails._id,
          name: loggedInDetails.name,
          stage: "Updates",
          activity:
            "Delivery date updated " +
            moment(new Date(req.body.delivery_date).toISOString())
              .tz(req.headers["tz"])
              .format("lll"),
        };

        fun.bookingLog(booking._id, activity);

        var updated = await Booking.findById(booking._id).exec();

        res.status(200).json({
          responseCode: 200,
          responseMessage: "Asset",
          responseData: updated,
        });
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Booking not found",
          responseData: {},
        });
      }
    }
  }
);

router.put(
  "/job/requirements/update",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      booking: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Booking required",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var loggedInDetails = await User.findById(decoded.user).exec();
      var business = req.headers["business"];
      var driver = null;

      var booking = await Booking.findById(req.body.booking).exec();
      if (booking) {
        if (req.body.is_driver) {
          if (req.body.driver) {
            var checkDriver = await User.findById(req.body.driver).exec();
            driver = checkDriver._id;
            Booking.findOneAndUpdate(
              { _id: booking._id },
              { $set: { driver: driver } },
              { new: true },
              function (err, doc) {}
            );
          } else {
            var data = {};
            var country = await Country.findOne({
              timezone: req.headers["tz"],
            }).exec();
            data.address = {
              country: country.countryName,
              timezone: req.headers["tz"],
              location: data.location,
            };

            data.account_info = {
              type: "user",
              added_by: null,
              status: "Complete",
            };

            var expired_at = new Date();
            expired_at.setDate(expired_at.getDate() + 365);

            data.agent = {
              agent: true,
              commission: 10,
              started_at: new Date(),
              expired_at: expired_at,
            };

            var name = req.body.name;
            name = name.substring(0, 3);
            var rand = Math.floor(Math.random() * 100000 + 1);

            data.username = name + "" + shortid.generate();
            data.contact_no = req.body.contact_no;
            data.email = "";
            data.name = req.body.name;

            var firstPart = (Math.random() * 46656) | 0;
            var secondPart = (Math.random() * 46656) | 0;
            firstPart = ("000" + firstPart.toString(36)).slice(-3);
            secondPart = ("000" + secondPart.toString(36)).slice(-3);
            data.referral_code =
              firstPart.toUpperCase() + secondPart.toUpperCase();

            data.geometry = [0, 0];
            data.device = [];
            data.otp = Math.floor(Math.random() * 90000) + 10000;

            data.careager_cash = 0;
            data.socialite = "";
            data.optional_info = "";
            data.business_info = "";
            req.body.uuid = uuidv1();

            User.create(data).then(async function (user) {
              event.signupSMS(user);
              //event.otpSms(user);
              driver = user._id;
              Booking.findOneAndUpdate(
                { _id: booking._id },
                { $set: { driver: driver } },
                { new: true },
                function (err, doc) {}
              );
            });
          }
        }

        var technician = null;
        if (req.body.technician) {
          var checkTechnician = await Management.findOne({
            business: business,
            user: req.body.technician,
          }).exec();
          if (checkTechnician) {
            technician = checkTechnician.user;
          }
        }

        Car.findOneAndUpdate(
          { _id: booking.car },
          { $set: { manufacture_year: req.body.manufacture_year } },
          { $new: false },
          function (err, doc) {}
        );

        var claim = false;
        if (req.body.claim == "yes") {
          claim = true;
        }

        var cashless = false;
        if (req.body.cashless == "yes") {
          cashless = true;
        }

        if (!req.body.accident_date) {
          req.body.accident_date = null;
        }

        var insurance_info = {
          policy_holder: booking.insurance_info.policy_holder,
          insurance_company: booking.insurance_info.insurance_company,
          branch: booking.insurance_info.branch,
          gstin: booking.insurance_info.gstin,
          policy_no: booking.insurance_info.policy_no,
          premium: booking.insurance_info.premium,
          expire: booking.insurance_info.expire,
          claim: claim,
          cashless: cashless,
          policy_type: booking.insurance_info.policy_type,
          claim_no: booking.insurance_info.claim_no,
          driver_accident: req.body.driver_accident,
          accident_place: req.body.accident_place,
          accident_date: new Date(req.body.accident_date).toISOString(),
          accident_time: req.body.accident_time,
          accident_cause: req.body.accident_cause,
          spot_survey: req.body.spot_survey,
          fir: req.body.fir,
          manufacture_year: req.body.manufacture_year,
        };

        var customer_requirements = req.body.demands;
        if (customer_requirements.length <= 0) {
          customer_requirements = booking.customer_requirements;
        }

        var data = {
          customer_requirements: customer_requirements,
          technician: technician,
          delivery_date: new Date(req.body.delivery_date).toISOString(),
          delivery_time: req.body.delivery_time,
          status: "JobOpen",
          sub_status: "JobOpen",
          insurance_info: insurance_info,
          updated_at: new Date(),
        };

        Booking.findOneAndUpdate(
          { _id: booking._id },
          { $set: data },
          { new: true },
          function (err, doc) {}
        );
        if (claim == true) {
          Booking.findOneAndUpdate(
            { _id: booking._id },
            { $set: { "payment.policy_clause": 1000 } },
            { new: true },
            function (err, doc) {}
          );
        }

        var activity = {
          user: loggedInDetails._id,
          name: loggedInDetails.name,
          stage: "NewJob",
          activity: "JobOpen",
        };

        fun.bookingLog(booking._id, activity);

        var updated = await Booking.findById(booking._id).exec();

        res.status(200).json({
          responseCode: 200,
          responseMessage: "Asset",
          responseData: updated,
        });
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Booking not found",
          responseData: {},
        });
      }
    }
  }
);

router.put(
  "/job/insurance-info/update",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      booking: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Booking required",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var loggedInDetails = await User.findById(decoded.user).exec();
      var business = req.headers["business"];

      var booking = await Booking.findById(req.body.booking).exec();
      if (booking) {
        var insurance_company = await InsuranceCompany.findOne({
          company: req.body.insurance_company,
        }).exec();
        var expire = null;
        if (req.body.expire) {
          expire = new Date(req.body.expire).toISOString();
        }

        var insurance_info = {
          policy_holder: req.body.policy_holder,
          insurance_company: req.body.insurance_company,
          branch: req.body.branch,
          state: req.body.state,
          contact_no: req.body.contact_no,
          gstin: req.body.gstin,
          policy_no: req.body.policy_no,
          premium: req.body.premium,
          expire: expire,
          claim: booking.insurance_info.claim,
          cashless: booking.insurance_info.cashless,
          policy_type: booking.insurance_info.policy_type,
          claim_no: booking.insurance_info.claim_no,
          driver_accident: booking.insurance_info.driver_accident,
          accident_place: booking.insurance_info.accident_place,
          accident_date: booking.insurance_info.accident_date,
          accident_time: booking.insurance_info.accident_time,
          accident_cause: booking.insurance_info.accident_cause,
          spot_survey: booking.insurance_info.spot_survey,
          fir: booking.insurance_info.fir,
          manufacture_year: booking.insurance_info.manufacture_year,
        };

        Car.findOneAndUpdate(
          { _id: booking.car },
          { $set: { insurance_info: insurance_info } },
          { new: false },
          function (err, doc) {}
        );

        Booking.findOneAndUpdate(
          { _id: booking._id },
          { $set: { insurance_info: insurance_info, updated_at: new Date() } },
          { new: false },
          function (err, doc) {}
        );

        var activity = {
          user: loggedInDetails._id,
          name: loggedInDetails.name,
          stage: "Job",
          activity: "InsuranceDetailsUpdate",
        };

        fun.bookingLog(booking._id, activity);

        var updated = await Booking.findById(booking._id).exec();

        res.status(200).json({
          responseCode: 200,
          responseMessage: "Insurance details updated...",
          responseData: updated,
        });
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Booking not found",
          responseData: {},
        });
      }
    }
  }
);

router.put(
  "/job/insurance/update",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      booking: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Booking required",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var loggedInDetails = await User.findById(decoded.user).exec();
      var business = req.headers["business"];

      var booking = await Booking.findById(req.body.booking).exec();
      if (booking) {
        var insurance_company = await InsuranceCompany.findOne({
          company: req.body.insurance_company,
        }).exec();
        var expire = "";
        var accident_date = "";
        if (req.body.expire) {
          expire = new Date(req.body.expire).toISOString();
        }
        if (req.body.accident_date) {
          accident_date = new Date(req.body.accident_date).toISOString();
        }
        var insurance_info = {
          policy_holder: req.body.policy_holder,
          insurance_company: req.body.insurance_company,
          branch: req.body.branch,
          state: req.body.state,
          contact_no: req.body.contact_no,
          gstin: req.body.gstin,
          policy_no: req.body.policy_no,
          premium: req.body.premium,
          expire: expire,
          claim: req.body.claim,
          cashless: req.body.cashless,
          policy_type: req.body.policy_type,
          claim_no: req.body.claim_no,
          driver_accident: req.body.driver_accident,
          accident_place: req.body.accident_place,
          accident_date: accident_date,
          accident_time: req.body.accident_time,
          accident_cause: req.body.accident_cause,
          spot_survey: req.body.spot_survey,
          fir: req.body.fir,
          manufacture_year: req.body.manufacture_year,
        };

        Car.findOneAndUpdate(
          { _id: booking.car },
          { $set: { insurance_info: insurance_info } },
          { new: false },
          function (err, doc) {}
        );

        Booking.findOneAndUpdate(
          { _id: booking._id },
          { $set: { insurance_info: insurance_info, updated_at: new Date() } },
          { new: false },
          function (err, doc) {}
        );

        var updated = await Booking.findById(booking._id).exec();

        res.status(200).json({
          responseCode: 200,
          responseMessage: "Insurance details updated...",
          responseData: updated,
        });
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Booking not found",
          responseData: {},
        });
      }
    }
  }
);

router.put(
  "/customer-info/update",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      user: "required",
      name: "required",
      contact_no: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "All field required",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var user = await User.findById(req.body.user).exec();
      if (user) {
        var check = await User.findOne({
          contact_no: req.body.contact_no,
          _id: { $ne: user._id },
          "account_info.type": user.account_info.type,
        }).exec();

        if (check) {
          res.status(400).json({
            responseCode: 400,
            responseMessage: "Contact no already exist",
            responseData: {},
          });
        } else {
          User.findOneAndUpdate(
            { _id: user._id },
            {
              $set: {
                name: req.body.name,
                contact_no: req.body.contact_no,
                email: req.body.email,
                "business_info.company_name": req.body.company_name,
                "business_info.gstin": req.body.gstin,
                updated_at: new Date(),
              },
            },
            { new: false },
            function (err, doc) {
              if (err) {
                res.status(422).json({
                  responseCode: 422,
                  responseMessage: "Error Occurred",
                  responseData: err,
                });
              } else {
                res.status(200).json({
                  responseCode: 200,
                  responseMessage: "User details updated...",
                  responseData: {},
                });
              }
            }
          );
        }
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "User not found",
          responseData: {},
        });
      }
    }
  }
);

router.put(
  "/booking/address/update",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      booking: "required",
      address: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Address is required",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var loggedInDetails = await User.findById(decoded.user).exec();
      var business = await User.findById(req.headers["business"]).exec();

      var booking = await Booking.findById(req.body.booking).exec();
      if (booking) {
        var address = await Address.findOne({
          _id: req.body.address,
          user: booking.user,
        }).exec();
        if (address) {
          if (address.state == business.address.state) {
            var tax_type = "GST";
          } else {
            var tax_type = "IGST";
          }

          Booking.findOneAndUpdate(
            { _id: booking._id },
            {
              $set: {
                tax_type: tax_type,
                address: req.body.address,
                updated_at: new Date(),
              },
            },
            { new: false },
            async function (err, doc) {
              if (err) {
                res.status(422).json({
                  responseCode: 422,
                  responseMessage: "Error",
                  responseData: {},
                });
              } else {
                var update = await Booking.findById(booking._id).exec();
                res.status(200).json({
                  responseCode: 200,
                  responseMessage: "Updated Successfully",
                  responseData: update,
                });
              }
            }
          );
        } else {
          res.status(400).json({
            responseCode: 400,
            responseMessage: "Address not found",
            responseData: {},
          });
        }
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Booking not found",
          responseData: {},
        });
      }
    }
  }
);

router.put(
  "/booking/tax-preference/update",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      booking: "required",
      with_tax: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Validation Error",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var loggedInDetails = await User.findById(decoded.user).exec();
      var business = await User.findById(req.headers["business"]).exec();

      var booking = await Booking.findById(req.body.booking).exec();
      if (booking) {
        Booking.findOneAndUpdate(
          { _id: booking._id },
          { $set: { with_tax: req.body.with_tax, updated_at: new Date() } },
          { new: false },
          async function (err, doc) {
            if (err) {
              res.status(422).json({
                responseCode: 422,
                responseMessage: "Error",
                responseData: {},
              });
            } else {
              var update = await Booking.findById(booking._id).exec();
              res.status(200).json({
                responseCode: 200,
                responseMessage: "Updated Successfully",
                responseData: update,
              });
            }
          }
        );
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Booking not found",
          responseData: {},
        });
      }
    }
  }
);

router.put(
  "/booking/car/update",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      car: "required",
      user: "required",
      booking: "required",
      variant: "required",
      registration_no: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Car is required",
        responseData: {},
      });
    } else {
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);

      var checkuser = await User.findOne({ _id: req.body.user })
        .populate("user")
        .exec();
      if (checkuser) {
        var user = checkuser._id;
        var booking = await Booking.findOne({ _id: req.body.booking }).exec();
        var car = await Car.findOne({ _id: req.body.car })
          .populate("user")
          .exec();
        var variant = await Variant.findOne({ _id: req.body.variant })
          .populate("model")
          .select("-service_schedule")
          .exec();
        if (car) {
          var rg = req.body.registration_no;
          req.body.registration_no = rg.replace(/ /g, "");

          var check_rn = await Car.findOne({
            registration_no: req.body.registration_no,
            _id: { $ne: car._id },
            status: true,
          }).exec();

          if (check_rn) {
            res.status(400).json({
              responseCode: 400,
              responseMessage: "Car registration no already exist",
              responseData: {},
            });
          } else {
            if (variant) {
              var automaker = await Automaker.findById(
                variant.model.automaker
              ).exec();
              if (variant.specification.type) {
                req.body.transmission = variant.specification.type;
              }

              req.body.automaker = variant.model.automaker;
              req.body._automaker = automaker.maker;
              req.body._variant = variant.value;
              req.body.model = variant.model.id;
              req.body._model = variant.model.value;
              req.body.title = variant.variant;
              req.body.fuel_type = variant.specification.fuel_type;
              req.body.updated_at = new Date();

              Car.findOneAndUpdate(
                { _id: req.body.car, user: user },
                { $set: req.body },
                { new: false },
                async function (err, s) {
                  if (err) {
                    res.status(400).json({
                      responseCode: 400,
                      responseMessage: "Error occured",
                      responseData: err,
                    });
                  } else {
                    Booking.findOneAndUpdate(
                      { _id: booking._id },
                      {
                        $set: {
                          odometer: req.body.odometer,
                          fuel_level: req.body.fuel_level,
                          updated_at: new Date(),
                        },
                      },
                      { new: false },
                      async function (err, doc) {
                        if (err) {
                          res.status(400).json({
                            responseCode: 400,
                            responseMessage: "Error occured",
                            responseData: err,
                          });
                        } else {
                          res.status(200).json({
                            responseCode: 200,
                            responseMessage: "Saved",
                            responseData: {},
                          });
                        }
                      }
                    );
                  }
                }
              );
            } else {
              res.status(400).json({
                responseCode: 400,
                responseMessage: "Unprocessable Entity",
                responseData: {},
              });
            }
          }
        } else {
          res.status(400).json({
            responseCode: 400,
            responseMessage: "Unauthorized",
            responseData: {},
          });
        }
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "User not found",
          responseData: {},
        });
      }
    }
  }
);

router.put(
  "/job/claim-info/update",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      booking: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Booking required",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var loggedInDetails = await User.findById(decoded.user).exec();
      var business = req.headers["business"];

      var booking = await Booking.findById(req.body.booking).exec();
      if (booking) {
        Car.findOneAndUpdate(
          { _id: booking.car },
          { $set: { manufacture_year: req.body.manufacture_year } },
          { $new: false },
          function (err, doc) {}
        );

        var claim = false;
        if (req.body.claim == "yes") {
          claim = true;
        }

        var cashless = false;
        if (req.body.cashless == "yes") {
          cashless = true;
        }

        if (!req.body.accident_date) {
          req.body.accident_date = null;
        }

        var insurance_info = {
          policy_holder: booking.insurance_info.policy_holder,
          insurance_company: booking.insurance_info.insurance_company,
          branch: booking.insurance_info.branch,
          gstin: booking.insurance_info.gstin,
          policy_no: booking.insurance_info.policy_no,
          premium: booking.insurance_info.premium,
          expire: booking.insurance_info.expire,
          claim: claim,
          cashless: cashless,
          policy_type: booking.insurance_info.policy_type,
          claim_no: booking.insurance_info.claim_no,
          driver_accident: req.body.driver_accident,
          accident_place: req.body.accident_place,
          accident_date: new Date(req.body.accident_date).toISOString(),
          accident_time: req.body.accident_time,
          accident_cause: req.body.accident_cause,
          spot_survey: req.body.spot_survey,
          fir: req.body.fir,
          manufacture_year: req.body.manufacture_year,
        };

        var data = {
          insurance_info: insurance_info,
          updated_at: new Date(),
        };

        Booking.findOneAndUpdate(
          { _id: booking._id },
          { $set: data },
          { new: true },
          function (err, doc) {}
        );
        if (claim == true) {
          Booking.findOneAndUpdate(
            { _id: booking._id },
            { $set: { "payment.policy_clause": 1000 } },
            { new: true },
            function (err, doc) {}
          );
        }

        var activity = {
          user: loggedInDetails._id,
          name: loggedInDetails.name,
          stage: "Job",
          activity: "ClaimDetailsUpdate",
        };

        fun.bookingLog(booking._id, activity);

        var updated = await Booking.findById(booking._id).exec();

        res.status(200).json({
          responseCode: 200,
          responseMessage: "Claim details updated...",
          responseData: updated,
        });
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Booking not found",
          responseData: {},
        });
      }
    }
  }
);

router.put(
  "/advisor/update",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      booking: "required",
      advisor: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Booking required",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var loggedInDetails = await User.findById(decoded.user).exec();
      var business = req.headers["business"];

      var booking = await Booking.findById(req.body.booking)
        .populate("advisor")
        .exec();
      if (booking) {
        var advisor = await User.findOne({ _id: req.body.advisor }).exec();
        if (advisor) {
          var management = await Management.findOne({
            user: advisor._id,
            business: business,
          }).exec();
          if (management) {
            Booking.findOneAndUpdate(
              { _id: booking._id },
              { $set: { advisor: advisor._id } },
              { new: true },
              async function (err, doc) {
                if (err) {
                  res.status(422).json({
                    responseCode: 422,
                    responseMessage: "Server Error",
                    responseData: err,
                  });
                } else {
                  var activity = {
                    user: loggedInDetails._id,
                    name: loggedInDetails.name,
                    stage: "Updates",
                    activity: booking.advisor.name + " to " + advisor.name,
                  };

                  fun.bookingLog(booking._id, activity);

                  var updated = await Booking.findById(booking._id).exec();

                  res.status(200).json({
                    responseCode: 200,
                    responseMessage: "Details updated...",
                    responseData: updated,
                  });
                }
              }
            );
          } else {
            res.status(400).json({
              responseCode: 400,
              responseMessage: "Advisor not found",
              responseData: {},
            });
          }
        } else {
          res.status(400).json({
            responseCode: 400,
            responseMessage: "Advisor not found",
            responseData: {},
          });
        }
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Booking not found",
          responseData: {},
        });
      }
    }
  }
);

router.put(
  "/technician/update",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      booking: "required",
      technician: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Booking required",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var loggedInDetails = await User.findById(decoded.user).exec();
      var business = req.headers["business"];

      var booking = await Booking.findById(req.body.booking)
        .populate("technician")
        .exec();
      if (booking) {
        var technician = await User.findOne({
          _id: req.body.technician,
        }).exec();
        if (technician) {
          var management = await Management.findOne({
            user: technician._id,
            business: business,
          }).exec();
          if (management) {
            Booking.findOneAndUpdate(
              { _id: booking._id },
              { $set: { technician: technician._id } },
              { new: true },
              async function (err, doc) {
                if (err) {
                  res.status(422).json({
                    responseCode: 422,
                    responseMessage: "Server Error",
                    responseData: err,
                  });
                } else {
                  if (booking.technician) {
                    var s = booking.technician.name + " to " + technician.name;
                  } else {
                    var s = technician.name;
                  }

                  var activity = {
                    user: loggedInDetails._id,
                    name: loggedInDetails.name,
                    stage: "Updates",
                    activity: s,
                  };

                  fun.bookingLog(booking._id, activity);

                  var updated = await Booking.findById(booking._id).exec();

                  res.status(200).json({
                    responseCode: 200,
                    responseMessage: "Details updated...",
                    responseData: updated,
                  });
                }
              }
            );
          } else {
            res.status(400).json({
              responseCode: 400,
              responseMessage: "Technician not found",
              responseData: {},
            });
          }
        } else {
          res.status(400).json({
            responseCode: 400,
            responseMessage: "Technician not found",
            responseData: {},
          });
        }
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Booking not found",
          responseData: {},
        });
      }
    }
  }
);

router.put(
  "/job/assets/update",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      booking: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Booking required",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var loggedInDetails = await User.findById(decoded.user).exec();
      var business = req.headers["business"];

      var booking = await Booking.findById(req.body.booking).exec();
      if (booking) {
        var data = {
          other_assets: req.body.other,
          assets: req.body.assets,
          updated_at: new Date(),
        };

        Booking.findOneAndUpdate(
          { _id: booking._id },
          { $set: data },
          { new: true },
          function (err, doc) {}
        );

        var activity = {
          user: loggedInDetails._id,
          name: loggedInDetails.name,
          stage: "Job",
          activity: "AssetsUpdate",
        };

        fun.bookingLog(booking._id, activity);

        var updated = await Booking.findById(booking._id).exec();

        res.status(200).json({
          responseCode: 200,
          responseMessage: "Assets updated...",
          responseData: updated,
        });
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Booking not found",
          responseData: {},
        });
      }
    }
  }
);

router.get("/jobs/get", xAccessToken.token, async function (req, res, next) {
  var token = req.headers["x-access-token"];
  var secret = config.secret;
  var decoded = jwt.verify(token, secret);
  var user = decoded.user;
  var business = req.headers["business"];
  var bookings = [];
  var filters = [];
  var totalResult = 0;

  var role = await Management.findOne({
    user: user,
    business: business,
  }).exec();

  var date = new Date();
  var to = new Date();
  to.setDate(date.getDate() - 1);
  to.setHours(23, 59, 58);

  var thumbnail = [];

  var specification = {};
  specification["$lookup"] = {
    from: "User",
    localField: "user",
    foreignField: "_id",
    as: "user",
  };
  filters.push(specification);

  var specification = {};
  specification["$unwind"] = {
    path: "$user",
    preserveNullAndEmptyArrays: false,
  };
  filters.push(specification);

  var specification = {};
  specification["$lookup"] = {
    from: "Car",
    localField: "car",
    foreignField: "_id",
    as: "car",
  };
  filters.push(specification);

  var specification = {};
  specification["$lookup"] = {
    from: "User",
    localField: "advisor",
    foreignField: "_id",
    as: "advisor",
  };
  filters.push(specification);

  var specification = {};
  specification["$unwind"] = {
    path: "$advisor",
    preserveNullAndEmptyArrays: false,
  };
  filters.push(specification);

  var page = 0;

  if (req.query.page == undefined) {
    page = 0;
  } else {
    page = req.query.page;
  }

  var page = Math.max(0, parseInt(page));

  if (role.role == "Service Advisor") {
    var specification = {};
    specification["$match"] = {
      "advisor._id": mongoose.Types.ObjectId(role.user),
    };
    filters.push(specification);
  }

  var queries = new Object();
  var sortBy = new Object();

  if (req.query.query) {
    var specification = {};
    specification["$match"] = {
      business: mongoose.Types.ObjectId(business),
      status: {
        $in: [
          "In-Process",
          "Rework",
          "JobInitiated",
          "JobOpen",
          "CompleteWork",
          "QC",
          "StoreApproval",
          "Ready",
          "Completed",
          "Closed",
        ],
      },
      $or: [
        { status: { $regex: req.query.query, $options: "i" } },
        { booking_no: { $eq: req.query.query } },
        { "user.name": { $regex: req.query.query, $options: "i" } },
        { "user.contact_no": { $regex: req.query.query, $options: "i" } },
        { "car.title": { $regex: req.query.query, $options: "i" } },
        { "car.registration_no": { $regex: req.query.query, $options: "i" } },
        { "advisor.name": { $regex: req.query.query, $options: "i" } },
        { "advisor.contact_no": { $regex: req.query.query, $options: "i" } },
        {
          "insurance_info.insurance_company": {
            $regex: req.query.query,
            $options: "i",
          },
        },
        {
          logs: {
            $elemMatch: {
              status: { $regex: req.query.query, $options: "i" },
            },
          },
        },
        {
          services: {
            $elemMatch: {
              service: { $regex: req.query.query, $options: "i" },
            },
          },
        },
        {
          services: {
            $elemMatch: {
              parts: {
                $elemMatch: {
                  item: { $regex: req.query.query, $options: "i" },
                },
              },
            },
          },
        },
        {
          services: {
            $elemMatch: {
              parts: {
                $elemMatch: {
                  part_no: { $regex: req.query.query, $options: "i" },
                },
              },
            },
          },
        },
      ],
    };
    filters.push(specification);

    var specification = {};
    specification["$sort"] = {
      updated_at: -1,
    };
    filters.push(specification);
  } else {
    if (req.query.status == "NewJob") {
      var specification = {};
      specification["$match"] = {
        business: mongoose.Types.ObjectId(business),
        status: { $in: ["JobInitiated", "JobOpen"] },
      };
      filters.push(specification);
    } else if (req.query.status == "In-Process") {
      var specification = {};
      specification["$match"] = {
        business: mongoose.Types.ObjectId(business),
        status: { $in: ["In-Process", "StartWork", "Rework"] },
      };
      filters.push(specification);
    } else if (req.query.status == "QC") {
      var specification = {};
      specification["$match"] = {
        business: mongoose.Types.ObjectId(business),
        status: { $in: ["QC", "CompleteWork"] },
      };
      filters.push(specification);
    } else if (req.query.status == "StoreApproval") {
      var specification = {};
      specification["$match"] = {
        business: mongoose.Types.ObjectId(business),
        status: { $in: ["StoreApproval"] },
      };
      filters.push(specification);
    } else if (req.query.status == "Ready") {
      var specification = {};
      specification["$match"] = {
        business: mongoose.Types.ObjectId(business),
        status: { $in: ["Ready"] },
      };
      filters.push(specification);
    }

    var specification = {};
    specification["$sort"] = {
      updated_at: -1,
    };
    filters.push(specification);
  }

  totalResult = await Booking.aggregate(filters);

  var specification = {};
  specification["$skip"] = config.perPage * page;
  filters.push(specification);

  var specification = {};
  specification["$limit"] = config.perPage;
  filters.push(specification);

  await Booking.aggregate(filters)
    .allowDiskUse(true)
    .cursor({ batchSize: 10 })
    .exec()
    .eachAsync(async function (booking) {
      if (booking.car.length > 0) {
        var car = {
          title: booking.car[0]._automaker + " " + booking.car[0]._model,
          _id: booking.car[0]._id,
          id: booking.car[0].id,
          rc_address: booking.car[0].rc_address,
          ic_address: booking.car[0].ic_address,
          ic: booking.car[0].ic,
          rc: booking.car[0].rc,
          registration_no: booking.car[0].registration_no,
        };
      } else {
        var car = {
          title: "",
          _id: null,
          id: null,
          rc_address: "",
          ic_address: "",
          ic: "",
          rc: "",
          registration_no: "",
        };
      }

      var serverTime = moment.tz(new Date(), req.headers["tz"]);

      var startDate = moment(serverTime, "DD.MM.YYYY");
      var endDate = moment(booking.delivery_date, "DD.MM.YYYY");

      var days_left = endDate.diff(startDate, "days");

      bookings.push({
        _id: booking._id,
        id: booking._id,
        car: car,
        user: {
          name: booking.user.name,
          _id: booking.user._id,
          id: booking.user.id,
          contact_no: booking.user.contact_no,
          email: booking.user.email,
        },
        manager: null,
        time_left: moment(booking.delivery_date)
          .tz(req.headers["tz"])
          .endOf("day")
          .fromNow(),
        days_left: days_left,
        delivery_date: moment(booking.delivery_date)
          .tz(req.headers["tz"])
          .format("ll"),
        delivery_time: booking.delivery_time,
        status: _.startCase(booking.status),
        _status: booking.status,
        sub_status: booking.sub_status,
        job_no: booking.job_no,
        booking_no: booking.booking_no,
        created_at: moment(booking.created_at)
          .tz(req.headers["tz"])
          .format("lll"),
        updated_at: moment(booking.updated_at)
          .tz(req.headers["tz"])
          .format("lll"),
      });
    });

  res.status(200).json({
    responseCode: 200,
    responseMessage: to,
    responseInfo: {
      //role: role.role,
      //filters: filters,
      totalResult: totalResult.length,
    },
    responseData: bookings,
  });
});

router.post(
  "/services/rate",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      car: "required",
    };

    var validation = new Validator(req.query, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Validation Error",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var user = decoded.user;
      var business = req.headers["business"];

      var totalResult = 0;

      var quantity = 1;
      var car = await Variant.findById(req.query.car).populate("model").exec();
      if (car) {
        var packages = [];

        if (req.query.type == "services") {
          await Service.find({
            segment: car.model.segment,
            part_cost: 0,
            publish: true,
            business: business,
          })
            .cursor()
            .eachAsync(async (service) => {
              var getDiscount = {
                booking: null,
                package: null,
                car: null,
                category: service.type,
                service: service.service,
                claim: false,
                tz: req.headers["tz"],
              };

              var package = await q.all(getPackageDiscount(getDiscount));

              var labour_list = service.labour;
              var labours = [];

              var discount_eligible_labour_cost = _.sumBy(
                labour_list,
                (x) => x.amount
              );
              if (labour_list.length > 0) {
                for (var l = 0; l < labour_list.length; l++) {
                  var discount_total = 0;
                  var total = 0;
                  var tax_info = await Tax.findOne({
                    tax: labour_list[l].tax,
                  }).exec();

                  var tax = [];
                  var rate = labour_list[l].rate;
                  var amount = parseFloat(labour_list[l].amount) * quantity;
                  var tax_rate = tax_info.detail;
                  var base = amount;

                  if (Object.keys(package).length > 0) {
                    if (package.discount_type == "percent") {
                      discount = parseFloat(package.discount);
                      if (!isNaN(discount) && discount > 0) {
                        var discount_total = amount * (discount / 100);
                        amount = amount - parseFloat(discount_total.toFixed(2));
                        if (amount < 0) {
                          amount = 0;
                        }
                      }
                    } else if (package.discount_type == "fixed") {
                      discount = parseFloat(package.discount);
                      if (!isNaN(discount) && discount > 0) {
                        var discount_total =
                          (amount / discount_eligible_labour_cost) * discount;
                        amount = parseFloat(discount_total.toFixed(2));
                        discount = amount - discount_total;
                        if (amount < 0) {
                          amount = 0;
                        }
                      }
                    } else {
                      discount = parseFloat(package.discount);
                      if (!isNaN(discount) && discount > 0) {
                        var discount_total =
                          (amount / discount_eligible_labour_cost) * discount;
                        amount = amount - parseFloat(discount_total.toFixed(2));
                        if (amount < 0) {
                          amount = 0;
                        }
                      }
                    }
                  }

                  if (labour_list[l].amount_is_tax == "inclusive") {
                    var x = (100 + tax_info.rate) / 100;
                    var tax_on_amount = amount / x;
                    if (tax_rate.length > 0) {
                      for (var r = 0; r < tax_rate.length; r++) {
                        if (tax_rate[r].rate != tax_info.rate) {
                          var t = tax_on_amount * (tax_rate[r].rate / 100);
                          base = base - t;
                          tax.push({
                            tax: tax_rate[r].tax,
                            rate: tax_rate[r].rate,
                            amount: parseFloat(t.toFixed(2)),
                          });
                        } else {
                          var t = amount - tax_on_amount;
                          base = base - t;
                          tax.push({
                            tax: tax_info.tax,
                            tax_rate: tax_info.rate,
                            rate: tax_info.rate,
                            amount: parseFloat(t.toFixed(2)),
                          });
                        }
                      }

                      //base = base - discount_total;
                    }
                    total = total + amount;
                  }

                  var tax_details = {
                    tax: tax_info.tax,
                    rate: tax_info.rate,
                    amount: total,
                    detail: tax,
                  };

                  labours.push({
                    item: labour_list[l].item,
                    source: labour_list[l].source,
                    rate: parseFloat(labour_list[l].rate),
                    quantity: quantity,
                    base: parseFloat(base.toFixed(2)),
                    discount: parseFloat(discount_total.toFixed(2)),
                    amount: total,
                    tax_amount: parseFloat(
                      _.sumBy(tax, (x) => x.amount).toFixed(2)
                    ),
                    amount_is_tax: labour_list[l].amount_is_tax,
                    tax: tax_info.tax,
                    tax_rate: tax_info.rate,
                    tax_info: tax_details,
                  });
                }
              }

              packages.push({
                package: service.package,
                service: service.service,
                labour: labours,
                labour_cost: _.sumBy(labours, (x) => x.amount),
                discount: _.sumBy(labours, (x) => x.discount),
                parts: service.parts,
                part_cost: parseFloat(service.part_cost),
                opening_fitting: service.opening_fitting,
                of_cost: parseFloat(service.of_cost),
                exceeded_cost: 0,
                mrp: parseFloat(service.mrp),
                cost:
                  parseFloat(service.part_cost) +
                  _.sumBy(labours, (x) => x.amount),
                doorstep: service.doorstep,
                unit: service.unit,
                quantity: quantity,
                part_cost_editable: service.part_cost_editable,
                labour_cost_editable: service.labour_cost_editable,
                of_cost_editable: service.of_cost_editable,
                type: service.type,
                source: service.id,
                description: service.description,
                id: service.id,
                _id: service._id,
              });

              packageDiscountOn = [];
            });

          await Service.find({
            model: car.model._id,
            part_cost: { $gt: 0 },
            publish: true,
            business: business,
          })
            .cursor()
            .eachAsync(async (service) => {
              var labels = [];

              labels.push(service.type);
              labels.push(service.service);
              var coupons = await Coupon.find({
                label: { $in: labels },
                expired_at: { $gte: new Date() },
                physical: false,
              }).exec();

              var gallery = service.gallery;
              var getDiscount = {
                booking: null,
                package: null,
                car: null,
                category: service.type,
                service: service.service,
                claim: false,
                tz: req.headers["tz"],
              };

              var package = await q.all(getPackageDiscount(getDiscount));
              var labour_list = service.labour;
              var labours = [];

              var discount_eligible_labour_cost = _.sumBy(
                labour_list,
                (x) => x.amount
              );
              if (labour_list.length > 0) {
                for (var l = 0; l < labour_list.length; l++) {
                  var quantity = 1;
                  if (labour_list[l].quantity) {
                    quantity = labour_list[l].quantity;
                  }

                  var discount_total = 0;
                  var total = 0;
                  var tax_info = await Tax.findOne({
                    tax: labour_list[l].tax,
                  }).exec();

                  var tax = [];
                  var rate = labour_list[l].rate;
                  var amount = parseFloat(labour_list[l].amount);
                  var tax_rate = tax_info.detail;
                  var base = amount;

                  if (Object.keys(package).length > 0) {
                    if (package.discount_type == "percent") {
                      discount = parseFloat(package.discount);
                      if (!isNaN(discount) && discount > 0) {
                        var discount_total = amount * (discount / 100);
                        amount = amount - parseFloat(discount_total.toFixed(2));
                        if (amount < 0) {
                          amount = 0;
                        }
                      }
                    } else if (package.discount_type == "fixed") {
                      discount = parseFloat(package.discount);
                      if (!isNaN(discount) && discount > 0) {
                        var discount_total =
                          (amount / discount_eligible_labour_cost) * discount;
                        amount = parseFloat(discount_total.toFixed(2));
                        discount = amount - discount_total;
                        if (amount < 0) {
                          amount = 0;
                        }
                      }
                    } else {
                      discount = parseFloat(package.discount);
                      if (!isNaN(discount) && discount > 0) {
                        var discount_total =
                          (amount / discount_eligible_labour_cost) * discount;
                        amount = amount - parseFloat(discount_total.toFixed(2));
                        if (amount < 0) {
                          amount = 0;
                        }
                      }
                    }
                  }

                  if (labour_list[l].amount_is_tax == "inclusive") {
                    var x = (100 + tax_info.rate) / 100;
                    var tax_on_amount = amount / x;
                    if (tax_rate.length > 0) {
                      for (var r = 0; r < tax_rate.length; r++) {
                        if (tax_rate[r].rate != tax_info.rate) {
                          var t = tax_on_amount * (tax_rate[r].rate / 100);
                          base = base - t;
                          tax.push({
                            tax: tax_rate[r].tax,
                            rate: tax_rate[r].rate,
                            amount: parseFloat(t.toFixed(2)),
                          });
                        } else {
                          var t = amount - tax_on_amount;
                          base = base - t;
                          tax.push({
                            tax: tax_info.tax,
                            tax_rate: tax_info.rate,
                            rate: tax_info.rate,
                            amount: parseFloat(t.toFixed(2)),
                          });
                        }
                      }

                      //base = base - discount_total;
                    }
                    total = total + amount;
                  }

                  var tax_details = {
                    tax: tax_info.tax,
                    rate: tax_info.rate,
                    amount: total,
                    detail: tax,
                  };

                  labours.push({
                    item: labour_list[l].item,
                    source: labour_list[l].source,
                    rate: parseFloat(labour_list[l].rate),
                    quantity: 1,
                    base: parseFloat(total.toFixed(2)),
                    discount: parseFloat(discount_total.toFixed(2)),
                    amount: total,
                    tax_amount: parseFloat(
                      _.sumBy(tax, (x) => x.amount).toFixed(2)
                    ),
                    amount_is_tax: labour_list[l].amount_is_tax,
                    tax: tax_info.tax,
                    tax_rate: tax_info.rate,
                    tax_info: tax_details,
                  });
                }
              }
              packages.push({
                package: service.package,
                service: service.service,
                labour: labours,
                labour_cost: _.sumBy(labours, (x) => x.amount),
                parts: service.parts,
                part_cost: Math.ceil(service.part_cost),
                opening_fitting: service.opening_fitting,
                of_cost: Math.ceil(service.of_cost),
                exceeded_cost: 0,
                mrp:
                  Math.ceil(service.part_cost) +
                  _.sumBy(labours, (x) => x.amount) +
                  _.sumBy(labours, (x) => x.amount) * (40 / 100),
                cost:
                  Math.ceil(service.part_cost) +
                  _.sumBy(labours, (x) => x.amount) +
                  service.of_cost,
                doorstep: service.doorstep,
                unit: service.unit,
                quantity: service.quantity,
                discount:
                  _.sumBy(labours, (x) => x.discount) +
                  _.sumBy(service.opening_fitting, (x) => x.discount) +
                  _.sumBy(service.parts, (x) => x.discount),
                part_cost_editable: service.part_cost_editable,
                labour_cost_editable: service.labour_cost_editable,
                of_cost_editable: service.of_cost_editable,
                type: service.type,
                source: service.id,
                gallery: gallery.length,
                description: service.description,
                coupons: coupons,
                id: service.id,
                _id: service._id,
              });
            });
        } else if (req.query.type == "collision") {
          await Collision.find({
            segment: car.model.segment,
            publish: true,
            business: business,
          })
            .cursor()
            .eachAsync(async (service) => {
              var getDiscount = {
                booking: null,
                package: null,
                car: null,
                category: service.type,
                service: service.service,
                claim: false,
                tz: req.headers["tz"],
              };

              var package = await q.all(getPackageDiscount(getDiscount));
              var labour_list = service.labour;
              var labours = [];

              var discount_eligible_labour_cost = _.sumBy(
                labour_list,
                (x) => x.amount
              );
              if (labour_list.length > 0) {
                for (var l = 0; l < labour_list.length; l++) {
                  var discount_total = 0;
                  var total = 0;
                  var tax_info = await Tax.findOne({
                    tax: labour_list[l].tax,
                  }).exec();

                  var tax = [];
                  var rate = labour_list[l].rate;
                  var amount = parseFloat(labour_list[l].amount) * quantity;
                  var tax_rate = tax_info.detail;
                  var base = amount;

                  if (Object.keys(package).length > 0) {
                    if (package.discount_type == "percent") {
                      discount = parseFloat(package.discount);
                      if (!isNaN(discount) && discount > 0) {
                        var discount_total = amount * (discount / 100);
                        amount = amount - parseFloat(discount_total.toFixed(2));
                        if (amount < 0) {
                          amount = 0;
                        }
                      }
                    } else if (package.discount_type == "fixed") {
                      discount = parseFloat(package.discount);
                      if (!isNaN(discount) && discount > 0) {
                        var discount_total =
                          (amount / discount_eligible_labour_cost) * discount;
                        amount = parseFloat(discount_total.toFixed(2));
                        discount = amount - discount_total;
                        if (amount < 0) {
                          amount = 0;
                        }
                      }
                    } else {
                      discount = parseFloat(package.discount);
                      if (!isNaN(discount) && discount > 0) {
                        var discount_total =
                          (amount / discount_eligible_labour_cost) * discount;
                        amount = amount - parseFloat(discount_total.toFixed(2));
                        if (amount < 0) {
                          amount = 0;
                        }
                      }
                    }
                  }

                  if (labour_list[l].amount_is_tax == "inclusive") {
                    var x = (100 + tax_info.rate) / 100;
                    var tax_on_amount = amount / x;
                    if (tax_rate.length > 0) {
                      for (var r = 0; r < tax_rate.length; r++) {
                        if (tax_rate[r].rate != tax_info.rate) {
                          var t = tax_on_amount * (tax_rate[r].rate / 100);
                          base = base - t;
                          tax.push({
                            tax: tax_rate[r].tax,
                            rate: tax_rate[r].rate,
                            amount: parseFloat(t.toFixed(2)),
                          });
                        } else {
                          var t = amount - tax_on_amount;
                          base = base - t;
                          tax.push({
                            tax: tax_info.tax,
                            tax_rate: tax_info.rate,
                            rate: tax_info.rate,
                            amount: parseFloat(t.toFixed(2)),
                          });
                        }
                      }

                      //base = base - discount_total;
                    }
                    total = total + amount;
                  }

                  var tax_details = {
                    tax: tax_info.tax,
                    rate: tax_info.rate,
                    amount: total,
                    detail: tax,
                  };

                  labours.push({
                    item: labour_list[l].item,
                    source: labour_list[l].source,
                    rate: parseFloat(labour_list[l].rate),
                    quantity: quantity,
                    base: parseFloat(base.toFixed(2)),
                    discount: parseFloat(discount_total.toFixed(2)),
                    amount: total,
                    tax_amount: parseFloat(
                      _.sumBy(tax, (x) => x.amount).toFixed(2)
                    ),
                    amount_is_tax: labour_list[l].amount_is_tax,
                    tax: tax_info.tax,
                    tax_rate: tax_info.rate,
                    tax_info: tax_details,
                  });

                  ////////////console.log(base.toFixed(2))
                }
              }

              packages.push({
                package: service.package,
                service: service.service,
                labour: labours,
                labour_cost: _.sumBy(labours, (x) => x.amount),
                parts: service.parts,
                discount: _.sumBy(labours, (x) => x.discount),
                part_cost: parseFloat(service.part_cost),
                opening_fitting: service.opening_fitting,
                of_cost: parseFloat(service.of_cost),
                exceeded_cost: 0,
                mrp: parseFloat(service.mrp),
                cost:
                  parseFloat(service.part_cost) +
                  _.sumBy(labours, (x) => x.amount),
                doorstep: service.doorstep,
                unit: service.unit,
                quantity: quantity,
                part_cost_editable: service.part_cost_editable,
                labour_cost_editable: service.labour_cost_editable,
                of_cost_editable: service.of_cost_editable,
                type: service.type,
                source: service.id,
                description: service.description,
                id: service.id,
                _id: service._id,
              });

              packageDiscountOn = [];
            });
        } else if (req.query.type == "customization") {
          await Customization.find({
            segment: car.model.segment,
            publish: true,
            business: business,
          })
            .cursor()
            .eachAsync(async (service) => {
              var getDiscount = {
                booking: null,
                package: null,
                car: null,
                category: service.type,
                service: service.service,
                claim: false,
                tz: req.headers["tz"],
              };
              var package = await q.all(getPackageDiscount(getDiscount));
              var labour_list = service.labour;
              var labours = [];

              var discount_eligible_labour_cost = _.sumBy(
                labour_list,
                (x) => x.amount
              );
              if (labour_list.length > 0) {
                for (var l = 0; l < labour_list.length; l++) {
                  /*var quantity = 1;*/
                  /*if(labour_list[l].quantity)
                                {
                                    quantity = labour_list[l].quantity;
                                }*/

                  var discount_total = 0;
                  var total = 0;
                  var tax_info = await Tax.findOne({
                    tax: labour_list[l].tax,
                  }).exec();

                  var tax = [];
                  var rate = labour_list[l].rate;
                  var amount = parseFloat(labour_list[l].amount) * quantity;
                  var tax_rate = tax_info.detail;
                  var base = amount;

                  if (Object.keys(package).length > 0) {
                    if (package.discount_type == "percent") {
                      discount = parseFloat(package.discount);
                      if (!isNaN(discount) && discount > 0) {
                        var discount_total = amount * (discount / 100);
                        amount = amount - parseFloat(discount_total.toFixed(2));
                        if (amount < 0) {
                          amount = 0;
                        }
                      }
                    } else if (package.discount_type == "fixed") {
                      discount = parseFloat(package.discount);
                      if (!isNaN(discount) && discount > 0) {
                        var discount_total =
                          (amount / discount_eligible_labour_cost) * discount;
                        amount = parseFloat(discount_total.toFixed(2));
                        discount = amount - discount_total;
                        if (amount < 0) {
                          amount = 0;
                        }
                      }
                    } else {
                      discount = parseFloat(package.discount);
                      if (!isNaN(discount) && discount > 0) {
                        var discount_total =
                          (amount / discount_eligible_labour_cost) * discount;
                        amount = amount - parseFloat(discount_total.toFixed(2));
                        if (amount < 0) {
                          amount = 0;
                        }
                      }
                    }
                  }

                  if (labour_list[l].amount_is_tax == "inclusive") {
                    var x = (100 + tax_info.rate) / 100;
                    var tax_on_amount = amount / x;
                    if (tax_rate.length > 0) {
                      for (var r = 0; r < tax_rate.length; r++) {
                        if (tax_rate[r].rate != tax_info.rate) {
                          var t = tax_on_amount * (tax_rate[r].rate / 100);
                          base = base - t;
                          tax.push({
                            tax: tax_rate[r].tax,
                            rate: tax_rate[r].rate,
                            amount: parseFloat(t.toFixed(2)),
                          });
                        } else {
                          var t = amount - tax_on_amount;
                          base = base - t;
                          tax.push({
                            tax: tax_info.tax,
                            tax_rate: tax_info.rate,
                            rate: tax_info.rate,
                            amount: parseFloat(t.toFixed(2)),
                          });
                        }
                      }

                      //base = base - discount_total;
                    }
                    total = total + amount;
                  }

                  var tax_details = {
                    tax: tax_info.tax,
                    rate: tax_info.rate,
                    amount: total,
                    detail: tax,
                  };

                  labours.push({
                    item: labour_list[l].item,
                    source: labour_list[l].source,
                    rate: parseFloat(labour_list[l].rate),
                    quantity: quantity,
                    base: parseFloat(base.toFixed(2)),
                    discount: parseFloat(discount_total.toFixed(2)),
                    amount: total,
                    tax_amount: parseFloat(
                      _.sumBy(tax, (x) => x.amount).toFixed(2)
                    ),
                    amount_is_tax: labour_list[l].amount_is_tax,
                    tax: tax_info.tax,
                    tax_rate: tax_info.rate,
                    tax_info: tax_details,
                  });

                  ////////////console.log(base.toFixed(2))
                }
              }

              packages.push({
                package: service.package,
                service: service.service,
                labour: labours,
                discount: _.sumBy(labours, (x) => x.discount),
                labour_cost: _.sumBy(labours, (x) => x.amount),
                parts: service.parts,
                part_cost: parseFloat(service.part_cost),
                opening_fitting: service.opening_fitting,
                of_cost: parseFloat(service.of_cost),
                exceeded_cost: 0,
                mrp: parseFloat(service.mrp),
                cost:
                  parseFloat(service.part_cost) +
                  _.sumBy(labours, (x) => x.amount),
                doorstep: service.doorstep,
                unit: service.unit,
                quantity: quantity,
                part_cost_editable: service.part_cost_editable,
                labour_cost_editable: service.labour_cost_editable,
                of_cost_editable: service.of_cost_editable,
                type: service.type,
                source: service.id,
                description: service.description,
                id: service.id,
                _id: service._id,
              });

              packageDiscountOn = [];
            });
        } else if (req.query.type == "detailing") {
          await Detailing.find({
            segment: car.model.segment,
            publish: true,
            business: business,
          })
            .cursor()
            .eachAsync(async (service) => {
              var getDiscount = {
                booking: null,
                package: null,
                car: null,
                category: service.type,
                service: service.service,
                claim: false,
                tz: req.headers["tz"],
              };
              var package = await q.all(getPackageDiscount(getDiscount));

              var labour_list = service.labour;
              var labours = [];

              var discount_eligible_labour_cost = _.sumBy(
                labour_list,
                (x) => x.amount
              );
              if (labour_list.length > 0) {
                for (var l = 0; l < labour_list.length; l++) {
                  var discount_total = 0;
                  var total = 0;
                  var tax_info = await Tax.findOne({
                    tax: labour_list[l].tax,
                  }).exec();

                  var tax = [];
                  var rate = labour_list[l].rate;
                  var amount = parseFloat(labour_list[l].amount) * quantity;
                  var tax_rate = tax_info.detail;
                  var base = amount;

                  if (Object.keys(package).length > 0) {
                    if (package.discount_type == "percent") {
                      discount = parseFloat(package.discount);
                      if (!isNaN(discount) && discount > 0) {
                        var discount_total = amount * (discount / 100);
                        amount = amount - parseFloat(discount_total.toFixed(2));
                        if (amount < 0) {
                          amount = 0;
                        }
                      }
                    } else if (package.discount_type == "fixed") {
                      discount = parseFloat(package.discount);
                      if (!isNaN(discount) && discount > 0) {
                        var discount_total =
                          (amount / discount_eligible_labour_cost) * discount;
                        amount = parseFloat(discount_total.toFixed(2));
                        discount = amount - discount_total;
                        if (amount < 0) {
                          amount = 0;
                        }
                      }
                    } else {
                      discount = parseFloat(package.discount);
                      if (!isNaN(discount) && discount > 0) {
                        var discount_total =
                          (amount / discount_eligible_labour_cost) * discount;
                        amount = amount - parseFloat(discount_total.toFixed(2));
                        if (amount < 0) {
                          amount = 0;
                        }
                      }
                    }
                  }

                  if (labour_list[l].amount_is_tax == "inclusive") {
                    var x = (100 + tax_info.rate) / 100;
                    var tax_on_amount = amount / x;
                    if (tax_rate.length > 0) {
                      for (var r = 0; r < tax_rate.length; r++) {
                        if (tax_rate[r].rate != tax_info.rate) {
                          var t = tax_on_amount * (tax_rate[r].rate / 100);
                          base = base - t;
                          tax.push({
                            tax: tax_rate[r].tax,
                            rate: tax_rate[r].rate,
                            amount: parseFloat(t.toFixed(2)),
                          });
                        } else {
                          var t = amount - tax_on_amount;
                          base = base - t;
                          tax.push({
                            tax: tax_info.tax,
                            tax_rate: tax_info.rate,
                            rate: tax_info.rate,
                            amount: parseFloat(t.toFixed(2)),
                          });
                        }
                      }

                      //base = base - discount_total;
                    }
                    total = total + amount;
                  }

                  var tax_details = {
                    tax: tax_info.tax,
                    rate: tax_info.rate,
                    amount: total,
                    detail: tax,
                  };

                  labours.push({
                    item: labour_list[l].item,
                    source: labour_list[l].source,
                    rate: parseFloat(labour_list[l].rate),
                    quantity: quantity,
                    base: parseFloat(base.toFixed(2)),
                    discount: parseFloat(discount_total.toFixed(2)),
                    amount: total,
                    tax_amount: parseFloat(
                      _.sumBy(tax, (x) => x.amount).toFixed(2)
                    ),
                    amount_is_tax: labour_list[l].amount_is_tax,
                    tax: tax_info.tax,
                    tax_rate: tax_info.rate,
                    tax_info: tax_details,
                  });
                }
              }

              packages.push({
                package: service.package,
                service: service.service,
                labour: labours,
                discount: _.sumBy(labours, (x) => x.discount),
                labour_cost: _.sumBy(labours, (x) => x.amount),
                parts: service.parts,
                part_cost: parseFloat(service.part_cost),
                opening_fitting: service.opening_fitting,
                of_cost: parseFloat(service.of_cost),
                exceeded_cost: 0,
                mrp: parseFloat(service.mrp),
                cost:
                  parseFloat(service.part_cost) +
                  _.sumBy(labours, (x) => x.amount),
                doorstep: service.doorstep,
                unit: service.unit,
                quantity: quantity,
                part_cost_editable: service.part_cost_editable,
                labour_cost_editable: service.labour_cost_editable,
                of_cost_editable: service.of_cost_editable,
                type: service.type,
                source: service.id,
                description: service.description,
                id: service.id,
                _id: service._id,
              });

              packageDiscountOn = [];
            });
        }

        packages = _(packages)
          .groupBy((x) => x.package)
          .map((value, key) => ({ package: key, services: value }))
          .value();

        res.status(200).json({
          responseCode: 200,
          responseMessage: "",
          responseData: packages,
        });
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Car not found",
          responseData: {},
        });
      }
    }
  }
);

router.post(
  "/estimation/services/search",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      booking: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Validation Error",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var user = decoded.user;
      var business = req.headers["business"];

      var totalResult = 0;

      var booking = await Booking.findOne({ _id: req.body.booking }).exec();
      if (booking) {
        var claim = false;
        if (booking.insurance_info) {
          claim = booking.insurance_info.claim;
        }

        var quantity = 1;
        if (req.body.quantity) {
          quantity = parseInt(req.body.quantity);
        }

        var car = await Car.findById(booking.car).populate("model").exec();
        if (car) {
          var packages = [];

          await Service.find({
            business: business,
            segment: car.model.segment,
            part_cost: 0,
            publish: true,
            service: new RegExp(req.body.service, "i"),
            business: business,
          })
            .cursor()
            .eachAsync(async (service) => {
              var getDiscount = {
                booking: booking._id,
                package: booking.package,
                car: booking.car,
                category: service.type,
                service: service.service,
                claim: claim,
                tz: req.headers["tz"],
              };

              var package = await q.all(getPackageDiscount(getDiscount));

              //////console.log(package);

              var labour_list = service.labour;
              var labours = [];

              var discount_eligible_labour_cost = _.sumBy(
                labour_list,
                (x) => x.amount
              );
              if (labour_list.length > 0) {
                for (var l = 0; l < labour_list.length; l++) {
                  var discount_total = 0;
                  var total = 0;
                  var tax_info = await Tax.findOne({
                    tax: labour_list[l].tax,
                  }).exec();

                  var tax = [];
                  var rate = labour_list[l].rate;
                  var amount = parseFloat(labour_list[l].amount) * quantity;
                  var tax_rate = tax_info.detail;
                  var base = amount;

                  if (Object.keys(package).length > 0) {
                    if (package.discount_type == "percent") {
                      discount = parseFloat(package.discount);
                      if (!isNaN(discount) && discount > 0) {
                        var discount_total = amount * (discount / 100);
                        amount = amount - parseFloat(discount_total.toFixed(2));
                        if (amount < 0) {
                          amount = 0;
                        }
                      }
                    } else if (package.discount_type == "fixed") {
                      discount = parseFloat(package.discount);
                      if (!isNaN(discount) && discount > 0) {
                        var discount_total =
                          (amount / discount_eligible_labour_cost) * discount;
                        amount = parseFloat(discount_total.toFixed(2));
                        discount = amount - discount_total;
                        if (amount < 0) {
                          amount = 0;
                        }
                      }
                    } else {
                      discount = parseFloat(package.discount);
                      if (!isNaN(discount) && discount > 0) {
                        var discount_total =
                          (amount / discount_eligible_labour_cost) * discount;
                        amount = amount - parseFloat(discount_total.toFixed(2));
                        if (amount < 0) {
                          amount = 0;
                        }
                      }
                    }
                  }

                  if (labour_list[l].amount_is_tax == "inclusive") {
                    var x = (100 + tax_info.rate) / 100;
                    var tax_on_amount = amount / x;
                    if (tax_rate.length > 0) {
                      for (var r = 0; r < tax_rate.length; r++) {
                        if (tax_rate[r].rate != tax_info.rate) {
                          var t = tax_on_amount * (tax_rate[r].rate / 100);
                          base = base - t;
                          tax.push({
                            tax: tax_rate[r].tax,
                            rate: tax_rate[r].rate,
                            amount: parseFloat(t.toFixed(2)),
                          });
                        } else {
                          var t = amount - tax_on_amount;
                          base = base - t;
                          tax.push({
                            tax: tax_info.tax,
                            tax_rate: tax_info.rate,
                            rate: tax_info.rate,
                            amount: parseFloat(t.toFixed(2)),
                          });
                        }
                      }

                      //base = base - discount_total;
                    }
                    total = total + amount;
                  }

                  var tax_details = {
                    tax: tax_info.tax,
                    rate: tax_info.rate,
                    amount: total,
                    detail: tax,
                  };

                  labours.push({
                    item: labour_list[l].item,
                    source: labour_list[l].source,
                    rate: parseFloat(labour_list[l].rate),
                    quantity: quantity,
                    base: parseFloat(base.toFixed(2)),
                    discount: parseFloat(discount_total.toFixed(2)),
                    amount: total,
                    customer_dep: 100,
                    insurance_dep: 0,
                    tax_amount: parseFloat(
                      _.sumBy(tax, (x) => x.amount).toFixed(2)
                    ),
                    amount_is_tax: labour_list[l].amount_is_tax,
                    tax: tax_info.tax,
                    tax_rate: tax_info.rate,
                    tax_info: tax_details,
                  });
                }
              }

              if (service.opening_fitting.length != 0) {
                service.opening_fitting[0].customer_dep = 100;
                service.opening_fitting[0].insurance_dep = 0;
              }

              if (service.parts.length != 0) {
                service.parts[0].customer_dep = 100;
                service.parts[0].insurance_dep = 0;
              }

              packages.push({
                package: service.package,
                service: service.service,
                labour: labours,
                labour_cost: _.sumBy(labours, (x) => x.amount),
                discount: _.sumBy(labours, (x) => x.discount),
                parts: service.parts,
                part_cost: parseFloat(service.part_cost),
                opening_fitting: service.opening_fitting,
                of_cost: parseFloat(service.of_cost),
                exceeded_cost: 0,
                mrp: parseFloat(service.mrp),
                cost:
                  parseFloat(service.part_cost) +
                  _.sumBy(labours, (x) => x.amount),
                doorstep: service.doorstep,
                unit: service.unit,
                quantity: quantity,
                part_cost_editable: service.part_cost_editable,
                labour_cost_editable: service.labour_cost_editable,
                of_cost_editable: service.of_cost_editable,
                type: service.type,
                source: service.id,
                description: service.description,
                id: service.id,
                _id: service._id,
              });

              packageDiscountOn = [];
            });

          await Service.find({
            business: business,
            model: car.model._id,
            publish: true,
            business: business,
          })
            .cursor()
            .eachAsync(async (service) => {
              var labels = [];

              labels.push(service.type);
              labels.push(service.service);
              var coupons = await Coupon.find({
                label: { $in: labels },
                expired_at: { $gte: new Date() },
                physical: false,
              }).exec();

              var gallery = service.gallery;
              var getDiscount = {
                booking: booking._id,
                package: booking.package,
                car: booking.car,
                category: service.type,
                service: service.service,
                claim: claim,
                tz: req.headers["tz"],
              };

              var package = await q.all(getPackageDiscount(getDiscount));
              var labour_list = service.labour;
              var labours = [];

              var discount_eligible_labour_cost = _.sumBy(
                labour_list,
                (x) => x.amount
              );
              if (labour_list.length > 0) {
                for (var l = 0; l < labour_list.length; l++) {
                  var quantity = 1;
                  if (labour_list[l].quantity) {
                    quantity = labour_list[l].quantity;
                  }

                  var discount_total = 0;
                  var total = 0;
                  var tax_info = await Tax.findOne({
                    tax: labour_list[l].tax,
                  }).exec();

                  var tax = [];
                  var rate = labour_list[l].rate;
                  var amount = parseFloat(labour_list[l].amount);
                  var tax_rate = tax_info.detail;
                  var base = amount;

                  if (Object.keys(package).length > 0) {
                    if (package.discount_type == "percent") {
                      discount = parseFloat(package.discount);
                      if (!isNaN(discount) && discount > 0) {
                        var discount_total = amount * (discount / 100);
                        amount = amount - parseFloat(discount_total.toFixed(2));
                        if (amount < 0) {
                          amount = 0;
                        }
                      }
                    } else if (package.discount_type == "fixed") {
                      discount = parseFloat(package.discount);
                      if (!isNaN(discount) && discount > 0) {
                        var discount_total =
                          (amount / discount_eligible_labour_cost) * discount;
                        amount = parseFloat(discount_total.toFixed(2));
                        discount = amount - discount_total;
                        if (amount < 0) {
                          amount = 0;
                        }
                      }
                    } else {
                      discount = parseFloat(package.discount);
                      if (!isNaN(discount) && discount > 0) {
                        var discount_total =
                          (amount / discount_eligible_labour_cost) * discount;
                        amount = amount - parseFloat(discount_total.toFixed(2));
                        if (amount < 0) {
                          amount = 0;
                        }
                      }
                    }
                  }

                  if (labour_list[l].amount_is_tax == "inclusive") {
                    var x = (100 + tax_info.rate) / 100;
                    var tax_on_amount = amount / x;
                    if (tax_rate.length > 0) {
                      for (var r = 0; r < tax_rate.length; r++) {
                        if (tax_rate[r].rate != tax_info.rate) {
                          var t = tax_on_amount * (tax_rate[r].rate / 100);
                          base = base - t;
                          tax.push({
                            tax: tax_rate[r].tax,
                            rate: tax_rate[r].rate,
                            amount: parseFloat(t.toFixed(2)),
                          });
                        } else {
                          var t = amount - tax_on_amount;
                          base = base - t;
                          tax.push({
                            tax: tax_info.tax,
                            tax_rate: tax_info.rate,
                            rate: tax_info.rate,
                            amount: parseFloat(t.toFixed(2)),
                          });
                        }
                      }

                      //base = base - discount_total;
                    }
                    total = total + amount;
                  }

                  var tax_details = {
                    tax: tax_info.tax,
                    rate: tax_info.rate,
                    amount: total,
                    detail: tax,
                  };

                  labours.push({
                    item: labour_list[l].item,
                    source: labour_list[l].source,
                    rate: parseFloat(labour_list[l].rate),
                    quantity: 1,
                    base: parseFloat(total.toFixed(2)),
                    discount: parseFloat(discount_total.toFixed(2)),
                    amount: total,
                    customer_dep: 100,
                    insurance_dep: 0,
                    tax_amount: parseFloat(
                      _.sumBy(tax, (x) => x.amount).toFixed(2)
                    ),
                    amount_is_tax: labour_list[l].amount_is_tax,
                    tax: tax_info.tax,
                    tax_rate: tax_info.rate,
                    tax_info: tax_details,
                  });
                }
              }

              if (service.opening_fitting.length != 0) {
                service.opening_fitting[0].customer_dep = 100;
                service.opening_fitting[0].insurance_dep = 0;
              }

              if (service.parts.length != 0) {
                service.parts[0].customer_dep = 100;
                service.parts[0].insurance_dep = 0;
              }

              packages.push({
                package: service.package,
                service: service.service,
                labour: labours,
                labour_cost: _.sumBy(labours, (x) => x.amount),
                parts: service.parts,
                part_cost: Math.ceil(service.part_cost),
                opening_fitting: service.opening_fitting,
                of_cost: Math.ceil(service.of_cost),
                exceeded_cost: 0,
                mrp:
                  Math.ceil(service.part_cost) +
                  _.sumBy(labours, (x) => x.amount) +
                  _.sumBy(labours, (x) => x.amount) * (40 / 100),
                cost:
                  Math.ceil(service.part_cost) +
                  _.sumBy(labours, (x) => x.amount) +
                  service.of_cost,
                doorstep: service.doorstep,
                unit: service.unit,
                quantity: service.quantity,
                discount:
                  _.sumBy(labours, (x) => x.discount) +
                  _.sumBy(service.opening_fitting, (x) => x.discount) +
                  _.sumBy(service.parts, (x) => x.discount),
                part_cost_editable: service.part_cost_editable,
                labour_cost_editable: service.labour_cost_editable,
                of_cost_editable: service.of_cost_editable,
                type: service.type,
                source: service.id,
                gallery: gallery.length,
                description: service.description,
                coupons: coupons,
                id: service.id,
                _id: service._id,
              });
            });

          await Collision.find({
            business: business,
            segment: car.model.segment,
            publish: true,
            service: new RegExp(req.body.service, "i"),
            business: business,
          })
            .cursor()
            .eachAsync(async (service) => {
              var getDiscount = {
                booking: booking._id,
                package: booking.package,
                car: booking.car,
                category: service.type,
                service: service.service,
                claim: claim,
                tz: req.headers["tz"],
              };
              var package = await q.all(getPackageDiscount(getDiscount));
              var labour_list = service.labour;
              var labours = [];

              var discount_eligible_labour_cost = _.sumBy(
                labour_list,
                (x) => x.amount
              );
              if (labour_list.length > 0) {
                for (var l = 0; l < labour_list.length; l++) {
                  var discount_total = 0;
                  var total = 0;
                  var tax_info = await Tax.findOne({
                    tax: labour_list[l].tax,
                  }).exec();

                  var tax = [];
                  var rate = labour_list[l].rate;
                  var amount = parseFloat(labour_list[l].amount) * quantity;
                  var tax_rate = tax_info.detail;
                  var base = amount;

                  if (Object.keys(package).length > 0) {
                    if (package.discount_type == "percent") {
                      discount = parseFloat(package.discount);
                      if (!isNaN(discount) && discount > 0) {
                        var discount_total = amount * (discount / 100);
                        amount = amount - parseFloat(discount_total.toFixed(2));
                        if (amount < 0) {
                          amount = 0;
                        }
                      }
                    } else if (package.discount_type == "fixed") {
                      discount = parseFloat(package.discount);
                      if (!isNaN(discount) && discount > 0) {
                        var discount_total =
                          (amount / discount_eligible_labour_cost) * discount;
                        amount = parseFloat(discount_total.toFixed(2));
                        discount = amount - discount_total;
                        if (amount < 0) {
                          amount = 0;
                        }
                      }
                    } else {
                      discount = parseFloat(package.discount);
                      if (!isNaN(discount) && discount > 0) {
                        var discount_total =
                          (amount / discount_eligible_labour_cost) * discount;
                        amount = amount - parseFloat(discount_total.toFixed(2));
                        if (amount < 0) {
                          amount = 0;
                        }
                      }
                    }
                  }

                  if (labour_list[l].amount_is_tax == "inclusive") {
                    var x = (100 + tax_info.rate) / 100;
                    var tax_on_amount = amount / x;
                    if (tax_rate.length > 0) {
                      for (var r = 0; r < tax_rate.length; r++) {
                        if (tax_rate[r].rate != tax_info.rate) {
                          var t = tax_on_amount * (tax_rate[r].rate / 100);
                          base = base - t;
                          tax.push({
                            tax: tax_rate[r].tax,
                            rate: tax_rate[r].rate,
                            amount: parseFloat(t.toFixed(2)),
                          });
                        } else {
                          var t = amount - tax_on_amount;
                          base = base - t;
                          tax.push({
                            tax: tax_info.tax,
                            tax_rate: tax_info.rate,
                            rate: tax_info.rate,
                            amount: parseFloat(t.toFixed(2)),
                          });
                        }
                      }

                      //base = base - discount_total;
                    }
                    total = total + amount;
                  }

                  var tax_details = {
                    tax: tax_info.tax,
                    rate: tax_info.rate,
                    amount: total,
                    detail: tax,
                  };

                  labours.push({
                    item: labour_list[l].item,
                    source: labour_list[l].source,
                    rate: parseFloat(labour_list[l].rate),
                    quantity: quantity,
                    base: parseFloat(base.toFixed(2)),
                    discount: parseFloat(discount_total.toFixed(2)),
                    amount: total,
                    customer_dep: 100,
                    insurance_dep: 0,
                    tax_amount: parseFloat(
                      _.sumBy(tax, (x) => x.amount).toFixed(2)
                    ),
                    amount_is_tax: labour_list[l].amount_is_tax,
                    tax: tax_info.tax,
                    tax_rate: tax_info.rate,
                    tax_info: tax_details,
                  });

                  ////////////console.log(base.toFixed(2))
                }
              }

              if (service.opening_fitting.length != 0) {
                service.opening_fitting[0].customer_dep = 100;
                service.opening_fitting[0].insurance_dep = 0;
              }

              if (service.parts.length != 0) {
                service.parts[0].customer_dep = 100;
                service.parts[0].insurance_dep = 0;
              }

              packages.push({
                package: service.package,
                service: service.service,
                labour: labours,
                labour_cost: _.sumBy(labours, (x) => x.amount),
                parts: service.parts,
                discount: _.sumBy(labours, (x) => x.discount),
                part_cost: parseFloat(service.part_cost),
                opening_fitting: service.opening_fitting,
                of_cost: parseFloat(service.of_cost),
                exceeded_cost: 0,
                mrp: parseFloat(service.mrp),
                cost:
                  parseFloat(service.part_cost) +
                  _.sumBy(labours, (x) => x.amount),
                doorstep: service.doorstep,
                unit: service.unit,
                quantity: quantity,
                part_cost_editable: service.part_cost_editable,
                labour_cost_editable: service.labour_cost_editable,
                of_cost_editable: service.of_cost_editable,
                type: service.type,
                source: service.id,
                description: service.description,
                id: service.id,
                _id: service._id,
              });

              packageDiscountOn = [];
            });

          await Customization.find({
            business: business,
            segment: car.model.segment,
            publish: true,
            service: new RegExp(req.body.service, "i"),
            business: business,
          })
            .cursor()
            .eachAsync(async (service) => {
              var getDiscount = {
                booking: booking._id,
                package: booking.package,
                car: booking.car,
                category: service.type,
                service: service.service,
                claim: claim,
                tz: req.headers["tz"],
              };
              var package = await q.all(getPackageDiscount(getDiscount));
              var labour_list = service.labour;
              var labours = [];

              var discount_eligible_labour_cost = _.sumBy(
                labour_list,
                (x) => x.amount
              );
              if (labour_list.length > 0) {
                for (var l = 0; l < labour_list.length; l++) {
                  /*var quantity = 1;*/
                  if (labour_list[l].quantity) {
                    quantity = labour_list[l].quantity;
                  }

                  var discount_total = 0;
                  var total = 0;
                  var tax_info = await Tax.findOne({
                    tax: labour_list[l].tax,
                  }).exec();

                  var tax = [];
                  var rate = labour_list[l].rate;
                  var amount = parseFloat(labour_list[l].amount) * quantity;
                  var tax_rate = tax_info.detail;
                  var base = amount;

                  if (Object.keys(package).length > 0) {
                    if (package.discount_type == "percent") {
                      discount = parseFloat(package.discount);
                      if (!isNaN(discount) && discount > 0) {
                        var discount_total = amount * (discount / 100);
                        amount = amount - parseFloat(discount_total.toFixed(2));
                        if (amount < 0) {
                          amount = 0;
                        }
                      }
                    } else if (package.discount_type == "fixed") {
                      discount = parseFloat(package.discount);
                      if (!isNaN(discount) && discount > 0) {
                        var discount_total =
                          (amount / discount_eligible_labour_cost) * discount;
                        amount = parseFloat(discount_total.toFixed(2));
                        discount = amount - discount_total;
                        if (amount < 0) {
                          amount = 0;
                        }
                      }
                    } else {
                      discount = parseFloat(package.discount);
                      if (!isNaN(discount) && discount > 0) {
                        var discount_total =
                          (amount / discount_eligible_labour_cost) * discount;
                        amount = amount - parseFloat(discount_total.toFixed(2));
                        if (amount < 0) {
                          amount = 0;
                        }
                      }
                    }
                  }

                  if (labour_list[l].amount_is_tax == "inclusive") {
                    var x = (100 + tax_info.rate) / 100;
                    var tax_on_amount = amount / x;
                    if (tax_rate.length > 0) {
                      for (var r = 0; r < tax_rate.length; r++) {
                        if (tax_rate[r].rate != tax_info.rate) {
                          var t = tax_on_amount * (tax_rate[r].rate / 100);
                          base = base - t;
                          tax.push({
                            tax: tax_rate[r].tax,
                            rate: tax_rate[r].rate,
                            amount: parseFloat(t.toFixed(2)),
                          });
                        } else {
                          var t = amount - tax_on_amount;
                          base = base - t;
                          tax.push({
                            tax: tax_info.tax,
                            tax_rate: tax_info.rate,
                            rate: tax_info.rate,
                            amount: parseFloat(t.toFixed(2)),
                          });
                        }
                      }

                      //base = base - discount_total;
                    }
                    total = total + amount;
                  }

                  var tax_details = {
                    tax: tax_info.tax,
                    rate: tax_info.rate,
                    amount: total,
                    detail: tax,
                  };

                  labours.push({
                    item: labour_list[l].item,
                    source: labour_list[l].source,
                    rate: parseFloat(labour_list[l].rate),
                    quantity: quantity,
                    base: parseFloat(base.toFixed(2)),
                    discount: parseFloat(discount_total.toFixed(2)),
                    amount: total,
                    customer_dep: 100,
                    insurance_dep: 0,
                    tax_amount: parseFloat(
                      _.sumBy(tax, (x) => x.amount).toFixed(2)
                    ),
                    amount_is_tax: labour_list[l].amount_is_tax,
                    tax: tax_info.tax,
                    tax_rate: tax_info.rate,
                    tax_info: tax_details,
                  });

                  ////////////console.log(base.toFixed(2))
                }
              }

              if (service.opening_fitting.length != 0) {
                service.opening_fitting[0].customer_dep = 100;
                service.opening_fitting[0].insurance_dep = 0;
              }

              if (service.parts.length != 0) {
                service.parts[0].customer_dep = 100;
                service.parts[0].insurance_dep = 0;
              }

              packages.push({
                package: service.package,
                service: service.service,
                labour: labours,
                discount: _.sumBy(labours, (x) => x.discount),
                labour_cost: _.sumBy(labours, (x) => x.amount),
                parts: service.parts,
                part_cost: parseFloat(service.part_cost),
                opening_fitting: service.opening_fitting,
                of_cost: parseFloat(service.of_cost),
                exceeded_cost: 0,
                mrp: parseFloat(service.mrp),
                cost:
                  parseFloat(service.part_cost) +
                  _.sumBy(labours, (x) => x.amount),
                doorstep: service.doorstep,
                unit: service.unit,
                quantity: quantity,
                part_cost_editable: service.part_cost_editable,
                labour_cost_editable: service.labour_cost_editable,
                of_cost_editable: service.of_cost_editable,
                type: service.type,
                source: service.id,
                description: service.description,
                id: service.id,
                _id: service._id,
              });

              packageDiscountOn = [];
            });

          await Detailing.find({
            business: business,
            segment: car.model.segment,
            publish: true,
            service: new RegExp(req.body.service, "i"),
            business: business,
          })
            .cursor()
            .eachAsync(async (service) => {
              var getDiscount = {
                booking: booking._id,
                package: booking.package,
                car: booking.car,
                category: service.type,
                service: service.service,
                claim: claim,
                tz: req.headers["tz"],
              };
              var package = await q.all(getPackageDiscount(getDiscount));

              var labour_list = service.labour;
              var labours = [];

              var discount_eligible_labour_cost = _.sumBy(
                labour_list,
                (x) => x.amount
              );
              if (labour_list.length > 0) {
                for (var l = 0; l < labour_list.length; l++) {
                  var discount_total = 0;
                  var total = 0;
                  var tax_info = await Tax.findOne({
                    tax: labour_list[l].tax,
                  }).exec();

                  var tax = [];
                  var rate = labour_list[l].rate;
                  var amount = parseFloat(labour_list[l].amount) * quantity;
                  var tax_rate = tax_info.detail;
                  var base = amount;

                  if (Object.keys(package).length > 0) {
                    if (package.discount_type == "percent") {
                      discount = parseFloat(package.discount);
                      if (!isNaN(discount) && discount > 0) {
                        var discount_total = amount * (discount / 100);
                        amount = amount - parseFloat(discount_total.toFixed(2));
                        if (amount < 0) {
                          amount = 0;
                        }
                      }
                    } else if (package.discount_type == "fixed") {
                      discount = parseFloat(package.discount);
                      if (!isNaN(discount) && discount > 0) {
                        var discount_total =
                          (amount / discount_eligible_labour_cost) * discount;
                        amount = parseFloat(discount_total.toFixed(2));
                        discount = amount - discount_total;
                        if (amount < 0) {
                          amount = 0;
                        }
                      }
                    } else {
                      discount = parseFloat(package.discount);
                      if (!isNaN(discount) && discount > 0) {
                        var discount_total =
                          (amount / discount_eligible_labour_cost) * discount;
                        amount = amount - parseFloat(discount_total.toFixed(2));
                        if (amount < 0) {
                          amount = 0;
                        }
                      }
                    }
                  }

                  if (labour_list[l].amount_is_tax == "inclusive") {
                    var x = (100 + tax_info.rate) / 100;
                    var tax_on_amount = amount / x;
                    if (tax_rate.length > 0) {
                      for (var r = 0; r < tax_rate.length; r++) {
                        if (tax_rate[r].rate != tax_info.rate) {
                          var t = tax_on_amount * (tax_rate[r].rate / 100);
                          base = base - t;
                          tax.push({
                            tax: tax_rate[r].tax,
                            rate: tax_rate[r].rate,
                            amount: parseFloat(t.toFixed(2)),
                          });
                        } else {
                          var t = amount - tax_on_amount;
                          base = base - t;
                          tax.push({
                            tax: tax_info.tax,
                            tax_rate: tax_info.rate,
                            rate: tax_info.rate,
                            amount: parseFloat(t.toFixed(2)),
                          });
                        }
                      }

                      //base = base - discount_total;
                    }
                    total = total + amount;
                  }

                  var tax_details = {
                    tax: tax_info.tax,
                    rate: tax_info.rate,
                    amount: total,
                    detail: tax,
                  };

                  labours.push({
                    item: labour_list[l].item,
                    source: labour_list[l].source,
                    rate: parseFloat(labour_list[l].rate),
                    quantity: quantity,
                    base: parseFloat(base.toFixed(2)),
                    discount: parseFloat(discount_total.toFixed(2)),
                    amount: total,
                    customer_dep: 100,
                    insurance_dep: 0,
                    tax_amount: parseFloat(
                      _.sumBy(tax, (x) => x.amount).toFixed(2)
                    ),
                    amount_is_tax: labour_list[l].amount_is_tax,
                    tax: tax_info.tax,
                    tax_rate: tax_info.rate,
                    tax_info: tax_details,
                  });
                }
              }

              if (service.opening_fitting.length != 0) {
                service.opening_fitting[0].customer_dep = 100;
                service.opening_fitting[0].insurance_dep = 0;
              }

              if (service.parts.length != 0) {
                service.parts[0].customer_dep = 100;
                service.parts[0].insurance_dep = 0;
              }

              packages.push({
                package: service.package,
                service: service.service,
                labour: labours,
                discount: _.sumBy(labours, (x) => x.discount),
                labour_cost: _.sumBy(labours, (x) => x.amount),
                parts: service.parts,
                part_cost: parseFloat(service.part_cost),
                opening_fitting: service.opening_fitting,
                of_cost: parseFloat(service.of_cost),
                exceeded_cost: 0,
                mrp: parseFloat(service.mrp),
                cost:
                  parseFloat(service.part_cost) +
                  _.sumBy(labours, (x) => x.amount),
                doorstep: service.doorstep,
                unit: service.unit,
                quantity: quantity,
                part_cost_editable: service.part_cost_editable,
                labour_cost_editable: service.labour_cost_editable,
                of_cost_editable: service.of_cost_editable,
                type: service.type,
                source: service.id,
                description: service.description,
                id: service.id,
                _id: service._id,
              });

              packageDiscountOn = [];
            });

          var package = packages.sort((a, b) => b.publish - a.publish);

          res.status(200).json({
            responseCode: 200,
            responseMessage: "",
            responseData: package,
          });
        } else {
          res.status(400).json({
            responseCode: 400,
            responseMessage: "Car not found",
            responseData: {},
          });
        }
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Booking not found",
          responseData: {},
        });
      }
    }
  }
);

router.get(
  "/user/packages/get",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      type: "required",
      query: "required",
    };

    var validation = new Validator(req.query, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Validation Error",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var business = req.headers["business"];
      var labour_cost = 0;
      var part_cost = 0;
      var of_cost = 0;
      var due_amount = 0;
      var totalResult = 0;
      var bookingService = [];

      if (req.query.type == "booking") {
        var booking = await Booking.findById(req.query.query).exec();
        if (booking) {
          var user = booking.user;
          var car = booking.car;
          var packages = [];

          var purchased = [];

          await UserPackage.find({
            user: user,
            business: business,
            $or: [{ car: car }, { car: null }],
          })
            .cursor()
            .eachAsync(async (package) => {
              var serverTime = moment.tz(new Date(), req.headers["tz"]);
              var bar = package.created_at;
              bar.setDate(bar.getDate() + package.validity);
              var e = bar;
              bar = moment.tz(bar, req.headers["tz"]);

              var baz = bar.diff(serverTime);
              if (baz > 0) {
                purchased.push(package._id);
                packages.push({
                  package: package._id,
                  name: package.name,
                  description: package.description,
                  payment: package.payment,
                  discount: package.discount,
                  type: "package",
                  cost: package.cost,
                  id: package._id,
                  _id: package._id,
                  category: package.category,
                  label: package.label,
                  validity: package.validity,
                  expired_at: moment(e).tz(req.headers["tz"]).format("ll"),
                  listing: "purchased",
                });
              }
            });

          await Package.find({ label: "special" })
            .cursor()
            .eachAsync(async (service) => {
              var serverTime = moment.tz(new Date(), req.headers["tz"]);

              var bar = service.created_at;
              bar.setDate(bar.getDate() + service.validity);

              var e = bar;
              bar = moment.tz(bar, req.headers["tz"]);

              var baz = bar.diff(serverTime);

              var check = await UserPackage.find({
                user: user,
                package: service._id,
                car: car.car,
              })
                .count()
                .exec();
              if (check <= 0) {
                if (baz > 0) {
                  packages.push({
                    package: service._id,
                    name: service.name + " - (Package)",
                    mrp: 0,
                    discount: service.discount,
                    labour_cost: service.cost,
                    part_cost: 0,
                    type: "package",
                    cost: service.cost,
                    id: service.id,
                    _id: service._id,
                    label: service.label,
                    doorstep: false,
                    validity: service.validity,
                    doorstep: service.doorstep,
                    expired_at: moment(service.expired_at)
                      .tz(req.headers["tz"])
                      .format("ll"),
                    listing: "new",
                  });
                }
              }
            });

          res.status(200).json({
            responseCode: 200,
            responseMessage: "",
            responseData: packages,
          });
        } else {
          res.status(400).json({
            responseCode: 400,
            responseMessage: "Booking not found",
            responseData: {},
          });
        }
      } else if (req.query.type == "user") {
        var booking = await Booking.findById(req.query.query).exec();
        if (booking) {
          var user = booking.user;
          var car = booking.car;
          var packages = [];

          var purchased = [];

          await UserPackage.find({ user: user, car: car, business: business })
            .cursor()
            .eachAsync(async (package) => {
              var serverTime = moment.tz(new Date(), req.headers["tz"]);
              var bar = package.created_at;
              bar.setDate(bar.getDate() + package.validity);
              var e = bar;
              bar = moment.tz(bar, req.headers["tz"]);

              var baz = bar.diff(serverTime);
              if (baz > 0) {
                purchased.push(package._id);
                packages.push({
                  package: package._id,
                  name: package.name,
                  description: package.description,
                  payment: package.payment,
                  discount: package.discount,
                  type: "package",
                  cost: package.cost,
                  id: package._id,
                  _id: package._id,
                  category: package.category,
                  label: package.label,
                  validity: package.validity,
                  expired_at: moment(e).tz(req.headers["tz"]).format("ll"),
                  listing: "purchased",
                });
              }
            });

          await Package.find({ label: "special" })
            .cursor()
            .eachAsync(async (service) => {
              var serverTime = moment.tz(new Date(), req.headers["tz"]);

              var bar = service.created_at;
              bar.setDate(bar.getDate() + service.validity);

              var e = bar;
              bar = moment.tz(bar, req.headers["tz"]);

              var baz = bar.diff(serverTime);

              var check = await UserPackage.find({
                user: user,
                package: service._id,
                car: car.car,
              })
                .count()
                .exec();
              if (check <= 0) {
                if (baz > 0) {
                  packages.push({
                    package: service._id,
                    service: service.name,
                    mrp: 0,
                    discount: service.discount,
                    labour_cost: service.cost,
                    part_cost: 0,
                    type: "package",
                    cost: service.cost,
                    id: service.id,
                    _id: service._id,
                    label: service.label,
                    doorstep: false,
                    validity: service.validity,
                    doorstep: service.doorstep,
                    expired_at: moment(service.expired_at)
                      .tz(req.headers["tz"])
                      .format("ll"),
                    listing: "new",
                  });
                }
              }
            });

          res.status(200).json({
            responseCode: 200,
            responseMessage: "",
            responseData: packages,
          });
        } else {
          res.status(400).json({
            responseCode: 400,
            responseMessage: "Booking not found",
            responseData: {},
          });
        }
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Packages not found",
          responseData: {},
        });
      }
    }
  }
);

router.post(
  "/booking/package/add",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      booking: "required",
      listing: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Validation Error",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var business = req.headers["business"];
      var labour_cost = 0;
      var part_cost = 0;
      var of_cost = 0;
      var due_amount = 0;
      var totalResult = 0;
      var bookingService = [];
      var booking = await Booking.findById(req.body.booking).exec();
      if (booking) {
        if (booking.insurance_info) {
          if (booking.insurance_info.claim == true) {
            var claim = true;
          } else {
            var claim = false;
          }
        } else {
          var claim = false;
        }

        var listing = req.body.listing;

        if (claim == false) {
          if (listing == "purchased") {
            var package = await UserPackage.findOne({
              user: booking.user,
              _id: req.body.package,
            }).exec();
            if (package) {
              Booking.findOneAndUpdate(
                { _id: booking._id },
                { $set: { package: package._id } },
                { new: false },
                async function (err, doc) {
                  if (err) {
                    res.status(400).json({
                      responseCode: 400,
                      responseMessage: "Error Occurred! Try again.",
                      responseData: {},
                    });
                  } else {
                    var updated = await Booking.findById(
                      req.body.booking
                    ).exec();
                    var services = updated.services;

                    for (var i = 0; i < services.length; i++) {
                      if (services[i].claim == true) {
                        bookingService.push(services[i]);
                      } else {
                        var getDiscount = {
                          booking: updated._id,
                          package: updated.package,
                          car: updated.car,
                          category: services[i].type,
                          service: services[i].service,
                          claim: services[i].claim,
                          tz: req.headers["tz"],
                        };

                        var package = await q.all(
                          getPackageDiscount(getDiscount)
                        );

                        var labour_list = services[i].labour;
                        var labours = [];

                        var discount_eligible_labour_cost = _.sumBy(
                          labour_list,
                          (x) => x.rate * x.quantity
                        );
                        if (labour_list.length > 0) {
                          for (var l = 0; l < labour_list.length; l++) {
                            var discount = req.body.discount;
                            var discount_total = 0;
                            var total = 0;
                            var tax_info = await Tax.findOne({
                              tax: labour_list[l].tax,
                            }).exec();

                            var tax = [];
                            var rate = labour_list[l].rate;
                            var amount =
                              parseFloat(labour_list[l].rate) *
                              parseFloat(labour_list[l].quantity);
                            var tax_rate = tax_info.detail;
                            var base = amount;

                            if (Object.keys(package).length > 0) {
                              ////////////console.log("y")
                              if (package.discount_type == "percent") {
                                discount = parseFloat(package.discount);
                                if (!isNaN(discount) && discount > 0) {
                                  var discount_total =
                                    amount * (discount / 100);
                                  amount =
                                    amount -
                                    parseFloat(discount_total.toFixed(2));
                                  if (amount < 0) {
                                    amount = 0;
                                  }
                                }
                              } else if (package.discount_type == "fixed") {
                                discount = parseFloat(package.discount);
                                if (!isNaN(discount) && discount > 0) {
                                  var discount_total =
                                    (amount / discount_eligible_labour_cost) *
                                    discount;
                                  amount = parseFloat(
                                    discount_total.toFixed(2)
                                  );
                                  discount = amount - discount_total;
                                  if (amount < 0) {
                                    amount = 0;
                                  }
                                }
                              } else {
                                discount = parseFloat(package.discount);
                                if (!isNaN(discount) && discount > 0) {
                                  var discount_total =
                                    (amount / discount_eligible_labour_cost) *
                                    discount;
                                  amount =
                                    amount -
                                    parseFloat(discount_total.toFixed(2));
                                  if (amount < 0) {
                                    amount = 0;
                                  }
                                }
                              }
                            }

                            if (labour_list[l].amount_is_tax == "exclusive") {
                              var tax_on_amount = amount;
                              if (tax_rate.length > 0) {
                                for (var r = 0; r < tax_rate.length; r++) {
                                  if (tax_rate[r].rate != tax_info.rate) {
                                    var t =
                                      tax_on_amount * (tax_rate[r].rate / 100);
                                    amount = amount + t;
                                    tax.push({
                                      tax: tax_rate[r].tax,
                                      rate: tax_rate[r].rate,
                                      amount: parseFloat(t.toFixed(2)),
                                    });
                                  } else {
                                    var t =
                                      tax_on_amount * (tax_rate[r].rate / 100);
                                    amount = amount + t;
                                    tax.push({
                                      tax: tax_info.tax,
                                      tax_rate: tax_info.rate,
                                      rate: tax_info.rate,
                                      amount: parseFloat(t.toFixed(2)),
                                    });
                                  }
                                }
                              }
                              total = total + amount;
                            }

                            if (labour_list[l].amount_is_tax == "inclusive") {
                              var x = (100 + tax_info.rate) / 100;
                              var tax_on_amount = amount / x;
                              if (tax_rate.length > 0) {
                                for (var r = 0; r < tax_rate.length; r++) {
                                  if (tax_rate[r].rate != tax_info.rate) {
                                    var t =
                                      tax_on_amount * (tax_rate[r].rate / 100);
                                    base = base - t;
                                    tax.push({
                                      tax: tax_rate[r].tax,
                                      rate: tax_rate[r].rate,
                                      amount: parseFloat(t.toFixed(2)),
                                    });
                                  } else {
                                    var t = amount - tax_on_amount;
                                    base = base - t;
                                    tax.push({
                                      tax: tax_info.tax,
                                      tax_rate: tax_info.rate,
                                      rate: tax_info.rate,
                                      amount: parseFloat(t.toFixed(2)),
                                    });
                                  }
                                }
                                //base = base - discount_total;
                              }
                              total = total + amount;
                            }

                            var tax_details = {
                              tax: tax_info.tax,
                              rate: tax_info.rate,
                              amount: total,
                              detail: tax,
                            };

                            if (!labour_list[l].customer_dep) {
                              customer_dep = 100;
                            } else {
                              customer_dep = labour_list[l].customer_dep;
                            }

                            if (!labour_list[l].insurance_dep) {
                              insurance_dep = 0;
                            } else {
                              insurance_dep = labour_list[l].insurance_dep;
                            }

                            labours.push({
                              item: labour_list[l].item,
                              source: labour_list[l].source,
                              rate: parseFloat(labour_list[l].rate),
                              quantity: parseFloat(labour_list[l].quantity),
                              base: parseFloat(base.toFixed(2)),
                              discount: parseFloat(discount_total.toFixed(2)),
                              amount: total,
                              customer_dep: customer_dep,
                              insurance_dep: insurance_dep,
                              tax_amount: parseFloat(
                                _.sumBy(tax, (x) => x.amount).toFixed(2)
                              ),
                              amount_is_tax: labour_list[l].amount_is_tax,
                              tax: tax_info.tax,
                              tax_rate: tax_info.rate,
                              tax_info: tax_details,
                            });

                            ////////////console.log(labours)
                          }

                          bookingService.push({
                            part_cost: services[i].part_cost,
                            labour_cost: _.sumBy(labours, (x) => x.amount),
                            of_cost: services[i].of_cost,
                            exceeded_cost: services[i].exceeded_cost,
                            part_rate: services[i].part_rate,
                            labour_rate: services[i].labour_rate,
                            quantity: services[i].quantity,
                            of_rate: services[i].of_rate,
                            parts: services[i].parts,
                            labour: labours,
                            cost:
                              services[i].part_cost +
                              _.sumBy(labours, (x) => x.amount) +
                              services[i].of_cost,
                            discount:
                              _.sumBy(labours, (x) => x.discount) +
                              _.sumBy(
                                services[i].opening_fitting,
                                (x) => x.discount
                              ) +
                              _.sumBy(services[i].parts, (x) => x.discount),
                            opening_fitting: services[i].opening_fitting,
                            part_cost_editable: services[i].part_cost_editable,
                            labour_cost_editable:
                              services[i].part_cost_editable,
                            of_cost_editable: services[i].part_cost_editable,
                            description: services[i].description,
                            service: services[i].service,
                            type: services[i].type,
                            claim: services[i].claim,
                            custom: services[i].custom,
                            customer_approval: services[i].customer_approval,
                            surveyor_approval: services[i].surveyor_approval,
                            source: services[i].source,
                          });
                        }
                      }
                    }

                    var policy_clause = 0;
                    if (booking.payment.policy_clause) {
                      policy_clause = booking.payment.policy_clause;
                    }
                    var salvage = 0;
                    if (booking.payment.salvage) {
                      salvage = booking.payment.salvage;
                    }

                    var approved = _.filter(
                      bookingService,
                      (customer_approval) =>
                        customer_approval.customer_approval == true
                    );

                    var labour_cost = _.sumBy(
                      bookingService,
                      (x) => x.labour_cost
                    );
                    var part_cost = _.sumBy(bookingService, (x) => x.part_cost);
                    var of_cost = _.sumBy(bookingService, (x) => x.of_cost);
                    var discount_total = _.sumBy(
                      bookingService,
                      (x) => x.discount
                    );
                    var pick_up_charges = booking.payment.pick_up_charges;

                    var paid_total = booking.payment.paid_total;

                    var careager_cash = await q.all(
                      fun.getBookingCarEagerCash(booking._id)
                    );

                    var payment_total =
                      labour_cost +
                      part_cost +
                      of_cost +
                      discount_total +
                      policy_clause +
                      salvage +
                      pick_up_charges;

                    var estimate_cost =
                      labour_cost +
                      part_cost +
                      of_cost +
                      policy_clause +
                      salvage +
                      pick_up_charges -
                      careager_cash;

                    var due_amount =
                      _.sumBy(approved, (x) => x.labour_cost) +
                      _.sumBy(approved, (x) => x.part_cost) +
                      _.sumBy(approved, (x) => x.of_cost) +
                      policy_clause +
                      salvage +
                      pick_up_charges -
                      (paid_total + careager_cash);

                    var due = {
                      due: Math.ceil(due_amount.toFixed(2)),
                    };

                    var payment = {
                      total: payment_total,
                      careager_cash: careager_cash,
                      estimate_cost: estimate_cost,
                      of_cost: of_cost,
                      labour_cost: labour_cost,
                      part_cost: part_cost,
                      payment_mode: booking.payment.payment_mode,
                      payment_status: booking.payment.payment_status,
                      coupon: "",
                      coupon_type: "",
                      discount_by: "",
                      discount_type: "Package",
                      discount: discount_total,
                      discount_total: discount_total,
                      policy_clause: policy_clause,
                      salvage: salvage,
                      terms: booking.payment.terms,
                      pick_up_limit: booking.payment.pick_up_limit,
                      pick_up_charges: booking.payment.pick_up_charges,
                      paid_total: parseFloat(booking.payment.paid_total),
                      discount_applied: booking.payment.discount_applied,
                      transaction_id: booking.payment.transaction_id,
                      transaction_date: booking.payment.transaction_date,
                      transaction_status: booking.payment.transaction_status,
                      transaction_response:
                        booking.payment.transaction_response,
                    };

                    Booking.findOneAndUpdate(
                      { _id: req.body.booking },
                      {
                        $set: {
                          services: bookingService,
                          payment: payment,
                          due: due,
                        },
                      },
                      { new: false },
                      async function (err, doc) {
                        if (err) {
                          res.status(400).json({
                            responseCode: 400,
                            responseMessage: "Error 1",
                            responseData: err,
                          });
                        } else {
                          var updated = await Booking.findById(
                            req.body.booking
                          ).exec();
                          res.status(200).json({
                            responseCode: 200,
                            responseMessage: "Package has been applied",
                            responseData: updated,
                          });
                        }
                      }
                    );
                  }
                }
              );
            } else {
              res.status(400).json({
                responseCode: 400,
                responseMessage: "Package not found",
                responseData: {},
              });
            }
          } else if (listing == "new") {
            var getPackage = await Package.findOne({
              _id: req.body.package,
            }).exec();
            if (getPackage) {
              var expired_at = new Date();
              expired_at.setDate(expired_at.getDate() + getPackage.validity);
              var check = await UserPackage.find({
                package: req.body.package,
                user: booking.user,
                car: booking.car,
              }).exec();

              if (check <= 0) {
                UserPackage.create({
                  user: booking.user,
                  car: booking.car,
                  name: getPackage.name,
                  booking: booking._id,
                  business: booking.business,
                  description: getPackage.description,
                  category: getPackage.category,
                  package: getPackage._id,
                  payment: {
                    total: getPackage.cost,
                    paid_total: getPackage.cost,
                  },
                  discount: getPackage.discount,
                  validity: getPackage.validity,
                  expired_at: expired_at,
                  status: false,
                  created_at: new Date(),
                  updated_at: new Date(),
                }).then(async function (package) {
                  var package_array = [];
                  var tax_info = await Tax.findOne({ tax: "18.0% GST" }).exec();
                  var tax_rate = tax_info.detail;

                  var amount = parseFloat(getPackage.cost);
                  var base = amount;
                  var package_tax = [];

                  var x = (100 + tax_info.rate) / 100;
                  var tax_on_amount = amount / x;
                  if (tax_rate.length > 0) {
                    for (var r = 0; r < tax_rate.length; r++) {
                      if (tax_rate[r].rate != tax_info.rate) {
                        var t = tax_on_amount * (tax_rate[r].rate / 100);
                        base = base - t;
                        package_tax.push({
                          tax: tax_rate[r].tax,
                          rate: parseFloat(tax_rate[r].rate.toFixed(2)),
                          amount: parseFloat(t.toFixed(2)),
                        });
                      } else {
                        base = base - t;
                        package_tax.push({
                          tax: tax_info.tax,
                          tax_rate: tax_info.rate,
                          rate: parseFloat(tax_info.rate.toFixed(2)),
                          amount: parseFloat(tax_on_amount.toFixed(2)),
                        });
                      }
                    }
                  }

                  package_array.push({
                    item: getPackage.name,
                    quantity: 1,
                    rate: parseFloat(getPackage.cost),
                    base: parseFloat(base.toFixed(2)),
                    amount: parseFloat(amount),
                    discount: 0,
                    amount_is_tax: "inclusive",
                    tax_amount: _.sumBy(package_tax, (x) => x.amount),
                    tax: tax_info.tax,
                    tax_rate: tax_info.rate,
                    tax_info: {
                      tax: tax_info.tax,
                      tax_rate: tax_info.rate,
                      rate: tax_info.rate,
                      base: parseFloat(base.toFixed(2)),
                      detail: package_tax,
                    },
                  });

                  var service = {
                    source: package._id,
                    service: getPackage.name,
                    description: package.description,
                    cost: parseFloat(getPackage.cost),
                    labour_cost: parseFloat(getPackage.cost),
                    labour: package_array,
                    part_cost: 0,
                    parts: [],
                    opening_fitting: [],
                    of_cost: 0,
                    custom: false,
                    claim: false,
                    discount: 0,
                    part_cost_editable: false,
                    labour_cost_editable: false,
                    of_cost_editable: false,
                    customer_approval: false,
                    surveyor_approval: false,
                    type: "package",
                  };

                  bookingService.push(service);

                  Booking.findOneAndUpdate(
                    { _id: req.body.booking },
                    { $set: { package: package._id } },
                    { new: false },
                    async function (err, doc) {
                      var updated = await Booking.findById(
                        req.body.booking
                      ).exec();

                      var services = updated.services;

                      if (services.length > 0) {
                        for (var i = 0; i < services.length; i++) {
                          if (services[i].claim == true) {
                            bookingService.push(services[i]);
                          } else {
                            var getDiscount = {
                              booking: updated._id,
                              package: updated.package,
                              car: updated.car,
                              category: services[i].type,
                              service: services[i].service,
                              claim: services[i].claim,
                              tz: req.headers["tz"],
                            };

                            var package = await q.all(
                              getPackageDiscount(getDiscount)
                            );

                            var labour_list = services[i].labour;
                            var labours = [];

                            var discount_eligible_labour_cost = _.sumBy(
                              labour_list,
                              (x) => x.rate * x.quantity
                            );
                            if (labour_list.length > 0) {
                              for (var l = 0; l < labour_list.length; l++) {
                                var discount = req.body.discount;
                                var discount_total = 0;
                                var total = 0;
                                var tax_info = await Tax.findOne({
                                  tax: labour_list[l].tax,
                                }).exec();

                                var tax = [];
                                var rate = labour_list[l].rate;
                                var amount =
                                  parseFloat(labour_list[l].rate) *
                                  parseFloat(labour_list[l].quantity);
                                var tax_rate = tax_info.detail;
                                var base = amount;

                                if (Object.keys(package).length > 0) {
                                  if (package.discount_type == "percent") {
                                    discount = parseFloat(package.discount);
                                    if (!isNaN(discount) && discount > 0) {
                                      var discount_total =
                                        amount * (discount / 100);
                                      amount =
                                        amount -
                                        parseFloat(discount_total.toFixed(2));
                                      if (amount < 0) {
                                        amount = 0;
                                      }
                                    }
                                  } else if (package.discount_type == "fixed") {
                                    discount = parseFloat(package.discount);
                                    if (!isNaN(discount) && discount > 0) {
                                      var discount_total =
                                        (amount /
                                          discount_eligible_labour_cost) *
                                        discount;
                                      amount = parseFloat(
                                        discount_total.toFixed(2)
                                      );
                                      discount = amount - discount_total;
                                      if (amount < 0) {
                                        amount = 0;
                                      }
                                    }
                                  } else {
                                    discount = parseFloat(package.discount);
                                    if (!isNaN(discount) && discount > 0) {
                                      var discount_total =
                                        (amount /
                                          discount_eligible_labour_cost) *
                                        discount;
                                      amount =
                                        amount -
                                        parseFloat(discount_total.toFixed(2));
                                      if (amount < 0) {
                                        amount = 0;
                                      }
                                    }
                                  }
                                }

                                if (
                                  labour_list[l].amount_is_tax == "exclusive"
                                ) {
                                  var tax_on_amount = amount;
                                  if (tax_rate.length > 0) {
                                    for (var r = 0; r < tax_rate.length; r++) {
                                      if (tax_rate[r].rate != tax_info.rate) {
                                        var t =
                                          tax_on_amount *
                                          (tax_rate[r].rate / 100);
                                        amount = amount + t;
                                        tax.push({
                                          tax: tax_rate[r].tax,
                                          rate: tax_rate[r].rate,
                                          amount: parseFloat(t.toFixed(2)),
                                        });
                                      } else {
                                        var t =
                                          tax_on_amount *
                                          (tax_rate[r].rate / 100);
                                        amount = amount + t;
                                        tax.push({
                                          tax: tax_info.tax,
                                          tax_rate: tax_info.rate,
                                          rate: tax_info.rate,
                                          amount: parseFloat(t.toFixed(2)),
                                        });
                                      }
                                    }
                                  }
                                  total = total + amount;
                                }

                                if (
                                  labour_list[l].amount_is_tax == "inclusive"
                                ) {
                                  var x = (100 + tax_info.rate) / 100;
                                  var tax_on_amount = amount / x;
                                  if (tax_rate.length > 0) {
                                    for (var r = 0; r < tax_rate.length; r++) {
                                      if (tax_rate[r].rate != tax_info.rate) {
                                        var t =
                                          tax_on_amount *
                                          (tax_rate[r].rate / 100);
                                        base = base - t;
                                        tax.push({
                                          tax: tax_rate[r].tax,
                                          rate: tax_rate[r].rate,
                                          amount: parseFloat(t.toFixed(2)),
                                        });
                                      } else {
                                        var t = amount - tax_on_amount;
                                        base = base - t;
                                        tax.push({
                                          tax: tax_info.tax,
                                          tax_rate: tax_info.rate,
                                          rate: tax_info.rate,
                                          amount: parseFloat(t.toFixed(2)),
                                        });
                                      }
                                    }

                                    //base = base - discount_total;
                                  }
                                  total = total + amount;
                                }

                                var tax_details = {
                                  tax: tax_info.tax,
                                  rate: tax_info.rate,
                                  amount: total,
                                  detail: tax,
                                };

                                ////////////console.log(discount_total)
                                if (!labour_list[l].customer_dep) {
                                  customer_dep = 100;
                                } else {
                                  customer_dep = labour_list[l].customer_dep;
                                }

                                if (!labour_list[l].insurance_dep) {
                                  insurance_dep = 0;
                                } else {
                                  insurance_dep = labour_list[l].insurance_dep;
                                }

                                labours.push({
                                  item: labour_list[l].item,
                                  source: labour_list[l].source,
                                  rate: parseFloat(labour_list[l].rate),
                                  quantity: parseFloat(labour_list[l].quantity),
                                  base: parseFloat(base.toFixed(2)),
                                  discount: parseFloat(
                                    discount_total.toFixed(2)
                                  ),
                                  amount: total,
                                  customer_dep: customer_dep,
                                  insurance_dep: insurance_dep,
                                  tax_amount: parseFloat(
                                    _.sumBy(tax, (x) => x.amount).toFixed(2)
                                  ),
                                  amount_is_tax: labour_list[l].amount_is_tax,
                                  tax: tax_info.tax,
                                  tax_rate: tax_info.rate,
                                  tax_info: tax_details,
                                });
                              }

                              bookingService.push({
                                part_cost: services[i].part_cost,
                                labour_cost: _.sumBy(labours, (x) => x.amount),
                                of_cost: services[i].of_cost,
                                exceeded_cost: services[i].exceeded_cost,
                                part_rate: services[i].part_rate,
                                labour_rate: services[i].labour_rate,
                                quantity: services[i].quantity,
                                of_rate: services[i].of_rate,
                                parts: services[i].parts,
                                labour: labours,
                                cost:
                                  services[i].part_cost +
                                  _.sumBy(labours, (x) => x.amount) +
                                  services[i].of_cost,
                                discount:
                                  _.sumBy(labours, (x) => x.discount) +
                                  _.sumBy(
                                    services[i].opening_fitting,
                                    (x) => x.discount
                                  ) +
                                  _.sumBy(services[i].parts, (x) => x.discount),
                                opening_fitting: services[i].opening_fitting,
                                part_cost_editable:
                                  services[i].part_cost_editable,
                                labour_cost_editable:
                                  services[i].part_cost_editable,
                                of_cost_editable:
                                  services[i].part_cost_editable,
                                description: services[i].description,
                                service: services[i].service,
                                type: services[i].type,
                                custom: services[i].custom,
                                claim: services[i].claim,
                                customer_approval:
                                  services[i].customer_approval,
                                surveyor_approval:
                                  services[i].surveyor_approval,
                                source: services[i].source,
                              });
                            }
                          }
                        }
                      }

                      var policy_clause = 0;
                      if (booking.payment.policy_clause) {
                        policy_clause = booking.payment.policy_clause;
                      }
                      var salvage = 0;
                      if (booking.payment.salvage) {
                        salvage = booking.payment.salvage;
                      }

                      var approved = _.filter(
                        bookingService,
                        (customer_approval) =>
                          customer_approval.customer_approval == true
                      );

                      var paid_total = booking.payment.paid_total;

                      var labour_cost = _.sumBy(
                        bookingService,
                        (x) => x.labour_cost
                      );
                      var part_cost = _.sumBy(
                        bookingService,
                        (x) => x.part_cost
                      );
                      var of_cost = _.sumBy(bookingService, (x) => x.of_cost);
                      var discount_total = _.sumBy(
                        bookingService,
                        (x) => x.discount
                      );
                      var pick_up_charges = booking.payment.pick_up_charges;
                      var careager_cash = await q.all(
                        fun.getBookingCarEagerCash(booking._id)
                      );

                      var payment_total =
                        labour_cost +
                        part_cost +
                        of_cost +
                        discount_total +
                        policy_clause +
                        salvage +
                        pick_up_charges;

                      var estimate_cost =
                        labour_cost +
                        part_cost +
                        of_cost +
                        policy_clause +
                        salvage +
                        pick_up_charges -
                        careager_cash;
                      var due_amount =
                        _.sumBy(approved, (x) => x.labour_cost) +
                        _.sumBy(approved, (x) => x.part_cost) +
                        _.sumBy(approved, (x) => x.of_cost) +
                        policy_clause +
                        salvage +
                        pick_up_charges -
                        (paid_total + careager_cash);

                      var due = {
                        due: Math.ceil(due_amount.toFixed(2)),
                      };

                      var payment = {
                        estimate_cost: estimate_cost,
                        total: payment_total,
                        careager_cash: careager_cash,
                        of_cost: of_cost,
                        labour_cost: labour_cost,
                        part_cost: part_cost,
                        payment_mode: booking.payment.payment_mode,
                        payment_status: booking.payment.payment_status,
                        coupon: "",
                        coupon_type: "",
                        discount_by: "",
                        discount_type: "Package",
                        discount: discount_total,
                        discount_total: discount_total,
                        policy_clause: policy_clause,
                        salvage: salvage,
                        terms: booking.payment.terms,
                        pick_up_limit: booking.payment.pick_up_limit,
                        pick_up_charges: booking.payment.pick_up_charges,
                        paid_total: parseFloat(booking.payment.paid_total),
                        discount_applied: booking.payment.discount_applied,
                        transaction_id: booking.payment.transaction_id,
                        transaction_date: booking.payment.transaction_date,
                        transaction_status: booking.payment.transaction_status,
                        transaction_response:
                          booking.payment.transaction_response,
                      };

                      Booking.findOneAndUpdate(
                        { _id: req.body.booking },
                        {
                          $set: {
                            services: bookingService,
                            payment: payment,
                            due: due,
                          },
                        },
                        { new: false },
                        async function (err, doc) {
                          if (err) {
                            res.status(400).json({
                              responseCode: 400,
                              responseMessage: "Error",
                              responseData: err,
                            });
                          } else {
                            var updated = await Booking.findById(
                              req.body.booking
                            ).exec();
                            res.status(200).json({
                              responseCode: 200,
                              responseMessage: "Package has been applied",
                              responseData: updated,
                            });
                          }
                        }
                      );
                    }
                  );
                });
              } else {
                res.status(400).json({
                  responseCode: 400,
                  responseMessage: "Package has been already applied",
                  responseData: {},
                });
              }
            } else {
              res.status(400).json({
                responseCode: 400,
                responseMessage: "Package not found",
                responseData: {},
              });
            }
          } else {
            Booking.findOneAndUpdate(
              { _id: booking._id },
              { $set: { package: null } },
              { new: false },
              async function (err, doc) {
                if (err) {
                  res.status(400).json({
                    responseCode: 400,
                    responseMessage: "Error Occurred! Try again.",
                    responseData: {},
                  });
                } else {
                  await UserPackage.remove({
                    user: booking.user,
                    status: false,
                  }).exec();

                  var updated = await Booking.findById(req.body.booking).exec();
                  var services = updated.services;

                  for (var i = 0; i < services.length; i++) {
                    if (services[i].type != "package") {
                      if (services[i].claim == true) {
                        bookingService.push(services[i]);
                      } else {
                        var getDiscount = {
                          booking: updated._id,
                          package: null,
                          car: updated.car,
                          category: services[i].type,
                          service: services[i].service,
                          claim: services[i].claim,
                          tz: req.headers["tz"],
                        };

                        var package = await q.all(
                          getPackageDiscount(getDiscount)
                        );

                        var labour_list = services[i].labour;
                        var labours = [];

                        var discount_eligible_labour_cost = _.sumBy(
                          labour_list,
                          (x) => x.rate * x.quantity
                        );
                        ////////////console.log(discount_eligible_labour_cost)
                        if (labour_list.length > 0) {
                          for (var l = 0; l < labour_list.length; l++) {
                            var discount = req.body.discount;
                            var discount_total = 0;
                            var total = 0;
                            var tax_info = await Tax.findOne({
                              tax: labour_list[l].tax,
                            }).exec();

                            var tax = [];
                            var rate = labour_list[l].rate;
                            var amount =
                              parseFloat(labour_list[l].rate) *
                              parseFloat(labour_list[l].quantity);
                            var tax_rate = tax_info.detail;
                            var base = amount;

                            if (Object.keys(package).length > 0) {
                              ////////////console.log("y")
                              if (package.discount_type == "percent") {
                                discount = parseFloat(package.discount);
                                if (!isNaN(discount) && discount > 0) {
                                  var discount_total =
                                    amount * (discount / 100);
                                  amount =
                                    amount -
                                    parseFloat(discount_total.toFixed(2));
                                }
                              } else if (package.discount_type == "fixed") {
                                discount = parseFloat(package.discount);
                                if (!isNaN(discount) && discount > 0) {
                                  var discount_total =
                                    (amount / discount_eligible_labour_cost) *
                                    discount;
                                  amount = parseFloat(
                                    discount_total.toFixed(2)
                                  );
                                  discount = amount - discount_total;
                                }
                              } else {
                                discount = parseFloat(package.discount);
                                if (!isNaN(discount) && discount > 0) {
                                  var discount_total =
                                    (amount / discount_eligible_labour_cost) *
                                    discount;
                                  amount =
                                    amount -
                                    parseFloat(discount_total.toFixed(2));
                                }
                              }
                            }

                            if (labour_list[l].amount_is_tax == "exclusive") {
                              var tax_on_amount = amount;
                              if (tax_rate.length > 0) {
                                for (var r = 0; r < tax_rate.length; r++) {
                                  if (tax_rate[r].rate != tax_info.rate) {
                                    var t =
                                      tax_on_amount * (tax_rate[r].rate / 100);
                                    amount = amount + t;
                                    tax.push({
                                      tax: tax_rate[r].tax,
                                      rate: tax_rate[r].rate,
                                      amount: parseFloat(t.toFixed(2)),
                                    });
                                  } else {
                                    var t =
                                      tax_on_amount * (tax_rate[r].rate / 100);
                                    amount = amount + t;
                                    tax.push({
                                      tax: tax_info.tax,
                                      tax_rate: tax_info.rate,
                                      rate: tax_info.rate,
                                      amount: parseFloat(t.toFixed(2)),
                                    });
                                  }
                                }
                              }
                              total = total + amount;
                            }

                            if (labour_list[l].amount_is_tax == "inclusive") {
                              var x = (100 + tax_info.rate) / 100;
                              var tax_on_amount = amount / x;
                              if (tax_rate.length > 0) {
                                for (var r = 0; r < tax_rate.length; r++) {
                                  if (tax_rate[r].rate != tax_info.rate) {
                                    var t =
                                      tax_on_amount * (tax_rate[r].rate / 100);
                                    base = base - t;
                                    tax.push({
                                      tax: tax_rate[r].tax,
                                      rate: tax_rate[r].rate,
                                      amount: parseFloat(t.toFixed(2)),
                                    });
                                  } else {
                                    var t = amount - tax_on_amount;
                                    base = base - t;
                                    tax.push({
                                      tax: tax_info.tax,
                                      tax_rate: tax_info.rate,
                                      rate: tax_info.rate,
                                      amount: parseFloat(t.toFixed(2)),
                                    });
                                  }
                                }

                                //base = base - discount_total;
                              }
                              total = total + amount;
                            }

                            var tax_details = {
                              tax: tax_info.tax,
                              rate: tax_info.rate,
                              amount: total,
                              detail: tax,
                            };

                            if (!labour_list[l].customer_dep) {
                              customer_dep = 100;
                            } else {
                              customer_dep = labour_list[l].customer_dep;
                            }

                            if (!labour_list[l].insurance_dep) {
                              insurance_dep = 0;
                            } else {
                              insurance_dep = labour_list[l].insurance_dep;
                            }

                            labours.push({
                              item: labour_list[l].item,
                              source: labour_list[l].source,
                              rate: parseFloat(labour_list[l].rate),
                              quantity: parseFloat(labour_list[l].quantity),
                              base: parseFloat(base.toFixed(2)),
                              discount: parseFloat(discount_total.toFixed(2)),
                              amount: total,
                              customer_dep: customer_dep,
                              insurance_dep: insurance_dep,
                              tax_amount: parseFloat(
                                _.sumBy(tax, (x) => x.amount).toFixed(2)
                              ),
                              amount_is_tax: labour_list[l].amount_is_tax,
                              tax: tax_info.tax,
                              tax_rate: tax_info.rate,
                              tax_info: tax_details,
                            });

                            ////////////console.log(labours)
                          }

                          bookingService.push({
                            part_cost: services[i].part_cost,
                            labour_cost: _.sumBy(labours, (x) => x.amount),
                            of_cost: services[i].of_cost,
                            exceeded_cost: services[i].exceeded_cost,
                            part_rate: services[i].part_rate,
                            labour_rate: services[i].labour_rate,
                            quantity: services[i].quantity,
                            of_rate: services[i].of_rate,
                            parts: services[i].parts,
                            labour: labours,
                            cost:
                              services[i].part_cost +
                              _.sumBy(labours, (x) => x.amount) +
                              services[i].of_cost,
                            discount:
                              _.sumBy(labours, (x) => x.discount) +
                              _.sumBy(
                                services[i].opening_fitting,
                                (x) => x.discount
                              ) +
                              _.sumBy(services[i].parts, (x) => x.discount),
                            opening_fitting: services[i].opening_fitting,
                            part_cost_editable: services[i].part_cost_editable,
                            labour_cost_editable:
                              services[i].part_cost_editable,
                            of_cost_editable: services[i].part_cost_editable,
                            description: services[i].description,
                            service: services[i].service,
                            type: services[i].type,
                            claim: services[i].claim,
                            custom: services[i].custom,
                            customer_approval: services[i].customer_approval,
                            surveyor_approval: services[i].surveyor_approval,
                            source: services[i].source,
                          });
                        }
                      }
                    }
                  }

                  var policy_clause = 0;
                  if (booking.payment.policy_clause) {
                    policy_clause = booking.payment.policy_clause;
                  }
                  var salvage = 0;
                  if (booking.payment.salvage) {
                    salvage = booking.payment.salvage;
                  }

                  var approved = _.filter(
                    bookingService,
                    (customer_approval) =>
                      customer_approval.customer_approval == true
                  );

                  var paid_total = booking.payment.paid_total;
                  var labour_cost = _.sumBy(
                    bookingService,
                    (x) => x.labour_cost
                  );
                  var part_cost = _.sumBy(bookingService, (x) => x.part_cost);
                  var of_cost = _.sumBy(bookingService, (x) => x.of_cost);
                  var discount_total = _.sumBy(
                    bookingService,
                    (x) => x.discount
                  );
                  var pick_up_charges = booking.payment.pick_up_charges;

                  var payment_total =
                    labour_cost +
                    part_cost +
                    of_cost +
                    discount_total +
                    policy_clause +
                    salvage +
                    pick_up_charges;

                  var careager_cash = await q.all(
                    fun.getBookingCarEagerCash(booking._id)
                  );

                  var estimate_cost =
                    labour_cost +
                    part_cost +
                    of_cost +
                    policy_clause +
                    salvage +
                    pick_up_charges -
                    careager_cash;
                  var due_amount =
                    _.sumBy(approved, (x) => x.labour_cost) +
                    _.sumBy(approved, (x) => x.part_cost) +
                    _.sumBy(approved, (x) => x.of_cost) +
                    policy_clause +
                    salvage +
                    pick_up_charges -
                    (paid_total + careager_cash);

                  var due = {
                    due: Math.ceil(due_amount.toFixed(2)),
                  };

                  var payment = {
                    estimate_cost: estimate_cost,
                    total: payment_total,
                    careager_cash: careager_cash,
                    of_cost: of_cost,
                    labour_cost: labour_cost,
                    part_cost: part_cost,
                    payment_mode: booking.payment.payment_mode,
                    payment_status: booking.payment.payment_status,
                    coupon: "",
                    coupon_type: "",
                    discount_by: "",
                    discount: discount_total,
                    discount_total: discount_total,
                    policy_clause: booking.payment.policy_clause,
                    salvage: booking.payment.salvage,
                    terms: booking.payment.terms,
                    pick_up_limit: booking.payment.pick_up_limit,
                    pick_up_charges: booking.payment.pick_up_charges,
                    paid_total: parseFloat(booking.payment.paid_total),
                    discount_applied: booking.payment.discount_applied,
                    transaction_id: booking.payment.transaction_id,
                    transaction_date: booking.payment.transaction_date,
                    transaction_status: booking.payment.transaction_status,
                    transaction_response: booking.payment.transaction_response,
                  };

                  Booking.findOneAndUpdate(
                    { _id: req.body.booking },
                    {
                      $set: {
                        services: bookingService,
                        payment: payment,
                        due: due,
                      },
                    },
                    { new: false },
                    async function (err, doc) {
                      if (err) {
                        res.status(400).json({
                          responseCode: 400,
                          responseMessage: "Error",
                          responseData: err,
                        });
                      } else {
                        var updated = await Booking.findById(
                          req.body.booking
                        ).exec();

                        res.status(200).json({
                          responseCode: 200,
                          responseMessage: "Package has been removed",
                          responseData: updated,
                        });
                      }
                    }
                  );
                }
              }
            );
          }
        } else {
          res.status(400).json({
            responseCode: 400,
            responseMessage: "Cannot add package to this service",
            responseData: {},
          });
        }
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Booking not found",
          responseData: {},
        });
      }
    }
  }
);

router.post(
  "/new/service/add",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      booking: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Validation Error",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var user = decoded.user;
      var business = req.headers["business"];
      var labour_cost = 0;
      var part_cost = 0;
      var of_cost = 0;
      var discount_total = 0;
      var due_amount = 0;
      var totalResult = 0;
      var bookingService = [];
      var parts = [];
      var labours = [];
      var opening_fitting = [];

      var customer_approval = false;

      if (req.body.customer_approval == true) {
        customer_approval = true;
      }

      var booking = await Booking.findById(req.body.booking).exec();
      if (booking) {
        var part_list = req.body.parts;
        var labour_list = req.body.labour;
        var of_list = req.body.opening_fitting;

        var claim = false;
        if (req.body.claim == true) {
          claim = true;
        }

        var getDiscount = {
          booking: booking._id,
          package: booking.package,
          car: booking.car,
          category: req.body.type,
          service: req.body.service,
          claim: req.body.claim,
          tz: req.headers["tz"],
        };

        var package = await q.all(getPackageDiscount(getDiscount));

        if (part_list) {
          for (var p = 0; p < part_list.length; p++) {
            var total = 0;
            var tax_info = await Tax.findOne({ tax: part_list[p].tax }).exec();
            var tax = [];
            var rate = part_list[p].rate;
            var amount =
              parseFloat(part_list[p].rate) * parseFloat(part_list[p].quantity);
            var tax_rate = tax_info.detail;
            var discount_total = 0;
            var base = amount;

            if (parseFloat(part_list[p].discount)) {
              discount_total = parseFloat(part_list[p].discount);
              amount = amount - parseFloat(discount_total.toFixed(2));
            }

            if (part_list[p].amount_is_tax == "exclusive") {
              var tax_on_amount = amount;
              if (tax_rate.length > 0) {
                for (var r = 0; r < tax_rate.length; r++) {
                  if (tax_rate[r].rate != tax_info.rate) {
                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                    amount = amount + t;
                    tax.push({
                      tax: tax_rate[r].tax,
                      rate: tax_rate[r].rate,
                      amount: parseFloat(t.toFixed(2)),
                    });
                  } else {
                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                    amount = amount + t;
                    tax.push({
                      tax: tax_info.tax,
                      tax_rate: tax_info.rate,
                      rate: tax_info.rate,
                      amount: parseFloat(t.toFixed(2)),
                    });
                  }
                }
              }
              total = total + amount;
            }

            if (part_list[p].amount_is_tax == "inclusive") {
              var x = (100 + tax_info.rate) / 100;
              var tax_on_amount = amount / x;
              if (tax_rate.length > 0) {
                for (var r = 0; r < tax_rate.length; r++) {
                  if (tax_rate[r].rate != tax_info.rate) {
                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                    base = base - t;
                    tax.push({
                      tax: tax_rate[r].tax,
                      rate: tax_rate[r].rate,
                      amount: parseFloat(t.toFixed(2)),
                    });
                  } else {
                    var t = amount - tax_on_amount;
                    base = base - t;
                    tax.push({
                      tax: tax_info.tax,
                      tax_rate: tax_info.rate,
                      rate: tax_info.rate,
                      amount: parseFloat(t.toFixed(2)),
                    });
                  }
                }
              }

              //base = base - discount_total;
              total = total + amount;
            }

            var tax_amount = total - parseFloat(base.toFixed(2));

            var tax_details = {
              tax: tax_info.tax,
              tax_rate: tax_info.rate,
              rate: tax_info.rate,
              amount: total,
              detail: tax,
            };

            parts.push({
              item: part_list[p].item,
              source: part_list[p].source,
              hsn_sac: part_list[p].hsn_sac,
              part_no: part_list[p].part_no,
              rate: parseFloat(part_list[p].rate),
              quantity: parseFloat(part_list[p].quantity),
              base: parseFloat(base.toFixed(2)),
              amount: total,
              discount: part_list[p].discount,
              issued: part_list[p].issued,
              customer_dep: parseFloat(part_list[p].customer_dep),
              insurance_dep: parseFloat(part_list[p].insurance_dep),
              tax_amount: parseFloat(_.sumBy(tax, (x) => x.amount).toFixed(2)),
              amount_is_tax: part_list[p].amount_is_tax,
              tax: tax_info.tax,
              tax_rate: tax_info.rate,
              tax_info: tax_details,
            });
          }
        }

        if (labour_list) {
          discount_eligible_labour_cost = _.sumBy(
            labour_list,
            (x) => x.rate * x.quantity
          );

          for (var l = 0; l < labour_list.length; l++) {
            var total = 0;
            var tax_info = await Tax.findOne({
              tax: labour_list[l].tax,
            }).exec();
            var tax = [];
            var rate = labour_list[l].rate;
            var amount =
              parseFloat(labour_list[l].rate) *
              parseFloat(labour_list[l].quantity);
            var tax_rate = tax_info.detail;
            var discount_total = 0;
            var base = amount;

            if (package.discount_type == "percent") {
              discount = parseFloat(package.discount);
              if (!isNaN(discount) && package.discount > 0) {
                discount_total = amount * (discount / 100);
                amount = amount - parseFloat(discount_total.toFixed(2));
              }
            } else if (package.discount_type == "fixed") {
              discount_type = "value";
              discount = parseFloat(package.discount);
              discount_total =
                (amount / discount_eligible_labour_cost) * discount;
              discount = amount - discount_total;
              amount = parseFloat(discount_total.toFixed(2));
            } else if (package.discount_type == "price") {
              discount_type = "value";
              discount = parseFloat(package.discount);
              if (!isNaN(discount) && discount > 0) {
                discount_total =
                  (amount / discount_eligible_labour_cost) * discount;
                amount = amount - parseFloat(discount_total.toFixed(2));
              }
            } else {
              discount_total = parseFloat(labour_list[l].discount);
              amount = amount - parseFloat(discount_total.toFixed(2));
            }

            if (labour_list[l].amount_is_tax == "exclusive") {
              var tax_on_amount = amount;
              if (tax_rate.length > 0) {
                for (var r = 0; r < tax_rate.length; r++) {
                  if (tax_rate[r].rate != tax_info.rate) {
                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                    amount = amount + t;
                    parseFloat;
                    tax.push({
                      tax: tax_rate[r].tax,
                      rate: tax_rate[r].rate,
                      amount: parseFloat(t.toFixed(2)),
                    });
                  } else {
                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                    amount = amount + t;
                    tax.push({
                      tax: tax_info.tax,
                      tax_rate: tax_info.rate,
                      rate: tax_info.rate,
                      amount: parseFloat(t.toFixed(2)),
                    });
                  }
                }
              }
              //total = total+amount;
            }

            if (labour_list[l].amount_is_tax == "inclusive") {
              var x = (100 + tax_info.rate) / 100;
              var tax_on_amount = amount / x;
              if (tax_rate.length > 0) {
                for (var r = 0; r < tax_rate.length; r++) {
                  if (tax_rate[r].rate != tax_info.rate) {
                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                    base = base - t;
                    tax.push({
                      tax: tax_rate[r].tax,
                      rate: tax_rate[r].rate,
                      amount: parseFloat(t.toFixed(2)),
                    });
                  } else {
                    var t = amount - tax_on_amount;
                    base = base - t;
                    tax.push({
                      tax: tax_info.tax,
                      tax_rate: tax_info.rate,
                      rate: tax_info.rate,
                      amount: parseFloat(t.toFixed(2)),
                    });
                  }
                }
              }
              //base = base - discount_total;
              total = total + amount;
            }

            var tax_amount = total - parseFloat(base.toFixed(2));

            var tax_details = {
              tax: tax_info.tax,
              rate: tax_info.rate,
              amount: total,
              detail: tax,
            };

            labours.push({
              item: labour_list[l].item,
              source: labour_list[l].source,
              rate: parseFloat(labour_list[l].rate),
              quantity: parseFloat(labour_list[l].quantity),
              base: parseFloat(base.toFixed(2)),
              amount: amount,
              discount: discount_total,
              customer_dep: parseFloat(labour_list[l].customer_dep),
              insurance_dep: parseFloat(labour_list[l].insurance_dep),
              tax_amount: parseFloat(_.sumBy(tax, (x) => x.amount).toFixed(2)),
              amount_is_tax: labour_list[l].amount_is_tax,
              tax: tax_info.tax,
              tax_rate: tax_info.rate,
              tax_info: tax_details,
            });
          }
        }

        if (of_list) {
          for (var o = 0; o < of_list.length; o++) {
            var total = 0;
            var tax_info = await Tax.findOne({ tax: of_list[o].tax }).exec();
            var tax = [];
            var rate = of_list[o].rate;
            var amount =
              parseFloat(of_list[o].rate) * parseFloat(of_list[o].quantity);
            var tax_rate = tax_info.detail;
            var discount_total = 0;
            var base = amount;

            if (parseFloat(of_list[0].discount)) {
              discount_total = parseFloat(of_list[o].discount);
              amount = amount - parseFloat(discount_total.toFixed(2));
            }

            if (of_list[o].amount_is_tax == "exclusive") {
              var tax_on_amount = amount;
              if (tax_rate.length > 0) {
                for (var r = 0; r < tax_rate.length; r++) {
                  if (tax_rate[r].rate != tax_info.rate) {
                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                    amount = amount + t;
                    parseFloat;
                    tax.push({
                      tax: tax_rate[r].tax,
                      rate: tax_rate[r].rate,
                      amount: parseFloat(t.toFixed(2)),
                    });
                  } else {
                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                    amount = amount + t;
                    tax.push({
                      tax: tax_info.tax,
                      tax_rate: tax_info.rate,
                      rate: tax_info.rate,
                      amount: parseFloat(t.toFixed(2)),
                    });
                  }
                }
              }
              total = total + amount;
            }

            if (of_list[o].amount_is_tax == "inclusive") {
              var x = (100 + tax_info.rate) / 100;
              var tax_on_amount = amount / x;
              if (tax_rate.length > 0) {
                for (var r = 0; r < tax_rate.length; r++) {
                  if (tax_rate[r].rate != tax_info.rate) {
                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                    base = base - t;
                    tax.push({
                      tax: tax_rate[r].tax,
                      rate: tax_rate[r].rate,
                      amount: parseFloat(t.toFixed(2)),
                    });
                  } else {
                    var t = amount - tax_on_amount;
                    base = base - t;
                    tax.push({
                      tax: tax_info.tax,
                      tax_rate: tax_info.rate,
                      rate: tax_info.rate,
                      amount: parseFloat(t.toFixed(2)),
                    });
                  }
                }
              }
              //base = base - discount_total;
              total = total + amount;
            }

            var tax_details = {
              tax: tax_info.tax,
              rate: tax_info.rate,
              amount: total,
              detail: tax,
            };

            var tax_amount = total - parseFloat(base.toFixed(2));

            opening_fitting.push({
              item: of_list[o].item,
              source: of_list[o].source,
              rate: parseFloat(of_list[o].rate),
              quantity: parseFloat(of_list[o].quantity),
              base: parseFloat(base.toFixed(2)),
              amount: total,
              discount: parseFloat(of_list[o].discount),
              customer_dep: parseFloat(of_list[o].customer_dep),
              insurance_dep: parseFloat(of_list[o].insurance_dep),
              tax_amount: parseFloat(_.sumBy(tax, (x) => x.amount).toFixed(2)),
              amount_is_tax: of_list[o].amount_is_tax,
              tax: tax_info.tax,
              tax_rate: tax_info.rate,
              tax_info: tax_details,
            });
          }
        }

        res.status(200).json({
          responseCode: 200,
          responseMessage: "",
          responseData: {
            part_cost: _.sumBy(parts, (x) => x.amount),
            labour_cost: parseFloat(
              _.sumBy(labours, (x) => x.amount).toFixed(2)
            ),
            of_cost: _.sumBy(opening_fitting, (x) => x.amount),
            part_rate: _.sumBy(parts, (x) => x.base),
            labour_rate: _.sumBy(labours, (x) => x.base),
            of_rate: _.sumBy(opening_fitting, (x) => x.base),
            parts: parts,
            labour: labours,
            opening_fitting: opening_fitting,
            part_cost_editable: true,
            labour_cost_editable: true,
            of_cost_editable: true,
            cost:
              _.sumBy(parts, (x) => x.amount) +
              _.sumBy(labours, (x) => x.amount) +
              _.sumBy(opening_fitting, (x) => x.amount),
            description: req.body.description,
            service: req.body.service,
            type: req.body.type,
            discount:
              _.sumBy(labours, (x) => x.discount) +
              _.sumBy(parts, (x) => x.discount) +
              _.sumBy(opening_fitting, (x) => x.discount),
            customer_approval: customer_approval,
            surveyor_approval: false,
            custom: true,
            exceeded_cost: 0,
            claim: claim,
          },
        });
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Booking not found",
          responseData: {},
        });
      }
    }
  }
);

router.post(
  "/manual/estimate/",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      booking: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Validation Error",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var user = decoded.user;
      var business = req.headers["business"];
      var labour_cost = 0;
      var part_cost = 0;
      var of_cost = 0;
      var due_amount = 0;
      var totalResult = 0;
      var bookingService = [];

      var loggedInDetails = await User.findById(decoded.user).exec();
      var booking = await Booking.findById(req.body.booking).exec();
      if (booking) {
        labour_cost = booking.payment.labour_cost;
        part_cost = booking.payment.part_cost;
        if (booking.payment.of_cost) {
          var of_cost = booking.payment.of_cost;
        }
        var services = req.body.services;

        for (var i = 0; i < services.length; i++) {
          var parts_visible = true;
          var part_tax = [];
          var labour_tax = [];
          var fitting_tax = [];
          var tax_detail = {};
          if (
            typeof services[i].quantity != "number" ||
            parseInt(services[i].quantity) <= 0
          ) {
            var quantity = 1;
          } else {
            var quantity = parseInt(services[i].quantity);
          }

          //var labour_cost_updated = services[i].service, parseFloat(se

          var parts = services[i].parts;
          var part = [];

          if (parts.length > 0) {
            part = parts;
          } else {
            parts_visible = false;
            var tax_info = await Tax.findOne({ tax: "0% GST" }).exec();
            ////////////console.log(tax_info)
            var tax_rate = tax_info.detail;
            var service = services[i].service;
            var amount = parseFloat(services[i].part_cost) * quantity;
            var base = amount;
            var part_tax = [];

            var x = (100 + tax_info.rate) / 100;
            var tax_on_amount = amount / x;
            ////////////console.log(tax_on_amount)
            if (tax_rate.length > 0) {
              for (var r = 0; r < tax_rate.length; r++) {
                if (tax_rate[r].rate != tax_info.rate) {
                  var t = tax_on_amount * (tax_rate[r].rate / 100);
                  ////////////console.log(t)
                  if (t > 0) {
                    base = base - t;
                  } else {
                    base = base;
                  }

                  part_tax.push({
                    tax: tax_rate[r].tax,
                    rate: tax_rate[r].rate,
                    amount: parseFloat(t.toFixed(2)),
                  });
                } else {
                  /*if(tax_info.rate>0)
                                {
                                    tax_on_amount = parseFloat(tax_on_amount.toFixed(2))
                                }
                                else
                                {
                                    tax_on_amount = 0;
                                }
                                part_tax.push({
                                    tax: tax_info.tax,tax_rate: tax_info.rate,
                                    rate: tax_info.rate,
                                    amount: 
                                });*/

                  var t = amount - tax_on_amount;
                  base = base - t;
                  part_tax.push({
                    tax: tax_info.tax,
                    tax_rate: tax_info.rate,
                    rate: tax_info.rate,
                    amount: parseFloat(t.toFixed(2)),
                  });
                }
              }
            }

            tax_detail = {
              tax: tax_info.tax,
              tax_rate: tax_info.rate,
              rate: tax_info.rate,
              base: parseFloat(base.toFixed(2)),
              detail: part_tax,
            };

            part.push({
              item: services[i].service,
              source: null,
              quantity: quantity,
              hsn_sac: "",
              part_no: "",
              rate: parseFloat(services[i].part_cost),
              base: parseFloat(base.toFixed(2)),
              amount: parseFloat(amount),
              tax_amount: _.sumBy(part_tax, (x) => x.amount),
              amount_is_tax: "inclusive",
              discount: 0,
              customer_dep: 100,
              insurance_dep: 0,
              tax: tax_info.tax,
              tax_rate: tax_info.rate,
              issued: false,
              tax_info: tax_detail,
            });
          }

          var labour = services[i].labour;
          var labours = [];

          if (labour.length > 0) {
            labours = labour;
          } else {
            var tax_info = await Tax.findOne({ tax: "18.0% GST" }).exec();
            var tax_rate = tax_info.detail;
            var service = services[i].service;
            var amount = parseFloat(services[i].labour_cost) * quantity;
            var base = amount;
            var labour_tax = [];

            var x = (100 + tax_info.rate) / 100;
            var tax_on_amount = amount / x;
            if (tax_rate.length > 0) {
              for (var r = 0; r < tax_rate.length; r++) {
                if (tax_rate[r].rate != tax_info.rate) {
                  var t = tax_on_amount * (tax_rate[r].rate / 100);
                  base = base - t;
                  labour_tax.push({
                    tax: tax_rate[r].tax,
                    rate: parseFloat(tax_rate[r].rate.toFixed(2)),
                    amount: parseFloat(t.toFixed(2)),
                  });
                } else {
                  base = base - t;
                  labour_tax.push({
                    tax: tax_info.tax,
                    tax_rate: tax_info.rate,
                    rate: parseFloat(tax_info.rate.toFixed(2)),
                    amount: parseFloat(tax_on_amount.toFixed(2)),
                  });
                }
              }
            }

            labours.push({
              item: services[i].service,
              quantity: quantity,
              rate: parseFloat(services[i].labour_cost),
              base: parseFloat(base.toFixed(2)),
              amount: parseFloat(amount),
              discount: 0,
              customer_dep: 100,
              insurance_dep: 0,
              amount_is_tax: "inclusive",
              tax_amount: _.sumBy(labour_tax, (x) => x.amount),
              tax: tax_info.tax,
              tax_rate: tax_info.rate,
              tax_info: {
                tax: tax_info.tax,
                tax_rate: tax_info.rate,
                rate: tax_info.rate,
                base: parseFloat(base.toFixed(2)),
                detail: labour_tax,
              },
            });
          }

          var opening_fittings = services[i].opening_fitting;
          var opening_fitting = [];

          if (opening_fittings.length > 0) {
            opening_fitting = opening_fittings;
          } else {
            if (services[i].of_cost != 0) {
              var tax_info = await Tax.findOne({ tax: "18.0% GST" }).exec();
              var tax_rate = tax_info.detail;
              var service = services[i].service;
              var amount = parseFloat(services[i].of_cost) * quantity;
              var base = amount;
              var fitting_tax = [];

              var x = (100 + tax_info.rate) / 100;
              var tax_on_amount = amount / x;
              if (tax_rate.length > 0) {
                for (var r = 0; r < tax_rate.length; r++) {
                  if (tax_rate[r].rate != tax_info.rate) {
                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                    base = base - t;
                    fitting_tax.push({
                      tax: tax_rate[r].tax,
                      rate: tax_rate[r].rate,
                      amount: parseFloat(t.toFixed(2)),
                    });
                  } else {
                    base = base - t;
                    fitting_tax.push({
                      tax: tax_info.tax,
                      tax_rate: tax_info.rate,
                      rate: tax_info.rate,
                      amount: parseFloat(tax_on_amount.toFixed(2)),
                    });
                  }
                }
              }

              opening_fitting.push({
                item: services[i].service,
                quantity: quantity,
                rate: parseFloat(services[i].of_cost),
                base: parseFloat(base.toFixed(2)),
                discount: 0,
                amount: parseFloat(amount),
                amount_is_tax: "inclusive",
                customer_dep: 100,
                insurance_dep: 0,
                tax_amount: _.sumBy(fitting_tax, (x) => x.amount),
                tax: tax_info.tax,
                tax_rate: tax_info.rate,
                tax_info: {
                  tax: tax_info.tax,
                  tax_rate: tax_info.rate,
                  rate: tax_info.rate,
                  base: parseFloat(base.toFixed(2)),
                  detail: fitting_tax,
                },
              });
            } else {
              opening_fitting = [];
            }
          }

          bookingService.push({
            source: services[i].source,
            service: services[i].service,
            mileage: services[i].mileage,
            parts: part,
            labour: labours,
            opening_fitting: opening_fitting,
            hours: services[i].hours,
            parts_visible: parts_visible,
            quantity: quantity,
            discount:
              _.sumBy(labours, (x) => x.discount) +
              _.sumBy(part, (x) => x.discount) +
              _.sumBy(opening_fitting, (x) => x.discount),
            description: services[i].description,
            cost:
              _.sumBy(labours, (x) => x.amount) +
              _.sumBy(part, (x) => x.amount) +
              _.sumBy(opening_fitting, (x) => x.amount),
            labour_cost: parseFloat(services[i].labour_cost),
            of_cost: parseFloat(services[i].of_cost),
            part_cost: parseFloat(services[i].part_cost),
            exceeded_cost: parseFloat(services[i].exceeded_cost),
            part_cost_editable: services[i].part_cost_editable,
            labour_cost_editable: services[i].labour_cost_editable,
            of_cost_editable: services[i].of_cost_editable,
            type: services[i].type,
            customer_approval: services[i].customer_approval,
            surveyor_approval: services[i].surveyor_approval,
            claim: services[i].claim,
            custom: services[i].custom,
          });
        }

        var policy_clause = booking.payment.policy_clause;
        if (req.body.policy_clause >= 0 && req.body.policy_clause != null) {
          policy_clause = req.body.policy_clause;
        }

        var salvage = booking.payment.salvage;
        if (req.body.salvage >= 0 && req.body.salvage != null) {
          salvage = req.body.salvage;
        }

        var pick_up_charges = booking.payment.pick_up_charges;
        if (req.body.pick_up_charge >= 0) {
          pick_up_charges = req.body.pick_up_charge;
        }

        var approved = _.filter(
          bookingService,
          (customer_approval) => customer_approval.customer_approval == true
        );

        var paid_total = booking.payment.paid_total;
        var labour_cost = _.sumBy(bookingService, (x) => x.labour_cost);
        var part_cost = _.sumBy(bookingService, (x) => x.part_cost);
        var of_cost = _.sumBy(bookingService, (x) => x.of_cost);
        var discount_total = _.sumBy(bookingService, (x) => x.discount);

        var payment_total =
          labour_cost +
          part_cost +
          of_cost +
          discount_total +
          policy_clause +
          salvage +
          pick_up_charges;

        var estimate_cost =
          labour_cost +
          part_cost +
          of_cost +
          policy_clause +
          salvage +
          pick_up_charges -
          careager_cash;
        var careager_cash = booking.payment.careager_cash;

        var due_amount =
          _.sumBy(approved, (x) => x.labour_cost) +
          _.sumBy(approved, (x) => x.part_cost) +
          _.sumBy(approved, (x) => x.of_cost) +
          policy_clause +
          salvage +
          pick_up_charges -
          (paid_total + careager_cash);

        var due = {
          due: Math.ceil(due_amount.toFixed(2)),
        };

        var payment = {
          estimate_cost: estimate_cost,
          total: payment_total,
          careager_cash: careager_cash,
          of_cost: of_cost,
          labour_cost: labour_cost,
          part_cost: part_cost,
          payment_mode: booking.payment.payment_mode,
          payment_status: booking.payment.payment_status,
          discount_type: booking.payment.discount_type,
          coupon: booking.payment.coupon,
          coupon_type: booking.payment.coupon_type,
          discount_by: booking.payment.discount_by,
          discount: booking.payment.discount,
          discount_total: discount_total,
          policy_clause: policy_clause,
          salvage: salvage,
          terms: booking.payment.terms,
          pick_up_limit: booking.payment.pick_up_limit,
          pick_up_charges: pick_up_charges,
          paid_total: parseFloat(booking.payment.paid_total),
          discount_applied: booking.payment.discount_applied,
          transaction_id: booking.payment.transaction_id,
          transaction_date: booking.payment.transaction_date,
          transaction_status: booking.payment.transaction_status,
          transaction_response: booking.payment.transaction_response,
        };

        var date = new Date();

        Booking.findOneAndUpdate(
          { _id: booking._id },
          {
            $set: {
              package: req.body.package,
              services: bookingService,
              payment: payment,
              due: due,
              advance: req.body.advance,
              convenience: req.body.convenience,
              updated_at: date,
            },
          },
          { new: false },
          async function (err, doc) {
            if (err) {
              res.status(422).json({
                responseCode: 422,
                responseMessage: "Server Error",
                responseData: err,
              });
            } else {
              var updated = await Booking.findById(booking.id).exec();
              event.zohoLead(updated._id);

              var activity = {
                user: loggedInDetails._id,
                name: loggedInDetails.name,
                stage: "Estimation",
                activity: "Estimate Prepared",
              };

              fun.bookingLog(booking._id, activity);
              event.zohoLead(booking._id);

              res.status(200).json({
                responseCode: 200,
                responseMessage: "Service has been added...",
                responseData: updated,
              });
            }
          }
        );
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Booking not found",
          responseData: {},
        });
      }
    }
  }
);

router.post(
  "/approved/customer/services",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      booking: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Validation Error",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var user = decoded.user;
      var business = req.headers["business"];
      var bookingService = [];
      var logged_remark = "";
      var loggedInDetails = await User.findById(decoded.user).exec();
      var booking = await Booking.findOne({
        _id: req.body.booking,
        business: business,
      }).exec();
      if (booking) {
        var services = req.body.services;
        for (var i = 0; i < services.length; i++) {
          var parts_visible = true;
          var part_tax = [];
          var labour_tax = [];
          var fitting_tax = [];
          var tax_detail = {};
          if (
            typeof services[i].quantity != "number" ||
            parseInt(services[i].quantity) <= 0
          ) {
            var quantity = 1;
          } else {
            var quantity = parseInt(services[i].quantity);
          }

          var parts = services[i].parts;
          var part = [];
          if (parts.length > 0) {
            part = services[i].parts;
            //////console.log(services[i].parts)
          } else {
            if (services[i].part_cost != 0) {
              parts_visible = false;
              var tax_info = await Tax.findOne({ tax: "0% GST" }).exec();
              var tax_rate = tax_info.detail;
              var service = services[i].service;
              var amount = Math.ceil(services[i].part_cost) * quantity;
              var base = amount;
              var part_tax = [];

              var x = (100 + tax_info.rate) / 100;
              var tax_on_amount = amount / x;
              if (tax_rate.length > 0) {
                for (var r = 0; r < tax_rate.length; r++) {
                  if (tax_rate[r].rate != tax_info.rate) {
                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                    base = base - t;
                    part_tax.push({
                      tax: tax_rate[r].tax,
                      rate: tax_rate[r].rate,
                      amount: parseFloat(t.toFixed(2)),
                    });
                  } else {
                    base = base - t;
                    part_tax.push({
                      tax: tax_info.tax,
                      tax_rate: tax_info.rate,
                      rate: tax_info.rate,
                      amount: parseFloat(tax_on_amount.toFixed(2)),
                    });
                  }
                }
              }

              tax_detail = {
                tax: tax_info.tax,
                tax_rate: tax_info.rate,
                rate: tax_info.rate,
                base: parseFloat(base.toFixed(2)),
                detail: part_tax,
              };

              part.push({
                item: services[i].service,
                hsn_sac: "",
                part_no: "",
                quantity: quantity,
                rate: parseFloat(services[i].part_cost),
                base: parseFloat(base.toFixed(2)),
                amount: parseFloat(amount),
                customer_dep: 100,
                insurance_dep: 0,
                tax_amount: _.sumBy(part_tax, (x) => x.amount),
                amount_is_tax: "inclusive",
                discount: 0,
                tax: tax_info.tax,
                tax_rate: tax_info.rate,
                tax_info: tax_detail,
              });
            }
          }

          var labours = services[i].labour;
          var labour = [];

          if (labours.length > 0) {
            labour = labours;
          } else {
            var tax_info = await Tax.findOne({ tax: "18.0% GST" }).exec();
            var tax_rate = tax_info.detail;
            var service = services[i].service;
            var amount = Math.ceil(services[i].labour_cost) * quantity;
            var base = amount;
            var labour_tax = [];

            var x = (100 + tax_info.rate) / 100;
            var tax_on_amount = amount / x;
            if (tax_rate.length > 0) {
              for (var r = 0; r < tax_rate.length; r++) {
                if (tax_rate[r].rate != tax_info.rate) {
                  var t = tax_on_amount * (tax_rate[r].rate / 100);
                  base = base - t;
                  labour_tax.push({
                    tax: tax_rate[r].tax,
                    rate: parseFloat(tax_rate[r].rate.toFixed(2)),
                    amount: parseFloat(t.toFixed(2)),
                  });
                } else {
                  base = base - t;
                  labour_tax.push({
                    tax: tax_info.tax,
                    tax_rate: tax_info.rate,
                    rate: parseFloat(tax_info.rate.toFixed(2)),
                    amount: parseFloat(tax_on_amount.toFixed(2)),
                  });
                }
              }
            }

            labour.push({
              item: services[i].service,
              quantity: quantity,
              rate: parseFloat(services[i].labour_cost),
              base: parseFloat(base.toFixed(2)),
              amount: parseFloat(amount),
              discount: 0,
              customer_dep: 100,
              insurance_dep: 0,
              amount_is_tax: "inclusive",
              tax_amount: _.sumBy(labour_tax, (x) => x.amount),
              tax: tax_info.tax,
              tax_rate: tax_info.rate,
              tax_info: {
                tax: tax_info.tax,
                tax_rate: tax_info.rate,
                rate: tax_info.rate,
                base: parseFloat(base.toFixed(2)),
                detail: labour_tax,
              },
            });
          }

          var opening_fittings = services[i].opening_fitting;
          var opening_fitting = [];

          if (opening_fittings.length > 0) {
            opening_fitting = opening_fittings;
          } else {
            if (services[i].of_cost != 0) {
              var tax_info = await Tax.findOne({ tax: "18.0% GST" }).exec();
              var tax_rate = tax_info.detail;
              var service = services[i].service;
              var amount = Math.ceil(services[i].of_cost) * quantity;
              var base = amount;
              var fitting_tax = [];

              var x = (100 + tax_info.rate) / 100;
              var tax_on_amount = amount / x;
              if (tax_rate.length > 0) {
                for (var r = 0; r < tax_rate.length; r++) {
                  if (tax_rate[r].rate != tax_info.rate) {
                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                    base = base - t;
                    fitting_tax.push({
                      tax: tax_rate[r].tax,
                      rate: tax_rate[r].rate,
                      amount: parseFloat(t.toFixed(2)),
                    });
                  } else {
                    base = base - t;
                    fitting_tax.push({
                      tax: tax_info.tax,
                      tax_rate: tax_info.rate,
                      rate: tax_info.rate,
                      amount: parseFloat(tax_on_amount.toFixed(2)),
                    });
                  }
                }
              }

              opening_fitting.push({
                item: services[i].service,
                quantity: quantity,
                rate: parseFloat(services[i].of_cost),
                base: parseFloat(base.toFixed(2)),
                discount: 0,
                amount: parseFloat(amount),
                customer_dep: 100,
                insurance_dep: 0,
                amount_is_tax: "inclusive",
                tax_amount: _.sumBy(fitting_tax, (x) => x.amount),
                tax: tax_info.tax,
                tax_rate: tax_info.rate,
                tax_info: {
                  tax: tax_info.tax,
                  tax_rate: tax_info.rate,
                  rate: tax_info.rate,
                  base: parseFloat(base.toFixed(2)),
                  detail: fitting_tax,
                },
              });
            }
          }

          if (services[i].customer_approval == true) {
            var cost =
              _.sumBy(part, (x) => x.amount) +
              _.sumBy(labour, (x) => x.amount) +
              _.sumBy(opening_fitting, (x) => x.amount);
            logged_remark =
              logged_remark +
              "-" +
              services[i].service +
              ": Rs/-" +
              cost +
              "\n";
          }

          bookingService.push({
            source: services[i].source,
            service: services[i].service,
            mileage: services[i].mileage,
            parts: part,
            labour: labour,
            opening_fitting: opening_fitting,
            hours: services[i].hours,
            parts_visible: parts_visible,
            quantity: quantity,
            description: services[i].description,
            part_cost: _.sumBy(part, (x) => x.amount),
            labour_cost: _.sumBy(labour, (x) => x.amount),
            of_cost: _.sumBy(opening_fitting, (x) => x.amount),
            exceeded_cost: services[i].exceeded_cost,
            cost:
              _.sumBy(part, (x) => x.amount) +
              _.sumBy(labour, (x) => x.amount) +
              _.sumBy(opening_fitting, (x) => x.amount),
            discount:
              _.sumBy(labour, (x) => x.discount) +
              _.sumBy(part, (x) => x.discount) +
              _.sumBy(opening_fitting, (x) => x.discount),
            part_cost_editable: services[i].part_cost_editable,
            labour_cost_editable: services[i].labour_cost_editable,
            of_cost_editable: services[i].of_cost_editable,
            type: services[i].type,
            customer_approval: services[i].customer_approval,
            surveyor_approval: services[i].surveyor_approval,
            claim: services[i].claim,
            custom: services[i].custom,
          });
        }

        var approved = _.filter(
          bookingService,
          (customer_approval) => customer_approval.customer_approval == true
        );

        var policy_clause = 0;
        if (booking.payment.policy_clause) {
          policy_clause = booking.payment.policy_clause;
        }
        var salvage = 0;
        if (booking.payment.salvage) {
          salvage = booking.payment.salvage;
        }

        var paid_total = booking.payment.paid_total;
        var labour_cost = _.sumBy(bookingService, (x) => x.labour_cost);
        var part_cost = _.sumBy(bookingService, (x) => x.part_cost);
        var of_cost = _.sumBy(bookingService, (x) => x.of_cost);
        var discount_total = _.sumBy(bookingService, (x) => x.discount);
        var pick_up_charges = booking.payment.pick_up_charges;

        var payment_total =
          labour_cost +
          part_cost +
          of_cost +
          discount_total +
          policy_clause +
          salvage +
          pick_up_charges;

        var estimate_cost =
          labour_cost +
          part_cost +
          of_cost +
          policy_clause +
          salvage +
          pick_up_charges -
          careager_cash;
        var careager_cash = booking.payment.careager_cash;

        var due_amount =
          _.sumBy(approved, (x) => x.labour_cost) +
          _.sumBy(approved, (x) => x.part_cost) +
          _.sumBy(approved, (x) => x.of_cost) +
          policy_clause +
          salvage +
          pick_up_charges -
          (paid_total + careager_cash);

        var due = {
          due: Math.ceil(due_amount.toFixed(2)),
        };

        var payment = {
          estimate_cost: estimate_cost,
          total: parseFloat(payment_total.toFixed(2)),
          careager_cash: careager_cash,
          of_cost: parseFloat(of_cost.toFixed(2)),
          labour_cost: parseFloat(labour_cost.toFixed(2)),
          part_cost: parseFloat(part_cost.toFixed(2)),
          payment_mode: booking.payment.payment_mode,
          payment_status: booking.payment.payment_status,
          coupon: booking.payment.coupon,
          coupon_type: booking.payment.coupon_type,
          discount_by: booking.payment.discount_by,
          discount_type: booking.payment.discount_type,
          discount: booking.payment.discount,
          discount_total: discount_total,
          terms: booking.payment.terms,
          pick_up_limit: booking.payment.pick_up_limit,
          policy_clause: policy_clause,
          salvage: salvage,
          pick_up_charges: pick_up_charges,
          paid_total: booking.payment.paid_total,
          discount_applied: booking.payment.discount_applied,
          transaction_id: booking.payment.transaction_id,
          transaction_date: booking.payment.transaction_date,
          transaction_status: booking.payment.transaction_status,
          transaction_response: booking.payment.transaction_response,
        };

        Booking.findOneAndUpdate(
          { _id: booking._id },
          {
            $set: {
              services: bookingService,
              payment: payment,
              due: due,
              updated_at: new Date(),
            },
          },
          { new: false },
          async function (err, doc) {
            if (err) {
              res.status(400).json({
                responseCode: 400,
                responseMessage: "Error Occurred Try again",
                responseData: err,
              });
            } else {
              if (booking.status == "JobOpen") {
                var stage = "In-Process";
                var status = "In-Process";

                Booking.findOneAndUpdate(
                  { _id: booking._id },
                  { $set: { status: status, updated_at: new Date() } },
                  { new: false },
                  async function (err, doc) {
                    if (err) {
                      return res.status(400).json({
                        responseCode: 400,
                        responseMessage: "Error Occurred Try again",
                        responseData: err,
                      });
                    }
                  }
                );
              }

              var activity = {
                user: loggedInDetails._id,
                name: loggedInDetails.name,
                stage: "Approval",
                activity: logged_remark,
              };

              fun.bookingLog(booking._id, activity);
              event.zohoLead(booking._id);

              var updated = await Booking.findById(booking.id).exec();

              res.status(200).json({
                responseCode: 200,
                responseMessage: "Service has been added...",
                responseData: updated,
              });
            }
          }
        );
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Booking not found",
          responseData: {},
        });
      }
    }
  }
);

router.post(
  "/estimation/service/add",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      booking: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Validation Error",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var user = decoded.user;
      var business = req.headers["business"];
      var labour_cost = 0;
      var part_cost = 0;
      var of_cost = 0;
      var due_amount = 0;
      var totalResult = 0;
      var bookingService = [];
      var services_added = "";
      var logged_remark = "";
      var loggedInDetails = await User.findById(decoded.user).exec();
      var booking = await Booking.findById(req.body.booking).exec();
      if (booking) {
        labour_cost = booking.payment.labour_cost;
        part_cost = booking.payment.part_cost;
        if (booking.payment.of_cost) {
          var of_cost = booking.payment.of_cost;
        }
        var services = req.body.services;

        for (var i = 0; i < services.length; i++) {
          var parts_visible = true;
          var part_tax = [];
          var labour_tax = [];
          var fitting_tax = [];
          var tax_detail = {};
          if (
            typeof services[i].quantity != "number" ||
            parseInt(services[i].quantity) <= 0
          ) {
            var quantity = 1;
          } else {
            var quantity = parseInt(services[i].quantity);
          }

          var parts = services[i].parts;
          var part = [];

          if (parts.length > 0) {
            part = parts;
          } else {
            if (services[i].part_cost > 0) {
              parts_visible = false;
              var tax_info = await Tax.findOne({ tax: "0% GST" }).exec();

              var tax_rate = tax_info.detail;
              var service = services[i].service;
              var amount = parseFloat(services[i].part_cost) * quantity;
              var base = amount;
              var part_tax = [];

              var x = (100 + tax_info.rate) / 100;
              var tax_on_amount = amount / x;

              if (tax_rate.length > 0) {
                for (var r = 0; r < tax_rate.length; r++) {
                  if (tax_rate[r].rate != tax_info.rate) {
                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                    ////////////console.log(t)
                    if (t > 0) {
                      base = base - t;
                    } else {
                      base = base;
                    }

                    part_tax.push({
                      tax: tax_rate[r].tax,
                      rate: tax_rate[r].rate,
                      amount: parseFloat(t.toFixed(2)),
                    });
                  } else {
                    /*if(tax_info.rate>0)
                                    {
                                        tax_on_amount = parseFloat(tax_on_amount.toFixed(2))
                                    }
                                    else
                                    {
                                        tax_on_amount = 0;
                                    }
                                    part_tax.push({
                                        tax: tax_info.tax,tax_rate: tax_info.rate,
                                        rate: tax_info.rate,
                                        amount: 
                                    });*/

                    var t = amount - tax_on_amount;
                    base = base - t;
                    part_tax.push({
                      tax: tax_info.tax,
                      tax_rate: tax_info.rate,
                      rate: tax_info.rate,
                      amount: parseFloat(t.toFixed(2)),
                    });
                  }
                }
              }

              tax_detail = {
                tax: tax_info.tax,
                tax_rate: tax_info.rate,
                rate: tax_info.rate,
                base: parseFloat(base.toFixed(2)),
                detail: part_tax,
              };

              part.push({
                item: services[i].service,
                source: null,
                quantity: quantity,
                hsn_sac: "",
                part_no: "",
                rate: parseFloat(services[i].part_cost),
                base: parseFloat(base.toFixed(2)),
                amount: parseFloat(amount),
                customer_dep: 100,
                insurance_dep: 0,
                tax_amount: _.sumBy(part_tax, (x) => x.amount),
                amount_is_tax: "inclusive",
                discount: 0,
                issued: false,
                tax: tax_info.tax,
                tax_rate: tax_info.rate,
                tax_info: tax_detail,
              });
            } else {
              part = [];
            }
          }

          var labour = services[i].labour;
          var labours = [];

          if (labour.length > 0) {
            labours = labour;
          } else {
            if (services[i].labour_cost > 0) {
              var tax_info = await Tax.findOne({ tax: "18.0% GST" }).exec();
              var tax_rate = tax_info.detail;
              var service = services[i].service;
              var amount = parseFloat(services[i].labour_cost) * quantity;
              var base = amount;
              var labour_tax = [];

              var x = (100 + tax_info.rate) / 100;
              var tax_on_amount = amount / x;
              if (tax_rate.length > 0) {
                for (var r = 0; r < tax_rate.length; r++) {
                  if (tax_rate[r].rate != tax_info.rate) {
                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                    base = base - t;
                    labour_tax.push({
                      tax: tax_rate[r].tax,
                      rate: parseFloat(tax_rate[r].rate.toFixed(2)),
                      amount: parseFloat(t.toFixed(2)),
                    });
                  } else {
                    base = base - t;
                    labour_tax.push({
                      tax: tax_info.tax,
                      tax_rate: tax_info.rate,
                      rate: parseFloat(tax_info.rate.toFixed(2)),
                      amount: parseFloat(tax_on_amount.toFixed(2)),
                    });
                  }
                }
              }

              labours.push({
                item: services[i].service,
                quantity: quantity,
                rate: parseFloat(services[i].labour_cost),
                base: parseFloat(base.toFixed(2)),
                amount: parseFloat(amount),
                customer_dep: 100,
                insurance_dep: 0,
                discount: 0,
                amount_is_tax: "inclusive",
                tax_amount: _.sumBy(labour_tax, (x) => x.amount),
                tax: tax_info.tax,
                tax_rate: tax_info.rate,
                tax_info: {
                  tax: tax_info.tax,
                  tax_rate: tax_info.rate,
                  rate: tax_info.rate,
                  base: parseFloat(base.toFixed(2)),
                  detail: labour_tax,
                },
              });
            }
          }

          var opening_fittings = services[i].opening_fitting;
          var opening_fitting = [];

          if (opening_fittings.length > 0) {
            opening_fitting = opening_fittings;
          } else {
            if (services[i].of_cost != 0) {
              var tax_info = await Tax.findOne({ tax: "18.0% GST" }).exec();
              var tax_rate = tax_info.detail;
              var service = services[i].service;
              var amount = parseFloat(services[i].of_cost) * quantity;
              var base = amount;
              var fitting_tax = [];

              var x = (100 + tax_info.rate) / 100;
              var tax_on_amount = amount / x;
              if (tax_rate.length > 0) {
                for (var r = 0; r < tax_rate.length; r++) {
                  if (tax_rate[r].rate != tax_info.rate) {
                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                    base = base - t;
                    fitting_tax.push({
                      tax: tax_rate[r].tax,
                      rate: tax_rate[r].rate,
                      amount: parseFloat(t.toFixed(2)),
                    });
                  } else {
                    base = base - t;
                    fitting_tax.push({
                      tax: tax_info.tax,
                      tax_rate: tax_info.rate,
                      rate: tax_info.rate,
                      amount: parseFloat(tax_on_amount.toFixed(2)),
                    });
                  }
                }
              }

              opening_fitting.push({
                item: services[i].service,
                quantity: quantity,
                rate: parseFloat(services[i].of_cost),
                base: parseFloat(base.toFixed(2)),
                discount: 0,
                amount: parseFloat(amount),
                customer_dep: 100,
                insurance_dep: 0,
                amount_is_tax: "inclusive",
                tax_amount: _.sumBy(fitting_tax, (x) => x.amount),
                tax: tax_info.tax,
                tax_rate: tax_info.rate,
                tax_info: {
                  tax: tax_info.tax,
                  tax_rate: tax_info.rate,
                  rate: tax_info.rate,
                  base: parseFloat(base.toFixed(2)),
                  detail: fitting_tax,
                },
              });
            }
          }

          var cost =
            _.sumBy(part, (x) => x.amount) +
            _.sumBy(labour, (x) => x.amount) +
            _.sumBy(opening_fitting, (x) => x.amount);
          if (services[i].customer_approval == true) {
            logged_remark =
              logged_remark +
              "-" +
              services[i].service +
              ": Rs/-" +
              cost +
              "\n";
          }

          services_added =
            services_added + "-" + services[i].service + ": Rs/-" + cost + "\n";

          bookingService.push({
            source: services[i].source,
            service: services[i].service,
            mileage: services[i].mileage,
            parts: part,
            labour: labours,
            opening_fitting: opening_fitting,
            hours: services[i].hours,
            parts_visible: parts_visible,
            quantity: quantity,
            discount:
              _.sumBy(labours, (x) => x.discount) +
              _.sumBy(part, (x) => x.discount) +
              _.sumBy(opening_fitting, (x) => x.discount),
            description: services[i].description,
            cost:
              _.sumBy(part, (x) => x.amount) +
              _.sumBy(labours, (x) => x.amount) +
              services[i].of_cost,
            labour_cost: parseFloat(services[i].labour_cost),
            of_cost: parseFloat(services[i].of_cost),
            part_cost: parseFloat(services[i].part_cost),
            exceeded_cost: parseFloat(services[i].exceeded_cost),
            part_cost_editable: services[i].part_cost_editable,
            labour_cost_editable: services[i].labour_cost_editable,
            of_cost_editable: services[i].of_cost_editable,
            type: services[i].type,
            customer_approval: services[i].customer_approval,
            surveyor_approval: services[i].surveyor_approval,
            claim: services[i].claim,
            custom: services[i].custom,
          });
        }

        var policy_clause = booking.payment.policy_clause;
        if (req.body.policy_clause >= 0 && req.body.policy_clause != null) {
          policy_clause = req.body.policy_clause;
        }

        var salvage = booking.payment.salvage;
        if (req.body.salvage >= 0 && req.body.salvage != null) {
          salvage = req.body.salvage;
        }

        var pick_up_charges = booking.payment.pick_up_charges;
        if (req.body.pick_up_charge >= 0) {
          pick_up_charges = req.body.pick_up_charge;
        }

        var approved = _.filter(
          bookingService,
          (customer_approval) => customer_approval.customer_approval == true
        );

        var paid_total = booking.payment.paid_total;
        var labour_cost = _.sumBy(bookingService, (x) => x.labour_cost);
        var part_cost = _.sumBy(bookingService, (x) => x.part_cost);
        var of_cost = _.sumBy(bookingService, (x) => x.of_cost);
        var discount_total = _.sumBy(bookingService, (x) => x.discount);

        var careager_cash = booking.payment.careager_cash;

        var payment_total =
          labour_cost +
          part_cost +
          of_cost +
          discount_total +
          policy_clause +
          salvage +
          pick_up_charges;

        var estimate_cost =
          labour_cost +
          part_cost +
          of_cost +
          policy_clause +
          salvage +
          pick_up_charges -
          careager_cash;

        var due_amount =
          _.sumBy(approved, (x) => x.labour_cost) +
          _.sumBy(approved, (x) => x.part_cost) +
          _.sumBy(approved, (x) => x.of_cost) +
          policy_clause +
          salvage +
          pick_up_charges -
          (paid_total + careager_cash);

        var due = {
          due: Math.ceil(due_amount.toFixed(2)),
        };

        var payment = {
          total: parseFloat(payment_total.toFixed(2)),
          estimate_cost: parseFloat(estimate_cost.toFixed(2)),
          careager_cash: careager_cash,
          of_cost: of_cost,
          labour_cost: labour_cost,
          part_cost: part_cost,
          payment_mode: booking.payment.payment_mode,
          payment_status: booking.payment.payment_status,
          discount_type: booking.payment.discount_type,
          coupon: booking.payment.coupon,
          coupon_type: booking.payment.coupon_type,
          discount_by: booking.payment.discount_by,
          discount: booking.payment.discount,
          discount_total: discount_total,
          policy_clause: policy_clause,
          salvage: salvage,
          terms: booking.payment.terms,
          pick_up_limit: booking.payment.pick_up_limit,
          pick_up_charges: pick_up_charges,
          paid_total: parseFloat(booking.payment.paid_total),
          discount_applied: booking.payment.discount_applied,
          transaction_id: booking.payment.transaction_id,
          transaction_date: booking.payment.transaction_date,
          transaction_status: booking.payment.transaction_status,
          transaction_response: booking.payment.transaction_response,
        };

        var date = new Date();

        Booking.findOneAndUpdate(
          { _id: booking._id },
          {
            $set: {
              services: bookingService,
              convenience: req.body.convenience,
              payment: payment,
              due: due,
              advance: req.body.advance,
              updated_at: date,
            },
          },
          { new: false },
          async function (err, doc) {
            if (err) {
              ////////////console.log(err)
            } else {
              var activity = {
                user: loggedInDetails._id,
                name: loggedInDetails.name,
                stage: "Estimation",
                activity: services_added,
              };

              fun.bookingLog(booking._id, activity);

              if (logged_remark) {
                var activity = {
                  user: loggedInDetails._id,
                  name: loggedInDetails.name,
                  stage: "Approval",
                  activity: logged_remark,
                };

                fun.bookingLog(booking._id, activity);
              }

              event.zohoLead(booking._id);

              var updated = await Booking.findById(booking.id).exec();
              res.status(200).json({
                responseCode: 200,
                responseMessage: "Service has been added...",
                responseData: updated,
              });
            }
          }
        );
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Booking not found",
          responseData: {},
        });
      }
    }
  }
);

router.post(
  "/intimation/send",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      booking: "required",
      email: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Validation Error",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var loggedInDetails = await User.findById(decoded.user).exec();
      var user = decoded.user;
      var business = req.headers["business"];
      var labour_cost = 0;
      var part_cost = 0;
      var of_cost = 0;
      var due_amount = 0;
      var totalResult = 0;
      var bookingService = [];

      var booking = await Booking.findById(req.body.booking).exec();
      if (booking) {
        if (booking.insurance_info.claim == true) {
          var services = booking.services;
          var claim = _.filter(services, (claim) => claim.claim == true);
          var labour_cost = _.sumBy(claim, (x) => x.labour_cost * x.quantity);
          var part_cost = _.sumBy(claim, (x) => x.part_cost * x.quantity);
          var of_cost = _.sumBy(claim, (x) => x.of_cost * x.quantity);

          var payment = {
            total: labour_cost + part_cost + of_cost,
            of_cost: of_cost,
            labour_cost: labour_cost,
            part_cost: part_cost,
            payment_mode: booking.payment.payment_mode,
            payment_status: booking.payment.payment_status,
            coupon: "",
            coupon_type: "",
            discount_by: "",
            discount_type: "",
            discount: 0,
            discount_total: 0,
            policy_clause: booking.payment.policy_clause,
            salvage: booking.payment.salvage,
            terms: booking.payment.terms,
            pick_up_limit: 0,
            pick_up_charges: 0,
            paid_total: 0,
            discount_applied: booking.payment.discount_applied,
            transaction_id: booking.payment.transaction_id,
            transaction_date: booking.payment.transaction_date,
            transaction_status: booking.payment.transaction_status,
            transaction_response: booking.payment.transaction_response,
          };

          var due = {
            due: part_cost + labour_cost + of_cost,
          };

          if (claim.length > 0) {
            Booking.findOneAndUpdate(
              { _id: booking._id },
              {
                $set: {
                  status: "ClaimIntimated",
                  claimed: services,
                  insurance_payment: payment,
                  insurance_due: due,
                },
              },
              { new: false },
              async function (err, doc) {
                if (err) {
                  return res.status(400).json({
                    responseCode: 400,
                    responseMessage: "Error",
                    responseData: err,
                  });
                } else {
                  var activity = {
                    user: loggedInDetails._id,
                    name: loggedInDetails.name,
                    stage: "Estimation",
                    activity: "ClaimIntimated",
                  };

                  fun.bookingLog(booking._id, activity);
                  event.intimateMail(
                    booking._id,
                    req.body.email,
                    req.headers["tz"]
                  );
                  return res.status(200).json({
                    responseCode: 200,
                    responseMessage: "Claim has been intimated",
                    responseData: {},
                  });
                }
              }
            );
          } else {
            return res.status(400).json({
              responseCode: 400,
              responseMessage: "There is no service under claim!",
              responseData: {},
            });
          }
        } else {
          return res.status(400).json({
            responseCode: 400,
            responseMessage: "Seems Jobcard is not open with insurance claim.",
            responseData: {},
          });
        }
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Booking not found",
          responseData: {},
        });
      }
    }
  }
);

router.post(
  "/approved/services/add",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      booking: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Validation Error",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var user = decoded.user;
      var business = req.headers["business"];
      var bookingService = [];

      var booking = await Booking.findById(req.body.booking).exec();
      if (booking) {
        var services = req.body.services;

        for (var i = 0; i < services.length; i++) {
          var parts_visible = true;
          var part_tax = [];
          var labour_tax = [];
          var fitting_tax = [];
          var tax_detail = {};
          if (
            typeof services[i].quantity != "number" ||
            parseInt(services[i].quantity) <= 0
          ) {
            var quantity = 1;
          } else {
            var quantity = parseInt(services[i].quantity);
          }

          var parts = services[i].parts;
          var part = [];

          if (parts.length > 0) {
            part = parts;
          } else {
            if (services[i].part_cost != 0) {
              parts_visible = false;
              var tax_info = await Tax.findOne({ tax: "0% GST" }).exec();
              var tax_rate = tax_info.detail;
              var service = services[i].service;
              var amount = parseFloat(services[i].part_cost) * quantity;
              var base = amount;
              var part_tax = [];

              var x = (100 + tax_info.rate) / 100;
              var tax_on_amount = amount / x;
              if (tax_rate.length > 0) {
                for (var r = 0; r < tax_rate.length; r++) {
                  if (tax_rate[r].rate != tax_info.rate) {
                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                    base = base - t;
                    part_tax.push({
                      tax: tax_rate[r].tax,
                      rate: tax_rate[r].rate,
                      amount: parseFloat(t.toFixed(2)),
                    });
                  } else {
                    base = base - t;
                    part_tax.push({
                      tax: tax_info.tax,
                      tax_rate: tax_info.rate,
                      rate: tax_info.rate,
                      amount: parseFloat(tax_on_amount.toFixed(2)),
                    });
                  }
                }
              }

              tax_detail = {
                tax: tax_info.tax,
                tax_rate: tax_info.rate,
                rate: tax_info.rate,
                base: parseFloat(base.toFixed(2)),
                detail: part_tax,
              };

              part.push({
                item: services[i].service,
                source: null,
                quantity: quantity,
                hsn_sac: "",
                part_no: "",
                rate: parseFloat(services[i].part_cost),
                base: parseFloat(base.toFixed(2)),
                amount: parseFloat(amount),
                customer_dep: 100,
                insurance_dep: 0,
                tax_amount: _.sumBy(part_tax, (x) => x.amount),
                amount_is_tax: "inclusive",
                discount: 0,
                issued: false,
                tax: tax_info.tax,
                tax_rate: tax_info.rate,
                tax_info: tax_detail,
              });
            } else {
              part = [];
            }
          }

          var labour = services[i].labour;
          var labours = [];

          if (labour.length > 0) {
            labours = labour;
          } else {
            var tax_info = await Tax.findOne({ tax: "18.0% GST" }).exec();
            var tax_rate = tax_info.detail;
            var service = services[i].service;
            var amount = parseFloat(services[i].labour_cost) * quantity;
            var base = amount;
            var labour_tax = [];

            var x = (100 + tax_info.rate) / 100;
            var tax_on_amount = amount / x;
            if (tax_rate.length > 0) {
              for (var r = 0; r < tax_rate.length; r++) {
                if (tax_rate[r].rate != tax_info.rate) {
                  var t = tax_on_amount * (tax_rate[r].rate / 100);
                  base = base - t;
                  labour_tax.push({
                    tax: tax_rate[r].tax,
                    rate: parseFloat(tax_rate[r].rate.toFixed(2)),
                    amount: parseFloat(t.toFixed(2)),
                  });
                } else {
                  base = base - t;
                  labour_tax.push({
                    tax: tax_info.tax,
                    tax_rate: tax_info.rate,
                    rate: parseFloat(tax_info.rate.toFixed(2)),
                    amount: parseFloat(tax_on_amount.toFixed(2)),
                  });
                }
              }
            }

            labours.push({
              item: services[i].service,
              quantity: quantity,
              rate: parseFloat(services[i].labour_cost),
              base: parseFloat(base.toFixed(2)),
              amount: parseFloat(amount),
              customer_dep: 100,
              insurance_dep: 0,
              discount: 0,
              amount_is_tax: "inclusive",
              tax_amount: _.sumBy(labour_tax, (x) => x.amount),
              tax: tax_info.tax,
              tax_rate: tax_info.rate,
              tax_info: {
                tax: tax_info.tax,
                tax_rate: tax_info.rate,
                rate: tax_info.rate,
                base: parseFloat(base.toFixed(2)),
                detail: labour_tax,
              },
            });
          }

          var opening_fittings = services[i].opening_fitting;
          var opening_fitting = [];

          if (opening_fittings.length > 0) {
            opening_fitting = opening_fittings;
          } else {
            if (services[i].of_cost != 0) {
              var tax_info = await Tax.findOne({ tax: "18.0% GST" }).exec();
              var tax_rate = tax_info.detail;
              var service = services[i].service;
              var amount = parseFloat(services[i].of_cost) * quantity;
              var base = amount;
              var fitting_tax = [];

              var x = (100 + tax_info.rate) / 100;
              var tax_on_amount = amount / x;
              if (tax_rate.length > 0) {
                for (var r = 0; r < tax_rate.length; r++) {
                  if (tax_rate[r].rate != tax_info.rate) {
                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                    base = base - t;
                    fitting_tax.push({
                      tax: tax_rate[r].tax,
                      rate: tax_rate[r].rate,
                      amount: parseFloat(t.toFixed(2)),
                    });
                  } else {
                    base = base - t;
                    fitting_tax.push({
                      tax: tax_info.tax,
                      tax_rate: tax_info.rate,
                      rate: tax_info.rate,
                      amount: parseFloat(tax_on_amount.toFixed(2)),
                    });
                  }
                }
              }

              opening_fitting.push({
                item: services[i].service,
                quantity: quantity,
                rate: parseFloat(services[i].of_cost),
                base: parseFloat(base.toFixed(2)),
                discount: 0,
                amount: parseFloat(amount),
                customer_dep: 100,
                insurance_dep: 0,
                amount_is_tax: "inclusive",
                tax_amount: _.sumBy(fitting_tax, (x) => x.amount),
                tax: tax_info.tax,
                tax_rate: tax_info.rate,
                tax_info: {
                  tax: tax_info.tax,
                  tax_rate: tax_info.rate,
                  rate: tax_info.rate,
                  base: parseFloat(base.toFixed(2)),
                  detail: fitting_tax,
                },
              });
            } else {
              opening_fitting = [];
            }
          }

          bookingService.push({
            source: services[i].source,
            service: services[i].service,
            mileage: services[i].mileage,
            parts: part,
            labour: labours,
            opening_fitting: opening_fitting,
            hours: services[i].hours,
            parts_visible: parts_visible,
            quantity: quantity,
            discount:
              _.sumBy(labours, (x) => x.discount) +
              _.sumBy(opening_fitting, (x) => x.discount) +
              _.sumBy(part, (x) => x.discount),
            description: services[i].description,
            cost:
              services[i].part_cost +
              _.sumBy(labours, (x) => x.amount) +
              services[i].of_cost,
            labour_cost: parseFloat(services[i].labour_cost),
            of_cost: parseFloat(services[i].of_cost),
            part_cost: parseFloat(services[i].part_cost),
            part_cost_editable: services[i].part_cost_editable,
            labour_cost_editable: services[i].labour_cost_editable,
            of_cost_editable: services[i].of_cost_editable,
            type: services[i].type,
            customer_approval: services[i].customer_approval,
            surveyor_approval: services[i].claim,
            claim: services[i].claim,
            custom: services[i].custom,
          });
        }

        var claim = _.filter(bookingService, (claim) => claim.claim == true);
        var labour_cost = _.sumBy(claim, (x) => x.labour_cost * x.quantity);
        var part_cost = _.sumBy(claim, (x) => x.part_cost * x.quantity);
        var of_cost = _.sumBy(claim, (x) => x.of_cost * x.quantity);

        var insurance_payment = {
          total: labour_cost + part_cost + of_cost,
          of_cost: of_cost,
          labour_cost: labour_cost,
          part_cost: part_cost,
          payment_mode: booking.payment.payment_mode,
          payment_status: booking.payment.payment_status,
          coupon: "",
          coupon_type: "",
          discount_by: "",
          discount_type: "",
          discount: 0,
          discount_total: 0,
          policy_clause: 0,
          salvage: 0,
          terms: "",
          pick_up_limit: 0,
          pick_up_charges: 0,
          paid_total: 0,
          transaction_id: "",
          transaction_date: "",
          transaction_status: "",
          transaction_response: "",
        };

        var insurance_due = {
          due: part_cost + labour_cost + of_cost,
        };

        var date = new Date();
        Booking.findOneAndUpdate(
          { _id: booking._id },
          {
            $set: {
              claimed: bookingService,
              services: bookingService,
              insurance_payment: insurance_payment,
              insurance_due: insurance_due,
              updated_at: new Date(),
            },
          },
          { new: false },
          async function (err, doc) {
            if (err) {
              res.status(400).json({
                responseCode: 400,
                responseMessage: "Error Occurred Try again",
                responseData: err,
              });
            } else {
              var activity = {
                user: user,
                model: "Booking",
                activity: "Surveyor Approved",
              };

              fun.bookingLog(booking._id, activity);

              var updated = await Booking.findById(booking.id).exec();
              res.status(200).json({
                responseCode: 200,
                responseMessage: "Service has been added...",
                responseData: updated,
              });
            }
          }
        );
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Booking not found",
          responseData: {},
        });
      }
    }
  }
);

router.post(
  "/estimate/settlement",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      booking: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Validation Error",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var user = decoded.user;
      var business = req.headers["business"];

      var labour_cost = 0;
      var part_cost = 0;
      var of_cost = 0;
      var due_amount = 0;
      var totalResult = 0;
      var bookingService = [];

      var booking = await Booking.findById(req.body.booking).exec();
      var loggedInDetails = await User.findById(decoded.user).exec();

      if (booking) {
        if (booking.sub_status == "") {
          Booking.findOneAndUpdate(
            { _id: booking._id },
            { $set: { updated_at: new Date() } },
            { new: false },
            async function (err, doc) {
              if (err) {
                res.status(400).json({
                  responseCode: 400,
                  responseMessage: "Error Occurred",
                  responseData: err,
                });
              } else {
                var activity = {
                  user: loggedInDetails._id,
                  name: loggedInDetails.name,
                  stage: "Estimation",
                  activity: "Approval",
                };

                fun.bookingLog(booking._id, activity);

                if (booking.manager) {
                  var notify = {
                    receiver: [booking.manager],
                    activity: "booking",
                    tag: "EstimateSendManager",
                    source: booking._id,
                    sender: loggedInDetails._id,
                    points: 0,
                  };
                  fun.newNotification(notify);
                }

                var notify = {
                  receiver: [booking.user],
                  activity: "booking",
                  tag: "EstimateSendUser",
                  source: booking._id,
                  sender: loggedInDetails._id,
                  points: 0,
                };

                fun.newNotification(notify);
                event.estimateMail(booking._id, req.headers["tz"]);
                event.jobSms(notify);

                res.status(200).json({
                  responseCode: 200,
                  responseMessage: "Estimation has been sent",
                  responseData: {},
                });
              }
            }
          );
        } else {
          Booking.findOneAndUpdate(
            { _id: booking._id },
            { $set: { updated_at: new Date() } },
            { new: false },
            async function (err, doc) {
              if (err) {
                return res.status(400).json({
                  responseCode: 400,
                  responseMessage: "Error",
                  responseData: err,
                });
              } else {
                var activity = {
                  user: loggedInDetails._id,
                  name: loggedInDetails.name,
                  stage: "Estimation",
                  activity: "CustomerApproval",
                };

                fun.bookingLog(booking._id, activity);
                event.zohoLead(booking._id);

                var notify = {
                  receiver: [booking.user],
                  activity: "booking",
                  tag: "ApprovalAwaited",
                  source: booking._id,
                  sender: loggedInDetails._id,
                  points: 0,
                };
                fun.newNotification(notify);
                event.estimateMail(booking._id, req.headers["tz"]);
                event.jobSms(notify);

                res.status(200).json({
                  responseCode: 200,
                  responseMessage: "Estimation has been sent",
                  responseData: {},
                });
              }
            }
          );
        }
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Booking not found",
          responseData: {},
        });
      }
    }
  }
);

router.post(
  "/booking/coupon/add",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      id: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Booking is required",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var user = decoded.user;

      if (req.headers["business"]) {
        user = req.headers["business"];
      }

      var data = new Object();
      var discount = 0;
      var code = "";
      var discount_type = "";
      var discount_by = "";

      var booking = await Booking.findOne({ _id: req.body.id }).exec();

      if (booking) {
        var careager_cash = await q.all(fun.getCarEagerCash(booking._id));
        //////console.log("careager_cash: "+careager_cash)
        var services = booking.services;
        if (booking.payment.total != 0 && booking.package == null) {
          type = req.body.type;

          if (type == "coupon") {
            discount_by = "coupon";
            discount_type = "coupon";
            var discount_eligible = [];
            var coupon = await Coupon.findOne({
              code: req.body.coupon.toUpperCase(),
              is_product: false,
            }).exec();
            var used = await CouponUsed.findOne({
              code: req.body.coupon.toUpperCase(),
              user: booking.user,
            })
              .count()
              .exec();

            if (coupon) {
              if (used < coupon.usage_limit) {
                var serverTime = moment.tz(new Date(), req.headers["tz"]);
                var bar = moment.tz(coupon.expired_at, req.headers["tz"]);
                var baz = bar.diff(serverTime);
                if (baz > 0) {
                  var limit = await CouponUsed.findOne({
                    code: req.body.coupon.toUpperCase(),
                  })
                    .count()
                    .exec();
                  if (limit <= coupon.limit) {
                    code = req.body.coupon.toUpperCase();
                    discount_type = "coupon";
                    if (coupon.coupon_on == "total") {
                      if (coupon.for == "category") {
                        var filter = _.filter(
                          booking.services,
                          (claim) => claim.claim == false
                        );
                        discount_eligible = _.filter(
                          filter,
                          (type) => type.type == coupon.label
                        );
                        if (discount_eligible.length > 0) {
                          var discount_eligible_labour = _.map(
                            discount_eligible,
                            "labour"
                          );
                          var discount_eligible_labour_cost = 0;
                          for (
                            var k = 0;
                            k < discount_eligible_labour.length;
                            k++
                          ) {
                            discount_eligible_labour_cost =
                              _.sumBy(
                                discount_eligible_labour[k],
                                (x) => x.rate * x.quantity
                              ) + discount_eligible_labour_cost;
                          }
                        } else {
                          return res.status(400).json({
                            responseCode: 400,
                            responseMessage:
                              "Coupon not valid for this services",
                            responseData: {},
                          });
                        }
                      } else if (coupon.for == "specific") {
                        var filter = _.filter(
                          booking.services,
                          (claim) => claim.claim == false
                        );
                        discount_eligible = _.filter(
                          filter,
                          (service) => service.service == coupon.label
                        );
                        if (discount_eligible.length > 0) {
                          var discount_eligible_labour = _.map(
                            discount_eligible,
                            "labour"
                          );
                          var discount_eligible_labour_cost = 0;
                          for (
                            var k = 0;
                            k < discount_eligible_labour.length;
                            k++
                          ) {
                            discount_eligible_labour_cost =
                              _.sumBy(
                                discount_eligible_labour[k],
                                (x) => x.rate * x.quantity
                              ) + discount_eligible_labour_cost;
                          }
                        } else {
                          return res.status(400).json({
                            responseCode: 400,
                            responseMessage:
                              "Coupon not valid for this services",
                            responseData: {},
                          });
                        }
                      }
                    } else {
                      if (coupon.for == "general") {
                        discount_eligible = _.filter(
                          booking.services,
                          (claim) => claim.claim == false
                        );
                        if (discount_eligible.length > 0) {
                          var discount_eligible_labour = _.map(
                            discount_eligible,
                            "labour"
                          );
                          var discount_eligible_labour_cost = 0;
                          for (
                            var k = 0;
                            k < discount_eligible_labour.length;
                            k++
                          ) {
                            discount_eligible_labour_cost =
                              _.sumBy(
                                discount_eligible_labour[k],
                                (x) => x.rate * x.quantity
                              ) + discount_eligible_labour_cost;
                          }
                        } else {
                          return res.status(400).json({
                            responseCode: 400,
                            responseMessage:
                              "Coupon not valid for this services",
                            responseData: {},
                          });
                        }
                      } else if (coupon.for == "category") {
                        var filter = _.filter(
                          booking.services,
                          (claim) => claim.claim == false
                        );
                        discount_eligible = _.filter(
                          filter,
                          (type) => type.type == coupon.label
                        );

                        if (discount_eligible.length > 0) {
                          var discount_eligible_labour = _.map(
                            discount_eligible,
                            "labour"
                          );
                          var discount_eligible_labour_cost = 0;
                          for (
                            var k = 0;
                            k < discount_eligible_labour.length;
                            k++
                          ) {
                            discount_eligible_labour_cost =
                              _.sumBy(
                                discount_eligible_labour[k],
                                (x) => x.rate * x.quantity
                              ) + discount_eligible_labour_cost;
                          }
                        } else {
                          return res.status(400).json({
                            responseCode: 400,
                            responseMessage:
                              "Coupon not valid for this services",
                            responseData: {},
                          });
                        }
                      } else if (coupon.for == "specific") {
                        var filter = _.filter(
                          booking.services,
                          (claim) => claim.claim == false
                        );
                        discount_eligible = _.filter(
                          filter,
                          (service) => service.service == coupon.label
                        );
                        if (discount_eligible.length > 0) {
                          var discount_eligible_labour = _.map(
                            discount_eligible,
                            "labour"
                          );
                          var discount_eligible_labour_cost = 0;
                          for (
                            var k = 0;
                            k < discount_eligible_labour.length;
                            k++
                          ) {
                            discount_eligible_labour_cost =
                              _.sumBy(
                                discount_eligible_labour[k],
                                (x) => x.rate * x.quantity
                              ) + discount_eligible_labour_cost;
                          }
                        } else {
                          return res.status(400).json({
                            responseCode: 400,
                            responseMessage:
                              "Coupon not valid for this services",
                            responseData: {},
                          });
                        }
                      }
                    }
                  } else {
                    return res.status(400).json({
                      responseCode: 400,
                      responseMessage: "Coupon has been expired",
                      responseData: {},
                    });
                  }
                } else {
                  return res.status(400).json({
                    responseCode: 400,
                    responseMessage: "Coupon has been expired",
                    responseData: {},
                  });
                }
              } else {
                return res.status(400).json({
                  responseCode: 400,
                  responseMessage: "Coupon has been used",
                  responseData: {},
                });
              }
            } else {
              return res.status(400).json({
                responseCode: 400,
                responseMessage: "Coupon doesn't Exist",
                responseData: {},
              });
            }

            var total_labour_cost = _.sumBy(services, (x) => x.labour_cost);

            if (total_labour_cost < careager_cash) {
              discount_total = 0;
            }

            for (var i = 0; i < services.length; i++) {
              if (services[i].claim == true) {
                bookingService.push(services[i]);
              } else {
                var labour_list = services[i].labour;

                var labours = [];

                if (labour_list) {
                  for (var l = 0; l < labour_list.length; l++) {
                    var discount_total = 0;
                    var total = 0;
                    var tax_info = await Tax.findOne({
                      tax: labour_list[l].tax,
                    }).exec();

                    var tax = [];
                    var rate = labour_list[l].rate;
                    var amount =
                      parseFloat(labour_list[l].rate) *
                      parseFloat(labour_list[l].quantity);
                    var tax_rate = tax_info.detail;
                    var base = amount;

                    if (coupon.coupon_on == "total") {
                      if (coupon.for == "category") {
                        if (services[i].type == coupon.label) {
                          if (coupon.type == "percent") {
                            discount_by = "percent";
                            discount = parseFloat(coupon.discount);
                            if (total_labour_cost < careager_cash) {
                              discount_total = 0;
                            }

                            if (!isNaN(discount) && discount > 0) {
                              discount_total = amount * (discount / 100);
                              amount =
                                amount - parseFloat(discount_total.toFixed(2));
                              if (amount < 0) {
                                amount = 0;
                              }
                            }
                          }
                        }
                      } else if (coupon.for == "specific") {
                        if (services[i].service == coupon.label) {
                          if (coupon.type == "percent") {
                            discount_by = "percent";
                            discount = parseFloat(coupon.discount);
                            if (total_labour_cost < careager_cash) {
                              discount_total = 0;
                            }

                            if (!isNaN(discount) && discount > 0) {
                              discount_total = amount * (discount / 100);
                              amount =
                                amount - parseFloat(discount_total.toFixed(2));
                              if (amount < 0) {
                                amount = 0;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (coupon.for == "general") {
                        if (coupon.type == "percent") {
                          discount_by = "percent";
                          discount = parseFloat(coupon.discount);

                          if (!isNaN(discount) && discount > 0) {
                            discount_total = amount * (discount / 100);
                            amount =
                              amount - parseFloat(discount_total.toFixed(2));
                            if (amount < 0) {
                              amount = 0;
                            }
                          }
                        } else if (coupon.type == "price") {
                          discount_by = "value";
                          discount = parseFloat(coupon.discount);

                          if (!isNaN(discount) && discount > 0) {
                            discount_total =
                              (amount / discount_eligible_labour_cost) *
                              discount;
                            amount =
                              amount - parseFloat(discount_total.toFixed(2));
                            if (amount < 0) {
                              amount = 0;
                            }
                          }
                        }
                      } else if (coupon.for == "category") {
                        if (services[i].type == coupon.label) {
                          if (coupon.type == "percent") {
                            discount_by = "percent";
                            discount = parseFloat(coupon.discount);
                            if (total_labour_cost < careager_cash) {
                              discount_total = 0;
                            }
                            if (!isNaN(discount) && discount > 0) {
                              discount_total = amount * (discount / 100);
                              amount =
                                amount - parseFloat(discount_total.toFixed(2));
                              if (amount < 0) {
                                amount = 0;
                              }
                            }
                          }
                        }
                      } else if (coupon.for == "specific") {
                        if (services[i].service == coupon.label) {
                          if (coupon.type == "percent") {
                            discount_by = "percent";
                            discount = parseFloat(coupon.discount);
                            if (total_labour_cost < careager_cash) {
                              discount_total = 0;
                            }
                            if (!isNaN(discount) && discount > 0) {
                              discount_total = amount * (discount / 100);
                              amount =
                                amount - parseFloat(discount_total.toFixed(2));
                              if (amount < 0) {
                                amount = 0;
                              }
                            }
                          }
                          if (coupon.type == "fixed") {
                            labour_list[l].amount_is_tax = "inclusive";
                            discount_by = "value";
                            discount = parseFloat(coupon.discount);
                            if (total_labour_cost < careager_cash) {
                              discount_total = 0;
                            }
                            discount_total =
                              (amount / discount_eligible_labour_cost) *
                              discount;
                            discount = amount - discount_total;
                            amount = parseFloat(discount_total.toFixed(2));
                            discount_total = discount;
                            if (amount < 0) {
                              amount = 0;
                            }
                          } else if (coupon.type == "price") {
                            discount_by = "value";
                            discount = parseFloat(coupon.discount);
                            if (total_labour_cost < careager_cash) {
                              discount_total = 0;
                            }
                            if (!isNaN(discount) && discount > 0) {
                              discount_total =
                                (amount / discount_eligible_labour_cost) *
                                discount;
                              amount =
                                amount - parseFloat(discount_total.toFixed(2));
                              if (amount < 0) {
                                amount = 0;
                              }
                            }
                          }
                        }
                      }
                    }

                    if (labour_list[l].amount_is_tax == "exclusive") {
                      var tax_on_amount = amount;
                      if (tax_rate.length > 0) {
                        for (var r = 0; r < tax_rate.length; r++) {
                          if (tax_rate[r].rate != tax_info.rate) {
                            var t = tax_on_amount * (tax_rate[r].rate / 100);
                            amount = amount + t;
                            tax.push({
                              tax: tax_rate[r].tax,
                              rate: tax_rate[r].rate,
                              amount: parseFloat(t.toFixed(2)),
                            });
                          } else {
                            var t = tax_on_amount * (tax_rate[r].rate / 100);
                            amount = amount + t;
                            tax.push({
                              tax: tax_info.tax,
                              tax_rate: tax_info.rate,
                              rate: tax_info.rate,
                              amount: parseFloat(t.toFixed(2)),
                            });
                          }
                        }
                      }
                      total = total + amount;
                    }

                    if (labour_list[l].amount_is_tax == "inclusive") {
                      var x = (100 + tax_info.rate) / 100;
                      var tax_on_amount = amount / x;
                      if (tax_rate.length > 0) {
                        for (var r = 0; r < tax_rate.length; r++) {
                          if (tax_rate[r].rate != tax_info.rate) {
                            var t = tax_on_amount * (tax_rate[r].rate / 100);
                            base = base - t;
                            tax.push({
                              tax: tax_rate[r].tax,
                              rate: tax_rate[r].rate,
                              amount: parseFloat(t.toFixed(2)),
                            });
                          } else {
                            var t = amount - tax_on_amount;
                            base = base - t;
                            tax.push({
                              tax: tax_info.tax,
                              tax_rate: tax_info.rate,
                              rate: tax_info.rate,
                              amount: parseFloat(t.toFixed(2)),
                            });
                          }
                        }

                        //base = base - discount_total;
                      }
                      total = total + amount;
                    }

                    var tax_details = {
                      tax: tax_info.tax,
                      rate: tax_info.rate,
                      amount: total,
                      detail: tax,
                    };

                    labours.push({
                      item: labour_list[l].item,
                      source: labour_list[l].source,
                      rate: parseFloat(labour_list[l].rate),
                      quantity: parseFloat(labour_list[l].quantity),
                      base: parseFloat(base.toFixed(2)),
                      discount: parseFloat(discount_total.toFixed(2)),
                      amount: total,
                      customer_dep: parseFloat(labour_list[l].customer_dep),
                      insurance_dep: parseFloat(labour_list[l].insurance_dep),
                      tax_amount: parseFloat(
                        _.sumBy(tax, (x) => x.amount).toFixed(2)
                      ),
                      amount_is_tax: labour_list[l].amount_is_tax,
                      tax: tax_info.tax,
                      tax_rate: tax_info.rate,
                      tax_info: tax_details,
                    });
                  }

                  bookingService.push({
                    quantity: services[i].quantity,
                    part_cost: services[i].part_cost,
                    labour_cost: _.sumBy(labours, (x) => x.amount),
                    of_cost: services[i].of_cost,
                    exceeded_cost: services[i].exceeded_cost,
                    part_rate: services[i].part_rate,
                    labour_rate: services[i].labour_rate,
                    of_rate: services[i].of_rate,
                    parts: services[i].parts,
                    labour: labours,
                    cost:
                      services[i].part_cost +
                      _.sumBy(labours, (x) => x.amount) +
                      services[i].of_cost,
                    opening_fitting: services[i].opening_fitting,
                    part_cost_editable: services[i].part_cost_editable,
                    labour_cost_editable: services[i].part_cost_editable,
                    of_cost_editable: services[i].part_cost_editable,
                    description: services[i].description,
                    service: services[i].service,
                    type: services[i].type,
                    claim: services[i].claim,
                    custom: services[i].custom,
                    discount:
                      _.sumBy(labours, (x) => x.discount) +
                      _.sumBy(services[i].parts, (x) => x.discount) +
                      _.sumBy(services[i].opening_fitting, (x) => x.discount),
                    customer_approval: services[i].customer_approval,
                    surveyor_approval: services[i].surveyor_approval,
                    source: services[i].source,
                  });
                }
              }
            }
          } else {
            bookingService = services;
          }
        } else {
          bookingService = services;
        }

        var paid_total = booking.payment.paid_total;
        var pick_up_charges = booking.payment.pick_up_charges;
        var labour_cost = _.sumBy(bookingService, (x) => x.labour_cost);
        var part_cost = _.sumBy(bookingService, (x) => x.part_cost);
        var of_cost = _.sumBy(bookingService, (x) => x.of_cost);
        var discount_total = _.sumBy(bookingService, (x) => x.discount);

        var policy_clause = 0;
        if (booking.payment.policy_clause) {
          policy_clause = booking.payment.policy_clause;
        }
        var salvage = 0;
        if (booking.payment.salvage) {
          salvage = booking.payment.salvage;
        }

        var total =
          labour_cost +
          part_cost +
          of_cost +
          discount_total +
          policy_clause +
          salvage +
          pick_up_charges;
        var due =
          part_cost +
          labour_cost +
          of_cost +
          policy_clause +
          salvage +
          pick_up_charges -
          careager_cash;

        var payment = {
          estimate_cost: due,
          careager_cash: careager_cash,
          total: parseFloat(total.toFixed(2)),
          of_cost: parseFloat(of_cost.toFixed(2)),
          labour_cost: parseFloat(labour_cost.toFixed(2)),
          part_cost: parseFloat(part_cost.toFixed(2)),
          payment_mode: booking.payment.payment_mode,
          payment_status: booking.payment.payment_status,
          coupon: code,
          coupon_type: "",
          discount_by: discount_by,
          discount_type: discount_type,
          discount: discount,
          discount_total: discount_total,
          policy_clause: booking.payment.policy_clause,
          salvage: booking.payment.salvage,
          terms: booking.payment.terms,
          pick_up_limit: booking.payment.pick_up_limit,
          pick_up_charges: booking.payment.pick_up_charges,
          paid_total: 0,
          discount_applied: booking.payment.discount_applied,
          transaction_id: booking.payment.transaction_id,
          transaction_date: booking.payment.transaction_date,
          transaction_status: booking.payment.transaction_status,
          transaction_response: booking.payment.transaction_response,
        };

        var due = {
          due: Math.ceil(due.toFixed(2)),
        };

        Booking.findOneAndUpdate(
          { _id: booking._id },
          {
            $set: {
              services: bookingService,
              payment: payment,
              due: due,
              updated_at: new Date(),
            },
          },
          { new: false },
          async function (err, doc) {
            if (err) {
              res.status(400).json({
                responseCode: 400,
                responseMessage: "Error",
                responseData: err,
              });
            } else {
              var update = await Booking.findById(booking.id).exec();
              res.status(200).json({
                responseCode: 200,
                responseMessage: "Discount has been applied",
                responseData: {
                  payment: payment,
                  due: due,
                },
              });
            }
          }
        );
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Unauthorized",
          responseData: {},
        });
      }
    }
  }
);

router.get(
  "/insurance/invoice",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      booking: "required",
    };

    var validation = new Validator(req.query, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Validation Error",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var user = decoded.user;
      var business = req.headers["business"];
      var labour_cost = 0;
      var part_cost = 0;
      var of_cost = 0;
      var due_amount = 0;
      var totalResult = 0;
      var bookingService = [];

      var loggedInDetails = await User.findById(decoded.user).exec();
      var booking = await Booking.findById(req.query.booking)
        .populate("address")
        .populate("business")
        .exec();
      var invoices_count = await Invoice.findOne({ business: business })
        .count()
        .exec();
      var limit = await q.all(businessPlanLimit(business, req.headers["tz"]));
      if (limit.invoices > invoices_count) {
        if (booking) {
          var tax_type = "GST";

          var policy_clause = 0;
          var salvage = 0;
          var pick_up_charges = 0;
          var careager_cash = 0;
          var paid_total = 0;

          if (booking.insurance_info.state) {
            if (
              booking.insurance_info.state.toLowerCase() ==
              booking.business.address.state.toLowerCase()
            ) {
              var tax_type = "GST";
            } else {
              var tax_type = "IGST";
            }
          }

          var services = _.filter(
            booking.services,
            (customer_approval) =>
              customer_approval.customer_approval == true &&
              customer_approval.claim == true
          );

          for (var i = 0; i < services.length; i++) {
            var part = [];
            var labours = [];
            var opening_fitting = [];

            var part_list = services[i].parts;
            var labour_list = services[i].labour;
            var of_list = services[i].opening_fitting;

            if (part_list) {
              for (var p = 0; p < part_list.length; p++) {
                var total = 0;
                var tax_info = await Tax.findOne({
                  rate: part_list[p].tax_rate,
                  type: tax_type,
                }).exec();
                var tax = [];
                var rate = part_list[p].rate;
                var amount =
                  parseFloat(part_list[p].rate) *
                  parseFloat(part_list[p].quantity);
                var tax_rate = tax_info.detail;
                var base = amount;

                var dep = 0;

                if (
                  parseFloat(part_list[p].insurance_dep) <= 0 &&
                  parseFloat(part_list[p].customer_dep) <= 0
                ) {
                  dep = 100;
                } else {
                  if (
                    parseFloat(part_list[p].insurance_dep) <= 0 &&
                    parseFloat(part_list[p].customer_dep <= 100)
                  ) {
                    dep = 100;
                  } else {
                    dep = 100 - parseFloat(part_list[p].insurance_dep);
                  }
                }

                amount = amount - (amount * dep) / 100;
                dep = base - amount;

                if (part_list[p].amount_is_tax == "exclusive") {
                  var tax_on_amount = amount;
                  if (tax_rate.length > 0) {
                    for (var r = 0; r < tax_rate.length; r++) {
                      if (tax_rate[r].rate != tax_info.rate) {
                        var t = tax_on_amount * (tax_rate[r].rate / 100);
                        amount = amount + t;
                        parseFloat;
                        tax.push({
                          tax: tax_rate[r].tax,
                          rate: tax_rate[r].rate,
                          amount: parseFloat(t.toFixed(2)),
                        });
                      } else {
                        var t = tax_on_amount * (tax_rate[r].rate / 100);
                        amount = amount + t;
                        tax.push({
                          tax: tax_info.tax,
                          tax_rate: tax_info.rate,
                          rate: tax_info.rate,
                          amount: parseFloat(t.toFixed(2)),
                        });
                      }
                    }
                  }
                  total = total + amount;
                }

                if (part_list[p].amount_is_tax == "inclusive") {
                  var x = (100 + tax_info.rate) / 100;
                  var tax_on_amount = amount / x;
                  if (tax_rate.length > 0) {
                    for (var r = 0; r < tax_rate.length; r++) {
                      if (tax_rate[r].rate != tax_info.rate) {
                        var t = tax_on_amount * (tax_rate[r].rate / 100);
                        base = base - t;
                        tax.push({
                          tax: tax_rate[r].tax,
                          rate: tax_rate[r].rate,
                          amount: parseFloat(t.toFixed(2)),
                        });
                      } else {
                        var t = amount - tax_on_amount;
                        base = base - t;
                        tax.push({
                          tax: tax_info.tax,
                          tax_rate: tax_info.rate,
                          rate: tax_info.rate,
                          amount: parseFloat(t.toFixed(2)),
                        });
                      }
                    }
                  }

                  base = base - dep;
                  total = total + amount;
                }

                var tax_amount = total - parseFloat(base.toFixed(2));

                var tax_details = {
                  tax: tax_info.tax,
                  tax_rate: tax_info.rate,
                  rate: tax_info.rate,
                  amount: total,
                  detail: tax,
                };

                part.push({
                  item: part_list[p].item,
                  source: part_list[p].source,
                  hsn_sac: part_list[p].hsn_sac,
                  part_no: part_list[p].part_no,
                  rate: parseFloat(part_list[p].rate),
                  quantity: parseFloat(part_list[p].quantity),
                  base: parseFloat(base.toFixed(2)),
                  amount: total,
                  discount: 0,
                  //discount: part_list[p].discount,
                  issued: part_list[p].issued,
                  customer_dep: parseFloat(part_list[p].customer_dep),
                  insurance_dep: parseFloat(part_list[p].insurance_dep),
                  tax_amount: parseFloat(
                    _.sumBy(tax, (x) => x.amount).toFixed(2)
                  ),
                  amount_is_tax: part_list[p].amount_is_tax,
                  tax: tax_info.tax,
                  tax_rate: tax_info.rate,
                  tax_info: tax_details,
                });
              }
            }

            if (labour_list) {
              discount_eligible_labour_cost = _.sumBy(
                labour_list,
                (x) => x.rate * x.quantity
              );

              for (var l = 0; l < labour_list.length; l++) {
                var total = 0;
                var tax_info = await Tax.findOne({
                  rate: labour_list[l].tax_rate,
                  type: tax_type,
                }).exec();
                var tax = [];
                var rate = labour_list[l].rate;
                var amount =
                  parseFloat(labour_list[l].rate) *
                  parseFloat(labour_list[l].quantity);
                var tax_rate = tax_info.detail;
                var base = amount;
                var dep = 0;

                if (
                  parseFloat(labour_list[l].insurance_dep) <= 0 &&
                  parseFloat(labour_list[l].customer_dep) <= 0
                ) {
                  dep = 100;
                } else {
                  if (
                    parseFloat(labour_list[l].insurance_dep) <= 0 &&
                    parseFloat(labour_list[l].customer_dep <= 100)
                  ) {
                    dep = 100;
                  } else {
                    dep = 100 - parseFloat(labour_list[l].insurance_dep);
                  }
                }

                amount = amount - (amount * dep) / 100;
                dep = base - amount;

                if (labour_list[l].amount_is_tax == "exclusive") {
                  var tax_on_amount = amount;
                  if (tax_rate.length > 0) {
                    for (var r = 0; r < tax_rate.length; r++) {
                      if (tax_rate[r].rate != tax_info.rate) {
                        var t = tax_on_amount * (tax_rate[r].rate / 100);
                        amount = amount + t;
                        parseFloat;
                        tax.push({
                          tax: tax_rate[r].tax,
                          rate: tax_rate[r].rate,
                          amount: parseFloat(t.toFixed(2)),
                        });
                      } else {
                        var t = tax_on_amount * (tax_rate[r].rate / 100);
                        amount = amount + t;
                        tax.push({
                          tax: tax_info.tax,
                          tax_rate: tax_info.rate,
                          rate: tax_info.rate,
                          amount: parseFloat(t.toFixed(2)),
                        });
                      }
                    }
                  }
                  //total = total+amount;
                }

                if (labour_list[l].amount_is_tax == "inclusive") {
                  var x = (100 + tax_info.rate) / 100;
                  var tax_on_amount = amount / x;
                  if (tax_rate.length > 0) {
                    for (var r = 0; r < tax_rate.length; r++) {
                      if (tax_rate[r].rate != tax_info.rate) {
                        var t = tax_on_amount * (tax_rate[r].rate / 100);
                        base = base - t;
                        tax.push({
                          tax: tax_rate[r].tax,
                          rate: tax_rate[r].rate,
                          amount: parseFloat(t.toFixed(2)),
                        });
                      } else {
                        var t = amount - tax_on_amount;
                        base = base - t;
                        tax.push({
                          tax: tax_info.tax,
                          tax_rate: tax_info.rate,
                          rate: tax_info.rate,
                          amount: parseFloat(t.toFixed(2)),
                        });
                      }
                    }
                  }

                  base = base - dep;
                  total = total + amount;
                }

                var tax_amount = total - parseFloat(base.toFixed(2));

                var tax_details = {
                  tax: tax_info.tax,
                  rate: tax_info.rate,
                  amount: total,
                  detail: tax,
                };

                labours.push({
                  item: labour_list[l].item,
                  source: labour_list[l].source,
                  rate: parseFloat(labour_list[l].rate),
                  quantity: parseFloat(labour_list[l].quantity),
                  base: parseFloat(base.toFixed(2)),
                  amount: amount,
                  discount: 0,
                  //discount: labour_list[l].discount,
                  customer_dep: parseFloat(labour_list[l].customer_dep),
                  insurance_dep: parseFloat(labour_list[l].insurance_dep),
                  tax_amount: parseFloat(
                    _.sumBy(tax, (x) => x.amount).toFixed(2)
                  ),
                  amount_is_tax: labour_list[l].amount_is_tax,
                  tax: tax_info.tax,
                  tax_rate: tax_info.rate,
                  tax_info: tax_details,
                });
              }
            }

            if (of_list) {
              for (var o = 0; o < of_list.length; o++) {
                var total = 0;
                var tax_info = await Tax.findOne({
                  rate: of_list[o].tax_rate,
                  type: tax_type,
                }).exec();
                var tax = [];
                var rate = of_list[o].rate;
                var amount =
                  parseFloat(of_list[o].rate) * parseFloat(of_list[o].quantity);
                var tax_rate = tax_info.detail;
                var base = amount;
                var dep = 0;

                if (
                  parseFloat(of_list[o].insurance_dep) <= 0 &&
                  parseFloat(of_list[o].customer_dep) <= 0
                ) {
                  dep = 100;
                } else {
                  if (
                    parseFloat(of_list[o].insurance_dep) <= 0 &&
                    parseFloat(of_list[o].customer_dep <= 100)
                  ) {
                    dep = 100;
                  } else {
                    dep = 100 - parseFloat(of_list[o].insurance_dep);
                  }
                }

                amount = amount - (amount * dep) / 100;
                dep = base - amount;

                if (of_list[o].amount_is_tax == "exclusive") {
                  var tax_on_amount = amount;
                  if (tax_rate.length > 0) {
                    for (var r = 0; r < tax_rate.length; r++) {
                      if (tax_rate[r].rate != tax_info.rate) {
                        var t = tax_on_amount * (tax_rate[r].rate / 100);
                        amount = amount + t;
                        parseFloat;
                        tax.push({
                          tax: tax_rate[r].tax,
                          rate: tax_rate[r].rate,
                          amount: parseFloat(t.toFixed(2)),
                        });
                      } else {
                        var t = tax_on_amount * (tax_rate[r].rate / 100);
                        amount = amount + t;
                        tax.push({
                          tax: tax_info.tax,
                          tax_rate: tax_info.rate,
                          rate: tax_info.rate,
                          amount: parseFloat(t.toFixed(2)),
                        });
                      }
                    }
                  }
                  total = total + amount;
                }

                if (of_list[o].amount_is_tax == "inclusive") {
                  var x = (100 + tax_info.rate) / 100;
                  var tax_on_amount = amount / x;
                  if (tax_rate.length > 0) {
                    for (var r = 0; r < tax_rate.length; r++) {
                      if (tax_rate[r].rate != tax_info.rate) {
                        var t = tax_on_amount * (tax_rate[r].rate / 100);
                        base = base - t;
                        tax.push({
                          tax: tax_rate[r].tax,
                          rate: tax_rate[r].rate,
                          amount: parseFloat(t.toFixed(2)),
                        });
                      } else {
                        var t = amount - tax_on_amount;
                        base = base - t;
                        tax.push({
                          tax: tax_info.tax,
                          tax_rate: tax_info.rate,
                          rate: tax_info.rate,
                          amount: parseFloat(t.toFixed(2)),
                        });
                      }
                    }
                  }

                  base = base - dep;
                  total = total + amount;
                }

                var tax_details = {
                  tax: tax_info.tax,
                  rate: tax_info.rate,
                  amount: total,
                  detail: tax,
                };

                var tax_amount = total - parseFloat(base.toFixed(2));

                opening_fitting.push({
                  item: of_list[o].item,
                  source: of_list[o].source,
                  rate: parseFloat(of_list[o].rate),
                  quantity: parseFloat(of_list[o].quantity),
                  base: parseFloat(base.toFixed(2)),
                  amount: total,
                  discount: 0,
                  //discount: parseFloat(of_list[o].discount),
                  customer_dep: parseFloat(of_list[o].customer_dep),
                  insurance_dep: parseFloat(of_list[o].insurance_dep),
                  tax_amount: parseFloat(
                    _.sumBy(tax, (x) => x.amount).toFixed(2)
                  ),
                  amount_is_tax: of_list[o].amount_is_tax,
                  tax: tax_info.tax,
                  tax_rate: tax_info.rate,
                  tax_info: tax_details,
                });
              }
            }

            var parts_visible = true;

            bookingService.push({
              source: services[i].source,
              service: services[i].service,
              mileage: services[i].mileage,
              parts: part,
              labour: labours,
              opening_fitting: opening_fitting,
              hours: services[i].hours,
              parts_visible: parts_visible,
              quantity: services[i].quantity,
              discount: 0,
              //discount: _.sumBy(labours, x => x.discount)+_.sumBy(part, x => x.discount)+_.sumBy(opening_fitting, x => x.discount),
              description: services[i].description,
              cost:
                _.sumBy(part, (x) => x.amount) +
                _.sumBy(labours, (x) => x.amount) +
                services[i].of_cost,
              labour_cost: _.sumBy(labours, (x) => x.amount),
              of_cost: _.sumBy(opening_fitting, (x) => x.amount),
              part_cost: _.sumBy(part, (x) => x.amount),
              exceeded_cost: parseFloat(services[i].exceeded_cost),
              part_cost_editable: services[i].part_cost_editable,
              labour_cost_editable: services[i].labour_cost_editable,
              of_cost_editable: services[i].of_cost_editable,
              type: services[i].type,
              customer_approval: services[i].customer_approval,
              surveyor_approval: services[i].surveyor_approval,
              claim: services[i].claim,
              custom: services[i].custom,
            });

            //////console.log(bookingService)
          }

          var labour_cost = _.sumBy(bookingService, (x) => x.labour_cost);
          var part_cost = _.sumBy(bookingService, (x) => x.part_cost);
          var of_cost = _.sumBy(bookingService, (x) => x.of_cost);
          var discount_total = _.sumBy(bookingService, (x) => x.discount);

          var payment_total =
            labour_cost +
            part_cost +
            of_cost +
            discount_total +
            policy_clause +
            salvage +
            pick_up_charges;

          var estimate_cost =
            labour_cost +
            part_cost +
            of_cost +
            policy_clause +
            salvage +
            pick_up_charges -
            careager_cash;

          var due_amount =
            _.sumBy(bookingService, (x) => x.labour_cost) +
            _.sumBy(bookingService, (x) => x.part_cost) +
            _.sumBy(bookingService, (x) => x.of_cost) +
            policy_clause +
            salvage +
            pick_up_charges -
            (paid_total + careager_cash);

          var due = {
            due: Math.ceil(due_amount.toFixed(2)),
          };

          var payment = {
            total: parseFloat(payment_total.toFixed(2)),
            estimate_cost: parseFloat(estimate_cost.toFixed(2)),
            careager_cash: 0,
            of_cost: of_cost,
            labour_cost: labour_cost,
            part_cost: part_cost,
            payment_mode: "",
            payment_status: "",
            discount_type: "",
            coupon: "",
            coupon_type: "",
            discount_by: "",
            discount: 0,
            discount_total: discount_total,
            policy_clause: policy_clause,
            salvage: salvage,
            terms: booking.payment.terms,
            pick_up_limit: booking.payment.pick_up_limit,
            pick_up_charges: pick_up_charges,
            paid_total: paid_total,
            discount_applied: booking.payment.discount_applied,
            transaction_id: "",
            transaction_date: "",
            transaction_status: "",
            transaction_response: "",
          };

          var data = {
            booking: booking._id,
            user: booking.user,
            car: booking.car,
            business: booking.business._id,
            advisor: booking.advisor,
            address: booking.address._id,
            job_no: booking.job_no,
            with_tax: booking.with_tax,
            booking_no: booking.booking_no,
            insurance_info: booking.insurance_info,
            delivery_date: booking.delivery_date,
            note: booking.note,
            due: due,
            odometer: booking.odometer,
            services: bookingService,
            payment: payment,
            invoice_type: "Insurance",
            status: "Active",
            tax_type: tax_type,
            started_at: booking.started_at,
            created_at: new Date(),
            updated_at: new Date(),
          };

          var invoice = await Invoice.findOne({
            booking: req.query.booking,
            invoice_type: "Insurance",
            status: "Active",
          }).exec();
          if (invoice) {
            Invoice.findOneAndUpdate(
              { _id: invoice._id },
              { $set: data },
              { new: true },
              async function (err, doc) {
                if (err) {
                  res.status(422).json({
                    responseCode: 422,
                    responseMessage: "Server Error",
                    responseData: err,
                  });
                } else {
                  var updated = await q.all(
                    fun.invoice(invoice._id, req.headers["tz"])
                  );
                  res.status(200).json({
                    responseCode: 200,
                    responseMessage: "",
                    responseData: updated,
                  });
                }
              }
            );
          } else {
            Invoice.create(data).then(async function (inv) {
              var count = await Invoice.find({
                _id: { $lt: inv._id },
                invoice_type: "Insurance",
                business: business,
              }).count();
              if (count == 0) {
                var last_invoice = "";
                var position = 1;
              } else {
                var lv = await Invoice.findOne({
                  _id: { $lt: inv._id },
                  invoice_type: "Insurance",
                  business: business,
                })
                  .sort({ _id: -1 })
                  .exec();
                var ls = lv.invoice_no.split("INS");
                var last_invoice = ls[1];
                position = count + 1;
              }

              var fy = {
                with_tax: true,
                last_invoice: last_invoice,
                position: position,
              };

              var assigned_invoice_no = await q.all(fun.fiscalyear(fy));

              if (assigned_invoice_no) {
                if (assigned_invoice_no.invoice) {
                  Invoice.findOneAndUpdate(
                    { _id: inv._id },
                    {
                      $set: { invoice_no: "INS" + assigned_invoice_no.invoice },
                    },
                    { new: true },
                    async function (err, doc) {
                      if (err) {
                        res.status(422).json({
                          responseCode: 422,
                          responseMessage: "Server Error",
                          responseData: err,
                        });
                      } else {
                        var updated = await q.all(
                          fun.invoice(inv._id, req.headers["tz"])
                        );
                        res.status(200).json({
                          responseCode: 200,
                          responseMessage: "",
                          responseInfo: {
                            fy: fy,
                            assigned_invoice_no: assigned_invoice_no,
                          },
                          responseData: updated,
                        });
                      }
                    }
                  );
                } else {
                  res.status(422).json({
                    responseCode: 422,
                    responseMessage: "Server Error",
                    responseData: {},
                  });
                }
              } else {
                res.status(422).json({
                  responseCode: 422,
                  responseMessage: "Server Error",
                  responseData: {},
                });
              }
            });
          }
        } else {
          res.status(400).json({
            responseCode: 400,
            responseMessage: "Booking not found",
            responseData: {},
          });
        }
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Invoices Limit Exceeded. Upgrade Your Plan",
          responseData: {},
        });
      }
    }
  }
);

router.get(
  "/booking/invoice/generate",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      booking: "required",
    };

    var validation = new Validator(req.query, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Booking is required",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var business = req.headers["business"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var user = decoded.user;
      var data = new Object();
      var discount = 0;
      var code = "";
      var discount_type = "";
      var bookingService = [];

      var booking = await Booking.findOne({ _id: req.query.booking })
        .populate("address")
        .populate("car")
        .populate("business")
        .populate("user")
        .exec();

      var invoices_count = await Invoice.findOne({ business: business })
        .count()
        .exec();
      var limit = await q.all(businessPlanLimit(business, req.headers["tz"]));
      if (limit.invoices > invoices_count) {
        if (booking) {
          var invoice = await Invoice.findOne({
            booking: booking._id,
            invoice_type: "Booking",
            status: "Active",
          }).exec();

          if (invoice) {
            res.status(422).json({
              responseCode: 422,
              responseMessage:
                "Booking already generated #Invoice No" + invoice.invoice_no,
              responseData: {},
            });
          } else {
            var tax_type = "GST";

            if (booking.address != null) {
              if (booking.address.state == booking.business.address.state) {
                tax_type = "GST";
              } else {
                tax_type = "IGST";
              }
            } else {
              return res.status(422).json({
                responseCode: 422,
                responseMessage: "Select an address",
                responseData: {},
              });
            }

            var services = _.filter(
              booking.services,
              (customer_approval) => customer_approval.customer_approval == true
            );

            for (var i = 0; i < services.length; i++) {
              var part = [];
              var labours = [];
              var opening_fitting = [];

              var part_list = services[i].parts;
              var labour_list = services[i].labour;
              var of_list = services[i].opening_fitting;

              if (part_list) {
                for (var p = 0; p < part_list.length; p++) {
                  var total = 0;
                  var tax_info = await Tax.findOne({
                    rate: part_list[p].tax_rate,
                    type: tax_type,
                  }).exec();
                  var tax = [];
                  var rate = part_list[p].rate;
                  var amount =
                    parseFloat(part_list[p].rate) *
                    parseFloat(part_list[p].quantity);
                  var tax_rate = tax_info.detail;
                  var discount_total = 0;
                  var base = amount;

                  if (
                    parseFloat(part_list[p].customer_dep) != null &&
                    parseFloat(part_list[p].insurance_dep) != null
                  ) {
                    var customer_dep = parseFloat(part_list[p].customer_dep);
                    var insurance_dep = parseFloat(part_list[p].insurance_dep);
                  } else {
                    var customer_dep = 100;
                    var insurance_dep = 0;

                    part_list[p].customer_dep = 100;
                    part_list[p].insurance_dep = 0;
                  }

                  var dep = 0;

                  if (services[i].claim == true) {
                    if (
                      parseFloat(part_list[p].insurance_dep) <= 0 &&
                      parseFloat(part_list[p].customer_dep) <= 0
                    ) {
                      dep = 0;
                    } else {
                      if (
                        parseFloat(part_list[p].customer_dep) <= 0 &&
                        parseFloat(part_list[p].insurance_dep <= 100)
                      ) {
                        dep = 100;
                      } else {
                        dep = 100 - parseFloat(part_list[p].customer_dep);
                      }
                    }

                    amount = amount - (amount * dep) / 100;
                    dep = base - amount;
                  }

                  if (part_list[p].discount) {
                    discount_total = part_list[p].discount;
                    amount = amount - parseFloat(discount_total.toFixed(2));
                  }

                  if (part_list[p].amount_is_tax == "exclusive") {
                    var tax_on_amount = amount;
                    if (tax_rate.length > 0) {
                      for (var r = 0; r < tax_rate.length; r++) {
                        if (tax_rate[r].rate != tax_info.rate) {
                          var t = tax_on_amount * (tax_rate[r].rate / 100);
                          amount = amount + t;
                          parseFloat;
                          tax.push({
                            tax: tax_rate[r].tax,
                            rate: tax_rate[r].rate,
                            amount: parseFloat(t.toFixed(2)),
                          });
                        } else {
                          var t = tax_on_amount * (tax_rate[r].rate / 100);
                          amount = amount + t;
                          tax.push({
                            tax: tax_info.tax,
                            tax_rate: tax_info.rate,
                            rate: tax_info.rate,
                            amount: parseFloat(t.toFixed(2)),
                          });
                        }
                      }
                    }
                    total = total + amount;
                  }

                  if (part_list[p].amount_is_tax == "inclusive") {
                    var x = (100 + tax_info.rate) / 100;
                    var tax_on_amount = amount / x;
                    if (tax_rate.length > 0) {
                      for (var r = 0; r < tax_rate.length; r++) {
                        if (tax_rate[r].rate != tax_info.rate) {
                          var t = tax_on_amount * (tax_rate[r].rate / 100);
                          base = base - t;
                          tax.push({
                            tax: tax_rate[r].tax,
                            rate: tax_rate[r].rate,
                            amount: parseFloat(t.toFixed(2)),
                          });
                        } else {
                          var t = amount - tax_on_amount;
                          base = base - t;
                          tax.push({
                            tax: tax_info.tax,
                            tax_rate: tax_info.rate,
                            rate: tax_info.rate,
                            amount: parseFloat(t.toFixed(2)),
                          });
                        }
                      }
                    }
                    base = base - dep;
                    total = total + amount;
                  }

                  var tax_amount = total - parseFloat(base.toFixed(2));

                  var tax_details = {
                    tax: tax_info.tax,
                    tax_rate: tax_info.rate,
                    rate: tax_info.rate,
                    amount: total,
                    detail: tax,
                  };

                  part.push({
                    item: part_list[p].item,
                    source: part_list[p].source,
                    hsn_sac: part_list[p].hsn_sac,
                    part_no: part_list[p].part_no,
                    rate: parseFloat(part_list[p].rate),
                    quantity: parseFloat(part_list[p].quantity),
                    base: parseFloat(base.toFixed(2)),
                    amount: total,
                    discount: part_list[p].discount,
                    issued: part_list[p].issued,
                    customer_dep: parseFloat(part_list[p].customer_dep),
                    insurance_dep: parseFloat(part_list[p].insurance_dep),
                    tax_amount: parseFloat(
                      _.sumBy(tax, (x) => x.amount).toFixed(2)
                    ),
                    amount_is_tax: part_list[p].amount_is_tax,
                    tax: tax_info.tax,
                    tax_rate: tax_info.rate,
                    tax_info: tax_details,
                  });
                }
              }

              if (labour_list) {
                for (var l = 0; l < labour_list.length; l++) {
                  var total = 0;
                  var tax_info = await Tax.findOne({
                    rate: labour_list[l].tax_rate,
                    type: tax_type,
                  }).exec();
                  var tax = [];
                  var rate = labour_list[l].rate;
                  var amount =
                    parseFloat(labour_list[l].rate) *
                    parseFloat(labour_list[l].quantity);
                  var tax_rate = tax_info.detail;
                  var discount_total = 0;
                  var base = amount;

                  if (
                    parseFloat(labour_list[l].customer_dep) != null &&
                    parseFloat(labour_list[l].insurance_dep) != null
                  ) {
                    var customer_dep = parseFloat(labour_list[l].customer_dep);
                    var insurance_dep = parseFloat(
                      labour_list[l].insurance_dep
                    );
                  } else {
                    var customer_dep = 100;
                    var insurance_dep = 0;

                    labour_list[l].customer_dep = 100;
                    labour_list[l].insurance_dep = 0;
                  }

                  var dep = 0;

                  if (services[i].claim == true) {
                    if (
                      parseFloat(labour_list[l].insurance_dep) <= 0 &&
                      parseFloat(labour_list[l].customer_dep) <= 0
                    ) {
                      dep = 0;
                    } else {
                      if (
                        parseFloat(labour_list[l].customer_dep) <= 0 &&
                        parseFloat(labour_list[l].insurance_dep <= 100)
                      ) {
                        dep = 100;
                      } else {
                        dep = 100 - parseFloat(labour_list[l].customer_dep);
                      }
                    }

                    amount = amount - (amount * dep) / 100;
                    dep = base - amount;
                  }

                  if (labour_list[l].discount) {
                    discount_total = labour_list[l].discount;
                    amount = amount - parseFloat(discount_total.toFixed(2));
                  }

                  if (labour_list[l].amount_is_tax == "exclusive") {
                    var tax_on_amount = amount;
                    if (tax_rate.length > 0) {
                      for (var r = 0; r < tax_rate.length; r++) {
                        if (tax_rate[r].rate != tax_info.rate) {
                          var t = tax_on_amount * (tax_rate[r].rate / 100);
                          amount = amount + t;
                          parseFloat;
                          tax.push({
                            tax: tax_rate[r].tax,
                            rate: tax_rate[r].rate,
                            amount: parseFloat(t.toFixed(2)),
                          });
                        } else {
                          var t = tax_on_amount * (tax_rate[r].rate / 100);
                          amount = amount + t;
                          tax.push({
                            tax: tax_info.tax,
                            tax_rate: tax_info.rate,
                            rate: tax_info.rate,
                            amount: parseFloat(t.toFixed(2)),
                          });
                        }
                      }
                    }
                    //total = total+amount;
                  }

                  if (labour_list[l].amount_is_tax == "inclusive") {
                    var x = (100 + tax_info.rate) / 100;
                    var tax_on_amount = amount / x;
                    if (tax_rate.length > 0) {
                      for (var r = 0; r < tax_rate.length; r++) {
                        if (tax_rate[r].rate != tax_info.rate) {
                          var t = tax_on_amount * (tax_rate[r].rate / 100);
                          base = base - t;
                          tax.push({
                            tax: tax_rate[r].tax,
                            rate: tax_rate[r].rate,
                            amount: parseFloat(t.toFixed(2)),
                          });
                        } else {
                          var t = amount - tax_on_amount;
                          base = base - t;
                          tax.push({
                            tax: tax_info.tax,
                            tax_rate: tax_info.rate,
                            rate: tax_info.rate,
                            amount: parseFloat(t.toFixed(2)),
                          });
                        }
                      }
                    }
                    base = base - dep;
                    total = total + amount;
                  }

                  var tax_amount = total - parseFloat(base.toFixed(2));

                  var tax_details = {
                    tax: tax_info.tax,
                    rate: tax_info.rate,
                    amount: total,
                    detail: tax,
                  };

                  labours.push({
                    item: labour_list[l].item,
                    source: labour_list[l].source,
                    rate: parseFloat(labour_list[l].rate),
                    quantity: parseFloat(labour_list[l].quantity),
                    base: parseFloat(base.toFixed(2)),
                    amount: amount,
                    discount: labour_list[l].discount,
                    customer_dep: parseFloat(labour_list[l].customer_dep),
                    insurance_dep: parseFloat(labour_list[l].insurance_dep),
                    tax_amount: parseFloat(
                      _.sumBy(tax, (x) => x.amount).toFixed(2)
                    ),
                    amount_is_tax: labour_list[l].amount_is_tax,
                    tax: tax_info.tax,
                    tax_rate: tax_info.rate,
                    tax_info: tax_details,
                  });
                }
              }

              if (of_list) {
                for (var o = 0; o < of_list.length; o++) {
                  var total = 0;
                  var tax_info = await Tax.findOne({
                    rate: of_list[o].tax_rate,
                    type: tax_type,
                  }).exec();
                  var tax = [];
                  var rate = of_list[o].rate;
                  var amount =
                    parseFloat(of_list[o].rate) *
                    parseFloat(of_list[o].quantity);
                  var tax_rate = tax_info.detail;
                  var base = amount;

                  if (
                    parseFloat(of_list[o].customer_dep) != null &&
                    parseFloat(of_list[o].insurance_dep) != null
                  ) {
                    var customer_dep = parseFloat(of_list[o].customer_dep);
                    var insurance_dep = parseFloat(of_list[o].insurance_dep);
                  } else {
                    var customer_dep = 100;
                    var insurance_dep = 0;

                    of_list[o].customer_dep = 100;
                    of_list[o].insurance_dep = 0;
                  }

                  var dep = 0;

                  if (services[i].claim == true) {
                    if (
                      parseFloat(of_list[o].insurance_dep) <= 0 &&
                      parseFloat(of_list[o].customer_dep) <= 0
                    ) {
                      dep = 0;
                    } else {
                      if (
                        parseFloat(of_list[o].customer_dep) <= 0 &&
                        parseFloat(of_list[o].insurance_dep <= 100)
                      ) {
                        dep = 100;
                      } else {
                        dep = 100 - parseFloat(of_list[o].customer_dep);
                      }
                    }

                    amount = amount - (amount * dep) / 100;

                    dep = base - amount;
                  }

                  if (of_list[o].discount) {
                    discount_total = of_list[o].discount;
                    amount = amount - parseFloat(discount_total.toFixed(2));
                  }

                  if (of_list[o].amount_is_tax == "exclusive") {
                    var tax_on_amount = amount;
                    if (tax_rate.length > 0) {
                      for (var r = 0; r < tax_rate.length; r++) {
                        if (tax_rate[r].rate != tax_info.rate) {
                          var t = tax_on_amount * (tax_rate[r].rate / 100);
                          amount = amount + t;
                          parseFloat;
                          tax.push({
                            tax: tax_rate[r].tax,
                            rate: tax_rate[r].rate,
                            amount: parseFloat(t.toFixed(2)),
                          });
                        } else {
                          var t = tax_on_amount * (tax_rate[r].rate / 100);
                          amount = amount + t;
                          tax.push({
                            tax: tax_info.tax,
                            tax_rate: tax_info.rate,
                            rate: tax_info.rate,
                            amount: parseFloat(t.toFixed(2)),
                          });
                        }
                      }
                    }
                    total = total + amount;
                  }

                  if (of_list[o].amount_is_tax == "inclusive") {
                    var x = (100 + tax_info.rate) / 100;
                    var tax_on_amount = amount / x;
                    if (tax_rate.length > 0) {
                      for (var r = 0; r < tax_rate.length; r++) {
                        if (tax_rate[r].rate != tax_info.rate) {
                          var t = tax_on_amount * (tax_rate[r].rate / 100);
                          base = base - t;
                          tax.push({
                            tax: tax_rate[r].tax,
                            rate: tax_rate[r].rate,
                            amount: parseFloat(t.toFixed(2)),
                          });
                        } else {
                          var t = amount - tax_on_amount;
                          base = base - t;
                          tax.push({
                            tax: tax_info.tax,
                            tax_rate: tax_info.rate,
                            rate: tax_info.rate,
                            amount: parseFloat(t.toFixed(2)),
                          });
                        }
                      }
                    }

                    base = base - dep;
                    total = total + amount;
                  }

                  var tax_details = {
                    tax: tax_info.tax,
                    rate: tax_info.rate,
                    amount: total,
                    detail: tax,
                  };

                  var tax_amount = total - parseFloat(base.toFixed(2));

                  opening_fitting.push({
                    item: of_list[o].item,
                    source: of_list[o].source,
                    rate: parseFloat(of_list[o].rate),
                    quantity: parseFloat(of_list[o].quantity),
                    base: parseFloat(base.toFixed(2)),
                    amount: total,
                    discount: parseFloat(of_list[o].discount),
                    customer_dep: parseFloat(of_list[o].customer_dep),
                    insurance_dep: parseFloat(of_list[o].insurance_dep),
                    tax_amount: parseFloat(
                      _.sumBy(tax, (x) => x.amount).toFixed(2)
                    ),
                    amount_is_tax: of_list[o].amount_is_tax,
                    tax: tax_info.tax,
                    tax_rate: tax_info.rate,
                    tax_info: tax_details,
                  });
                }
              }

              var parts_visible = true;

              bookingService.push({
                source: services[i].source,
                service: services[i].service,
                mileage: services[i].mileage,
                parts: part,
                labour: labours,
                opening_fitting: opening_fitting,
                hours: services[i].hours,
                parts_visible: parts_visible,
                quantity: services[i].quantity,
                discount:
                  _.sumBy(labours, (x) => x.discount) +
                  _.sumBy(part, (x) => x.discount) +
                  _.sumBy(opening_fitting, (x) => x.discount),
                description: services[i].description,
                cost:
                  _.sumBy(part, (x) => x.amount) +
                  _.sumBy(labours, (x) => x.amount) +
                  services[i].of_cost,
                labour_cost: _.sumBy(labours, (x) => x.amount),
                of_cost: _.sumBy(opening_fitting, (x) => x.amount),
                part_cost: _.sumBy(part, (x) => x.amount),
                exceeded_cost: parseFloat(services[i].exceeded_cost),
                part_cost_editable: services[i].part_cost_editable,
                labour_cost_editable: services[i].labour_cost_editable,
                of_cost_editable: services[i].of_cost_editable,
                type: services[i].type,
                customer_approval: services[i].customer_approval,
                surveyor_approval: services[i].surveyor_approval,
                claim: services[i].claim,
                custom: services[i].custom,
              });
            }

            var policy_clause = 0;
            if (booking.payment.policy_clause) {
              policy_clause = booking.payment.policy_clause;
            }
            var salvage = 0;
            if (booking.payment.salvage) {
              salvage = booking.payment.salvage;
            }

            var paid_total = booking.payment.paid_total;
            var labour_cost = _.sumBy(bookingService, (x) => x.labour_cost);
            var part_cost = _.sumBy(bookingService, (x) => x.part_cost);
            var of_cost = _.sumBy(bookingService, (x) => x.of_cost);
            var discount_total = _.sumBy(bookingService, (x) => x.discount);
            var pick_up_charges = booking.payment.pick_up_charges;
            var careager_cash = booking.payment.careager_cash;
            var payment_total =
              labour_cost +
              part_cost +
              of_cost +
              discount_total +
              policy_clause +
              salvage +
              pick_up_charges;

            var estimate_cost =
              labour_cost +
              part_cost +
              of_cost +
              policy_clause +
              salvage +
              pick_up_charges -
              careager_cash;

            var due_amount =
              _.sumBy(bookingService, (x) => x.labour_cost) +
              _.sumBy(bookingService, (x) => x.part_cost) +
              _.sumBy(bookingService, (x) => x.of_cost) +
              policy_clause +
              salvage +
              pick_up_charges -
              (paid_total + careager_cash);

            var due = {
              due: Math.ceil(due_amount.toFixed(2)),
            };

            var payment = {
              estimate_cost: estimate_cost,
              total: payment_total,
              careager_cash: careager_cash,
              of_cost: of_cost,
              labour_cost: labour_cost,
              part_cost: part_cost,
              payment_mode: booking.payment.payment_mode,
              payment_status: booking.payment.payment_status,
              coupon: booking.payment.coupon,
              coupon_type: booking.payment.coupon_type,
              discount_by: booking.payment.discount_by,
              discount_type: booking.payment.discount_type,
              discount: booking.payment.discount,
              discount_total: discount_total,
              policy_clause: policy_clause,
              salvage: salvage,
              terms: booking.payment.terms,
              pick_up_limit: booking.payment.pick_up_limit,
              pick_up_charges: pick_up_charges,
              paid_total: parseFloat(booking.payment.paid_total),
              discount_applied: booking.payment.discount_applied,
              transaction_id: booking.payment.transaction_id,
              transaction_date: booking.payment.transaction_date,
              transaction_status: booking.payment.transaction_status,
              transaction_response: booking.payment.transaction_response,
            };

            var data = {
              booking: booking._id,
              user: booking.user,
              car: booking.car._id,
              business: booking.business,
              advisor: booking.advisor,
              address: booking.address,
              job_no: booking.job_no,
              booking_no: booking.booking_no,
              delivery_date: booking.delivery_date,
              delivery_date: booking.delivery_date,
              delivery_time: booking.delivery_time,
              with_tax: booking.with_tax,
              odometer: booking.odometer,
              note: booking.note,
              insurance_info: booking.insurance_info,
              due: due,
              services: bookingService,
              payment: payment,
              invoice_type: "Booking",
              status: "Active",
              started_at: booking.started_at,
              created_at: new Date(),
              updated_at: new Date(),
            };

            Invoice.create(data).then(async function (inv) {
              var status = "Completed";
              if (booking.insurance_info) {
                if (booking.insurance_info.claim == true) {
                  status = booking.status;
                }
              }

              Booking.findOneAndUpdate(
                { _id: booking._id },
                { $set: { status: status, updated_at: new Date() } },
                { new: false },
                async function (err, doc) {
                  if (err) {
                    res.status(400).json({
                      responseCode: 400,
                      responseMessage: "Error",
                      responseData: err,
                    });
                  } else {
                    if (booking.business.isCarEager == true) {
                      var partner = await q.all(
                        fun.partnerCommission(booking._id)
                      );
                    }
                    event.zohoLead(booking._id);

                    if (booking.package) {
                      packageDeduction(booking._id);
                    }

                    var count = await Invoice.find({
                      _id: { $lt: inv._id },
                      invoice_type: "Booking",
                      with_tax: inv.with_tax,
                      business: business,
                    }).count();

                    if (count == 0) {
                      var last_invoice = "";
                      var position = 1;
                    } else {
                      var lv = await Invoice.findOne({
                        _id: { $lt: inv._id },
                        invoice_type: "Booking",
                        with_tax: inv.with_tax,
                        business: business,
                      })
                        .sort({ _id: -1 })
                        .exec();

                      var last_invoice = lv.invoice_no;
                      position = count + 1;
                    }

                    var fy = {
                      with_tax: inv.with_tax,
                      last_invoice: last_invoice,
                      position: position,
                    };

                    var assigned_invoice_no = await q.all(fun.fiscalyear(fy));

                    if (assigned_invoice_no) {
                      if (assigned_invoice_no.invoice) {
                        Invoice.findOneAndUpdate(
                          { _id: inv._id },
                          { $set: { invoice_no: assigned_invoice_no.invoice } },
                          { new: true },
                          async function (err, doc) {
                            if (err) {
                              res.status(422).json({
                                responseCode: 422,
                                responseMessage: "Server Error",
                                responseData: err,
                              });
                            } else {
                              var updated = await q.all(
                                fun.invoice(inv._id, req.headers["tz"])
                              );
                              res.status(200).json({
                                responseCode: 200,
                                responseMessage: "Success",
                                responseData: updated,
                              });
                            }
                          }
                        );
                      } else {
                        res.status(422).json({
                          responseCode: 422,
                          responseMessage: "Server Error",
                          responseData: {},
                        });
                      }
                    } else {
                      res.status(422).json({
                        responseCode: 422,
                        responseMessage: "Server Error",
                        responseData: {},
                      });
                    }
                  }
                }
              );
            });
          }
        } else {
          res.status(400).json({
            responseCode: 400,
            responseMessage: "Booking not found",
            responseData: {},
          });
        }
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Invoices Limit Exceeded. Upgrade Your Plan",
          responseData: {},
        });
      }
    }
  }
);

router.get(
  "/booking/invoices/get/old",
  xAccessToken.token,
  async function (req, res, next) {
    businessFunctions.logs(
      "INFO: /booking/invoices/get Api Called from booking.js," +
        " " +
        "Request Headers:" +
        JSON.stringify(req.headers) +
        ", " +
        "Request Query:" +
        JSON.stringify(req.query)
    );

    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers["business"];
    var loggedInDetails = await User.findById(decoded.user).exec();
    var invoices = [];
    var filters = [];
    var totalResult = 0;

    var role = await Management.findOne({
      user: user,
      business: business,
    }).exec();
    if (req.query.page == undefined) {
      var page = 0;
    } else {
      var page = req.query.page;
    }

    var date = new Date();
    var to = new Date();
    to.setDate(date.getDate() - 1);
    to.setHours(23, 59, 58);

    var page = Math.max(0, parseInt(page));
    var queries = new Object();
    var sortBy = new Object();

    var thumbnail = [];

    var specification = {};
    specification["$lookup"] = {
      from: "Booking",
      localField: "booking",
      foreignField: "_id",
      as: "booking",
    };
    filters.push(specification);

    var specification = {};
    specification["$unwind"] = {
      path: "$booking",
      preserveNullAndEmptyArrays: false,
    };
    filters.push(specification);

    var specification = {};
    specification["$lookup"] = {
      from: "User",
      localField: "user",
      foreignField: "_id",
      as: "user",
    };
    filters.push(specification);

    var specification = {};
    specification["$unwind"] = {
      path: "$user",
      preserveNullAndEmptyArrays: false,
    };
    filters.push(specification);

    var specification = {};
    specification["$lookup"] = {
      from: "Car",
      localField: "car",
      foreignField: "_id",
      as: "car",
    };
    filters.push(specification);

    var specification = {};
    specification["$unwind"] = {
      path: "$car",
      preserveNullAndEmptyArrays: true,
    };

    var specification = {};
    specification["$lookup"] = {
      from: "User",
      localField: "advisor",
      foreignField: "_id",
      as: "advisor",
    };
    filters.push(specification);

    var specification = {};
    specification["$unwind"] = {
      path: "$advisor",
      preserveNullAndEmptyArrays: true,
    };
    filters.push(specification);

    //  else {
    //     var specification = {};
    //     specification["business"] = mongoose.Types.ObjectId(business)
    //     filters.push(specification);
    // }

    if (role.role == "Service Advisor") {
      // console.log("Service Advisor = " + role.user)
      var specification = {};
      specification["$match"] = {
        business: mongoose.Types.ObjectId(business),
        "advisor._id": mongoose.Types.ObjectId(role.user),
      };
      filters.push(specification);
    } else {
      var specification = {};
      specification["$match"] = {
        business: mongoose.Types.ObjectId(business),
      };
      filters.push(specification);
    }

    if (req.query.query) {
      req.query.query = req.query.query.replace(
        /([.?*+^$[\]\\(){}|-])/g,
        "\\$1"
      );
      var specification = {};
      specification["$match"] = {
        business: mongoose.Types.ObjectId(business),
        $or: [
          { status: { $regex: req.query.query, $options: "i" } },
          { booking_no: { $eq: req.query.query } },
          { invoice_no: { $regex: req.query.query, $options: "i" } },
          { "user.name": { $regex: req.query.query, $options: "i" } },
          { "user.contact_no": { $regex: req.query.query, $options: "i" } },
          { "car.title": { $regex: req.query.query, $options: "i" } },
          { "car.registration_no": { $regex: req.query.query, $options: "i" } },
          { "advisor.name": { $regex: req.query.query, $options: "i" } },
          {
            "insurance_info.insurance_company": {
              $regex: req.query.query,
              $options: "i",
            },
          },
          {
            "insurance_info.branch": { $regex: req.query.query, $options: "i" },
          },
          { "advisor.contact_no": { $regex: req.query.query, $options: "i" } },
        ],
      };
      filters.push(specification);
    }
    // else {
    //     var specification = {};
    //     specification['$match'] = {
    //         business: mongoose.Types.ObjectId(business),
    //         'advisor._id': mongoose.Types.ObjectId(role.user),
    //     };
    //     filters.push(specification);
    // }

    totalResult = await Invoice.aggregate(filters);
    // console.log("Total length  = " + totalResult.length)
    var specification = {};
    specification["$sort"] = {
      _id: -1,
    };
    filters.push(specification);

    //totalResult = await Invoice.aggregate(filters);

    var all = _.filter(totalResult, (x) => x.status == "Active");
    var map_due = _.map(all, "due");
    var map_payment = _.map(all, "payment");

    var due = parseFloat(_.sumBy(map_due, (x) => x.due).toFixed(2));
    var payment_total = parseFloat(
      _.sumBy(map_payment, (x) => x.total).toFixed(2)
    );

    var due_result = await businessFunctions.numberConversion(due);
    var payment_total_result = await businessFunctions.numberConversion(
      payment_total
    );

    var specification = {};
    specification["$skip"] = config.perPage * page;
    filters.push(specification);

    var specification = {};
    specification["$limit"] = config.perPage;
    filters.push(specification);
    if (
      Log_Level == 4 ||
      Log_Level == 6 ||
      Log_Level == 8 ||
      Log_Level == 10 ||
      Log_Level == 0
    ) {
      businessFunctions.logs(
        "DEBUG: Fatching Invoice Details, User:" + loggedInDetails.name
      );
    }
    await Invoice.aggregate(filters)
      .allowDiskUse(true)
      .cursor({ batchSize: 10 })
      .exec()
      .eachAsync(async function (invoice) {
        invoices.push({
          _id: invoice._id,
          // id: invoice._id,
          car: invoice.car[0].title,
          user: invoice.user.name,
          // business: {
          //     _id: invoice.business._id,
          //     id: invoice.business._id,
          //     name: invoice.business.name,
          //     contact_no: invoice.business.contact_no,
          //     email: invoice.business.email,
          //     account_info: invoice.business.account_info,
          //     business_info: invoice.business.business_info,
          //     address: invoice.business.address,
          // },
          /*advisor: {
                    _id: invoice.advisor._id,
                    id: invoice.advisor._id,
                    name: invoice.advisor.name,
                    contact_no: invoice.advisor.contact_no,
                    email: invoice.advisor.email
                },*/
          // advisor: invoice.advisor,
          booking: invoice.booking._id,
          // services: invoice.services,
          status: _.startCase(invoice.status),
          invoice_no: invoice.invoice_no,
          // job_no: invoice.job_no,
          // booking_no: invoice.booking_no,
          // address: invoice.address,
          paymentTotal: currencyFormatter.format(invoice.payment.total, {
            code: "INR",
          }),
          due: currencyFormatter.format(invoice.due.due, { code: "INR" }),
          // odometer: invoice.odometer,
          //insurance_info: invoice.booking.insurance_info,
          // invoice_type: invoice.invoice_type,
          // started_at: moment(invoice.started_at).tz(req.headers['tz']).format('lll'),
          // delivery_date: moment(invoice.delivery_date).tz(req.headers['tz']).format('ll'),
          // delivery_time: invoice.delivery_time,
          status: invoice.status,
          started_at: moment(invoice.started_at)
            .tz(req.headers["tz"])
            .format("lll"),
          created_at: moment(invoice.created_at)
            .tz(req.headers["tz"])
            .format("lll"),
          updated_at: moment(invoice.updated_at)
            .tz(req.headers["tz"])
            .format("lll"),
        });
      });

    if (
      Log_Level == 4 ||
      Log_Level == 6 ||
      Log_Level == 8 ||
      Log_Level == 10 ||
      Log_Level == 0
    ) {
      businessFunctions.logs(
        "DEBUG: Sending Invoices List in Response, User:" + loggedInDetails.name
      );
    }
    res.status(200).json({
      responseCode: 200,
      responseMessage: to,
      responseInfo: {
        due: due_result,
        totalResult: totalResult.length,
        payment_total: payment_total_result,
      },
      responseData: invoices,
    });
    if (
      Log_Level == 3 ||
      Log_Level == 7 ||
      Log_Level == 9 ||
      Log_Level == 10 ||
      Log_Level == 0
    ) {
      businessFunctions.logs(
        "INFO: Invoices List send in Response Successfully, User:" +
          loggedInDetails.name
      );
    }
  }
);

router.get(
  "/booking/invoices/get",
  xAccessToken.token,
  async function (req, res, next) {
    businessFunctions.logs(
      "INFO: /booking/invoices/get Api Called from 3.0.js," +
        " " +
        "Request Headers:" +
        JSON.stringify(req.headers) +
        ", " +
        "Request Query:" +
        JSON.stringify(req.query)
    );

    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers["business"];
    var loggedInDetails = await User.findById(decoded.user).exec();
    var invoices = [];
    var filters = [];

    if (req.query.page == undefined) {
      var page = 0;
    } else {
      var page = req.query.page;
    }

    var date = new Date();
    var to = new Date();
    to.setDate(date.getDate() - 1);
    to.setHours(23, 59, 58);

    var thumbnail = [];
    var role = await Management.findOne({
      user: user,
      business: business,
    }).exec();

    if (role.role == "Service Advisor") {
      var specification = {};
      specification["$match"] = {
        business: mongoose.Types.ObjectId(business),
        "advisor._id": mongoose.Types.ObjectId(role.user),
      };
      filters.push(specification);
    } else {
      var specification = {};
      specification["$match"] = {
        business: mongoose.Types.ObjectId(business),
      };
      filters.push(specification);
    }

    if (req.query.query) {
      req.query.query = req.query.query.replace(
        /([.?*+^$[\]\\(){}|-])/g,
        "\\$1"
      );
      var specification = {};
      specification["$match"] = {
        business: mongoose.Types.ObjectId(business),
        $or: [
          { status: { $regex: req.query.query, $options: "i" } },
          { booking_no: { $eq: req.query.query } },
          { invoice_no: { $regex: req.query.query, $options: "i" } },
          { "user.name": { $regex: req.query.query, $options: "i" } },
          { "user.contact_no": { $regex: req.query.query, $options: "i" } },
          { "car.title": { $regex: req.query.query, $options: "i" } },
          { "car.registration_no": { $regex: req.query.query, $options: "i" } },
          { "advisor.name": { $regex: req.query.query, $options: "i" } },
          {
            "insurance_info.insurance_company": {
              $regex: req.query.query,
              $options: "i",
            },
          },
          {
            "insurance_info.branch": { $regex: req.query.query, $options: "i" },
          },
          { "advisor.contact_no": { $regex: req.query.query, $options: "i" } },
        ],
      };
      filters.push(specification);
    }

    var specification = {};
    specification["$lookup"] = {
      from: "Booking",
      localField: "booking",
      foreignField: "_id",
      as: "booking",
    };
    filters.push(specification);

    var specification = {};
    specification["$unwind"] = {
      path: "$booking",
      preserveNullAndEmptyArrays: false,
    };
    filters.push(specification);

    var specification = {};
    specification["$lookup"] = {
      from: "User",
      localField: "user",
      foreignField: "_id",
      as: "user",
    };
    filters.push(specification);

    var specification = {};
    specification["$unwind"] = {
      path: "$user",
      preserveNullAndEmptyArrays: false,
    };
    filters.push(specification);

    var specification = {};
    specification["$lookup"] = {
      from: "Car",
      localField: "car",
      foreignField: "_id",
      as: "car",
    };
    filters.push(specification);

    var specification = {};
    specification["$unwind"] = {
      path: "$car",
      preserveNullAndEmptyArrays: true,
    };

    var specification = {};
    specification["$lookup"] = {
      from: "User",
      localField: "advisor",
      foreignField: "_id",
      as: "advisor",
    };
    filters.push(specification);

    var specification = {};
    specification["$unwind"] = {
      path: "$advisor",
      preserveNullAndEmptyArrays: true,
    };
    filters.push(specification);

    // var totalResult = 0
    // var totalResult = await Invoice.aggregate(filters);

    var specification = {};
    specification["$sort"] = {
      _id: -1,
    };
    filters.push(specification);

    var specification = {};
    specification["$skip"] = 6 * page;
    filters.push(specification);

    var specification = {};
    specification["$limit"] = config.perPage;
    filters.push(specification);

    // var all = _.filter(totalResult, x => x.status == "Active");
    // var map_due = _.map(all, 'due');
    // var map_payment = _.map(all, 'payment')

    // var due = parseFloat(_.sumBy(map_due, x => x.due).toFixed(2));
    // var payment_total = parseFloat(_.sumBy(map_payment, x => x.total).toFixed(2));

    // var due_result = await businessFunctions.numberConversion(due)
    // var payment_total_result = await businessFunctions.numberConversion(payment_total)

    if (
      Log_Level == 4 ||
      Log_Level == 6 ||
      Log_Level == 8 ||
      Log_Level == 10 ||
      Log_Level == 0
    ) {
      businessFunctions.logs(
        "DEBUG: Fatching Invoice Details, User:" + loggedInDetails.name
      );
    }

    await Invoice.aggregate(filters)
      .allowDiskUse(true)
      .cursor({ batchSize: 10 })
      .exec()
      .eachAsync(async function (invoice) {
        invoices.push({
          _id: invoice._id,
          // id: invoice._id,
          car: invoice.car[0].title,
          user: invoice.user.name,
          userId: invoice.user._id,
          contact_no: invoice.user.contact_no,
          // business: {
          //     _id: invoice.business._id,
          //     id: invoice.business._id,
          //     name: invoice.business.name,
          //     contact_no: invoice.business.contact_no,
          //     email: invoice.business.email,
          //     account_info: invoice.business.account_info,
          //     business_info: invoice.business.business_info,
          //     address: invoice.business.address,
          // },
          /*advisor: {
                    _id: invoice.advisor._id,
                    id: invoice.advisor._id,
                    name: invoice.advisor.name,
                    contact_no: invoice.advisor.contact_no,
                    email: invoice.advisor.email
                },*/
          // advisor: invoice.advisor,
          booking: invoice.booking._id,
          // services: invoice.services,
          status: _.startCase(invoice.status),
          invoice_no: invoice.invoice_no,
          // job_no: invoice.job_no,
          // booking_no: invoice.booking_no,
          // address: invoice.address,
          paymentTotal: currencyFormatter.format(invoice.payment.total, {
            code: "INR",
          }),
          due: currencyFormatter.format(invoice.due.due, { code: "INR" }),
          // odometer: invoice.odometer,
          //insurance_info: invoice.booking.insurance_info,
          invoice_type: invoice.invoice_type,
          // started_at: moment(invoice.started_at).tz(req.headers['tz']).format('lll'),
          // delivery_date: moment(invoice.delivery_date).tz(req.headers['tz']).format('ll'),
          // delivery_time: invoice.delivery_time,
          status: invoice.status,
          started_at: moment(invoice.started_at)
            .tz(req.headers["tz"])
            .format("lll"),
          created_at: moment(invoice.created_at)
            .tz(req.headers["tz"])
            .format("lll"),
          updated_at: moment(invoice.updated_at)
            .tz(req.headers["tz"])
            .format("lll"),
        });
      });

    if (
      Log_Level == 4 ||
      Log_Level == 6 ||
      Log_Level == 8 ||
      Log_Level == 10 ||
      Log_Level == 0
    ) {
      businessFunctions.logs(
        "DEBUG: Sending Invoices List in Response, User:" + loggedInDetails.name
      );
    }
    res.status(200).json({
      responseCode: 200,
      responseMessage: to,
      // responseInfo: {
      //     due: due_result,
      //     totalResult: totalResult.length,
      //     payment_total: payment_total_result
      // },
      responseData: invoices,
    });
    if (
      Log_Level == 3 ||
      Log_Level == 7 ||
      Log_Level == 9 ||
      Log_Level == 10 ||
      Log_Level == 0
    ) {
      businessFunctions.logs(
        "INFO: Invoices List send in Response Successfully, User:" +
          loggedInDetails.name
      );
    }
  }
);

router.get(
  "/booking/invoices_total/get",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var business = req.headers["business"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;

    var filters = [];
    var role = await Management.findOne({
      user: user,
      business: business,
    }).exec();
    if (role.role == "Service Advisor") {
      var specification = {};
      specification["$match"] = {
        business: mongoose.Types.ObjectId(business),
        "advisor._id": mongoose.Types.ObjectId(role.user),
      };
      filters.push(specification);
    } else {
      var specification = {};
      specification["$match"] = {
        business: mongoose.Types.ObjectId(business),
      };
      filters.push(specification);
    }

    var specification = {};
    specification["$lookup"] = {
      from: "Booking",
      localField: "booking",
      foreignField: "_id",
      as: "booking",
    };
    filters.push(specification);

    var specification = {};
    specification["$unwind"] = {
      path: "$booking",
      preserveNullAndEmptyArrays: false,
    };
    filters.push(specification);

    var specification = {};
    specification["$lookup"] = {
      from: "User",
      localField: "user",
      foreignField: "_id",
      as: "user",
    };
    filters.push(specification);

    var specification = {};
    specification["$unwind"] = {
      path: "$user",
      preserveNullAndEmptyArrays: false,
    };
    filters.push(specification);

    var specification = {};
    specification["$lookup"] = {
      from: "Car",
      localField: "car",
      foreignField: "_id",
      as: "car",
    };
    filters.push(specification);

    var specification = {};
    specification["$unwind"] = {
      path: "$car",
      preserveNullAndEmptyArrays: true,
    };

    var specification = {};
    specification["$lookup"] = {
      from: "User",
      localField: "advisor",
      foreignField: "_id",
      as: "advisor",
    };
    filters.push(specification);

    var specification = {};
    specification["$unwind"] = {
      path: "$advisor",
      preserveNullAndEmptyArrays: true,
    };
    filters.push(specification);

    // var totalResult = 0
    var totalResult = await Invoice.aggregate(filters);

    var all = _.filter(totalResult, (x) => x.status == "Active");
    var map_due = _.map(all, "due");
    var map_payment = _.map(all, "payment");

    var due = parseFloat(_.sumBy(map_due, (x) => x.due).toFixed(2));
    var payment_total = parseFloat(
      _.sumBy(map_payment, (x) => x.total).toFixed(2)
    );

    var due_result = await businessFunctions.numberConversion(due);
    var payment_total_result = await businessFunctions.numberConversion(
      payment_total
    );

    res.status(200).json({
      responseCode: 200,
      responseMessage: "success",
      responseData: {
        totalResult: totalResult.length,
        payment_total: payment_total_result,
        due: due_result,
      },
    });
  }
);

router.delete(
  "/booking/invoice/cancel",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      invoice: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Invoice is required",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var business = req.headers["business"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var user = decoded.user;
      var data = new Object();

      var loggedInDetails = await User.findById(user).exec();

      var invoice = await Invoice.findOne({
        _id: req.body.invoice,
        status: "Active",
      }).exec();
      if (invoice) {
        Invoice.findOneAndUpdate(
          { _id: invoice._id },
          { $set: { status: "Cancelled" } },
          { new: true },
          async function (err, doc) {
            if (err) {
              res.status(422).json({
                responseCode: 422,
                responseMessage: "Server Error",
                responseData: err,
              });
            } else {
              Booking.findOneAndUpdate(
                { _id: invoice.booking },
                { $set: { status: "Ready" } },
                { new: true },
                async function (err, doc) {
                  if (err) {
                    res.status(422).json({
                      responseCode: 422,
                      responseMessage: "Server Error",
                      responseData: err,
                    });
                  } else {
                    var activity = {
                      user: loggedInDetails._id,
                      name: loggedInDetails.name,
                      stage: "Invoice",
                      activity:
                        "Invoice Cancelled #(" + invoice.invoice_no + ")",
                    };

                    fun.bookingLog(invoice.booking, activity);

                    res.status(200).json({
                      responseCode: 200,
                      responseMessage: "Invoice Cancelled",
                      responseData: {},
                    });
                  }
                }
              );
            }
          }
        );
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Invoice not found",
          responseData: {},
        });
      }
    }
  }
);

router.get("/invoice/get", xAccessToken.token, async function (req, res, next) {
  var rules = {
    invoice: "required",
  };
  var validation = new Validator(req.query, rules);

  if (validation.fails()) {
    res.status(422).json({
      responseCode: 422,
      responseMessage: "Invoice is required",
      responseData: {
        res: validation.errors.all(),
      },
    });
  } else {
    var token = req.headers["x-access-token"];
    var business = req.headers["business"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var data = new Object();
    var discount = 0;
    var code = "";
    var discount_type = "";
    var bookingService = [];

    var invoice = await Invoice.findOne({ _id: req.query.invoice })
      .populate({ path: "booking" })
      .populate({ path: "address" })
      .populate({ path: "advisor", select: "_id id name contact_no email" })
      .populate({
        path: "user",
        select: "_id id name contact_no email business_info",
      })
      .populate({
        path: "business",
        select:
          "_id id name contact_no email business_info bank_details address",
      })
      .populate({
        path: "car",
        select:
          "_id id title registration_no ic rc vin engine_no insurance_info",
      })
      .exec();

    if (invoice) {
      var booking = invoice.booking;
      var tax_type = invoice.tax_type;
      var services = invoice.services;
      if (invoice.invoice_type == "Insurance") {
        if (
          invoice.insurance_info.insurance_company &&
          invoice.insurance_info.branch &&
          invoice.insurance_info.state &&
          invoice.insurance_info.gstin
        ) {
          if (
            booking.insurance_info.state.toLowerCase() ==
            booking.business.address.state.toLowerCase()
          ) {
            tax_type = "GST";
          } else {
            tax_type = "IGST";
          }
        }

        for (var i = 0; i < services.length; i++) {
          var part = [];
          var labours = [];
          var opening_fitting = [];

          var part_list = services[i].parts;
          var labour_list = services[i].labour;
          var of_list = services[i].opening_fitting;

          if (part_list) {
            for (var p = 0; p < part_list.length; p++) {
              var total = 0;
              var tax_info = await Tax.findOne({
                rate: part_list[p].tax_rate,
                type: tax_type,
              }).exec();
              var tax = [];
              var rate = part_list[p].rate;
              var amount =
                parseFloat(part_list[p].rate) *
                parseFloat(part_list[p].quantity);
              var tax_rate = tax_info.detail;
              var discount_total = 0;
              var base = amount;

              var dep = 0;

              if (
                parseFloat(part_list[p].insurance_dep) <= 0 &&
                parseFloat(part_list[p].customer_dep) <= 0
              ) {
                dep = 100;
              } else {
                if (
                  parseFloat(part_list[p].insurance_dep) <= 0 &&
                  parseFloat(part_list[p].customer_dep <= 100)
                ) {
                  dep = 100;
                } else {
                  dep = 100 - parseFloat(part_list[p].insurance_dep);
                }
              }

              amount = amount - (amount * dep) / 100;

              var dep = base - amount;

              if (part_list[p].amount_is_tax == "exclusive") {
                var tax_on_amount = amount;
                if (tax_rate.length > 0) {
                  for (var r = 0; r < tax_rate.length; r++) {
                    if (tax_rate[r].rate != tax_info.rate) {
                      var t = tax_on_amount * (tax_rate[r].rate / 100);
                      amount = amount + t;
                      parseFloat;
                      tax.push({
                        tax: tax_rate[r].tax,
                        rate: tax_rate[r].rate,
                        amount: parseFloat(t.toFixed(2)),
                      });
                    } else {
                      var t = tax_on_amount * (tax_rate[r].rate / 100);
                      amount = amount + t;
                      tax.push({
                        tax: tax_info.tax,
                        tax_rate: tax_info.rate,
                        rate: tax_info.rate,
                        amount: parseFloat(t.toFixed(2)),
                      });
                    }
                  }
                }
                total = total + amount;
              }

              if (part_list[p].amount_is_tax == "inclusive") {
                var x = (100 + tax_info.rate) / 100;
                var tax_on_amount = amount / x;
                if (tax_rate.length > 0) {
                  for (var r = 0; r < tax_rate.length; r++) {
                    if (tax_rate[r].rate != tax_info.rate) {
                      var t = tax_on_amount * (tax_rate[r].rate / 100);
                      base = base - t;
                      tax.push({
                        tax: tax_rate[r].tax,
                        rate: tax_rate[r].rate,
                        amount: parseFloat(t.toFixed(2)),
                      });
                    } else {
                      var t = amount - tax_on_amount;
                      base = base - t;
                      tax.push({
                        tax: tax_info.tax,
                        tax_rate: tax_info.rate,
                        rate: tax_info.rate,
                        amount: parseFloat(t.toFixed(2)),
                      });
                    }
                  }
                }

                base = base - dep;
                total = total + amount;
              }

              var tax_amount = total - parseFloat(base.toFixed(2));

              var tax_details = {
                tax: tax_info.tax,
                tax_rate: tax_info.rate,
                rate: tax_info.rate,
                amount: total,
                detail: tax,
              };

              part.push({
                item: part_list[p].item,
                source: part_list[p].source,
                hsn_sac: part_list[p].hsn_sac,
                part_no: part_list[p].part_no,
                rate: parseFloat(part_list[p].rate),
                quantity: parseFloat(part_list[p].quantity),
                base: parseFloat(base.toFixed(2)),
                amount: total,
                discount: 0,
                //discount: part_list[p].discount,
                issued: part_list[p].issued,
                customer_dep: parseFloat(part_list[p].customer_dep),
                insurance_dep: parseFloat(part_list[p].insurance_dep),
                tax_amount: parseFloat(
                  _.sumBy(tax, (x) => x.amount).toFixed(2)
                ),
                amount_is_tax: part_list[p].amount_is_tax,
                tax: tax_info.tax,
                tax_rate: tax_info.rate,
                tax_info: tax_details,
              });
            }
          }

          if (labour_list) {
            for (var l = 0; l < labour_list.length; l++) {
              var total = 0;
              var tax_info = await Tax.findOne({
                rate: labour_list[l].tax_rate,
                type: tax_type,
              }).exec();
              var tax = [];
              var rate = labour_list[l].rate;
              var amount =
                parseFloat(labour_list[l].rate) *
                parseFloat(labour_list[l].quantity);
              var tax_rate = tax_info.detail;
              var discount_total = 0;
              var base = amount;
              var dep = 0;

              if (
                parseFloat(labour_list[l].insurance_dep) <= 0 &&
                parseFloat(labour_list[l].customer_dep) <= 0
              ) {
                dep = 100;
              } else {
                if (
                  parseFloat(labour_list[l].insurance_dep) <= 0 &&
                  parseFloat(labour_list[l].customer_dep <= 100)
                ) {
                  dep = 100;
                } else {
                  dep = 100 - parseFloat(labour_list[l].insurance_dep);
                }
              }

              amount = amount - (amount * dep) / 100;
              var dep = base - amount;

              if (labour_list[l].amount_is_tax == "exclusive") {
                var tax_on_amount = amount;
                if (tax_rate.length > 0) {
                  for (var r = 0; r < tax_rate.length; r++) {
                    if (tax_rate[r].rate != tax_info.rate) {
                      var t = tax_on_amount * (tax_rate[r].rate / 100);
                      amount = amount + t;
                      parseFloat;
                      tax.push({
                        tax: tax_rate[r].tax,
                        rate: tax_rate[r].rate,
                        amount: parseFloat(t.toFixed(2)),
                      });
                    } else {
                      var t = tax_on_amount * (tax_rate[r].rate / 100);
                      amount = amount + t;
                      tax.push({
                        tax: tax_info.tax,
                        tax_rate: tax_info.rate,
                        rate: tax_info.rate,
                        amount: parseFloat(t.toFixed(2)),
                      });
                    }
                  }
                }
                //total = total+amount;
              }

              if (labour_list[l].amount_is_tax == "inclusive") {
                var x = (100 + tax_info.rate) / 100;
                var tax_on_amount = amount / x;
                if (tax_rate.length > 0) {
                  for (var r = 0; r < tax_rate.length; r++) {
                    if (tax_rate[r].rate != tax_info.rate) {
                      var t = tax_on_amount * (tax_rate[r].rate / 100);
                      base = base - t;
                      tax.push({
                        tax: tax_rate[r].tax,
                        rate: tax_rate[r].rate,
                        amount: parseFloat(t.toFixed(2)),
                      });
                    } else {
                      var t = amount - tax_on_amount;
                      base = base - t;
                      tax.push({
                        tax: tax_info.tax,
                        tax_rate: tax_info.rate,
                        rate: tax_info.rate,
                        amount: parseFloat(t.toFixed(2)),
                      });
                    }
                  }
                }

                base = base - dep;

                total = total + amount;
              }

              var tax_amount = total - parseFloat(base.toFixed(2));

              var tax_details = {
                tax: tax_info.tax,
                rate: tax_info.rate,
                amount: total,
                detail: tax,
              };

              labours.push({
                item: labour_list[l].item,
                source: labour_list[l].source,
                rate: parseFloat(labour_list[l].rate),
                quantity: parseFloat(labour_list[l].quantity),
                base: parseFloat(base.toFixed(2)),
                amount: amount,
                discount: 0,
                //discount: labour_list[l].discount,
                customer_dep: parseFloat(labour_list[l].customer_dep),
                insurance_dep: parseFloat(labour_list[l].insurance_dep),
                tax_amount: parseFloat(
                  _.sumBy(tax, (x) => x.amount).toFixed(2)
                ),
                amount_is_tax: labour_list[l].amount_is_tax,
                tax: tax_info.tax,
                tax_rate: tax_info.rate,
                tax_info: tax_details,
              });
            }
          }

          if (of_list) {
            for (var o = 0; o < of_list.length; o++) {
              var total = 0;
              var tax_info = await Tax.findOne({
                rate: of_list[o].tax_rate,
                type: tax_type,
              }).exec();
              var tax = [];
              var rate = of_list[o].rate;
              var amount =
                parseFloat(of_list[o].rate) * parseFloat(of_list[o].quantity);
              var tax_rate = tax_info.detail;
              var discount_total = 0;
              var base = amount;
              var dep = 0;

              if (
                parseFloat(of_list[o].insurance_dep) <= 0 &&
                parseFloat(of_list[o].customer_dep) <= 0
              ) {
                dep = 100;
              } else {
                if (
                  parseFloat(of_list[o].insurance_dep) <= 0 &&
                  parseFloat(of_list[o].customer_dep <= 100)
                ) {
                  dep = 100;
                } else {
                  dep = 100 - parseFloat(of_list[o].insurance_dep);
                }
              }

              amount = amount - (amount * dep) / 100;
              var dep = base - amount;

              if (of_list[o].amount_is_tax == "exclusive") {
                var tax_on_amount = amount;
                if (tax_rate.length > 0) {
                  for (var r = 0; r < tax_rate.length; r++) {
                    if (tax_rate[r].rate != tax_info.rate) {
                      var t = tax_on_amount * (tax_rate[r].rate / 100);
                      amount = amount + t;
                      parseFloat;
                      tax.push({
                        tax: tax_rate[r].tax,
                        rate: tax_rate[r].rate,
                        amount: parseFloat(t.toFixed(2)),
                      });
                    } else {
                      var t = tax_on_amount * (tax_rate[r].rate / 100);
                      amount = amount + t;
                      tax.push({
                        tax: tax_info.tax,
                        tax_rate: tax_info.rate,
                        rate: tax_info.rate,
                        amount: parseFloat(t.toFixed(2)),
                      });
                    }
                  }
                }
                total = total + amount;
              }

              if (of_list[o].amount_is_tax == "inclusive") {
                var x = (100 + tax_info.rate) / 100;
                var tax_on_amount = amount / x;
                if (tax_rate.length > 0) {
                  for (var r = 0; r < tax_rate.length; r++) {
                    if (tax_rate[r].rate != tax_info.rate) {
                      var t = tax_on_amount * (tax_rate[r].rate / 100);
                      base = base - t;
                      tax.push({
                        tax: tax_rate[r].tax,
                        rate: tax_rate[r].rate,
                        amount: parseFloat(t.toFixed(2)),
                      });
                    } else {
                      var t = amount - tax_on_amount;
                      base = base - t;
                      tax.push({
                        tax: tax_info.tax,
                        tax_rate: tax_info.rate,
                        rate: tax_info.rate,
                        amount: parseFloat(t.toFixed(2)),
                      });
                    }
                  }
                }
                base = base - dep;
                total = total + amount;
              }

              var tax_details = {
                tax: tax_info.tax,
                rate: tax_info.rate,
                amount: total,
                detail: tax,
              };

              var tax_amount = total - parseFloat(base.toFixed(2));

              opening_fitting.push({
                item: of_list[o].item,
                source: of_list[o].source,
                rate: parseFloat(of_list[o].rate),
                quantity: parseFloat(of_list[o].quantity),
                base: parseFloat(base.toFixed(2)),
                amount: total,
                discount: 0,
                //discount: parseFloat(of_list[o].discount),
                customer_dep: parseFloat(of_list[o].customer_dep),
                insurance_dep: parseFloat(of_list[o].insurance_dep),
                tax_amount: parseFloat(
                  _.sumBy(tax, (x) => x.amount).toFixed(2)
                ),
                amount_is_tax: of_list[o].amount_is_tax,
                tax: tax_info.tax,
                tax_rate: tax_info.rate,
                tax_info: tax_details,
              });
            }
          }

          var parts_visible = true;

          bookingService.push({
            source: services[i].source,
            service: services[i].service,
            mileage: services[i].mileage,
            parts: part,
            labour: labours,
            opening_fitting: opening_fitting,
            hours: services[i].hours,
            parts_visible: parts_visible,
            quantity: services[i].quantity,
            discount: 0,
            //discount: _.sumBy(labours, x => x.discount)+_.sumBy(part, x => x.discount)+_.sumBy(opening_fitting, x => x.discount),
            description: services[i].description,
            cost:
              _.sumBy(part, (x) => x.amount) +
              _.sumBy(labours, (x) => x.amount) +
              services[i].of_cost,
            labour_cost: _.sumBy(labours, (x) => x.amount),
            of_cost: _.sumBy(opening_fitting, (x) => x.amount),
            part_cost: _.sumBy(part, (x) => x.amount),
            exceeded_cost: parseFloat(services[i].exceeded_cost),
            part_cost_editable: services[i].part_cost_editable,
            labour_cost_editable: services[i].labour_cost_editable,
            of_cost_editable: services[i].of_cost_editable,
            type: services[i].type,
            customer_approval: services[i].customer_approval,
            surveyor_approval: services[i].surveyor_approval,
            claim: services[i].claim,
            custom: services[i].custom,
          });
        }
      } else {
        if (invoice.address) {
          if (
            invoice.address.state.toLowerCase() ==
            invoice.business.address.state.toLowerCase()
          ) {
            tax_type = "GST";
          } else {
            tax_type = "IGST";
          }
        }

        for (var i = 0; i < services.length; i++) {
          var part = [];
          var labours = [];
          var opening_fitting = [];

          var part_list = services[i].parts;
          var labour_list = services[i].labour;
          var of_list = services[i].opening_fitting;

          if (part_list) {
            for (var p = 0; p < part_list.length; p++) {
              var total = 0;
              var tax_info = await Tax.findOne({
                rate: part_list[p].tax_rate,
                type: tax_type,
              }).exec();
              var tax = [];
              var rate = part_list[p].rate;
              var amount =
                parseFloat(part_list[p].rate) *
                parseFloat(part_list[p].quantity);
              var tax_rate = tax_info.detail;
              var discount_total = 0;
              var base = amount;

              var dep = 0;

              if (services[i].claim == true) {
                if (
                  parseFloat(part_list[p].insurance_dep) <= 0 &&
                  parseFloat(part_list[p].customer_dep) <= 0
                ) {
                  dep = 0;
                } else {
                  if (
                    parseFloat(part_list[p].customer_dep) <= 0 &&
                    parseFloat(part_list[p].insurance_dep <= 100)
                  ) {
                    dep = 100;
                  } else {
                    dep = 100 - parseFloat(part_list[p].customer_dep);
                  }
                }

                amount = amount - (amount * dep) / 100;
                dep = base - amount;
              }

              if (part_list[p].discount) {
                discount_total = part_list[p].discount;
                amount = amount - parseFloat(discount_total.toFixed(2));
              }

              if (part_list[p].amount_is_tax == "exclusive") {
                var tax_on_amount = amount;
                if (tax_rate.length > 0) {
                  for (var r = 0; r < tax_rate.length; r++) {
                    if (tax_rate[r].rate != tax_info.rate) {
                      var t = tax_on_amount * (tax_rate[r].rate / 100);
                      amount = amount + t;
                      parseFloat;
                      tax.push({
                        tax: tax_rate[r].tax,
                        rate: tax_rate[r].rate,
                        amount: parseFloat(t.toFixed(2)),
                      });
                    } else {
                      var t = tax_on_amount * (tax_rate[r].rate / 100);
                      amount = amount + t;
                      tax.push({
                        tax: tax_info.tax,
                        tax_rate: tax_info.rate,
                        rate: tax_info.rate,
                        amount: parseFloat(t.toFixed(2)),
                      });
                    }
                  }
                }
                total = total + amount;
              }

              if (part_list[p].amount_is_tax == "inclusive") {
                var x = (100 + tax_info.rate) / 100;
                var tax_on_amount = amount / x;
                if (tax_rate.length > 0) {
                  for (var r = 0; r < tax_rate.length; r++) {
                    if (tax_rate[r].rate != tax_info.rate) {
                      var t = tax_on_amount * (tax_rate[r].rate / 100);
                      base = base - t;
                      tax.push({
                        tax: tax_rate[r].tax,
                        rate: tax_rate[r].rate,
                        amount: parseFloat(t.toFixed(2)),
                      });
                    } else {
                      var t = amount - tax_on_amount;
                      base = base - t;
                      tax.push({
                        tax: tax_info.tax,
                        tax_rate: tax_info.rate,
                        rate: tax_info.rate,
                        amount: parseFloat(t.toFixed(2)),
                      });
                    }
                  }
                }

                base = base - dep;
                total = total + amount;
              }

              var tax_amount = total - parseFloat(base.toFixed(2));

              var tax_details = {
                tax: tax_info.tax,
                tax_rate: tax_info.rate,
                rate: tax_info.rate,
                amount: total,
                detail: tax,
              };

              part.push({
                item: part_list[p].item,
                source: part_list[p].source,
                hsn_sac: part_list[p].hsn_sac,
                part_no: part_list[p].part_no,
                rate: parseFloat(part_list[p].rate),
                quantity: parseFloat(part_list[p].quantity),
                base: parseFloat(base.toFixed(2)),
                amount: total,
                discount: part_list[p].discount,
                issued: part_list[p].issued,
                customer_dep: parseFloat(part_list[p].customer_dep),
                insurance_dep: parseFloat(part_list[p].insurance_dep),
                tax_amount: parseFloat(
                  _.sumBy(tax, (x) => x.amount).toFixed(2)
                ),
                amount_is_tax: part_list[p].amount_is_tax,
                tax: tax_info.tax,
                tax_rate: tax_info.rate,
                tax_info: tax_details,
              });
            }
          }

          if (labour_list) {
            for (var l = 0; l < labour_list.length; l++) {
              var total = 0;
              var tax_info = await Tax.findOne({
                rate: labour_list[l].tax_rate,
                type: tax_type,
              }).exec();
              var tax = [];
              var rate = labour_list[l].rate;
              var amount =
                parseFloat(labour_list[l].rate) *
                parseFloat(labour_list[l].quantity);
              var tax_rate = tax_info.detail;
              var discount_total = 0;
              var base = amount;
              var dep = 0;

              if (services[i].claim == true) {
                if (
                  parseFloat(labour_list[l].insurance_dep) <= 0 &&
                  parseFloat(labour_list[l].customer_dep) <= 0
                ) {
                  dep = 0;
                } else {
                  if (
                    parseFloat(labour_list[l].customer_dep) <= 0 &&
                    parseFloat(labour_list[l].insurance_dep <= 100)
                  ) {
                    dep = 100;
                  } else {
                    dep = 100 - parseFloat(labour_list[l].customer_dep);
                  }
                }

                amount = amount - (amount * dep) / 100;
                dep = base - amount;
              }

              if (labour_list[l].discount) {
                discount_total = labour_list[l].discount;
                amount = amount - parseFloat(discount_total.toFixed(2));
              }

              if (labour_list[l].amount_is_tax == "exclusive") {
                var tax_on_amount = amount;
                if (tax_rate.length > 0) {
                  for (var r = 0; r < tax_rate.length; r++) {
                    if (tax_rate[r].rate != tax_info.rate) {
                      var t = tax_on_amount * (tax_rate[r].rate / 100);
                      amount = amount + t;
                      parseFloat;
                      tax.push({
                        tax: tax_rate[r].tax,
                        rate: tax_rate[r].rate,
                        amount: parseFloat(t.toFixed(2)),
                      });
                    } else {
                      var t = tax_on_amount * (tax_rate[r].rate / 100);
                      amount = amount + t;
                      tax.push({
                        tax: tax_info.tax,
                        tax_rate: tax_info.rate,
                        rate: tax_info.rate,
                        amount: parseFloat(t.toFixed(2)),
                      });
                    }
                  }
                }
                //total = total+amount;
              }

              if (labour_list[l].amount_is_tax == "inclusive") {
                var x = (100 + tax_info.rate) / 100;
                var tax_on_amount = amount / x;
                if (tax_rate.length > 0) {
                  for (var r = 0; r < tax_rate.length; r++) {
                    if (tax_rate[r].rate != tax_info.rate) {
                      var t = tax_on_amount * (tax_rate[r].rate / 100);
                      base = base - t;
                      tax.push({
                        tax: tax_rate[r].tax,
                        rate: tax_rate[r].rate,
                        amount: parseFloat(t.toFixed(2)),
                      });
                    } else {
                      var t = amount - tax_on_amount;
                      base = base - t;
                      tax.push({
                        tax: tax_info.tax,
                        tax_rate: tax_info.rate,
                        rate: tax_info.rate,
                        amount: parseFloat(t.toFixed(2)),
                      });
                    }
                  }
                }

                base = base - dep;

                total = total + amount;
              }

              var tax_amount = total - parseFloat(base.toFixed(2));

              var tax_details = {
                tax: tax_info.tax,
                rate: tax_info.rate,
                amount: total,
                detail: tax,
              };

              labours.push({
                item: labour_list[l].item,
                source: labour_list[l].source,
                rate: parseFloat(labour_list[l].rate),
                quantity: parseFloat(labour_list[l].quantity),
                base: parseFloat(base.toFixed(2)),
                amount: amount,
                discount: labour_list[l].discount,
                customer_dep: parseFloat(labour_list[l].customer_dep),
                insurance_dep: parseFloat(labour_list[l].insurance_dep),
                tax_amount: parseFloat(
                  _.sumBy(tax, (x) => x.amount).toFixed(2)
                ),
                amount_is_tax: labour_list[l].amount_is_tax,
                tax: tax_info.tax,
                tax_rate: tax_info.rate,
                tax_info: tax_details,
              });
            }
          }

          if (of_list) {
            for (var o = 0; o < of_list.length; o++) {
              var total = 0;
              var tax_info = await Tax.findOne({
                rate: of_list[o].tax_rate,
                type: tax_type,
              }).exec();
              var tax = [];
              var rate = of_list[o].rate;
              var amount =
                parseFloat(of_list[o].rate) * parseFloat(of_list[o].quantity);
              var tax_rate = tax_info.detail;
              var discount_total = 0;
              var base = amount;
              var dep = 0;

              if (services[i].claim == true) {
                if (
                  parseFloat(of_list[o].insurance_dep) <= 0 &&
                  parseFloat(of_list[o].customer_dep) <= 0
                ) {
                  dep = 0;
                } else {
                  if (
                    parseFloat(of_list[o].customer_dep) <= 0 &&
                    parseFloat(of_list[o].insurance_dep <= 100)
                  ) {
                    dep = 100;
                  } else {
                    dep = 100 - parseFloat(of_list[o].customer_dep);
                  }
                }

                amount = amount - (amount * dep) / 100;
                dep = base - amount;
              }

              if (of_list[o].discount) {
                var discount_total = of_list[o].discount;
                amount = amount - parseFloat(discount_total.toFixed(2));
              }

              if (of_list[o].amount_is_tax == "exclusive") {
                var tax_on_amount = amount;
                if (tax_rate.length > 0) {
                  for (var r = 0; r < tax_rate.length; r++) {
                    if (tax_rate[r].rate != tax_info.rate) {
                      var t = tax_on_amount * (tax_rate[r].rate / 100);
                      amount = amount + t;
                      parseFloat;
                      tax.push({
                        tax: tax_rate[r].tax,
                        rate: tax_rate[r].rate,
                        amount: parseFloat(t.toFixed(2)),
                      });
                    } else {
                      var t = tax_on_amount * (tax_rate[r].rate / 100);
                      amount = amount + t;
                      tax.push({
                        tax: tax_info.tax,
                        tax_rate: tax_info.rate,
                        rate: tax_info.rate,
                        amount: parseFloat(t.toFixed(2)),
                      });
                    }
                  }
                }
                total = total + amount;
              }

              if (of_list[o].amount_is_tax == "inclusive") {
                var x = (100 + tax_info.rate) / 100;
                var tax_on_amount = amount / x;
                if (tax_rate.length > 0) {
                  for (var r = 0; r < tax_rate.length; r++) {
                    if (tax_rate[r].rate != tax_info.rate) {
                      var t = tax_on_amount * (tax_rate[r].rate / 100);
                      base = base - t;
                      tax.push({
                        tax: tax_rate[r].tax,
                        rate: tax_rate[r].rate,
                        amount: parseFloat(t.toFixed(2)),
                      });
                    } else {
                      var t = amount - tax_on_amount;
                      base = base - t;
                      tax.push({
                        tax: tax_info.tax,
                        tax_rate: tax_info.rate,
                        rate: tax_info.rate,
                        amount: parseFloat(t.toFixed(2)),
                      });
                    }
                  }
                }

                base = base - dep;
                total = total + amount;
              }

              var tax_details = {
                tax: tax_info.tax,
                rate: tax_info.rate,
                amount: total,
                detail: tax,
              };

              var tax_amount = total - parseFloat(base.toFixed(2));

              opening_fitting.push({
                item: of_list[o].item,
                source: of_list[o].source,
                rate: parseFloat(of_list[o].rate),
                quantity: parseFloat(of_list[o].quantity),
                base: parseFloat(base.toFixed(2)),
                amount: total,
                discount: parseFloat(of_list[o].discount),
                customer_dep: parseFloat(of_list[o].customer_dep),
                insurance_dep: parseFloat(of_list[o].insurance_dep),
                tax_amount: parseFloat(
                  _.sumBy(tax, (x) => x.amount).toFixed(2)
                ),
                amount_is_tax: of_list[o].amount_is_tax,
                tax: tax_info.tax,
                tax_rate: tax_info.rate,
                tax_info: tax_details,
              });
            }
          }

          var parts_visible = true;

          bookingService.push({
            source: services[i].source,
            service: services[i].service,
            mileage: services[i].mileage,
            parts: part,
            labour: labours,
            opening_fitting: opening_fitting,
            hours: services[i].hours,
            parts_visible: parts_visible,
            quantity: services[i].quantity,
            discount:
              _.sumBy(labours, (x) => x.discount) +
              _.sumBy(part, (x) => x.discount) +
              _.sumBy(opening_fitting, (x) => x.discount),
            description: services[i].description,
            cost:
              _.sumBy(part, (x) => x.amount) +
              _.sumBy(labours, (x) => x.amount) +
              services[i].of_cost,
            labour_cost: _.sumBy(labours, (x) => x.amount),
            of_cost: _.sumBy(opening_fitting, (x) => x.amount),
            part_cost: _.sumBy(part, (x) => x.amount),
            exceeded_cost: parseFloat(services[i].exceeded_cost),
            part_cost_editable: services[i].part_cost_editable,
            labour_cost_editable: services[i].labour_cost_editable,
            of_cost_editable: services[i].of_cost_editable,
            type: services[i].type,
            customer_approval: services[i].customer_approval,
            surveyor_approval: services[i].surveyor_approval,
            claim: services[i].claim,
            custom: services[i].custom,
          });
        }
      }

      var approved = invoice.services;

      var paid_total = invoice.payment.paid_total;
      var labour_cost = _.sumBy(approved, (x) => x.labour_cost);
      var part_cost = _.sumBy(approved, (x) => x.part_cost);
      var of_cost = _.sumBy(approved, (x) => x.of_cost);
      var discount_total = _.sumBy(approved, (x) => x.discount);

      var pick_up_charges = invoice.payment.pick_up_charges;
      var policy_clause = invoice.payment.policy_clause;
      var salvage = invoice.payment.salvage;

      var careager_cash = invoice.payment.careager_cash;

      var payment_total =
        labour_cost +
        part_cost +
        of_cost +
        discount_total +
        policy_clause +
        salvage +
        pick_up_charges;

      var estimate_cost =
        labour_cost +
        part_cost +
        of_cost +
        policy_clause +
        salvage +
        pick_up_charges;

      var due_amount =
        _.sumBy(approved, (x) => x.labour_cost) +
        _.sumBy(approved, (x) => x.part_cost) +
        _.sumBy(approved, (x) => x.of_cost) +
        policy_clause +
        salvage +
        pick_up_charges -
        (paid_total + careager_cash);

      var due = {
        due: Math.ceil(due_amount.toFixed(2)),
      };

      var payment = {
        estimate_cost: estimate_cost,
        total: payment_total,
        careager_cash: careager_cash,
        of_cost: of_cost,
        labour_cost: labour_cost,
        part_cost: part_cost,
        payment_mode: invoice.payment.payment_mode,
        payment_status: invoice.payment.payment_status,
        coupon: invoice.payment.coupon,
        coupon_type: invoice.payment.coupon_type,
        discount_by: invoice.payment.discount_by,
        discount_type: invoice.payment.discount_type,
        discount: invoice.payment.discount,
        discount_total: discount_total,
        policy_clause: policy_clause,
        salvage: salvage,
        terms: invoice.payment.terms,
        pick_up_limit: invoice.payment.pick_up_limit,
        pick_up_charges: pick_up_charges,
        paid_total: parseFloat(invoice.payment.paid_total),
        discount_applied: invoice.payment.discount_applied,
        transaction_id: invoice.payment.transaction_id,
        transaction_date: invoice.payment.transaction_date,
        transaction_status: invoice.payment.transaction_status,
        transaction_response: invoice.payment.transaction_response,
      };

      var show = {
        _id: invoice._id,
        id: invoice._id,
        car: invoice.car,
        user: invoice.user,
        business: invoice.business,
        advisor: invoice.advisor,
        services: bookingService,
        status: _.startCase(invoice.status),
        invoice_no: invoice.invoice_no,
        job_no: invoice.job_no,
        booking: invoice.booking,
        booking_no: invoice.booking_no,
        address: invoice.address,
        payment: payment,
        due: invoice.due,
        odometer: invoice.odometer,
        insurance_info: invoice.insurance_info,
        invoice_type: invoice.invoice_type,
        with_tax: invoice.with_tax,
        note: invoice.note,
        started_at: moment(invoice.started_at)
          .tz(req.headers["tz"])
          .format("lll"),
        delivery_date: moment(invoice.delivery_date)
          .tz(req.headers["tz"])
          .format("ll"),
        delivery_time: invoice.delivery_time,
        started_at: moment(invoice.started_at)
          .tz(req.headers["tz"])
          .format("lll"),
        created_at: moment(invoice.created_at)
          .tz(req.headers["tz"])
          .format("lll"),
        updated_at: moment(invoice.updated_at)
          .tz(req.headers["tz"])
          .format("lll"),
      };

      res.status(200).json({
        responseCode: 200,
        responseMessage: "Success",
        responseData: show,
      });
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Unauthorized",
        responseData: {},
      });
    }
  }
});

router.get(
  "/my/booking/invoice/get",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      invoice: "required",
    };
    var validation = new Validator(req.query, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Invoice is required",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var business = req.headers["business"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var user = decoded.user;
      var data = new Object();
      var discount = 0;
      var code = "";
      var discount_type = "";

      var invoice = await Invoice.findOne({ booking: req.query.invoice })
        .populate({
          path: "advisor",
          populate: { path: "user", select: "_id id name contact_no email" },
        })
        .populate({
          path: "user",
          populate: {
            path: "user",
            select: "_id id name contact_no email business_info",
          },
        })
        .populate({
          path: "business",
          populate: {
            path: "user",
            select: "_id id name contact_no email business_info",
          },
        })
        .populate({
          path: "car",
          select:
            "_id id title registration_no ic rc vin engine_no insurance_info",
        })
        .exec();

      if (invoice) {
        var car = null;
        var advisor = null;
        var customer_requirements = [];
        var address = null;
        var recording = "";
        if (invoice.car) {
          car = {
            title: invoice.car.title,
            _id: invoice.car._id,
            id: invoice.car.id,
            vin: invoice.car.vin,
            engine_no: invoice.car.engine_no,
            registration_no: invoice.car.registration_no,
            ic_address: invoice.car.ic_address,
            rc_address: invoice.car.rc_address,
          };
        }

        if (invoice.advisor) {
          var email = "";
          if (invoice.advisor.email) {
            email = invoice.advisor.email;
          }
          advisor = {
            name: invoice.advisor.name,
            _id: invoice.advisor._id,
            id: invoice.advisor.id,
            contact_no: invoice.advisor.contact_no,
            email: email,
          };
        }

        if (invoice.customer_requirements) {
          customer_requirements = invoice.customer_requirements;
        }

        if (invoice.address) {
          var address = await Address.findOne({ _id: invoice.address }).exec();
        }

        var show = {
          _id: invoice._id,
          id: invoice._id,
          car: car,
          user: {
            name: invoice.user.name,
            _id: invoice.user._id,
            id: invoice.user.id,
            contact_no: invoice.user.contact_no,
            email: invoice.user.email,
            business_info: invoice.user.business_info,
          },
          business: {
            name: invoice.business.name,
            _id: invoice.business._id,
            id: invoice.business.id,
            contact_no: invoice.business.contact_no,
            email: invoice.business.email,
            business_info: invoice.business.business_info,
          },
          advisor: advisor,
          services: invoice.services,
          status: _.startCase(invoice.status),
          invoice_no: invoice.invoice_no,
          job_no: invoice.job_no,
          booking: invoice.booking,
          booking_no: invoice.booking_no,
          address: address,
          payment: invoice.payment,
          due: invoice.due,
          odometer: invoice.odometer,
          started_at: moment(invoice.started_at)
            .tz(req.headers["tz"])
            .format("lll"),
          delivery_date: moment(invoice.delivery_date)
            .tz(req.headers["tz"])
            .format("ll"),
          delivery_time: invoice.delivery_time,
          started_at: moment(invoice.started_at)
            .tz(req.headers["tz"])
            .format("lll"),
          created_at: moment(invoice.created_at)
            .tz(req.headers["tz"])
            .format("lll"),
          updated_at: moment(invoice.updated_at)
            .tz(req.headers["tz"])
            .format("lll"),
        };

        res.status(200).json({
          responseCode: 200,
          responseMessage: "Success",
          responseData: show,
        });
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Unauthorized",
          responseData: {},
        });
      }
    }
  }
);

router.get("/search/all", xAccessToken.token, async function (req, res, next) {
  var token = req.headers["x-access-token"];
  var secret = config.secret;
  var decoded = jwt.verify(token, secret);
  var user = decoded.user;
  var business = req.headers["business"];
  var bookings = [];
  var totalResult = 0;

  if (req.query.page == undefined) {
    var page = 0;
  } else {
    var page = req.query.page;
  }

  var page = Math.max(0, parseInt(page));
  var result = [];
  var data = {};
  var query = req.query.query;
  var type = req.query.type;

  if (query) {
    if (type == "user") {
      var users = [];
      await User.find({ "account_info.status": "Active" })
        .or([
          { $or: [{ name: new RegExp(query, "i") }] },
          { $or: [{ contact_no: new RegExp(query, "i") }] },
        ])
        .cursor()
        .eachAsync(async (user) => {
          var b = await Booking.find({
            business: business,
            user: user._id,
          }).count();
          var l = await Lead.find({
            business: business,
            user: user._id,
          }).count();
          var o = await BusinessOrder.find({
            business: business,
            user: user._id,
          }).count();
          if (b > 0 || l > 0 || o > 0) {
            result.push({
              name: user.name,
              email: user.email,
              contact_no: user.contact_no,
              _id: user._id,
              id: user._id,
              type: "user",
            });
          }
        });

      data = {
        user: result,
      };
    } else if (type == "booking") {
      var customer = await User.findOne({ contact_no: query }).exec();
      if (customer) {
        var search = {};
        search["user"] = mongoose.Types.ObjectId(customer._id);
        bookings.push(search);
      }

      var car = await Car.findOne({
        reg_no_copy: query.replace(/\s/g, ""),
      }).exec();
      if (car) {
        var search = {};
        search["car"] = mongoose.Types.ObjectId(car._id);
        bookings.push(search);
      }

      var search = {};
      if (!parseInt(query)) {
        query = 0;
      }

      search["booking_no"] = parseInt(query);
      bookings.push(search);

      var thumbnail = [];

      await Booking.find({
        business: business,
        status: {
          $in: [
            "Pending",
            "Confirmed",
            "EstimateRequested",
            "Approved",
            "Approval",
            "Completed",
          ],
        },
        $or: bookings,
      })
        .populate({
          path: "user",
          populate: { path: "user", select: "_id id name contact_no" },
        })
        .populate({
          path: "manager",
          populate: { path: "user", select: "_id id name contact_no" },
        })
        .populate({
          path: "car",
          select: "_id id title registration_no ic rc",
          populate: { path: "thumbnails" },
        })
        .cursor()
        .eachAsync(async (booking) => {
          var address = await Address.findOne({ _id: booking.address }).exec();
          if (booking.car) {
            if (booking.car.thumbnails[0]) {
              var thumbnail = [booking.car.thumbnails[0]];
            } else {
              var thumbnail = [];
            }

            var car = {
              title: booking.car.title,
              _id: booking.car._id,
              id: booking.car.id,
              rc_address: booking.car.rc_address,
              ic_address: booking.car.ic_address,
              ic: booking.car.ic,
              rc: booking.car.rc,
              registration_no: booking.car.registration_no,
            };
          } else {
            var car = null;
          }

          var manager = null;
          if (booking.manager) {
            manager = {
              name: booking.manager.name,
              _id: booking.manager._id,
              id: booking.manager.id,
              contact_no: booking.manager.contact_no,
              email: booking.manager.email,
            };
          }

          result.push({
            _id: booking._id,
            id: booking._id,
            car: car,
            user: {
              name: booking.user.name,
              _id: booking.user._id,
              id: booking.user.id,
              contact_no: booking.user.contact_no,
            },
            manager: manager,
            services: booking.services,
            convenience: booking.convenience,
            date: moment(booking.date).tz(req.headers["tz"]).format("ll"),
            time_slot: booking.time_slot,
            status: booking.status,
            booking_no: booking.booking_no,
            address: address,
            payment: booking.payment,
            customer_requirements: booking.customer_requirements,
            estimation_requested: booking.estimation_requested,
            txnid: booking.txnid,
            __v: booking.__v,
            updated_at: booking.updated_at,
            updated_at: booking.updated_at,
            type: "Booking",
          });
        });

      data = {
        booking: result,
      };
    } else if (type == "order") {
      var customer = await User.findOne({ contact_no: query }).exec();
      if (customer) {
        var search = {};
        search["user"] = mongoose.Types.ObjectId(customer._id);
        bookings.push(search);
      }

      var search = {};
      search["order_no"] = query;
      bookings.push(search);

      ////////////console.log(bookings)

      await OrderLine.aggregate([
        {
          $match: {
            business: { $eq: mongoose.Types.ObjectId(business) },
            $or: bookings,
          },
        },
        { $unwind: "$user" },
        {
          $lookup: {
            from: "User",
            localField: "user",
            foreignField: "_id",
            as: "user",
          },
        },
        { $unwind: "$order" },
        {
          $lookup: {
            from: "Order",
            localField: "order",
            foreignField: "_id",
            as: "order",
          },
        },
        { $unwind: "$product" },
        {
          $lookup: {
            from: "BusinessProduct",
            localField: "product",
            foreignField: "_id",
            as: "product",
          },
        },
        { $group: { _id: "$order._id", data: { $push: "$$ROOT" } } },
        { $skip: config.perPage * page },
        { $limit: config.perPage },
      ])
        .allowDiskUse(true)
        .cursor({ batchSize: 10 })
        .exec()
        .eachAsync(async function (doc) {
          var data = doc.data;
          var stock = true;
          data.forEach(async function (d) {
            if (d.product[0].stock.available <= 0) {
              stock = false;
            }
          });

          var address = await Address.findById(
            doc.data[0].order[0].address
          ).exec();
          var time_left = moment(doc.data[0].date).endOf("day").fromNow();

          if (time_left.includes("ago")) {
            time_left = time_left;
          } else {
            time_left = time_left.replace("in ", "") + " left";
          }

          result.push({
            _id: doc.data[0].order[0]._id,
            id: doc.data[0].order[0]._id,
            order_no: doc.data[0].order[0].order_no,
            name: doc.data[0].user[0].name,
            contact_no: doc.data[0].user[0].contact_no,
            stock: stock,
            address: address,
            convenience: doc.data[0].convenience,
            time_left: time_left,
            status: doc.data[0].order[0].status,
            created_at: moment(doc.data[0].order[0].created_at)
              .tz(req.headers["tz"])
              .format("lll"),
            delivered_by: moment(doc.data[0].date)
              .tz(req.headers["tz"])
              .format("ll"),
            time_slot: doc.data[0].time_slot,
          });
        });

      data = {
        order: result,
      };
    } else if (type == "lead") {
      await Lead.find({
        "remark.status": { $in: ["Open", "Follow-Up", "PSF"] },
      })
        .or([
          { $or: [{ lead_id: new RegExp(query, "i") }] },
          { $or: [{ name: new RegExp(query, "i") }] },
          { $or: [{ contact_no: new RegExp(query, "i") }] },
        ])
        .populate({ path: "assignee", select: "id name contact_no email" })
        .sort({ updated_at: -1 })
        .skip(config.perPage * page)
        .limit(config.perPage)
        .cursor()
        .eachAsync(async (lead) => {
          if (lead) {
            var remark = await LeadRemark.findOne({ lead: lead._id })
              .sort({ created_at: -1 })
              .exec();
            result.push({
              user: lead.user,
              name: lead.name,
              contact_no: lead.contact_no,
              email: lead.email,
              _id: lead._id,
              id: lead.id,
              type: lead.type,
              date: moment(lead.updated_at).tz(req.headers["tz"]).format("lll"),
              status: lead.status,
              important: lead.important,
              follow_up: lead.follow_up,
              remark: lead.remark,
              assignee: lead.assignee,
              created_at: moment(lead.created_at)
                .tz(req.headers["tz"])
                .format("lll"),
              updated_at: moment(lead.updated_at)
                .tz(req.headers["tz"])
                .format("lll"),
            });
          }
        });

      data = {
        lead: result,
      };
    }
    res.status(200).json({
      responseCode: 200,
      responseMessage: "",
      responseData: data,
    });
  } else {
    res.status(200).json({
      responseCode: 200,
      responseMessage: "",
      responseData: data,
    });
  }
});

router.post(
  "/address/add",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      user: "required",
      address: "required",
      zip: "required",
      city: "required",
      state: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Error",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var user = await User.findById(req.body.user);
      if (user) {
        var data = {
          user: user._id,
          address: req.body.address,
          area: req.body.area,
          landmark: req.body.landmark,
          zip: req.body.zip,
          city: req.body.city,
          state: req.body.state,
          created_at: new Date(),
          updated_at: new Date(),
        };

        Address.create(data).then(async function (address) {
          res.status(200).json({
            responseCode: 200,
            responseMessage: "Address Updated",
            responseData: address,
          });
        });
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "User not found",
          responseData: {},
        });
      }
    }
  }
);

router.get("/address/get", xAccessToken.token, async function (req, res, next) {
  var token = req.headers["x-access-token"];
  var secret = config.secret;
  var decoded = jwt.verify(token, secret);
  var user = await User.findById(req.query.user);
  if (user) {
    res.status(200).json({
      responseCode: 200,
      responseMessage: "Address",
      responseData: await Address.find({ user: user._id }).exec(),
    });
  } else {
    res.status(400).json({
      responseCode: 400,
      responseMessage: "User not found",
      responseData: {},
    });
  }
});

router.get("/parts/get/", xAccessToken.token, async function (req, res, next) {
  var rules = {
    query: "required",
    quantity: "required",
  };

  var validation = new Validator(req.query, rules);

  if (validation.fails()) {
    res.status(422).json({
      responseCode: 422,
      responseMessage: "Part/Part No & quantity required",
      responseData: {
        res: validation.errors.all(),
      },
    });
  } else {
    if (parseFloat(req.query.quantity) > 0) {
      var business = req.headers["business"];
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var data = [];
      await BusinessProduct.find({
        business:
          business /*,"stock.available":{$gt: 0},list_type: {$in: ["Offline"]}*/,
        $or: [
          { part_no: new RegExp(req.query.query, "i") },
          {
            title: new RegExp(req.query.query, "i"),
          } /*{models: {$in:new RegExp(req.query.query, "i")}}*/,
        ],
      })
        .cursor()
        .eachAsync(async (p) => {
          var quantity = parseFloat(req.query.quantity);
          if (p.stock.available >= quantity) {
            var rate = p.price.sell_price;
            var base = p.price.sell_price * quantity;
            var amount = p.price.sell_price * quantity;

            var tax_info = await Tax.findOne({ tax: p.tax_info.tax }).exec();
            var tax_rate = tax_info.detail;
            var tax = [];

            var x = (100 + p.tax_info.rate) / 100;
            var tax_on_amount = amount / x;
            if (tax_rate.length > 0) {
              for (var r = 0; r < tax_rate.length; r++) {
                if (tax_rate[r].rate != tax_info.rate) {
                  var t = tax_on_amount * (tax_rate[r].rate / 100);
                  base = base - t;
                  tax.push({
                    tax: tax_rate[r].tax,
                    rate: tax_rate[r].rate,
                    amount: parseFloat(t.toFixed(2)),
                  });
                } else {
                  var t = amount - tax_on_amount;
                  base = base - t;
                  tax.push({
                    tax: tax_info.tax,
                    rate: tax_info.rate,
                    amount: parseFloat(t.toFixed(2)),
                  });
                }
              }
            }

            var tax_details = {
              tax: tax_info.tax,
              rate: tax_info.rate,
              amount: p.price.sell_price,
              detail: tax,
            };

            data.push({
              _id: mongoose.Types.ObjectId(),
              item: p.title,
              sku: p.sku,
              part_no: p.part_no,
              hsn_sac: p.hsn_sac,
              source: p._id,
              unit: p.unit,
              issued: false,
              quantity: parseFloat(quantity.toFixed(2)),
              mrp: parseFloat(rate.toFixed(2)),
              selling_price: parseFloat(rate.toFixed(2)),
              rate: parseFloat(rate.toFixed(2)),
              base: parseFloat(base.toFixed(2)),
              amount: parseFloat(amount.toFixed(2)),
              discount: 0,
              amount_is_tax: p.amount_is_tax,
              tax_amount: parseFloat(_.sumBy(tax, (x) => x.amount).toFixed(2)),
              tax: p.tax_info.tax,
              tax_rate: p.tax_info.rate,
              tax_info: tax_details,
              out_of_stock: false,
              stock_available: parseFloat(p.stock.available.toFixed(2)),
              business: p.business,
              customer_dep: 100,
              insurance_dep: 0,
            });
          } else if (p.stock.available < quantity && p.stock.available > 0) {
            quantity = p.stock.available;
            var rate = p.price.sell_price;
            var base = p.price.sell_price * quantity;
            var amount = p.price.sell_price * quantity;

            var tax_info = await Tax.findOne({ tax: p.tax_info.tax }).exec();
            var tax_rate = tax_info.detail;
            var tax = [];

            var x = (100 + p.tax_info.rate) / 100;
            var tax_on_amount = amount / x;
            if (tax_rate.length > 0) {
              for (var r = 0; r < tax_rate.length; r++) {
                if (tax_rate[r].rate != tax_info.rate) {
                  var t = tax_on_amount * (tax_rate[r].rate / 100);
                  base = base - t;
                  tax.push({
                    tax: tax_rate[r].tax,
                    rate: tax_rate[r].rate,
                    amount: parseFloat(t.toFixed(2)),
                  });
                } else {
                  var t = amount - tax_on_amount;
                  base = base - t;
                  tax.push({
                    tax: tax_info.tax,
                    rate: tax_info.rate,
                    amount: parseFloat(t.toFixed(2)),
                  });
                }
              }
            }

            var tax_details = {
              tax: tax_info.tax,
              rate: tax_info.rate,
              amount: p.price.sell_price,
              detail: tax,
            };

            data.push({
              _id: mongoose.Types.ObjectId(),
              sku: p.sku,
              item: p.title,
              part_no: p.part_no,
              hsn_sac: p.hsn_sac,
              source: p._id,
              quantity: parseFloat(quantity.toFixed(2)),
              mrp: parseFloat(rate.toFixed(2)),
              selling_price: parseFloat(rate.toFixed(2)),
              rate: parseFloat(rate.toFixed(2)),
              base: parseFloat(base.toFixed(2)),
              amount: parseFloat(amount.toFixed(2)),
              issued: false,
              discount: 0,
              unit: p.unit,
              amount_is_tax: p.amount_is_tax,
              tax_amount: parseFloat(_.sumBy(tax, (x) => x.amount).toFixed(2)),
              tax: p.tax_info.tax,
              tax_rate: p.tax_info.rate,
              tax_info: tax_details,
              out_of_stock: false,
              stock_available: parseFloat(p.stock.available.toFixed(2)),
              business: p.business,
              customer_dep: 100,
              insurance_dep: 0,
            });
          } else if (p.stock.available <= 0) {
            var rate = p.price.sell_price;
            var base = p.price.sell_price * quantity;
            var amount = p.price.sell_price * quantity;

            var tax_info = await Tax.findOne({ tax: p.tax_info.tax }).exec();
            var tax_rate = tax_info.detail;
            var tax = [];

            var x = (100 + p.tax_info.rate) / 100;
            var tax_on_amount = amount / x;
            if (tax_rate.length > 0) {
              for (var r = 0; r < tax_rate.length; r++) {
                if (tax_rate[r].rate != tax_info.rate) {
                  var t = tax_on_amount * (tax_rate[r].rate / 100);
                  base = base - t;
                  tax.push({
                    tax: tax_rate[r].tax,
                    rate: tax_rate[r].rate,
                    amount: parseFloat(t.toFixed(2)),
                  });
                } else {
                  var t = amount - tax_on_amount;
                  //base = base - discount_total
                  tax.push({
                    tax: tax_info.tax,
                    rate: tax_info.rate,
                    amount: parseFloat(t.toFixed(2)),
                  });
                }
              }
            }

            var tax_details = {
              tax: tax_info.tax,
              rate: tax_info.rate,
              amount: p.price.sell_price,
              detail: tax,
            };

            data.push({
              _id: mongoose.Types.ObjectId(),
              sku: p.sku,
              item: p.title,
              part_no: p.part_no,
              hsn_sac: p.hsn_sac,
              source: p._id,
              quantity: parseFloat(quantity.toFixed(2)),
              mrp: parseFloat(rate.toFixed(2)),
              selling_price: parseFloat(rate.toFixed(2)),
              rate: parseFloat(rate.toFixed(2)),
              base: parseFloat(base.toFixed(2)),
              amount: parseFloat(amount.toFixed(2)),
              discount: 0,
              issued: false,
              unit: p.unit,
              tax_amount: parseFloat(_.sumBy(tax, (x) => x.amount).toFixed(2)),
              amount_is_tax: p.amount_is_tax,
              tax: p.tax_info.tax,
              tax_rate: p.tax_info.rate,
              tax_info: tax_details,
              out_of_stock: true,
              stock_available: 0,
              business: p.business,
              customer_dep: 100,
              insurance_dep: 0,
            });
          }
        });

      res.status(200).json({
        responseCode: 200,
        responseMessage: "",
        responseData: data,
      });
    } else {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Part/Part No & quantity required",
        responseData: {},
      });
    }
  }
});

router.post(
  "/job/parts/add/",
  xAccessToken.token,
  async function (req, res, next) {
    var business = req.headers["business"];
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var data = [];
    var loggedInDetails = await User.findById(decoded.user).exec();
    var booking = await Booking.findById(req.body.booking).exec();
    if (booking) {
      var updated_parts = [];
      var exceeded_cost = 0;
      var services = req.body.service;
      var bookingService = {};
      if (services) {
        var service_part = services.parts;
        if (service_part.length > 0) {
          for (var p = 0; p < service_part.length; p++) {
            parts_visible = false;
            var tax_info = await Tax.findOne({
              tax: service_part[p].tax,
            }).exec();
            var quantity = service_part[p].quantity;
            var tax_rate = tax_info.detail;
            var amount = service_part[p].amount;
            var discount_total = 0;
            var base = amount;
            var part_tax = [];

            if (service_part[p].discount) {
              discount_total = service_part[p].discount;
              amount = amount - parseFloat(discount_total.toFixed(2));
            }

            if (service_part[p].amount_is_tax == "exclusive") {
              var tax_on_amount = amount;
              if (tax_rate.length > 0) {
                for (var r = 0; r < tax_rate.length; r++) {
                  if (tax_rate[r].rate != tax_info.rate) {
                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                    amount = amount + t;
                    parseFloat;
                    part_tax.push({
                      tax: tax_rate[r].tax,
                      rate: tax_rate[r].rate,
                      amount: parseFloat(t.toFixed(2)),
                    });
                  } else {
                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                    amount = amount + t;
                    part_tax.push({
                      tax: tax_info.tax,
                      tax_rate: tax_info.rate,
                      rate: tax_info.rate,
                      amount: parseFloat(t.toFixed(2)),
                    });
                  }
                }
              }
            }

            if (service_part[p].amount_is_tax == "inclusive") {
              var x = (100 + tax_info.rate) / 100;
              var tax_on_amount = amount / x;
              if (tax_rate.length > 0) {
                for (var r = 0; r < tax_rate.length; r++) {
                  if (tax_rate[r].rate != tax_info.rate) {
                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                    base = base - t;
                    part_tax.push({
                      tax: tax_rate[r].tax,
                      rate: tax_rate[r].rate,
                      amount: parseFloat(t.toFixed(2)),
                    });
                  } else {
                    var t = amount - tax_on_amount;
                    base = base - t;
                    part_tax.push({
                      tax: tax_info.tax,
                      tax_rate: tax_info.rate,
                      rate: tax_info.rate,
                      amount: parseFloat(t.toFixed(2)),
                    });
                  }
                }
              }

              //base = base - discount_total;
            }

            var tax_detail = {
              tax: tax_info.tax,
              tax_rate: tax_info.rate,
              rate: tax_info.rate,
              base: parseFloat(base.toFixed(2)),
              detail: part_tax,
            };

            updated_parts.push({
              _id: service_part[p]._id,
              item: service_part[p].item,
              source: service_part[p].source,
              quantity: service_part[p].quantity,
              hsn_sac: service_part[p].hsn_sac,
              part_no: service_part[p].part_no,
              rate: parseFloat(service_part[p].rate),
              base: parseFloat(base.toFixed(2)),
              amount: parseFloat(amount),
              customer_dep: parseFloat(service_part[p].customer_dep),
              insurance_dep: parseFloat(service_part[p].insurance_dep),
              tax_amount: _.sumBy(part_tax, (x) => x.amount),
              amount_is_tax: service_part[p].amount_is_tax,
              discount: service_part[p].discount,
              tax: tax_info.tax,
              tax_rate: tax_info.rate,
              issued: service_part[p].issued,
              tax_info: tax_detail,
            });
          }
        }

        var issue_part_cost = _.sumBy(updated_parts, (x) => x.amount);
        var issue_labour_cost = _.sumBy(services.labour, (x) => x.amount);
        if (services.source != null) {
          bookingService = {
            source: services.source,
            part_cost: issue_part_cost,
            labour_cost: services.labour_cost,
            exceeded_cost: exceeded_cost,
            of_cost: services.of_cost,
            part_rate: services.part_rate,
            cost: issue_part_cost + services.labour_cost + services.of_cost,
            labour_rate: services.labour_rate,
            quantity: services.quantity,
            of_rate: services.of_rate,
            parts: updated_parts,
            labour: services.labour,
            discount:
              _.sumBy(services.labour, (x) => x.discount) +
              _.sumBy(updated_parts, (x) => x.discount) +
              _.sumBy(services.opening_fitting, (x) => x.discount),
            opening_fitting: services.opening_fitting,
            part_cost_editable: services.part_cost_editable,
            labour_cost_editable: services.part_cost_editable,
            of_cost_editable: services.part_cost_editable,
            description: services.description,
            service: services.service,
            type: services.type,
            claim: services.claim,
            custom: services.custom,
            customer_approval: services.customer_approval,
            surveyor_approval: services.claim,
          };
        } else {
          bookingService = {
            source: services.source,
            part_cost: issue_part_cost,
            labour_cost: services.labour_cost,
            exceeded_cost: exceeded_cost,
            of_cost: services.of_cost,
            part_rate: services.part_rate,
            cost: issue_part_cost + services.labour_cost + services.of_cost,
            labour_rate: services.labour_rate,
            quantity: services.quantity,
            of_rate: services.of_rate,
            parts: updated_parts,
            labour: services.labour,
            discount:
              _.sumBy(services.labour, (x) => x.discount) +
              _.sumBy(updated_parts, (x) => x.discount) +
              _.sumBy(services.opening_fitting, (x) => x.discount),
            opening_fitting: services.opening_fitting,
            part_cost_editable: services.part_cost_editable,
            labour_cost_editable: services.part_cost_editable,
            of_cost_editable: services.part_cost_editable,
            description: services.description,
            service: services.service,
            type: services.type,
            claim: services.claim,
            custom: services.custom,
            customer_approval: services.customer_approval,
            surveyor_approval: services.claim,
          };
        }

        serviceAdd(bookingService, booking._id);
        res.status(200).json({
          responseCode: 200,
          responseMessage: "",
          responseData: bookingService,
        });
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "No Service found",
          responseData: {},
        });
      }
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Booking not found",
        responseData: {},
      });
    }
  }
);

router.post(
  "/job/parts/issue/",
  xAccessToken.token,
  async function (req, res, next) {
    var business = req.headers["business"];
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var data = [];
    var loggedInDetails = await User.findById(decoded.user).exec();
    var booking = await Booking.findById(req.body.booking).exec();
    if (booking) {
      var bookingService = [];
      var services = req.body.services;
      if (services.length > 0) {
        for (var i = 0; i < services.length; i++) {
          var update_parts = [];
          var parts = services[i].parts;
          if (parts.length > 0) {
            for (var k = 0; k < parts.length; k++) {
              if (
                parseFloat(parts[k].customer_dep) == 0 &&
                parseFloat(parts[k].insurance_dep) == 0
              ) {
                var customer_dep = 100;
                var insurance_dep = 0;
              } else {
                var customer_dep = parseFloat(parts[k].customer_dep);
                var insurance_dep = parseFloat(parts[k].insurance_dep);
              }

              if (parts[k].source != null && parts[k].issued == false) {
                var businessProduct = await BusinessProduct.findById(
                  parts[k].source
                ).exec();

                if (businessProduct.stock.available >= parts[k].quantity) {
                  var stockTotal = parseFloat(businessProduct.stock.total);
                  var stockAvailable =
                    parseFloat(businessProduct.stock.available) -
                    parts[k].quantity;
                  var stockConsumed =
                    parseFloat(businessProduct.stock.consumed) +
                    parts[k].quantity;

                  if (stockAvailable < 0) {
                    stockAvailable = 0;
                  }

                  if (stockConsumed < 0) {
                    stockConsumed = 0;
                  }

                  var stock = {
                    total: stockTotal,
                    available: stockAvailable,
                    consumed: stockConsumed,
                  };

                  update_parts.push({
                    _id: parts[k]._id,
                    source: parts[k].source,
                    quantity: parts[k].quantity,
                    issued: true,
                    item: parts[k].item,
                    hsn_sac: parts[k].hsn_sac,
                    part_no: parts[k].part_no,
                    quantity: parts[k].quantity,
                    rate: parts[k].rate,
                    base: parts[k].base,
                    amount: parts[k].amount,
                    customer_dep: customer_dep,
                    insurance_dep: insurance_dep,
                    tax_amount: parts[k].tax_amount,
                    amount_is_tax: parts[k].amount_is_tax,
                    discount: parts[k].discount,
                    tax_rate: parts[k].tax_rate,
                    tax: parts[k].tax,
                    tax_info: parts[k].tax_info,
                  });

                  var activity = {
                    user: loggedInDetails._id,
                    name: loggedInDetails.name,
                    stage: "Parts Updates",
                    activity:
                      parts[k].item +
                      "(" +
                      parts[k].part_no +
                      ") has been issued.\n" +
                      parts[k].quantity +
                      "" +
                      businessProduct.unit +
                      "/ Price: " +
                      parts[k].amount,
                  };

                  fun.bookingLog(booking._id, activity);

                  BusinessProduct.findOneAndUpdate(
                    { _id: parts[k].source },
                    { $set: { stock: stock } },
                    { new: false },
                    async function (err, doc) {
                      if (err) {
                        //////console.log(err)
                      } else {
                      }
                    }
                  );
                } else {
                  update_parts.push({
                    _id: parts[k]._id,
                    source: parts[k].source,
                    quantity: parts[k].quantity,
                    issued: parts[k].issued,
                    item: parts[k].item,
                    hsn_sac: parts[k].hsn_sac,
                    part_no: parts[k].part_no,
                    quantity: parts[k].quantity,
                    rate: parts[k].rate,
                    base: parts[k].base,
                    amount: parts[k].amount,
                    customer_dep: customer_dep,
                    insurance_dep: insurance_dep,
                    tax_amount: parts[k].tax_amount,
                    amount_is_tax: parts[k].amount_is_tax,
                    discount: parts[k].discount,
                    tax_rate: parts[k].tax_rate,
                    tax: parts[k].tax,
                    tax_info: parts[k].tax_info,
                  });
                }
              } else {
                update_parts.push({
                  _id: parts[k]._id,
                  source: parts[k].source,
                  quantity: parts[k].quantity,
                  issued: parts[k].issued,
                  item: parts[k].item,
                  hsn_sac: parts[k].hsn_sac,
                  part_no: parts[k].part_no,
                  quantity: parts[k].quantity,
                  rate: parts[k].rate,
                  base: parts[k].base,
                  amount: parts[k].amount,
                  customer_dep: customer_dep,
                  insurance_dep: insurance_dep,
                  tax_amount: parts[k].tax_amount,
                  amount_is_tax: parts[k].amount_is_tax,
                  discount: parts[k].discount,
                  tax_rate: parts[k].tax_rate,
                  tax: parts[k].tax,
                  tax_info: parts[k].tax_info,
                });
              }
            }
          } else {
            update_parts = parts;
          }

          bookingService.push({
            part_cost: services[i].part_cost,
            labour_cost: services[i].labour_cost,
            of_cost: services[i].of_cost,
            exceeded_cost: services[i].exceeded_cost,
            quantity: services[i].quantity,
            parts: update_parts,
            labour: services[i].labour,
            cost:
              _.sumBy(services[i].labour, (x) => x.amount) +
              _.sumBy(update_parts, (x) => x.amount) +
              _.sumBy(services[i].opening_fitting, (x) => x.amount),
            discount:
              _.sumBy(services[i].labour, (x) => x.discount) +
              _.sumBy(update_parts, (x) => x.discount) +
              _.sumBy(services[i].opening_fitting, (x) => x.discount),
            opening_fitting: services[i].opening_fitting,
            part_cost_editable: services[i].part_cost_editable,
            labour_cost_editable: services[i].part_cost_editable,
            of_cost_editable: services[i].part_cost_editable,
            description: services[i].description,
            service: services[i].service,
            type: services[i].type,
            claim: services[i].claim,
            custom: services[i].custom,
            customer_approval: services[i].customer_approval,
            surveyor_approval: services[i].surveyor_approval,
            source: services[i].source,
          });
        }

        var approved = _.filter(
          bookingService,
          (customer_approval) => customer_approval.customer_approval == true
        );

        var policy_clause = 0;
        if (booking.payment.policy_clause) {
          policy_clause = booking.payment.policy_clause;
        }
        var salvage = 0;
        if (booking.payment.salvage) {
          salvage = booking.payment.salvage;
        }

        var paid_total = booking.payment.paid_total;
        var labour_cost = _.sumBy(bookingService, (x) => x.labour_cost);
        var part_cost = _.sumBy(bookingService, (x) => x.part_cost);
        var of_cost = _.sumBy(bookingService, (x) => x.of_cost);
        var discount_total = _.sumBy(bookingService, (x) => x.discount);
        var pick_up_charges = booking.payment.pick_up_charges;
        var careager_cash = await q.all(
          fun.getBookingCarEagerCash(booking._id)
        );
        var payment_total =
          labour_cost +
          part_cost +
          of_cost +
          discount_total +
          policy_clause +
          salvage +
          pick_up_charges;

        var estimate_cost =
          labour_cost +
          part_cost +
          of_cost +
          policy_clause +
          salvage +
          pick_up_charges -
          careager_cash;
        var due_amount =
          _.sumBy(approved, (x) => x.labour_cost) +
          _.sumBy(approved, (x) => x.part_cost) +
          _.sumBy(approved, (x) => x.of_cost) +
          policy_clause +
          salvage +
          pick_up_charges -
          (paid_total + careager_cash);

        var due = {
          due: Math.ceil(due_amount.toFixed(2)),
        };

        var payment = {
          estimate_cost: estimate_cost,
          total: payment_total,
          careager_cash: careager_cash,
          of_cost: of_cost,
          labour_cost: labour_cost,
          part_cost: part_cost,
          payment_mode: booking.payment.payment_mode,
          payment_status: booking.payment.payment_status,
          coupon: booking.payment.coupon,
          coupon_type: booking.payment.coupon_type,
          discount_by: booking.payment.discount_by,
          discount_type: booking.payment.discount_type,
          discount: booking.payment.discount,
          discount_total: discount_total,
          policy_clause: policy_clause,
          salvage: salvage,
          terms: booking.payment.terms,
          pick_up_limit: booking.payment.pick_up_limit,
          pick_up_charges: pick_up_charges,
          paid_total: parseFloat(booking.payment.paid_total),
          discount_applied: booking.payment.discount_applied,
          transaction_id: booking.payment.transaction_id,
          transaction_date: booking.payment.transaction_date,
          transaction_status: booking.payment.transaction_status,
          transaction_response: booking.payment.transaction_response,
        };

        Booking.findOneAndUpdate(
          { _id: booking._id },
          {
            $set: {
              services: bookingService,
              payment: payment,
              due: due,
              updated_at: new Date(),
            },
          },
          { new: false },
          async function (err, doc) {
            if (err) {
              res.status(400).json({
                responseCode: 400,
                responseMessage: "Error",
                responseData: err,
              });
            } else {
              var update = await Booking.findById(booking.id).exec();

              res.status(200).json({
                responseCode: 200,
                responseMessage: "Parts has been added",
                responseData: update,
              });
            }
          }
        );
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Services not found",
          responseData: {},
        });
      }
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Booking not found",
        responseData: {},
      });
    }
  }
);

router.put(
  "/job/part/return/",
  xAccessToken.token,
  async function (req, res, next) {
    var business = req.headers["business"];
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    var loggedInDetails = await User.findById(decoded.user).exec();
    var booking = await Booking.findById(req.body.booking).exec();
    if (booking) {
      var product = await BusinessProduct.findById(req.body.source).exec();
      if (product) {
        var stockTotal = parseFloat(product.stock.total);
        var stockConsumed =
          parseFloat(product.stock.consumed) - parseFloat(req.body.quantity);
        var stockAvailable =
          parseFloat(product.stock.available) + parseFloat(req.body.quantity);

        if (stockConsumed < 0) {
          stockConsumed = 0;
        }

        if (stockAvailable > stockTotal) {
          stockAvailable = stockTotal;
        }

        var stock = {
          total: stockTotal,
          consumed: stockTotal - stockAvailable,
          available: stockAvailable,
        };

        BusinessProduct.findOneAndUpdate(
          { _id: product._id, business: business },
          { $set: { stock: stock } },
          { new: false },
          async function (err, doc) {
            if (err) {
              res.status(422).json({
                responseCode: 422,
                responseMessage: "Server Error",
                responseData: err,
              });
            } else {
              var bookingServices = [];
              var services = booking.services;

              for (var i = 0; i < services.length; i++) {
                var update_parts = [];
                var parts = services[i].parts;
                if (parts.length > 0) {
                  for (var k = 0; k < parts.length; k++) {
                    if (parts[k]._id.equals(req.body._id)) {
                      //////console.log(req.body._id+'Return')
                      update_parts.push({
                        _id: parts[k]._id,
                        source: null,
                        quantity: parts[k].quantity,
                        issued: false,
                        item: parts[k].item,
                        hsn_sac: parts[k].hsn_sac,
                        part_no: parts[k].part_no,
                        quantity: parts[k].quantity,
                        rate: parts[k].rate,
                        base: parts[k].base,
                        amount: parts[k].amount,
                        customer_dep: parts[k].customer_dep,
                        insurance_dep: parts[k].insurance_dep,
                        tax_amount: parts[k].tax_amount,
                        amount_is_tax: parts[k].amount_is_tax,
                        discount: parts[k].discount,
                        tax_rate: parts[k].tax_rate,
                        tax: parts[k].tax,
                        tax_info: parts[k].tax_info,
                      });
                    } else {
                      update_parts.push({
                        _id: parts[k]._id,
                        source: parts[k].source,
                        quantity: parts[k].quantity,
                        issued: parts[k].issued,
                        item: parts[k].item,
                        hsn_sac: parts[k].hsn_sac,
                        part_no: parts[k].part_no,
                        quantity: parts[k].quantity,
                        rate: parts[k].rate,
                        base: parts[k].base,
                        amount: parts[k].amount,
                        customer_dep: parts[k].customer_dep,
                        insurance_dep: parts[k].insurance_dep,
                        tax_amount: parts[k].tax_amount,
                        amount_is_tax: parts[k].amount_is_tax,
                        discount: parts[k].discount,
                        tax_rate: parts[k].tax_rate,
                        tax: parts[k].tax,
                        tax_info: parts[k].tax_info,
                      });
                    }
                  }
                }

                bookingServices.push({
                  part_cost: services[i].part_cost,
                  labour_cost: services[i].labour_cost,
                  of_cost: services[i].of_cost,
                  exceeded_cost: services[i].exceeded_cost,
                  part_rate: services[i].part_rate,
                  labour_rate: services[i].labour_rate,
                  quantity: services[i].quantity,
                  of_rate: services[i].of_rate,
                  parts: update_parts,
                  labour: services[i].labour,
                  cost: services[i].cost,
                  discount:
                    _.sumBy(services[i].labour, (x) => x.discount) +
                    _.sumBy(services[i].opening_fitting, (x) => x.discount) +
                    _.sumBy(update_parts, (x) => x.discount),
                  opening_fitting: services[i].opening_fitting,
                  part_cost_editable: services[i].part_cost_editable,
                  labour_cost_editable: services[i].part_cost_editable,
                  of_cost_editable: services[i].part_cost_editable,
                  description: services[i].description,
                  service: services[i].service,
                  type: services[i].type,
                  claim: services[i].claim,
                  custom: services[i].custom,
                  customer_approval: services[i].customer_approval,
                  surveyor_approval: services[i].surveyor_approval,
                  source: services[i].source,
                });
              }

              Booking.findOneAndUpdate(
                { _id: booking._id },
                { $set: { services: bookingServices, updated_at: new Date() } },
                { new: false },
                async function (err, doc) {
                  if (err) {
                    res.status(400).json({
                      responseCode: 400,
                      responseMessage: "Error",
                      responseData: err,
                    });
                  } else {
                    if (req.body.remark) {
                      var remarks = [];
                      remarks = booking.remarks;

                      remarks.push({
                        remark: req.body.remark,
                        added_by: loggedInDetails._id,
                        date: moment().format("YYYY-MM-DD"),
                        created_at: new Date(),
                        updated_at: new Date(),
                      });

                      Booking.findOneAndUpdate(
                        { _id: booking._id },
                        { $set: { remarks: remarks, updated_at: new Date() } },
                        { new: false },
                        async function (err, doc) {}
                      );
                    }

                    var activity = {
                      user: loggedInDetails._id,
                      name: loggedInDetails.name,
                      stage: "Parts Updates",
                      activity:
                        product.title +
                        "(" +
                        product.part_no +
                        ") has been returned",
                    };

                    fun.bookingLog(booking._id, activity);

                    var update = await Booking.findById(booking.id).exec();

                    res.status(200).json({
                      responseCode: 200,
                      responseMessage: "Part return successfully",
                      responseData: update,
                    });
                  }
                }
              );
            }
          }
        );
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Part not found",
          responseData: {},
        });
      }
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Booking not found",
        responseData: {},
      });
    }
  }
);

router.get(
  "/payment/mode",
  xAccessToken.token,
  async function (req, res, next) {
    res.status(200).json({
      responseCode: 200,
      responseMessage: "Booking not found",
      responseData: [
        "Cash",
        "Cheque",
        "Paytm",
        "PhonePe",
        "Google Pay",
        "UPI",
        "Debit Card",
        "Credit Card",
        "Account Transfer",
      ],
    });
  }
);

router.post(
  "/job/payment/receive",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      booking: "required",
      amount: "required",
      date: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Amount and date are mandatory",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var business = req.headers["business"];
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var data = [];
      var loggedInDetails = await User.findById(decoded.user).exec();
      var booking = await Booking.findById(req.body.booking).exec();
      if (booking) {
        var data = {
          user: booking.user,
          business: business,
          status: "Job Payment-In",
          type: "Payment-In",
          paid_by: req.body.paid_by,
          activity: req.body.type,
          source: req.body.user,
          bill_id: "N/A",
          bill_amount: parseFloat(req.body.amount),
          transaction_amount: parseFloat(req.body.amount),
          balance: parseFloat(req.body.amount),
          total: parseFloat(req.body.amount),
          paid_total: 0,
          due: 0,
          payment_status: "Success",
          payment_mode: req.body.payment_mode,
          received_by: loggedInDetails.name,
          transaction_id: req.body.transaction_id,
          transaction_date: new Date(req.body.date),
          transaction_status: "Success",
          transaction_response: "Success",
          transaction_type: "Payment-In",
          remark: req.body.remark,
        };
        var valid = q.all(businessFunctions.addTransaction(data));

        await TransactionLog.create({
          user: booking.user,
          activity: "Booking",
          source: booking._id,
          status: "Payment-In",
          type: "Payment-In",
          payment_in: req.body.amount,
          paid_by: req.body.paid_by,
          paid_total: req.body.amount,
          total: booking.payment.total,
          payment_mode: req.body.payment_mode,
          payment_status: "Success",
          order_id: null,
          transaction_id: req.body.transaction_id,
          transaction_date: new Date(req.body.date).toISOString(),
          transaction_status: "Success",
          transaction_response: "Success",
          created_at: booking.updated_at,
          updated_at: booking.updated_at,
        }).then(async function (transaction) {
          await User.findByIdAndUpdate(data.user),
            { $push: { transactions: transaction._id } },
            { new: true },
            async function (err, doc) {};

          var claim = false;
          if (booking.insurance_info) {
            if (booking.insurance_info.claim == true) {
              claim = true;
            }
          }

          var transactions = await TransactionLog.find({
            source: booking._id,
            payment_status: { $ne: "Failure" },
          }).exec();

          var insurance_log = _.filter(
            transactions,
            (paid_by) => paid_by.paid_by == "Insurance"
          );
          var insurance_payment = parseFloat(
            _.sumBy(insurance_log, (x) => x.paid_total)
          );

          var customer_log = _.filter(
            transactions,
            (paid_by) => paid_by.paid_by != "Insurance"
          );
          var customer_payment = parseFloat(
            _.sumBy(customer_log, (x) => x.paid_total)
          );

          var paid_total = insurance_payment + customer_payment;

          var insurance_invoice = await Invoice.findOne({
            booking: booking._id,
            invoice_type: "Insurance",
            status: "Active",
          }).exec();

          if (insurance_invoice) {
            var bookingService = insurance_invoice.services;
            var discount_total = 0;
            var policy_clause = 0;
            var salvage = 0;
            var pick_up_charges = 0;
            var careager_cash = 0;

            var due_amount =
              _.sumBy(bookingService, (x) => x.labour_cost) +
              _.sumBy(bookingService, (x) => x.part_cost) +
              _.sumBy(bookingService, (x) => x.of_cost) +
              policy_clause +
              salvage +
              pick_up_charges -
              (insurance_payment + careager_cash);

            Invoice.findOneAndUpdate(
              { _id: insurance_invoice._id },
              {
                $set: {
                  "due.due": due_amount,
                  "payment.paid_total": insurance_payment,
                },
              },
              { new: false },
              async function (err, doc) {
                if (err) {
                  return res.status(422).json({
                    responseCode: 422,
                    responseMessage: "Server Error",
                    responseData: err,
                  });
                }
              }
            );
          }

          var customer_invoice = await Invoice.findOne({
            booking: booking._id,
            invoice_type: "Booking",
            status: "Active",
          }).exec();

          if (customer_invoice) {
            ////console.log(customer_invoice._id)
            var bookingService = customer_invoice.services;

            var policy_clause = customer_invoice.payment.policy_clause;

            var salvage = customer_invoice.payment.salvage;

            var pick_up_charges = customer_invoice.payment.pick_up_charges;

            var careager_cash = await q.all(
              fun.getBookingCarEagerCash(booking._id)
            );

            var due_amount =
              _.sumBy(bookingService, (x) => x.labour_cost) +
              _.sumBy(bookingService, (x) => x.part_cost) +
              _.sumBy(bookingService, (x) => x.of_cost) +
              policy_clause +
              salvage +
              pick_up_charges -
              (customer_payment + careager_cash);

            Invoice.findOneAndUpdate(
              { _id: customer_invoice._id },
              {
                $set: {
                  "due.due": due_amount,
                  "payment.paid_total": customer_payment,
                },
              },
              { new: false },
              async function (err, doc) {
                if (err) {
                  return res.status(422).json({
                    responseCode: 422,
                    responseMessage: "Server Error",
                    responseData: err,
                  });
                }
              }
            );
          }

          var bookingService = booking.services;
          var policy_clause = booking.payment.policy_clause;

          var salvage = booking.payment.salvage;

          var pick_up_charges = booking.payment.pick_up_charges;

          var careager_cash = await q.all(
            fun.getBookingCarEagerCash(booking._id)
          );

          var due_amount =
            _.sumBy(bookingService, (x) => x.labour_cost) +
            _.sumBy(bookingService, (x) => x.part_cost) +
            _.sumBy(bookingService, (x) => x.of_cost) +
            policy_clause +
            salvage +
            pick_up_charges -
            (customer_payment + insurance_payment + careager_cash);

          Booking.findOneAndUpdate(
            { _id: booking._id },
            {
              $set: {
                "payment.paid_total": customer_payment + insurance_payment,
                "due.due": due_amount,
                updated_at: new Date(),
              },
            },
            { new: false },
            async function (err, doc) {
              if (err) {
                res.status(422).json({
                  responseCode: 422,
                  responseMessage: "Server Error",
                  responseData: err,
                });
              } else {
                var activity = {
                  user: loggedInDetails._id,
                  name: loggedInDetails.name,
                  stage: "Payment",
                  activity: "Payment Recieved " + req.body.amount,
                };
                await whatsAppEvent.paymentDone(
                  booking._id,
                  req.body.amount,
                  business
                );
                fun.bookingLog(booking._id, activity);

                var updated = await Booking.findById(booking._id).exec();
                res.status(200).json({
                  responseCode: 200,
                  responseMessage: "Payment Received Successfully.",
                  responseData: updated,
                });
              }
            }
          );
        });
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Booking not found",
          responseData: {},
        });
      }
    }
  }
);

router.delete(
  "/job/payment/remove",
  xAccessToken.token,
  async function (req, res, next) {
    var business = req.headers["business"];
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var data = [];
    var loggedInDetails = await User.findById(decoded.user).exec();

    var transaction = await TransactionLog.findById(req.query.id).exec();
    if (transaction) {
      var booking = await Booking.findById(transaction.source).exec();

      TransactionLog.remove({ _id: transaction._id }, async function (err) {
        if (err) {
          res.status(422).json({
            responseCode: 422,
            responseMessage: "Server Error",
            responseData: err,
          });
        } else {
          var transactions = await TransactionLog.find({
            source: booking._id,
            payment_status: { $ne: "Failure" },
          }).exec();
          var insurance_log = _.filter(
            transactions,
            (paid_by) => paid_by.paid_by == "Insurance"
          );
          var insurance_payment = parseFloat(
            _.sumBy(insurance_log, (x) => x.paid_total)
          );

          var customer_log = _.filter(
            transactions,
            (paid_by) => paid_by.paid_by != "Insurance"
          );
          var customer_payment = parseFloat(
            _.sumBy(customer_log, (x) => x.paid_total)
          );

          var paid_total = insurance_payment + customer_payment;

          var claim = false;
          if (booking.insurance_info) {
            if (booking.insurance_info.claim == true) {
              claim == true;
            }
          }

          if (claim == true) {
            var insurance_invoice = await Invoice.findOne({
              booking: booking._id,
              invoice_type: "Insurance",
              status: "Active",
            }).exec();

            if (insurance_invoice) {
              var bookingService = insurance_invoice.services;
              var discount_total = 0;
              var policy_clause = 0;
              var salvage = 0;
              var pick_up_charges = 0;
              var careager_cash = 0;

              var due_amount =
                _.sumBy(bookingService, (x) => x.labour_cost) +
                _.sumBy(bookingService, (x) => x.part_cost) +
                _.sumBy(bookingService, (x) => x.of_cost) +
                policy_clause +
                salvage +
                pick_up_charges -
                (insurance_payment + careager_cash);

              Invoice.findOneAndUpdate(
                { _id: insurance_invoice._id },
                {
                  $set: {
                    "due.due": due_amount,
                    "payment.paid_total": insurance_payment,
                  },
                },
                { new: false },
                async function (err, doc) {
                  if (err) {
                    return res.status(422).json({
                      responseCode: 422,
                      responseMessage: "Server Error",
                      responseData: err,
                    });
                  }
                }
              );
            }
          } else {
            var customer_invoice = await Invoice.findOne({
              booking: booking._id,
              invoice_type: "Booking",
              status: "Active",
            }).exec();

            if (customer_invoice) {
              var bookingService = customer_invoice.services;

              var policy_clause = customer_invoice.payment.policy_clause;

              var salvage = customer_invoice.payment.salvage;

              var pick_up_charges = customer_invoice.payment.pick_up_charges;

              var careager_cash = await q.all(
                fun.getBookingCarEagerCash(booking._id)
              );

              var due_amount =
                _.sumBy(bookingService, (x) => x.labour_cost) +
                _.sumBy(bookingService, (x) => x.part_cost) +
                _.sumBy(bookingService, (x) => x.of_cost) +
                policy_clause +
                salvage +
                pick_up_charges -
                (customer_payment + careager_cash);

              Invoice.findOneAndUpdate(
                { _id: customer_invoice._id },
                {
                  $set: {
                    "due.due": due_amount,
                    "payment.paid_total": customer_payment,
                  },
                },
                { new: false },
                async function (err, doc) {
                  if (err) {
                    return res.status(422).json({
                      responseCode: 422,
                      responseMessage: "Server Error",
                      responseData: err,
                    });
                  }
                }
              );
            }
          }

          var bookingService = booking.services;

          var policy_clause = booking.payment.policy_clause;

          var salvage = booking.payment.salvage;

          var pick_up_charges = booking.payment.pick_up_charges;

          var careager_cash = await q.all(
            fun.getBookingCarEagerCash(booking._id)
          );

          var due_amount =
            _.sumBy(bookingService, (x) => x.labour_cost) +
            _.sumBy(bookingService, (x) => x.part_cost) +
            _.sumBy(bookingService, (x) => x.of_cost) +
            policy_clause +
            salvage +
            pick_up_charges -
            (customer_payment + insurance_payment + careager_cash);

          Booking.findOneAndUpdate(
            { _id: booking._id },
            {
              $set: {
                "payment.paid_total": customer_payment + insurance_payment,
                "due.due": due_amount,
                updated_at: new Date(),
              },
            },
            { new: false },
            async function (err, doc) {
              if (err) {
                res.status(422).json({
                  responseCode: 422,
                  responseMessage: "Server Error",
                  responseData: err,
                });
              } else {
                var activity = {
                  user: loggedInDetails._id,
                  name: loggedInDetails.name,
                  stage: "Payment",
                  activity: "Payment Removed " + transaction.paid_total,
                };

                fun.bookingLog(booking._id, activity);

                var updated = await Booking.findById(booking._id).exec();
                res.status(200).json({
                  responseCode: 200,
                  responseMessage: "",
                  responseData: updated,
                });
              }
            }
          );
        }
      });
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Transaction not found",
        responseData: {},
      });
    }
  }
);

router.get("/job/qc/", xAccessToken.token, async function (req, res, next) {
  var business = req.headers["business"];
  var token = req.headers["x-access-token"];
  var secret = config.secret;
  var decoded = jwt.verify(token, secret);
  var data = [];
  var booking = await Booking.findById(req.query.booking).exec();
  if (booking) {
    var body = booking.services;

    var category = ["general"];
    body = _.uniqBy(body, "type");

    for (var i = 0; i < body.length; i++) {
      if (body[i].type == "addOn") {
        category.push("services");
      } else {
        category.push(body[i].type);
      }
    }

    var qc = [];

    await QualityCheck.find({ category: { $in: category } })
      .sort({ position: 1 })
      .cursor()
      .eachAsync(async (p) => {
        var category = p.category;
        qc.push({
          _id: p._id,
          id: p._id,
          position: p.position,
          point: p.point,
          category: category.toString(),
        });
      });

    res.status(200).json({
      responseCode: 200,
      responseMessage: "",
      responseData: qc,
    });
  } else {
    res.status(400).json({
      responseCode: 400,
      responseMessage: "Booking not found",
      responseData: {},
    });
  }
});

router.put(
  "/job/qc/update",
  xAccessToken.token,
  async function (req, res, next) {
    var business = req.headers["business"];
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var data = [];
    var loggedInDetails = await User.findById(decoded.user).exec();
    var booking = await Booking.findById(req.body.booking).exec();
    if (booking) {
      var qc = _.orderBy(req.body.qc, "position", "asc");
      var status = req.body.status;

      var logs = _.filter(booking.logs, (status) => status.status == status);

      if (logs.length > 0) {
        status = logs[logs.length - 1].status;
      }

      Booking.findOneAndUpdate(
        { _id: booking._id },
        { $set: { qc: qc, status: status, updated_at: new Date() } },
        { new: false },
        async function (err, doc) {
          if (err) {
            res.status(400).json({
              responseCode: 400,
              responseMessage: "Error",
              responseData: err,
            });
          } else {
            var activity = {
              user: loggedInDetails._id,
              name: loggedInDetails.name,
              stage: req.body.stage,
              activity: req.body.status,
            };

            fun.bookingLog(booking._id, activity);

            var update = await Booking.findById(booking.id).exec();

            res.status(200).json({
              responseCode: 200,
              responseMessage: "Status has been updated",
              responseData: update,
            });
          }
        }
      );
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Booking not found",
        responseData: {},
      });
    }
  }
);

router.put(
  "/job/status/update",
  xAccessToken.token,
  async function (req, res, next) {
    var business = req.headers["business"];
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var data = [];
    var loggedInDetails = await User.findById(decoded.user).exec();
    var booking = await Booking.findById(req.body.booking).exec();
    if (booking) {
      var status = req.body.status;
      if (status == "CompleteWork") {
        status = "QC";
      }

      Booking.findOneAndUpdate(
        { _id: booking._id },
        { $set: { status: status, updated_at: new Date() } },
        { new: false },
        async function (err, doc) {
          if (err) {
            res.status(400).json({
              responseCode: 400,
              responseMessage: "Error",
              responseData: err,
            });
          } else {
            var activity = {
              user: loggedInDetails._id,
              name: loggedInDetails.name,
              stage: req.body.stage,
              activity: req.body.status,
            };

            //event.zohoLead(booking._id)

            fun.bookingLog(booking._id, activity);

            if (req.body.back != "enable") {
              var notify = {
                receiver: [booking.user],
                activity: "jobcard",
                tag: req.body.status,
                source: booking._id,
                sender: booking.business,
                points: 0,
              };

              fun.newNotification(notify);
              event.jobSms(notify);
            }

            var update = await Booking.findById(booking.id).exec();

            res.status(200).json({
              responseCode: 200,
              responseMessage: "Status has been updated",
              responseData: update,
            });
          }
        }
      );
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Booking not found",
        responseData: {},
      });
    }
  }
);

router.post(
  "/booking/convenience/add",
  xAccessToken.token,
  async function (req, res, next) {
    var business = req.headers["business"];
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var data = [];

    var loggedInDetails = await User.findById(decoded.user).exec();
    if (loggedInDetails) {
      var management = await Management.findOne({
        user: decoded.user,
        business: business,
        role: "Admin",
      })
        .populate("user")
        .exec();
      if (management) {
        var body = req.body;
        if (body.length > 0) {
          for (var i = 0; i < body.length; i++) {
            var businessConvenience = await BusinessConvenience.findOne({
              business: business,
              convenience: body[i].convenience,
            }).exec();
            if (businessConvenience) {
              var data = {
                charges: body[i].charges,
                updated_at: new Date(),
              };

              BusinessConvenience.findOneAndUpdate(
                { _id: businessConvenience._id },
                { $set: data },
                { new: false },
                async function (err, doc) {
                  if (err) {
                    return res.status(422).json({
                      responseCode: 422,
                      responseMessage: "Server Error",
                      responseData: err,
                    });
                  }
                }
              );
            } else {
              var data = {
                business: business,
                convenience: body[i].convenience,
                charges: body[i].charges,
                created_at: new Date(),
                updated_at: new Date(),
              };

              BusinessConvenience.create(data).then(async function (e) {});
            }
          }

          var businessConvenience = await BusinessConvenience.find({
            business: business,
          }).exec();

          res.status(200).json({
            responseCode: 200,
            responseMessage: "Conveniences",
            responseData: businessConvenience,
          });
        } else {
          res.status(400).json({
            responseCode: 400,
            responseMessage: "Convenience Required",
            responseData: {},
          });
        }
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Authorization Error",
          responseData: {},
        });
      }
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "User not found",
        responseData: {},
      });
    }
  }
);

router.get(
  "/booking/conveniences/get",
  xAccessToken.token,
  async function (req, res, next) {
    var business = req.headers["business"];
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var data = [];

    var businessConvenience = await BusinessConvenience.find({
      business: business,
    }).exec();
    if (businessConvenience.length > 0) {
      res.status(200).json({
        responseCode: 200,
        responseMessage: "Conveniences",
        responseData: businessConvenience,
      });
    } else {
      var businessConvenience = await BusinessConvenience.find({
        business: null,
      }).exec();
      res.status(200).json({
        responseCode: 200,
        responseMessage: "Conveniences",
        responseData: businessConvenience,
      });
    }
  }
);

router.post(
  "/order/convenience/add",
  xAccessToken.token,
  async function (req, res, next) {
    var business = req.headers["business"];
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var data = [];

    var loggedInDetails = await User.findById(decoded.user).exec();
    if (loggedInDetails) {
      var management = await Management.findOne({
        user: decoded.user,
        business: business,
        role: "Admin",
      })
        .populate("user")
        .exec();
      if (management) {
        var body = req.body;
        if (body.length > 0) {
          for (var i = 0; i < body.length; i++) {
            var orderConvenience = await OrderConvenience.findOne({
              business: business,
              convenience: body[i].convenience,
            }).exec();
            if (orderConvenience) {
              var data = {
                charges: body[i].charges,
                updated_at: new Date(),
              };

              OrderConvenience.findOneAndUpdate(
                { _id: orderConvenience._id },
                { $set: data },
                { new: false },
                async function (err, doc) {
                  if (err) {
                    return res.status(422).json({
                      responseCode: 422,
                      responseMessage: "Server Error",
                      responseData: err,
                    });
                  }
                }
              );
            } else {
              var data = {
                business: business,
                convenience: body[i].convenience,
                charges: body[i].charges,
                created_at: new Date(),
                updated_at: new Date(),
              };

              OrderConvenience.create(data).then(async function (e) {});
            }
          }

          var orderConvenience = await OrderConvenience.find({
            business: business,
          }).exec();

          res.status(200).json({
            responseCode: 200,
            responseMessage: "Conveniences",
            responseData: orderConvenience,
          });
        } else {
          res.status(400).json({
            responseCode: 400,
            responseMessage: "Convenience Required",
            responseData: {},
          });
        }
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Authorization Error",
          responseData: {},
        });
      }
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "User not found",
        responseData: {},
      });
    }
  }
);

router.post(
  "/order/create",
  xAccessToken.token,
  async function (req, res, next) {
    var business = req.headers["business"];
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var date = new Date();
    var loggedInDetails = decoded.user;
    var car = null;
    var address = null;
    var items = [];
    var data = [];

    var item_total = 0;
    var discount = 0;
    var item_total = 0;
    var total = 0;
    var due = {
      due: 0,
    };

    var user = await User.findById(req.body.user).exec();
    var loggedInDetails = await User.findById(decoded.user).exec();
    if (user) {
      if (req.body.address) {
        var checkAddress = await Address.findOne({
          _id: req.body.address,
          user: user._id,
        }).exec();
        if (checkAddress) {
          address = checkAddress._id;
        } else {
          return res.status(400).json({
            responseCode: 400,
            responseMessage: "Address not found",
            responseData: {},
          });
        }
      }
      /*else
        {
            return res.status(400).json({
                responseCode: 400,
                responseMessage: "Address not found",
                responseData: {}
            });
        }*/

      if (req.body.car) {
        var checkCar = await Car.findOne({
          _id: req.body.car,
          user: user._id,
        }).exec();
        if (checkCar) {
          car = checkCar._id;
        } else {
          return res.status(400).json({
            responseCode: 400,
            responseMessage: "Car not found",
            responseData: {},
          });
        }
      }

      var date = new Date();
      var payment = {
        payment_mode: "",
        payment_status: "",
        extra_charges_limit: 0,
        convenience_charges: 0,
        discount_type: "",
        coupon_type: "",
        coupon: "",
        discount_applied: false,
        transaction_id: "",
        transaction_date: "",
        transaction_status: "",
        transaction_response: "",
        total: total,
        discount_total: discount,
        paid_total: 0,
      };

      await Order.create({
        convenience: req.body.convenience,
        time_slot: req.body.time_slot,
        user: user._id,
        car: car,
        address: address,
        items: items,
        business: business,
        payment: payment,
        due: due,
        isPurchaseOrder: false,
        vendorOrder: null,
        status: "Ordered",
        created_at: date,
        updated_at: date,
      }).then(async function (o) {
        var count = await Order.find({ _id: { $lt: o._id } }).count();
        // var count = await Order.find({ business: business }).count();
        var order_no =
          Math.round(+new Date() / 1000) +
          "-" +
          Math.ceil(Math.random() * 90000 + 10000) +
          "-" +
          Math.ceil(count + 1);
        await Order.findOneAndUpdate(
          { _id: o._id },
          { $set: { order_no: order_no } },
          { new: true },
          async function (err, doc) {
            if (err) {
              res.status(422).json({
                responseCode: 422,
                responseMessage: "Server Error",
                responseData: err,
              });
            } else {
              var businessOrder = {
                order: o._id,
                _order: order_no,
                due_date: null,
                delivery_date: null,
                convenience: req.body.convenience,
                time_slot: req.body.time_slot,
                user: user._id,
                items: items,
                business: business,
                payment: payment,
                status: "Confirmed",
                created_at: date,
                updated_at: date,
                vendorOrder: null,
                isPurchaseOrder: false,
                due: due,
              };

              await BusinessOrder.create(businessOrder).then(async function (
                bo
              ) {
                // var count = await BusinessOrder.find({ _id: { $lt: bo._id } }).count();
                var count = await BusinessOrder.find({
                  business: business,
                }).count();
                var order_no = count + 1;

                await BusinessOrder.findOneAndUpdate(
                  { _id: bo._id },
                  { $set: { order_no: order_no } },
                  { new: true },
                  async function (err, doc) {
                    var order = await BusinessOrder.findById(bo._id)
                      .populate({
                        path: "order",
                        populate: [
                          {
                            path: "user",
                            select:
                              "name contact_no username email account_info ",
                          },
                          {
                            path: "car",
                            select:
                              "title variant registration_no _automaker _model",
                          },
                          { path: "address" },
                        ],
                      })
                      .exec();

                    var items = await OrderLine.find({
                      order: order.order._id,
                      business: business,
                    }).exec();

                    var purchaseOrder = await q.all(
                      businessFunctions.createLinkedPurcahseOrder(
                        user._id,
                        order.order._id,
                        loggedInDetails.name
                      )
                    );
                    if (purchaseOrder) {
                      // console.log("Purchase Order  = " + JSON.stringify(purchaseOrder, null, '\t'))
                    }
                    var activity = {
                      business: business,
                      activity_by: loggedInDetails.name,
                      activity: "Order Created",
                      // time: new Date().getTime.toLocaleTimeString(),
                      remark: "Order",
                      created_at: new Date(),
                    };
                    // console.log("Activity")
                    businessFunctions.salesOrderLogs(order.order._id, activity);
                    //Create Linked Purachse_Order with this Sales_Order

                    res.status(200).json({
                      responseCode: 200,
                      responseMessage: "Order Created",
                      responseData: {
                        _id: order._id,
                        id: order._id,
                        order_no: order.order_no,
                        order: order.order._id,
                        _order: order._order,
                        convenience: order.order.convenience,
                        car: order.order.car,
                        user: order.order.user,
                        address: order.order.address,
                        items: items,
                      },
                    });
                  }
                );
              });
            }
          }
        );
      });
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "User not found",
        responseData: {},
      });
    }
  }
);

router.get(
  "/order/items/search/",
  xAccessToken.token,
  async function (req, res, next) {
    businessFunctions.logs(
      "INFO: /order/items/search/ Api Called from 3.0.js," +
        " " +
        "Request Headers:" +
        JSON.stringify(req.headers) +
        ", " +
        "Request Query:" +
        JSON.stringify(req.query)
    );

    var rules = {
      query: "required",
      // quantity: 'required',
    };
    var validation = new Validator(req.query, rules);
    if (validation.fails()) {
      if (
        Log_Level == 1 ||
        Log_Level == 5 ||
        Log_Level == 6 ||
        Log_Level == 7 ||
        Log_Level == 0
      ) {
        businessFunctions.logs(
          "ERROR: Validation failed, Part Name / Part No Required is required."
        );
      }
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Part Name / Part No Required",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var id = mongoose.Types.ObjectId();
      var business = req.headers["business"];
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var user = await User.findById(decoded.user).exec();

      var data = [];
      if (
        Log_Level == 4 ||
        Log_Level == 6 ||
        Log_Level == 8 ||
        Log_Level == 10 ||
        Log_Level == 0
      ) {
        businessFunctions.logs(
          "DEBUG: Fatching Search item details, Search Query:" + req.query.query
        );
      }
      await BusinessProduct.find({
        business: business,
        list_type: { $in: ["Offline"] },
        $or: [
          { part_no: new RegExp(req.query.query, "i") },
          { title: new RegExp(req.query.query, "i") },
          { models: { $in: new RegExp(req.query.query, "i") } },
        ],
      })
        .cursor()
        .eachAsync(async (p) => {
          data.push({
            _id: p.id,
            id: p.id,
            title: p.title,
            sku: p.sku,
            part_no: p.part_no,
            hsn_sac: p.hsn_sac,
            product: p._id,
            unit: p.unit,
            issued: false,
            discount: p.price.discount,
            discount_type: p.price.discount_type,
            amount_is_tax: p.amount_is_tax,
            price: p.price,
            // tax_amount: parseFloat(_.sumBy(tax, x => x.amount).toFixed(2)),
            tax: p.tax,
            tax_rate: p.tax_rate,
            // tax_info: tax_details,
            available: p.stock.available,
            business: p.business,
          });
        });
      if (
        Log_Level == 4 ||
        Log_Level == 6 ||
        Log_Level == 8 ||
        Log_Level == 10 ||
        Log_Level == 0
      ) {
        businessFunctions.logs(
          "DEBUG: Sending Search item details in Response, Search Query:" +
            req.query.query
        );
      }
      res.status(200).json({
        responseCode: 200,
        responseMessage: "",
        responseData: data,
      });
      if (
        Log_Level == 3 ||
        Log_Level == 7 ||
        Log_Level == 9 ||
        Log_Level == 10 ||
        Log_Level == 0
      ) {
        businessFunctions.logs(
          "INFO: Search item details send successfully in response, User:" +
            user.name
        );
      }
    }
  }
);

router.post(
  "/order/item/add",
  xAccessToken.token,
  async function (req, res, next) {
    var business = req.headers["business"];
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var date = new Date();
    var loggedInDetails = decoded.user;
    var items = [];
    var data = [];
    var convenience_charges = 0;
    var item_total = 0;
    var discount = 0;
    var item_total = 0;
    var total = 0;

    var order = await Order.findById(req.body.order).exec();
    var loggedInDetails = await User.findById(decoded.user).exec();
    if (order) {
      var products = req.body.items;
      if (products.title != "") {
        var businessOrder = await BusinessOrder.findOne({
          order: order._id,
          business: business,
        }).exec();

        var log = {
          status: "Confirmed",
          type: "Counter",
          activity: "Confirmed",
          user: loggedInDetails._id,
          name: loggedInDetails.name,
          created_at: date,
          updated_at: date,
        };
        var id = mongoose.Types.ObjectId();
        if (products.id != null) {
          id = products.id;
        }
        if (products) {
          var tax_info = await Tax.findOne({ tax: products.tax }).exec();
          if (products.product) {
            var product = await BusinessProduct.findOne({
              _id: products.product,
              business: business,
            }).exec();
            if (product) {
              var tax = [];
              var rate = products.rate;
              var amount = products.rate * products.quantity;
              var tax_rate = tax_info.detail;
              var discount_total = 0;
              var base = amount;

              var discount = products.discount;

              if (discount.indexOf("%") >= 0) {
                discount = parseFloat(discount);
                if (!isNaN(discount) && discount > 0) {
                  discount_total = amount * (discount / 100);
                  amount = amount - parseFloat(discount_total.toFixed(2));
                }
              } else {
                if (discount == "") {
                  discount = "0";
                }

                discount_total = parseFloat(discount);

                if (!isNaN(discount_total) && discount_total > 0) {
                  amount = amount - parseFloat(discount_total.toFixed(2));
                }
              }

              if (products.amount_is_tax == "exclusive") {
                var tax_on_amount = amount;
                if (tax_rate.length > 0) {
                  for (var r = 0; r < tax_rate.length; r++) {
                    if (tax_rate[r].rate != tax_info.rate) {
                      var t = tax_on_amount * (tax_rate[r].rate / 100);
                      amount = amount + t;
                      tax.push({
                        tax: tax_rate[r].tax,
                        rate: tax_rate[r].rate,
                        amount: parseFloat(t.toFixed(2)),
                      });
                    } else {
                      var t = tax_on_amount * (tax_info.rate / 100);
                      amount = amount + t;
                      tax.push({
                        tax: tax_info.tax,
                        tax_rate: tax_info.rate,
                        rate: tax_info.rate,
                        amount: parseFloat(t.toFixed(2)),
                      });
                    }
                  }
                }
              }

              if (products.amount_is_tax == "inclusive") {
                var x = (100 + tax_info.rate) / 100;
                var tax_on_amount = amount / x;
                if (tax_rate.length > 0) {
                  for (var r = 0; r < tax_rate.length; r++) {
                    if (tax_rate[r].rate != tax_info.rate) {
                      var t = tax_on_amount * (tax_rate[r].rate / 100);
                      base = base - t;
                      tax.push({
                        tax: tax_rate[r].tax,
                        rate: tax_rate[r].rate,
                        amount: parseFloat(t.toFixed(2)),
                      });
                    } else {
                      var t = amount - tax_on_amount;
                      base = base - t;
                      tax.push({
                        tax: tax_info.tax,
                        rate: tax_info.rate,
                        amount: parseFloat(t.toFixed(2)),
                      });
                    }
                  }
                }
                //base = base - discount_total;
              }

              var tax_details = {
                tax: tax_info.tax,
                rate: tax_info.rate,
                amount: total,
                detail: tax,
              };

              items = {
                _id: id,
                order: order._id,
                product: product._id,
                category: product.category,
                _category: product._category,
                subcategory: product.subcategory,
                _subcategory: product._subcategory,
                product_brand: product.product_brand,
                _brand: product.product_brand,
                product_model: product.product_model,
                _model: product.product_model,
                source: product.source,
                part_no: products.part_no,
                hsn_sac: products.hsn_sac,
                unit: products.unit,
                title: products.title,
                sku: products.sku,
                mrp: products.mrp,
                selling_price: products.selling_price,
                rate: products.rate,
                quantity: products.quantity,
                base: parseFloat(base.toFixed(2)),
                amount: amount,
                discount: products.discount,
                discount_total: parseFloat(discount_total.toFixed(2)),
                amount_is_tax: products.amount_is_tax,
                tax_amount: parseFloat(
                  _.sumBy(tax, (x) => x.amount).toFixed(2)
                ),
                amount: parseFloat(amount.toFixed(2)),
                tax: tax_info.tax,
                tax_rate: tax_info.rate,
                tax_info: tax,
                issued: true,
                added_by_customer: false,
                delivery_date: businessOrder.delivery_date,
                tracking_no:
                  Math.round(+new Date() / 1000) +
                  "-" +
                  Math.ceil(Math.random() * 90000 + 10000),
                business: business,
                created_at: new Date(),
                updated_at: new Date(),
              };
            } else {
              return res.status(400).json({
                responseCode: 400,
                responseMessage: "Items not found",
                responseData: {},
              });
            }
          } else {
            var tax = [];
            var rate = products.rate;
            var amount = products.rate * products.quantity;
            var tax_rate = tax_info.detail;
            var discount_total = 0;
            var base = amount;
            var discount = products.discount;

            if (discount.indexOf("%") >= 0) {
              discount = parseFloat(discount);
              if (!isNaN(discount) && discount > 0) {
                discount_total = amount * (discount / 100);
                if (parseFloat(discount_total.toFixed(2)) > amount) {
                  products.discount = amount.toString();
                  discount_total = amount;
                }

                amount = amount - parseFloat(discount_total.toFixed(2));
              }
            } else {
              discount_total = parseFloat(discount);
              if (!isNaN(discount_total) && discount_total > 0) {
                if (parseFloat(discount_total.toFixed(2)) > amount) {
                  products.discount = amount.toString();
                  discount_total = amount;
                }

                amount = amount - parseFloat(discount_total.toFixed(2));
              }
            }

            if (products.amount_is_tax == "exclusive") {
              var tax_on_amount = amount;
              if (tax_rate.length > 0) {
                for (var r = 0; r < tax_rate.length; r++) {
                  if (tax_rate[r].rate != tax_info.rate) {
                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                    amount = amount + t;
                    tax.push({
                      tax: tax_rate[r].tax,
                      rate: tax_rate[r].rate,
                      amount: parseFloat(t.toFixed(2)),
                    });
                  } else {
                    var t = tax_on_amount * (tax_info.rate / 100);
                    amount = amount + t;
                    tax.push({
                      tax: tax_info.tax,
                      tax_rate: tax_info.rate,
                      rate: tax_info.rate,
                      amount: parseFloat(t.toFixed(2)),
                    });
                  }
                }
              }
            }

            if (products.amount_is_tax == "inclusive") {
              amount = amount;
              var x = (100 + tax_info.rate) / 100;
              var tax_on_amount = amount / x;
              if (tax_rate.length > 0) {
                for (var r = 0; r < tax_rate.length; r++) {
                  if (tax_rate[r].rate != tax_info.rate) {
                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                    base = base - t;
                    tax.push({
                      tax: tax_rate[r].tax,
                      rate: tax_rate[r].rate,
                      amount: parseFloat(t.toFixed(2)),
                    });
                  } else {
                    var t = amount - tax_on_amount;
                    base = base - t;
                    tax.push({
                      tax: tax_info.tax,
                      rate: tax_info.rate,
                      amount: parseFloat(t.toFixed(2)),
                    });
                  }
                }
              }

              //base = base - discount_total;
            }

            var tax_details = {
              tax: tax_info.tax,
              rate: tax_info.rate,
              amount: total,
              detail: tax,
            };

            items = {
              _id: id,
              order: order._id,
              product: products.product,
              category: null,
              _category: "",
              subcategory: null,
              _subcategory: "",
              product_brand: null,
              _brand: "",
              product_model: null,
              _model: "",
              source: products.source,
              part_no: products.part_no,
              hsn_sac: products.hsn_sac,
              unit: products.unit,
              title: products.title,
              quantity: products.quantity,
              unit: products.unit,
              sku: products.sku,
              mrp: products.mrp,
              selling_price: products.selling_price,
              rate: products.rate,
              base: parseFloat(base.toFixed(2)),
              discount: products.discount,
              discount_total: parseFloat(discount_total.toFixed(2)),
              amount_is_tax: products.amount_is_tax,
              tax_amount: parseFloat(_.sumBy(tax, (x) => x.amount).toFixed(2)),
              amount: parseFloat(amount.toFixed(2)),
              tax: tax_info.tax,
              tax_rate: tax_info.rate,
              tax_info: tax,
              issued: false,
              added_by_customer: false,
              delivery_date: businessOrder.delivery_date,
              tracking_no:
                Math.round(+new Date() / 1000) +
                "-" +
                Math.ceil(Math.random() * 90000 + 10000),
              business: products.business,
              created_at: new Date(),
              updated_at: new Date(),
            };
          }
        }

        await OrderLine.create(items).then(async function (ol) {
          var items = await OrderLine.find({
            order: order._id,
            issued: true,
            business: business,
            status: { $nin: ["Cancelled"] },
          }).exec();

          if (businessOrder.payment.convenience_charges) {
            convenience_charges = Math.ceil(
              businessOrder.payment.convenience_charges
            );
          }

          var discount = parseFloat(
            _.sumBy(items, (x) => x.discount_total).toFixed(2)
          );
          var amount = parseFloat(_.sumBy(items, (x) => x.amount).toFixed(2));
          var total = amount + discount + convenience_charges;

          var transaction_log = await q.all(
            fun.getOrderTransaction(order._id, business)
          );
          var paid_total = transaction_log.paid_total;

          var data = {
            updated_at: new Date(),
            "payment.paid_total": paid_total,
            "payment.amount": parseFloat(amount.toFixed(2)),
            "payment.discount_total": parseFloat(discount.toFixed(2)),
            "payment.total": parseFloat(total.toFixed(2)),
            "payment.order_discount": parseFloat(order.payment.order_discount),
            due: {
              due:
                Math.ceil(amount) +
                convenience_charges -
                paid_total -
                parseFloat(order.payment.order_discount),
            },
          };
          var user = await User.findById(order.user).exec();

          var issued = await q.all(
            businessFunctions.salesPartIssue(
              ol,
              business,
              user,
              loggedInDetails
            )
          );
          if (issued) {
            await OrderLine.findOneAndUpdate(
              { _id: order._id },
              { $set: { issued: issued, updated_at: new Date() } },
              { new: false },
              async function (err, doc) {}
            );
          }
          console.log("Issued = " + issued);

          await Order.findOneAndUpdate(
            { _id: ol._id },
            { $set: data },
            { new: false },
            async function (err, doc) {
              if (err) {
                res.status(422).json({
                  responseCode: 422,
                  responseMessage: "Server Error",
                  responseData: err,
                });
              } else {
                await BusinessOrder.findOneAndUpdate(
                  { order: order._id, business: business },
                  { $set: data },
                  { new: false },
                  async function (err, doc) {
                    if (err) {
                      res.status(422).json({
                        responseCode: 422,
                        responseMessage: "Server Error",
                        responseData: err,
                      });
                    } else {
                      await BusinessOrder.find({
                        order: businessOrder.order,
                        business: business,
                      })
                        .populate({
                          path: "order",
                          populate: [
                            {
                              path: "user",
                              select:
                                "name contact_no username email account_info ",
                            },
                            {
                              path: "car",
                              select:
                                "title variant registration_no _automaker _model",
                            },
                            { path: "address" },
                          ],
                        })
                        .cursor()
                        .eachAsync(async (p) => {
                          var has_invoice = false;
                          var invoices = await OrderInvoice.find({
                            order: p.order._id,
                            business: business,
                          })
                            .select("status invoice_no")
                            .exec();

                          if (invoices.length > 0) {
                            has_invoice = true;
                          }

                          var orders = {
                            _id: p.order._id,
                            id: p.order._id,
                            items: await q.all(
                              fun.getBusinessOrderItems(
                                p.order._id,
                                business,
                                req.headers["tz"]
                              )
                            ),
                            user: p.order.user,
                            car: p.order.car,
                            address: p.order.address,
                            due_date: moment(p.due_date)
                              .tz(req.headers["tz"])
                              .format("lll"),
                            delivery_date: moment(p.delivery_date)
                              .tz(req.headers["tz"])
                              .format("lll"),
                            time_slot: p.time_slot,
                            convenience: p.order.convenience,
                            order_no: p.order.order_no,
                            address: p.order.address,
                            payment: p.payment,
                            due: p.due,
                            log: p.log,
                            status: p.status,
                            has_invoice: has_invoice,
                            invoices: invoices,
                            created_at: moment(p.created_at)
                              .tz(req.headers["tz"])
                              .format("lll"),
                            updated_at: moment(p.updated_at)
                              .tz(req.headers["tz"])
                              .format("lll"),
                          };
                          var activity = {
                            business: business,
                            activity_by: loggedInDetails.name,
                            activity: "'" + products.title + "' Added to Order",
                            remark: "Item Added",
                            created_at: new Date(),
                          };
                          businessFunctions.salesOrderLogs(order._id, activity);

                          res.status(200).json({
                            responseCode: 200,
                            responseMessage: "success",
                            responseData: orders,
                          });
                        });
                    }
                  }
                );
              }
            }
          );
        });
      } else {
        res.status(200).json({
          responseCode: 200,
          responseMessage: "Add New Item",
          responseData: {},
        });
      }
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Order not found",
        responseData: {},
      });
    }
  }
);

router.put(
  "/order/item/remove/",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      id: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Item required",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var business = req.headers["business"];
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);

      var loggedInDetails = await User.findById(decoded.user).exec();
      var order = await Order.findById(req.body.order).exec();
      if (order) {
        var item = await OrderLine.findOne({
          _id: req.body.id,
          order: order._id,
        }).exec();
        if (item) {
          if (item.issued == false) {
            if (item.added_by_customer == false) {
              OrderLine.remove({ _id: item._id }, async function (err) {
                if (err) {
                  res.status(422).json({
                    responseCode: 422,
                    responseMessage: "Server Error",
                    responseData: err,
                  });
                } else {
                  var businessOrder = await BusinessOrder.findOne({
                    order: order._id,
                    business: business,
                  }).exec();

                  var items = await OrderLine.find({
                    order: order._id,
                    business: business,
                    status: { $nin: ["Cancelled"] },
                  }).exec();

                  var convenience_charges = 0;
                  if (businessOrder.payment.convenience_charges) {
                    convenience_charges = Math.ceil(
                      businessOrder.payment.convenience_charges
                    );
                  }

                  var discount = parseFloat(
                    _.sumBy(items, (x) => x.discount_total).toFixed(2)
                  );
                  var amount = parseFloat(
                    _.sumBy(items, (x) => x.amount).toFixed(2)
                  );
                  var total = amount + discount + convenience_charges;

                  var transaction_log = await q.all(
                    fun.getOrderTransaction(order, business)
                  );
                  var paid_total = transaction_log.paid_total;

                  var data = {
                    updated_at: new Date(),
                    "payment.paid_total": paid_total,
                    "payment.amount": parseFloat(amount.toFixed(2)),
                    "payment.discount_total": parseFloat(discount.toFixed(2)),
                    "payment.total": parseFloat(total.toFixed(2)),
                    due: {
                      due: Math.ceil(amount) + convenience_charges - paid_total,
                    },
                  };

                  Order.findOneAndUpdate(
                    { _id: businessOrder.order },
                    { $set: data },
                    { new: false },
                    async function (err, doc) {
                      if (err) {
                        res.status(422).json({
                          responseCode: 422,
                          responseMessage: "Server Error",
                          responseData: err,
                        });
                      } else {
                        BusinessOrder.findOneAndUpdate(
                          { order: businessOrder.order, business: business },
                          { $set: data },
                          { new: false },
                          async function (err, doc) {
                            if (err) {
                              res.status(422).json({
                                responseCode: 422,
                                responseMessage: "Server Error",
                                responseData: err,
                              });
                            } else {
                              await BusinessOrder.find({
                                order: businessOrder.order,
                                business: business,
                              })
                                .populate({
                                  path: "order",
                                  populate: [
                                    {
                                      path: "user",
                                      select:
                                        "name contact_no username email account_info ",
                                    },
                                    {
                                      path: "car",
                                      select:
                                        "title variant registration_no _automaker _model",
                                    },
                                    { path: "address" },
                                  ],
                                })
                                .cursor()
                                .eachAsync(async (p) => {
                                  var has_invoice = false;
                                  var invoices = await OrderInvoice.find({
                                    order: p.order._id,
                                    business: business,
                                  })
                                    .select("status invoice_no")
                                    .exec();

                                  if (invoices.length > 0) {
                                    has_invoice = true;
                                  }

                                  var orders = {
                                    _id: p.order._id,
                                    id: p.order._id,
                                    items: await q.all(
                                      fun.getBusinessOrderItems(
                                        p.order._id,
                                        business,
                                        req.headers["tz"]
                                      )
                                    ),
                                    user: p.order.user,
                                    car: p.order.car,
                                    address: p.order.address,
                                    due_date: moment(p.due_date)
                                      .tz(req.headers["tz"])
                                      .format("lll"),
                                    delivery_date: moment(p.delivery_date)
                                      .tz(req.headers["tz"])
                                      .format("lll"),
                                    time_slot: p.time_slot,
                                    convenience: p.order.convenience,
                                    order_no: p.order.order_no,
                                    address: p.order.address,
                                    payment: p.payment,
                                    due: p.due,
                                    log: p.log,
                                    status: p.status,
                                    has_invoice: has_invoice,
                                    invoices: invoices,
                                    created_at: moment(p.created_at)
                                      .tz(req.headers["tz"])
                                      .format("lll"),
                                    updated_at: moment(p.updated_at)
                                      .tz(req.headers["tz"])
                                      .format("lll"),
                                  };

                                  res.status(200).json({
                                    responseCode: 200,
                                    responseMessage: "success",
                                    responseData: orders,
                                  });
                                });
                            }
                          }
                        );
                      }
                    }
                  );
                }
              });
            } else {
              res.status(400).json({
                responseCode: 400,
                responseMessage: "Cannot delete item added by customer",
                responseData: {},
              });
            }
          } else {
            res.status(400).json({
              responseCode: 400,
              responseMessage:
                "Error! This item has been issued from inventory",
              responseData: {},
            });
          }
        } else {
          res.status(400).json({
            responseCode: 400,
            responseMessage: "Item not found",
            responseData: {},
          });
        }
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Order not found",
          responseData: {},
        });
      }
    }
  }
);

router.put(
  "/order/item/return",
  xAccessToken.token,
  async function (req, res, next) {
    var business = req.headers["business"];
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var date = new Date();
    var loggedInDetails = decoded.user;
    var items = [];
    var data = [];
    var convenience_charges = 0;
    var amount = 0;
    var discount = 0;
    var total = 0;

    var item = await OrderLine.findOne({
      _id: req.body.id,
      status: { $nin: ["Cancelled"] },
    }).exec();
    var loggedInDetails = await User.findById(decoded.user).exec();
    if (item) {
      var businessOrder = await BusinessOrder.findOne({
        order: item.order,
        business: business,
      }).exec();

      if (item.issued == true) {
        var r = await q.all(businessFunctions.orderItemReturn(item));
        // console.log("Item Removed " + r)
        if (r) {
          item.status = "Cancelled";
          item.markModified("status");
          item.save();

          var items = await OrderLine.find({
            order: item.order,
            business: business,
            issued: true,
            status: { $nin: ["Cancelled"] },
          }).exec();

          if (businessOrder.payment.convenience_charges) {
            convenience_charges = Math.ceil(
              businessOrder.payment.convenience_charges
            );
          }

          var discount = parseFloat(
            _.sumBy(items, (x) => x.discount_total).toFixed(2)
          );
          var amount = parseFloat(_.sumBy(items, (x) => x.amount).toFixed(2));
          var total = amount + discount + convenience_charges;
          //console.log("2828 Total =" + total)
          var transaction_log = await q.all(
            fun.getOrderTransaction(item.order, business)
          );
          var paid_total = transaction_log.paid_total;

          var data = {
            updated_at: new Date(),
            "payment.paid_total": paid_total,
            "payment.amount": parseFloat(amount.toFixed(2)),
            "payment.discount_total": parseFloat(discount.toFixed(2)),
            "payment.total": parseFloat(total.toFixed(2)),
            "payment.order_discount": parseFloat(
              businessOrder.payment.order_discount
            ),
            due: {
              due:
                Math.ceil(amount) +
                convenience_charges -
                paid_total -
                parseFloat(businessOrder.payment.order_discount),
            },
          };

          await OrderInvoice.findOneAndUpdate(
            { order: businessOrder.order, status: "Active" },
            {
              $set: {
                due: {
                  due: Math.ceil(amount) + convenience_charges - paid_total,
                },
              },
            },
            { new: false },
            async function (err, doc) {}
          );

          await Order.findOneAndUpdate(
            { _id: businessOrder.order },
            { $set: data },
            { new: false },
            async function (err, doc) {
              if (err) {
                res.status(422).json({
                  responseCode: 422,
                  responseMessage: "Server Error",
                  responseData: err,
                });
              } else {
                await BusinessOrder.findOneAndUpdate(
                  { order: businessOrder.order, business: business },
                  { $set: data },
                  { new: false },
                  async function (err, doc) {
                    if (err) {
                      res.status(422).json({
                        responseCode: 422,
                        responseMessage: "Server Error",
                        responseData: err,
                      });
                    } else {
                      await BusinessOrder.find({
                        order: businessOrder.order,
                        business: business,
                      })
                        .populate({
                          path: "order",
                          populate: [
                            {
                              path: "user",
                              select:
                                "name contact_no username email account_info ",
                            },
                            {
                              path: "car",
                              select:
                                "title variant registration_no _automaker _model",
                            },
                            { path: "address" },
                          ],
                        })
                        .cursor()
                        .eachAsync(async (p) => {
                          var has_invoice = false;
                          var invoices = await OrderInvoice.find({
                            order: p.order._id,
                            business: business,
                          })
                            .select("status invoice_no")
                            .exec();

                          if (invoices.length > 0) {
                            has_invoice = true;
                          }

                          var orders = {
                            _id: p.order._id,
                            id: p.order._id,
                            items: await q.all(
                              fun.getBusinessOrderItems(
                                p.order._id,
                                business,
                                req.headers["tz"]
                              )
                            ),
                            user: p.order.user,
                            car: p.order.car,
                            address: p.order.address,
                            due_date: moment(p.due_date)
                              .tz(req.headers["tz"])
                              .format("lll"),
                            delivery_date: moment(p.delivery_date)
                              .tz(req.headers["tz"])
                              .format("lll"),
                            time_slot: p.time_slot,
                            convenience: p.order.convenience,
                            order_no: p.order.order_no,
                            address: p.order.address,
                            payment: p.payment,
                            due: p.due,
                            log: p.log,
                            status: p.status,
                            has_invoice: has_invoice,
                            invoices: invoices,
                            created_at: moment(p.created_at)
                              .tz(req.headers["tz"])
                              .format("lll"),
                            updated_at: moment(p.updated_at)
                              .tz(req.headers["tz"])
                              .format("lll"),
                          };
                          var activity = {
                            business: business,
                            activity_by: loggedInDetails.name,
                            activity: "'" + item.title + "' removed from Order",
                            remark: "Item Removed",
                            created_at: new Date(),
                          };
                          businessFunctions.salesOrderLogs(
                            p.order._id,
                            activity
                          );

                          res.status(200).json({
                            responseCode: 200,
                            responseMessage: "success",
                            responseData: orders,
                          });
                        });
                    }
                  }
                );
              }
            }
          );
        } else {
          res.status(400).json({
            responseCode: 400,
            responseMessage: "Item not Returned",
            responseData: {},
          });
        }
      }
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Item not found",
        responseData: {},
      });
    }
  }
);

router.put(
  "/order/item/product/update",
  xAccessToken.token,
  async function (req, res, next) {
    var business = req.headers["business"];
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var date = new Date();
    var loggedInDetails = decoded.user;
    var items = [];
    var data = [];

    var item_total = 0;
    var discount = 0;
    var item_total = 0;
    var total = 0;

    var order = await Order.findById(req.body.order).exec();
    var loggedInDetails = await User.findById(decoded.user).exec();
    if (order) {
      var date = new Date();
      var log = {
        status: "Confirmed",
        type: "Counter",
        activity: "Confirmed",
        user: loggedInDetails._id,
        name: loggedInDetails.name,
        created_at: date,
        updated_at: date,
      };

      var products = req.body.item;

      if (products) {
        var tax_info = await Tax.findOne({ tax: products.tax }).exec();
        var orderLine = await OrderLine.findOne({ _id: products.id }).exec();
        if (orderLine) {
          var businessProduct = await BusinessProduct.findOne({
            _id: products.product,
          }).exec();
          if (businessProduct) {
            var tax = [];
            var rate = products.rate;
            var amount = products.rate * products.quantity;
            var tax_rate = tax_info.detail;
            var discount_total = 0;
            var base = amount;

            var discount = products.discount;

            if (discount.indexOf("%") >= 0) {
              discount = parseFloat(discount);
              if (!isNaN(discount) && discount > 0) {
                discount_total = amount * (discount / 100);
                amount = amount - parseFloat(discount_total.toFixed(2));
              }
            } else {
              if (discount == "") {
                discount = "0";
              }

              discount_total = parseFloat(discount);
              if (!isNaN(discount_total) && discount_total > 0) {
                amount = amount - parseFloat(discount_total.toFixed(2));
              }
            }

            if (products.amount_is_tax == "exclusive") {
              var tax_on_amount = amount;
              if (tax_rate.length > 0) {
                for (var r = 0; r < tax_rate.length; r++) {
                  if (tax_rate[r].rate != tax_info.rate) {
                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                    amount = amount + t;
                    tax.push({
                      tax: tax_rate[r].tax,
                      rate: tax_rate[r].rate,
                      amount: parseFloat(t.toFixed(2)),
                    });
                  } else {
                    var t = tax_on_amount * (tax_info.rate / 100);
                    amount = amount + t;
                    tax.push({
                      tax: tax_info.tax,
                      tax_rate: tax_info.rate,
                      rate: tax_info.rate,
                      amount: parseFloat(t.toFixed(2)),
                    });
                  }
                }
              }
            }

            if (products.amount_is_tax == "inclusive") {
              var x = (100 + tax_info.rate) / 100;
              var tax_on_amount = amount / x;
              if (tax_rate.length > 0) {
                for (var r = 0; r < tax_rate.length; r++) {
                  if (tax_rate[r].rate != tax_info.rate) {
                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                    base = base - t;
                    tax.push({
                      tax: tax_rate[r].tax,
                      rate: tax_rate[r].rate,
                      amount: parseFloat(t.toFixed(2)),
                    });
                  } else {
                    var t = amount - tax_on_amount;
                    base = base - t;
                    tax.push({
                      tax: tax_info.tax,
                      rate: tax_info.rate,
                      amount: parseFloat(t.toFixed(2)),
                    });
                  }
                }
              }

              //base =base- discount_total;
            }

            var tax_details = {
              tax: tax_info.tax,
              rate: tax_info.rate,
              amount: total,
              detail: tax,
            };

            var item = {
              order: order._id,
              product: businessProduct._id,
              category: businessProduct.category,
              _category: businessProduct._category,
              subcategory: businessProduct.subcategory,
              _subcategory: businessProduct._subcategory,
              product_brand: businessProduct.product_brand,
              _brand: businessProduct.product_brand,
              product_model: businessProduct.product_model,
              _model: businessProduct.product_model,
              source: businessProduct.source,
              status: orderLine.status,
              part_no: products.part_no,
              hsn_sac: products.hsn_sac,
              unit: products.unit,
              title: products.title,
              sku: products.sku,
              mrp: products.mrp,
              selling_price: products.selling_price,
              rate: products.rate,
              quantity: products.quantity,
              base: parseFloat(base.toFixed(2)),
              amount: amount,
              discount: products.discount,
              discount_total: parseFloat(discount_total.toFixed(2)),
              amount_is_tax: products.amount_is_tax,
              tax_amount: parseFloat(_.sumBy(tax, (x) => x.amount).toFixed(2)),
              amount: parseFloat(amount.toFixed(2)),
              tax: tax_info.tax,
              tax_rate: tax_info.rate,
              tax_info: tax,
              issued: products.issued,
              business: business,
              updated_at: new Date(),
            };

            OrderLine.findOneAndUpdate(
              { _id: orderLine._id },
              { $set: item },
              { new: false },
              async function (err, doc) {
                if (err) {
                  return res.status(422).json({
                    responseCode: 422,
                    responseMessage: "Server Error",
                    responseData: err,
                  });
                }
              }
            );
          } else {
            return res.status(400).json({
              responseCode: 400,
              responseMessage: "Product not found",
              responseData: {},
            });
          }
        } else {
          return res.status(400).json({
            responseCode: 400,
            responseMessage: "Item not found",
            responseData: {},
          });
        }
      } else {
        return res.status(400).json({
          responseCode: 400,
          responseMessage: "Items not found",
          responseData: {},
        });
      }

      var businessOrder = await BusinessOrder.findOne({
        order: order._id,
        business: business,
      }).exec();
      var items = await OrderLine.find({
        order: order._id,
        business: business,
        status: { $nin: ["Cancelled"] },
      }).exec();

      var convenience_charges = 0;
      if (businessOrder.payment.convenience_charges) {
        convenience_charges = Math.ceil(
          businessOrder.payment.convenience_charges
        );
      }

      var amount = _.sumBy(items, (x) => x.amount);
      var discount = _.sumBy(items, (x) => x.discount_total);
      var total = amount + discount + convenience_charges;

      var transaction_log = await q.all(
        fun.getOrderTransaction(order, business)
      );
      var paid_total = transaction_log.paid_total;

      var data = {
        updated_at: new Date(),
        "payment.paid_total": paid_total,
        "payment.amount": parseFloat(amount.toFixed(2)),
        "payment.discount_total": parseFloat(discount.toFixed(2)),
        "payment.total": parseFloat(total.toFixed(2)),
        due: {
          due: Math.ceil(amount) + Math.ceil(convenience_charges) - paid_total,
        },
      };

      Order.findOneAndUpdate(
        { _id: businessOrder.order },
        { $set: data },
        { new: false },
        async function (err, doc) {
          if (err) {
            res.status(422).json({
              responseCode: 422,
              responseMessage: "Server Error",
              responseData: err,
            });
          } else {
            BusinessOrder.findOneAndUpdate(
              { order: businessOrder.order, business: business },
              { $set: data },
              { new: false },
              async function (err, doc) {
                if (err) {
                  res.status(422).json({
                    responseCode: 422,
                    responseMessage: "Server Error",
                    responseData: err,
                  });
                } else {
                  await BusinessOrder.find({
                    order: businessOrder.order,
                    business: business,
                  })
                    .populate({
                      path: "order",
                      populate: [
                        {
                          path: "user",
                          select:
                            "name contact_no username email account_info ",
                        },
                        {
                          path: "car",
                          select:
                            "title variant registration_no _automaker _model",
                        },
                        { path: "address" },
                      ],
                    })
                    .cursor()
                    .eachAsync(async (p) => {
                      var has_invoice = false;
                      var invoices = await OrderInvoice.find({
                        order: p.order._id,
                        business: business,
                      })
                        .select("status invoice_no")
                        .exec();

                      if (invoices.length > 0) {
                        has_invoice = true;
                      }
                      var orders = {
                        _id: p.order._id,
                        id: p.order._id,
                        items: await q.all(
                          fun.getBusinessOrderItems(
                            p.order._id,
                            business,
                            req.headers["tz"]
                          )
                        ),
                        user: p.order.user,
                        car: p.order.car,
                        address: p.order.address,
                        due_date: moment(p.due_date)
                          .tz(req.headers["tz"])
                          .format("lll"),
                        delivery_date: moment(p.delivery_date)
                          .tz(req.headers["tz"])
                          .format("lll"),
                        time_slot: p.time_slot,
                        convenience: p.order.convenience,
                        order_no: p.order.order_no,
                        address: p.order.address,
                        payment: p.payment,
                        due: p.due,
                        log: p.log,
                        status: p.status,
                        has_invoice: has_invoice,
                        invoices: invoices,
                        created_at: moment(p.created_at)
                          .tz(req.headers["tz"])
                          .format("lll"),
                        updated_at: moment(p.updated_at)
                          .tz(req.headers["tz"])
                          .format("lll"),
                      };

                      res.status(200).json({
                        responseCode: 200,
                        responseMessage: "success",
                        responseData: orders,
                      });
                    });
                }
              }
            );
          }
        }
      );
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Order not found",
        responseData: {},
      });
    }
  }
);

router.put(
  "/order/update",
  xAccessToken.token,
  async function (req, res, next) {
    var business = req.headers["business"];
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var date = new Date();
    var loggedInDetails = decoded.user;
    var items = [];
    var data = [];

    var item_total = 0;
    var discount = 0;
    var item_total = 0;
    var total = 0;

    var order = await Order.findById(req.body.order).exec();
    var loggedInDetails = await User.findById(decoded.user).exec();
    if (order) {
      var date = new Date();

      var log = {
        status: "Confirmed",
        type: "Counter",
        activity: "Confirmed",
        user: loggedInDetails._id,
        name: loggedInDetails.name,
        created_at: date,
        updated_at: date,
      };

      var products = req.body.items;

      if (products.length > 0) {
        for (var p = 0; p < products.length; p++) {
          var category = null;
          var _category = "";
          var subcategory = null;
          var _subcategory = "";
          var product_brand = null;
          var _brand = "";
          var product_model = null;
          var _model = "";
          var source = null;

          var tax_info = await Tax.findOne({ tax: products[p].tax }).exec();
          if (products[p].product) {
            var businessProduct = await BusinessProduct.findById(
              products[p].product
            ).exec();
            if (businessProduct) {
              category = businessProduct.category;
              _category = businessProduct._category;
              subcategory = businessProduct.subcategory;
              _subcategory = businessProduct._subcategory;
              product_brand = businessProduct.product_brand;
              _brand = businessProduct._product_brand;
              product_model = businessProduct.product_model;
              _model = businessProduct._product_model;
              source = businessProduct.product;
            }
          }

          var orderLine = await OrderLine.findOne({
            _id: products[p].id,
          }).exec();
          if (orderLine) {
            var tax = [];
            var rate = products[p].rate;
            var amount = products[p].rate * products[p].quantity;
            var tax_rate = tax_info.detail;
            var discount_total = 0;
            var base = amount;

            var discount = products[p].discount;

            if (discount.indexOf("%") >= 0) {
              discount = parseFloat(discount);
              if (!isNaN(discount) && discount > 0) {
                var discount_total = amount * (discount / 100);
                amount = amount - parseFloat(discount_total.toFixed(2));
              }
            } else {
              if (discount == "") {
                discount = "0";
              }

              discount_total = parseFloat(discount);
              if (!isNaN(discount_total) && discount_total > 0) {
                amount = amount - parseFloat(discount_total.toFixed(2));
              }
            }

            if (products[p].amount_is_tax == "exclusive") {
              var tax_on_amount = amount;
              if (tax_rate.length > 0) {
                for (var r = 0; r < tax_rate.length; r++) {
                  if (tax_rate[r].rate != tax_info.rate) {
                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                    amount = amount + t;
                    tax.push({
                      tax: tax_rate[r].tax,
                      rate: tax_rate[r].rate,
                      amount: parseFloat(t.toFixed(2)),
                    });
                  } else {
                    var t = tax_on_amount * (tax_info.rate / 100);
                    amount = amount + t;
                    tax.push({
                      tax: tax_info.tax,
                      tax_rate: tax_info.rate,
                      rate: tax_info.rate,
                      amount: parseFloat(t.toFixed(2)),
                    });
                  }
                }
              }
            }

            if (products[p].amount_is_tax == "inclusive") {
              var x = (100 + tax_info.rate) / 100;
              var tax_on_amount = amount / x;
              if (tax_rate.length > 0) {
                for (var r = 0; r < tax_rate.length; r++) {
                  if (tax_rate[r].rate != tax_info.rate) {
                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                    base = base - t;
                    tax.push({
                      tax: tax_rate[r].tax,
                      rate: tax_rate[r].rate,
                      amount: parseFloat(t.toFixed(2)),
                    });
                  } else {
                    var t = amount - tax_on_amount;
                    base = base - t;
                    tax.push({
                      tax: tax_info.tax,
                      rate: tax_info.rate,
                      amount: parseFloat(t.toFixed(2)),
                    });
                  }
                }
              }

              //base = base - discount_total;
            }

            var tax_details = {
              tax: tax_info.tax,
              rate: tax_info.rate,
              amount: total,
              detail: tax,
            };

            var item = {
              order: order._id,
              product: products[p].product,
              category: category,
              _category: _category,
              subcategory: subcategory,
              _subcategory: _subcategory,
              product_brand: product_brand,
              _brand: _brand,
              product_model: product_model,
              _model: _model,
              source: source,
              status: orderLine.status,
              part_no: products[p].part_no,
              unit: products[p].unit,
              hsn_sac: products[p].hsn_sac,
              title: products[p].title,
              sku: products[p].sku,
              mrp: products[p].mrp,
              selling_price: products[p].selling_price,
              rate: products[p].rate,
              quantity: products[p].quantity,
              base: parseFloat(base.toFixed(2)),
              amount: amount,
              discount: products[p].discount,
              discount_total: parseFloat(discount_total.toFixed(2)),
              amount_is_tax: products[p].amount_is_tax,
              tax_amount: parseFloat(_.sumBy(tax, (x) => x.amount).toFixed(2)),
              amount: parseFloat(amount.toFixed(2)),
              tax: tax_info.tax,
              tax_rate: tax_info.rate,
              tax_info: tax,
              issued: products[p].issued,
              business: business,
              updated_at: new Date(),
            };

            OrderLine.findOneAndUpdate(
              { _id: products[p].id },
              { $set: item },
              { new: false },
              async function (err, doc) {}
            );
          } else {
            return res.status(400).json({
              responseCode: 400,
              responseMessage: "Item not found",
              responseData: {},
            });
          }
        }
      } else {
        return res.status(400).json({
          responseCode: 400,
          responseMessage: "Items not found",
          responseData: {},
        });
      }

      var businessOrder = await BusinessOrder.findOne({
        order: order._id,
        business: business,
      }).exec();
      var items = await OrderLine.find({
        order: order._id,
        business: business,
        status: { $nin: ["Cancelled"] },
      }).exec();

      var convenience_charges = 0;
      if (req.body.convenience_charges) {
        convenience_charges = Math.ceil(req.body.convenience_charges);
      } else {
        if (businessOrder.payment.convenience_charges) {
          convenience_charges = Math.ceil(
            businessOrder.payment.convenience_charges
          );
        }
      }

      var amount = _.sumBy(items, (x) => x.amount);
      var discount = _.sumBy(items, (x) => x.discount_total);
      var total = amount + discount + convenience_charges;

      var transaction_log = await q.all(
        fun.getOrderTransaction(order, business)
      );
      var paid_total = transaction_log.paid_total;

      var data = {
        convenience: req.body.convenience,
        updated_at: new Date(),
        "payment.paid_total": paid_total,
        "payment.convenience_charges": convenience_charges,
        "payment.amount": parseFloat(amount.toFixed(2)),
        "payment.discount_total": parseFloat(discount.toFixed(2)),
        "payment.total": parseFloat(total.toFixed(2)),
        due: {
          due: Math.ceil(amount) + Math.ceil(convenience_charges) - paid_total,
        },
      };

      Order.findOneAndUpdate(
        { _id: businessOrder.order },
        { $set: data },
        { new: false },
        async function (err, doc) {
          if (err) {
            res.status(422).json({
              responseCode: 422,
              responseMessage: "Server Error",
              responseData: err,
            });
          } else {
            BusinessOrder.findOneAndUpdate(
              { order: businessOrder.order, business: business },
              { $set: data },
              { new: false },
              async function (err, doc) {
                if (err) {
                  res.status(422).json({
                    responseCode: 422,
                    responseMessage: "Server Error",
                    responseData: err,
                  });
                } else {
                  await BusinessOrder.find({
                    order: businessOrder.order,
                    business: business,
                  })
                    .populate({
                      path: "order",
                      populate: [
                        {
                          path: "user",
                          select:
                            "name contact_no username email account_info ",
                        },
                        {
                          path: "car",
                          select:
                            "title variant registration_no _automaker _model",
                        },
                        { path: "address" },
                      ],
                    })
                    .cursor()
                    .eachAsync(async (p) => {
                      var has_invoice = false;
                      var invoices = await OrderInvoice.find({
                        order: p.order._id,
                        business: business,
                      })
                        .select("status invoice_no")
                        .exec();

                      if (invoices.length > 0) {
                        has_invoice = true;
                      }
                      var orders = {
                        _id: p.order._id,
                        id: p.order._id,
                        items: await q.all(
                          fun.getBusinessOrderItems(
                            p.order._id,
                            business,
                            req.headers["tz"]
                          )
                        ),
                        user: p.order.user,
                        car: p.order.car,
                        address: p.order.address,
                        due_date: moment(p.due_date)
                          .tz(req.headers["tz"])
                          .format("lll"),
                        delivery_date: moment(p.delivery_date)
                          .tz(req.headers["tz"])
                          .format("lll"),
                        time_slot: p.time_slot,
                        convenience: p.order.convenience,
                        order_no: p.order.order_no,
                        address: p.order.address,
                        payment: p.payment,
                        due: p.due,
                        log: p.log,
                        has_invoice: has_invoice,
                        invoices: invoices,
                        status: p.status,
                        created_at: moment(p.created_at)
                          .tz(req.headers["tz"])
                          .format("lll"),
                        updated_at: moment(p.updated_at)
                          .tz(req.headers["tz"])
                          .format("lll"),
                      };

                      res.status(200).json({
                        responseCode: 200,
                        responseMessage: "success",
                        responseData: orders,
                      });
                    });
                }
              }
            );
          }
        }
      );
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Order not found",
        responseData: {},
      });
    }
  }
);

router.put(
  "/order/items/dispatch",
  xAccessToken.token,
  async function (req, res, next) {
    var business = req.headers["business"];
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var date = new Date();
    var loggedInDetails = decoded.user;
    var items = [];
    var data = [];

    var item_total = 0;
    var discount = 0;
    var item_total = 0;
    var total = 0;

    var order = await Order.findById(req.body.order).exec();
    var loggedInDetails = await User.findById(decoded.user).exec();
    if (order) {
      var date = new Date();
      var availablity = false;
      var log = {
        status: "Confirmed",
        type: "Counter",
        activity: "Confirmed",
        user: loggedInDetails._id,
        name: loggedInDetails.name,
        created_at: date,
        updated_at: date,
      };

      var products = req.body.items;

      var oids = _.map(products, "product");
      var productCount = 0;
      for (var o = 0; o < oids.length; o++) {
        var checkExist = await BusinessProduct.find({
          _id: oids[o],
          business: business,
        }).exec();
        if (checkExist) {
          productCount = productCount + 1;
        }
      }

      if (products.length == productCount) {
        for (var p = 0; p < products.length; p++) {
          var tax_info = await Tax.findOne({ tax: products[p].tax }).exec();
          var orderLine = await OrderLine.findOne({
            _id: products[p].id,
            status: { $nin: ["Cancelled"] },
          }).exec();
          if (orderLine) {
            if (orderLine.issued == false) {
              var available = await BusinessProduct.findOne({
                _id: products[p].product,
                "stock.available": { $gte: products[p].quantity },
              }).exec();
              if (available) {
                availablity = true;
              } else {
                availablity = false;
              }
            } else {
              availablity = true;
            }

            var tax = [];
            var rate = products[p].rate;
            var amount = products[p].rate * products[p].quantity;
            var tax_rate = tax_info.detail;
            var discount_total = 0;
            var base = amount;

            var discount = products[p].discount;

            if (discount.indexOf("%") >= 0) {
              discount = parseFloat(discount);
              if (!isNaN(discount) && discount > 0) {
                var discount_total = amount * (discount / 100);
                amount = amount - parseFloat(discount_total.toFixed(2));
              }
            } else {
              if (discount == "") {
                discount = "0";
              }

              discount_total = parseFloat(discount);
              if (!isNaN(discount_total) && discount_total > 0) {
                amount = amount - parseFloat(discount_total.toFixed(2));
              }
            }

            if (products[p].amount_is_tax == "exclusive") {
              var tax_on_amount = amount;
              if (tax_rate.length > 0) {
                for (var r = 0; r < tax_rate.length; r++) {
                  if (tax_rate[r].rate != tax_info.rate) {
                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                    amount = amount + t;
                    tax.push({
                      tax: tax_rate[r].tax,
                      rate: tax_rate[r].rate,
                      amount: parseFloat(t.toFixed(2)),
                    });
                  } else {
                    var t = tax_on_amount * (tax_info.rate / 100);
                    amount = amount + t;
                    tax.push({
                      tax: tax_info.tax,
                      tax_rate: tax_info.rate,
                      rate: tax_info.rate,
                      amount: parseFloat(t.toFixed(2)),
                    });
                  }
                }
              }
            }

            if (products[p].amount_is_tax == "inclusive") {
              var x = (100 + tax_info.rate) / 100;
              var tax_on_amount = amount / x;
              if (tax_rate.length > 0) {
                for (var r = 0; r < tax_rate.length; r++) {
                  if (tax_rate[r].rate != tax_info.rate) {
                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                    base = base - t;
                    tax.push({
                      tax: tax_rate[r].tax,
                      rate: tax_rate[r].rate,
                      amount: parseFloat(t.toFixed(2)),
                    });
                  } else {
                    var t = amount - tax_on_amount;
                    base = base - t;
                    tax.push({
                      tax: tax_info.tax,
                      rate: tax_info.rate,
                      amount: parseFloat(t.toFixed(2)),
                    });
                  }
                }
              }
              //base = base - discount_total;
            }

            var tax_details = {
              tax: tax_info.tax,
              rate: tax_info.rate,
              amount: total,
              detail: tax,
            };

            var item = {
              order: order._id,
              product: orderLine.product,
              category: orderLine.category,
              _category: orderLine._category,
              subcategory: orderLine.subcategory,
              _subcategory: orderLine._subcategory,
              product_brand: orderLine.product_brand,
              _brand: orderLine.product_brand,
              product_model: orderLine.product_model,
              _model: orderLine.product_model,
              source: orderLine.source,
              status: orderLine.status,
              part_no: orderLine.part_no,
              hsn_sac: products[p].hsn_sac,
              title: products[p].title,
              sku: products[p].sku,
              mrp: products[p].mrp,
              selling_price: products[p].selling_price,
              rate: products[p].rate,
              unit: products[p].unit,
              quantity: products[p].quantity,
              base: parseFloat(base.toFixed(2)),
              discount: products[p].discount,
              discount_total: parseFloat(discount_total.toFixed(2)),
              amount_is_tax: products[p].amount_is_tax,
              tax_amount: parseFloat(_.sumBy(tax, (x) => x.amount).toFixed(2)),
              amount: parseFloat(amount.toFixed(2)),
              tax: tax_info.tax,
              tax_rate: tax_info.rate,
              tax_info: tax,
              issued: products[p].issued,
              business: business,
              updated_at: new Date(),
            };

            OrderLine.findOneAndUpdate(
              { _id: products[p].id },
              { $set: item },
              { new: false },
              async function (err, doc) {
                if (err) {
                  return res.status(422).json({
                    responseCode: 422,
                    responseMessage: "Server Error",
                    responseData: err,
                  });
                }
              }
            );
          } else {
            return res.status(400).json({
              responseCode: 400,
              responseMessage: "Items not found",
              responseData: {},
            });
          }
        }
      } else {
        return res.status(400).json({
          responseCode: 400,
          responseInfo: {
            0: products.length,
            1: checkExist.length,
          },
          responseMessage:
            "Please check all items availablity before dispatching them",
          responseData: {},
        });
      }

      var businessOrder = await BusinessOrder.findOne({
        order: order._id,
        business: business,
      }).exec();

      var items = await OrderLine.find({
        order: order._id,
        business: business,
        status: { $nin: ["Cancelled"] },
      }).exec();
      var convenience_charges = 0;
      if (businessOrder.payment.convenience_charges) {
        convenience_charges = Math.ceil(
          businessOrder.payment.convenience_charges
        );
      }

      var amount = _.sumBy(items, (x) => x.amount);
      var discount = _.sumBy(items, (x) => x.discount_total);
      var total = amount + discount + convenience_charges;

      var transaction_log = await q.all(
        fun.getOrderTransaction(order, business)
      );
      var paid_total = transaction_log.paid_total;

      if (availablity == true) {
        var a = await q.all(orderItemDeduct(order._id, business));
        if (a == true) {
          var message = "Items dispatched";
          var status = "Dispatched";
          var status_code = 200;
          OrderLine.update(
            { order: order._id, business: business },
            { $set: { status: status } },
            { multi: true },
            async function (err, doc) {
              if (err) {
                return res.status(422).json({
                  responseCode: 422,
                  responseMessage: "Server Error",
                  responseData: err,
                });
              }
            }
          );
        } else {
          var message =
            "Please check all items availablity before dispatching them";
          var status = "Confirmed";
          var status_code = 422;
        }
      } else {
        var message =
          "Please check all items availablity before dispatching them";
        var status = "Confirmed";
        var status_code = 422;
      }

      var data = {
        updated_at: new Date(),
        "payment.paid_total": paid_total,
        "payment.amount": parseFloat(amount.toFixed(2)),
        "payment.discount_total": parseFloat(discount.toFixed(2)),
        "payment.total": parseFloat(total.toFixed(2)),
        status: status,
        due: {
          due: Math.ceil(amount) + Math.ceil(convenience_charges) - paid_total,
        },
      };

      Order.findOneAndUpdate(
        { _id: order._id },
        { $set: data },
        { new: false },
        async function (err, doc) {
          if (err) {
            res.status(422).json({
              responseCode: 422,
              responseMessage: "Server Error",
              responseData: err,
            });
          } else {
            BusinessOrder.findOneAndUpdate(
              { order: order._id, business: business },
              { $set: data },
              { new: false },
              async function (err, doc) {
                if (err) {
                  res.status(422).json({
                    responseCode: 422,
                    responseMessage: "Server Error",
                    responseData: err,
                  });
                } else {
                  await BusinessOrder.find({
                    order: businessOrder.order,
                    business: business,
                  })
                    .populate({
                      path: "order",
                      populate: [
                        {
                          path: "user",
                          select:
                            "name contact_no username email account_info ",
                        },
                        {
                          path: "car",
                          select:
                            "title variant registration_no _automaker _model",
                        },
                        { path: "address" },
                      ],
                    })
                    .cursor()
                    .eachAsync(async (p) => {
                      var has_invoice = false;
                      var invoices = await OrderInvoice.find({
                        order: p.order._id,
                        business: business,
                      })
                        .select("status invoice_no")
                        .exec();

                      if (invoices.length > 0) {
                        has_invoice = true;
                      }
                      var orders = {
                        _id: p.order._id,
                        id: p.order._id,
                        items: await q.all(
                          fun.getBusinessOrderItems(
                            p.order._id,
                            business,
                            req.headers["tz"]
                          )
                        ),
                        user: p.order.user,
                        car: p.order.car,
                        address: p.order.address,
                        due_date: moment(p.due_date)
                          .tz(req.headers["tz"])
                          .format("lll"),
                        delivery_date: moment(p.delivery_date)
                          .tz(req.headers["tz"])
                          .format("lll"),
                        time_slot: p.time_slot,
                        convenience: p.order.convenience,
                        order_no: p.order.order_no,
                        address: p.order.address,
                        payment: p.payment,
                        due: p.due,
                        log: p.log,
                        has_invoice: has_invoice,
                        invoices: invoices,
                        status: p.status,
                        created_at: moment(p.created_at)
                          .tz(req.headers["tz"])
                          .format("lll"),
                        updated_at: moment(p.updated_at)
                          .tz(req.headers["tz"])
                          .format("lll"),
                      };

                      res.status(status_code).json({
                        responseCode: status_code,
                        responseMessage: message,
                        responseData: orders,
                      });
                    });
                }
              }
            );
          }
        }
      );
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Order not found",
        responseData: {},
      });
    }
  }
);

router.put(
  "/order/due-date/update",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      order: "required",
      due_date: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Due Date required",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var business = req.headers["business"];
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var date = new Date();
      var loggedInDetails = decoded.user;
      var items = [];
      var data = [];

      var item_total = 0;
      var discount = 0;
      var item_total = 0;
      var total = 0;

      var order = await Order.findById(req.body.order).exec();
      var loggedInDetails = await User.findById(decoded.user).exec();
      if (order) {
        var due_date = new Date(req.body.due_date).toISOString();

        BusinessOrder.findOneAndUpdate(
          { order: order._id, business: business },
          { $set: { due_date: due_date } },
          { new: false },
          async function (err, doc) {
            if (err) {
              res.status(422).json({
                responseCode: 422,
                responseMessage: "Server Error",
                responseData: err,
              });
            } else {
              res.status(200).json({
                responseCode: 200,
                responseMessage: "Saved",
                responseData: {
                  due_date: moment(due_date)
                    .tz(req.headers["tz"])
                    .format("YYYY-MM-DD"),
                },
              });
            }
          }
        );
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Order not found",
          responseData: {},
        });
      }
    }
  }
);

router.put(
  "/order/delivery-date/update",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      order: "required",
      delivery_date: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Due Date required",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var business = req.headers["business"];
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var date = new Date();
      var loggedInDetails = decoded.user;
      var items = [];
      var data = [];

      var item_total = 0;
      var discount = 0;
      var item_total = 0;
      var total = 0;

      var order = await Order.findById(req.body.order).exec();
      var loggedInDetails = await User.findById(decoded.user).exec();
      if (order) {
        var delivery_date = new Date(req.body.delivery_date).toISOString();

        BusinessOrder.findOneAndUpdate(
          { order: order._id, business: business },
          { $set: { delivery_date: delivery_date } },
          { new: false },
          async function (err, doc) {
            if (err) {
              res.status(422).json({
                responseCode: 422,
                responseMessage: "Server Error",
                responseData: err,
              });
            } else {
              OrderLine.update(
                { order: order._id, business: business },
                { $set: { delivery_date: delivery_date } },
                { multi: true },
                async function (err, doc) {
                  if (err) {
                    res.status(422).json({
                      responseCode: 422,
                      responseMessage: "Server Error",
                      responseData: err,
                    });
                  } else {
                    res.status(200).json({
                      responseCode: 200,
                      responseMessage: "Saved",
                      responseData: {
                        delivery_date: moment(delivery_date)
                          .tz(req.headers["tz"])
                          .format("YYYY-MM-DD"),
                      },
                    });
                  }
                }
              );
            }
          }
        );
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Order not found",
          responseData: {},
        });
      }
    }
  }
);

router.put(
  "/order/car/update",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      order: "required",
      car: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Due Date required",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var business = req.headers["business"];
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var date = new Date();
      var loggedInDetails = decoded.user;
      var items = [];
      var data = [];

      var item_total = 0;
      var discount = 0;
      var item_total = 0;
      var total = 0;

      var order = await Order.findById(req.body.order).exec();
      var loggedInDetails = await User.findById(decoded.user).exec();
      if (order) {
        var car = await Variant.findOne({ _id: req.body.car }).exec();
        if (car) {
          Order.findOneAndUpdate(
            { _id: order._id },
            { $set: { car: car._id } },
            { new: false },
            async function (err, doc) {
              if (err) {
                res.status(422).json({
                  responseCode: 422,
                  responseMessage: "Server Error",
                  responseData: err,
                });
              } else {
                res.status(200).json({
                  responseCode: 200,
                  responseMessage: "Saved",
                  responseData: {
                    car: car,
                  },
                });
              }
            }
          );
        } else {
          res.status(400).json({
            responseCode: 400,
            responseMessage: "Car not found",
            responseData: {},
          });
        }
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Order not found",
          responseData: {},
        });
      }
    }
  }
);

router.put(
  "/order/address/update",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      order: "required",
      address: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Due Date required",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var business = req.headers["business"];
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var date = new Date();
      var loggedInDetails = decoded.user;
      var items = [];
      var data = [];

      var item_total = 0;
      var discount = 0;
      var item_total = 0;
      var total = 0;

      var order = await Order.findById(req.body.order).exec();
      var loggedInDetails = await User.findById(decoded.user).exec();
      if (order) {
        var address = await Address.findOne({
          _id: req.body.address,
          user: order.user,
        }).exec();
        if (address) {
          Order.findOneAndUpdate(
            { _id: order._id },
            { $set: { address: address._id } },
            { new: false },
            async function (err, doc) {
              if (err) {
                res.status(422).json({
                  responseCode: 422,
                  responseMessage: "Server Error",
                  responseData: err,
                });
              } else {
                res.status(200).json({
                  responseCode: 200,
                  responseMessage: "Saved",
                  responseData: {
                    address: address,
                  },
                });
              }
            }
          );
        } else {
          res.status(400).json({
            responseCode: 400,
            responseMessage: "Address not found",
            responseData: {},
          });
        }
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Order not found",
          responseData: {},
        });
      }
    }
  }
);

router.get(
  "/order/convenience/get",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var business = req.headers["business"];
    var conveniences = [];

    var check = await OrderConvenience.find({ business: business })
      .count()
      .exec();
    if (check > 0) {
      await OrderConvenience.find({ business: business })
        .cursor()
        .eachAsync(async function (p) {
          conveniences.push({
            _id: p._id,
            _id: p._id,
            convenience: p.convenience,
            chargeable: p.chargeable,
            charges: p.charges,
          });
        });
    } else {
      await OrderConvenience.find({ business: null })
        .cursor()
        .eachAsync(async function (p) {
          conveniences.push({
            _id: p._id,
            _id: p._id,
            convenience: p.convenience,
            chargeable: p.chargeable,
            charges: p.charges,
          });
        });
    }

    res.status(200).json({
      responseCode: 200,
      responseMessage: "",
      responseData: conveniences,
    });
  }
);

router.put(
  "/order/convenience/update",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      order: "required",
      convenience: "required",
      convenience_charges: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Due Date required",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var business = req.headers["business"];
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var date = new Date();
      var loggedInDetails = decoded.user;
      var items = [];
      var data = [];

      var item_total = 0;
      var discount = 0;
      var item_total = 0;
      var total = 0;

      var order = await Order.findById(req.body.order).exec();
      var loggedInDetails = await User.findById(decoded.user).exec();
      if (order) {
        var convenience_charges = 0;
        var items = await OrderLine.find({
          order: order._id,
          business: business,
          status: { $nin: ["Cancelled"] },
        }).exec();
        if (req.body.convenience_charges) {
          convenience_charges = Math.ceil(req.body.convenience_charges);
        }

        var discount = parseFloat(
          _.sumBy(items, (x) => x.discount_total).toFixed(2)
        );
        var amount = parseFloat(_.sumBy(items, (x) => x.amount).toFixed(2));
        var total = amount + discount + convenience_charges;

        var transaction_log = await q.all(
          fun.getOrderTransaction(order._id, business)
        );
        var paid_total = transaction_log.paid_total;

        var data = {
          updated_at: new Date(),
          "payment.paid_total": paid_total,
          "payment.amount": parseFloat(amount.toFixed(2)),
          "payment.discount_total": parseFloat(discount.toFixed(2)),
          "payment.convenience_charges": parseFloat(
            convenience_charges.toFixed(2)
          ),
          "payment.total": parseFloat(total.toFixed(2)),
          convenience: req.body.convenience,
          due: {
            due: Math.ceil(amount) + convenience_charges - paid_total,
          },
        };

        Order.findOneAndUpdate(
          { _id: order._id },
          { $set: data },
          { new: false },
          async function (err, doc) {
            if (err) {
              res.status(422).json({
                responseCode: 422,
                responseMessage: "Server Error",
                responseData: err,
              });
            } else {
              BusinessOrder.findOneAndUpdate(
                { order: order._id, business: business },
                { $set: data },
                { new: false },
                async function (err, doc) {
                  if (err) {
                    res.status(422).json({
                      responseCode: 422,
                      responseMessage: "Server Error",
                      responseData: err,
                    });
                  } else {
                    var p = await BusinessOrder.findOne({
                      order: order._id,
                      business: business,
                    })
                      .populate({
                        path: "order",
                        populate: [
                          {
                            path: "user",
                            select:
                              "name contact_no username email account_info",
                          },
                          {
                            path: "car",
                            select:
                              "title variant registration_no _automaker _model",
                          },
                          { path: "address" },
                        ],
                      })
                      .exec();

                    res.status(200).json({
                      responseCode: 200,
                      responseMessage: "success",
                      responseData: {
                        _id: p.order._id,
                        id: p.order._id,
                        items: await q.all(
                          fun.getBusinessOrderItems(
                            p.order._id,
                            business,
                            req.headers["tz"]
                          )
                        ),
                        user: p.order.user,
                        car: p.order.car,
                        address: p.order.address,
                        due_date: moment(p.due_date)
                          .tz(req.headers["tz"])
                          .format("lll"),
                        delivery_date: moment(p.delivery_date)
                          .tz(req.headers["tz"])
                          .format("lll"),
                        time_slot: p.time_slot,
                        convenience: p.convenience,
                        order_no: p.order_no,
                        address: p.order.address,
                        payment: p.payment,
                        status: p.status,
                        due: p.due,
                        log: p.log,
                        created_at: moment(p.created_at)
                          .tz(req.headers["tz"])
                          .format("lll"),
                        updated_at: moment(p.updated_at)
                          .tz(req.headers["tz"])
                          .format("lll"),
                      },
                    });
                  }
                }
              );
            }
          }
        );
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Order not found",
          responseData: {},
        });
      }
    }
  }
);

router.get(
  "/order/payments/log",
  xAccessToken.token,
  async function (req, res, next) {
    var business = req.headers["business"];
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    var order = await Order.findById(req.query.order).exec();
    if (order) {
      var logs = [];
      await TransactionLog.find({ source: req.query.order, business: business })
        .sort({ updated_at: -1 })
        .cursor()
        .eachAsync(async (log) => {
          logs.push({
            _id: log._id,
            id: log._id,
            activity: log.activity,
            payment_mode: log.payment_mode,
            paid_total: log.paid_total,
            payment_status: log.payment_status,
            transaction_id: log.transaction_id,
            transaction_date: moment(log.transaction_date)
              .tz(req.headers["tz"])
              .format("ll"),
            transaction_status: log.transaction_status,
            transaction_response: log.transaction_response,
            user: log.user,
            source: log.source,
            paid_total: log.paid_total,
            total: log.total,
            type: log.type,
            created_at: moment(log.created_at)
              .tz(req.headers["tz"])
              .format("lll"),
            updated_at: moment(log.updated_at)
              .tz(req.headers["tz"])
              .format("lll"),
          });
        });
      res.status(200).json({
        responseCode: 200,
        responseMessage: "Transaction Log",
        responseData: logs,
      });
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Order not found",
        responseData: {},
      });
    }
  }
);

router.post(
  "/order/payment/add",
  xAccessToken.token,
  async function (req, res, next) {
    console.log("Body= ", JSON.stringify(req.body));
    var rules = {
      order: "required",
      amount: "required",
      date: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Amount & Date are mandatory",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var business = req.headers["business"];
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var data = [];
      var loggedInDetails = await User.findById(decoded.user).exec();

      var order = await Order.findOne({ _id: req.body.order }).exec();
      if (order) {
        var businessOrder = await BusinessOrder.findOne({
          order: req.body.order,
          business: business,
        }).exec();
        if (businessOrder) {
          var recieved = parseFloat(req.body.amount);

          var date = new Date();
          var payment_mode = req.body.payment_mode;
          var transaction_id = req.body.transaction_id;

          var due_amount = 0;
          if (businessOrder.due) {
            if (businessOrder.due.due) {
              due_amount = businessOrder.due.due;
            }
          }

          TransactionLog.create({
            user: order.user,
            activity: "Order",
            business: business,
            source: order._id,
            paid_total: recieved,
            total: businessOrder.payment.total,
            due: due_amount,
            payment_status: "Success",
            payment_mode: payment_mode,
            transaction_id: transaction_id,
            transaction_date: new Date(req.body.date).toISOString(),
            transaction_status: "Success",
            transaction_response: "Success",
            created_at: new Date(),
            updated_at: new Date(),
          }).then(async function (transaction) {
            var data = {
              user: order.user,
              business: business,
              status: "Payment-In",
              type: "Payment-In",
              paid_by: "Customer",
              activity: "Payment-In",
              source: order.user,
              bill_id: "N/A",
              bill_amount: recieved,
              transaction_amount: recieved,
              balance: recieved,
              total: recieved,
              paid_total: 0,
              due: 0,
              payment_status: "Success",
              payment_mode: payment_mode,
              received_by: loggedInDetails.name,
              transaction_id: transaction_id,
              transaction_date: new Date(req.body.date),
              transaction_status: "Success",
              transaction_response: "Success",
              transaction_type: "Payment-In",
              remark: req.body.remark,
            };
            var valid = q.all(businessFunctions.addTransaction(data));

            var convenience_charges = 0;
            if (businessOrder.payment.convenience_charges) {
              convenience_charges = Math.ceil(
                businessOrder.payment.convenience_charges
              );
            }

            var items = await OrderLine.find({
              order: order._id,
              business: business,
              status: { $nin: ["Cancelled"] },
            }).exec();
            var amount = _.sumBy(items, (x) => x.amount);
            var discount = _.sumBy(items, (x) => x.discount_total);
            var total = amount + discount + convenience_charges;

            var transaction_log = await TransactionLog.find({
              source: order._id,
              payment_status: "Success",
            }).exec();

            var paid_total = _.sumBy(transaction_log, (x) => x.paid_total);

            var due =
              Math.ceil(amount.toFixed(2)) +
              Math.ceil(convenience_charges) -
              paid_total;

            var data = {
              updated_at: date,
              "payment.paid_total": paid_total,
              "payment.amount": parseFloat(amount.toFixed(2)),
              "payment.discount_total": parseFloat(discount.toFixed(2)),
              "payment.total": parseFloat(total.toFixed(2)),
              "payment.order_discount": parseFloat(
                order.payment.order_discount
              ),
              due: {
                due:
                  Math.ceil(amount) +
                  convenience_charges -
                  paid_total -
                  parseFloat(order.payment.order_discount),
              },
            };

            var orderInvoice = await OrderInvoice.findOne({
              order: order._id,
              business: business,
              status: "Active",
            }).exec();
            if (orderInvoice) {
              OrderInvoice.findOneAndUpdate(
                { order: order._id, business: business, status: "Active" },
                { $set: data },
                { new: false },
                async function (err, doc) {
                  if (err) {
                    return res.status(422).json({
                      responseCode: 422,
                      responseMessage: "Server Error",
                      responseData: err,
                    });
                  }
                }
              );
            }

            Order.findOneAndUpdate(
              { _id: order._id },
              { $set: data },
              { new: false },
              async function (err, doc) {
                if (err) {
                  res.status(422).json({
                    responseCode: 422,
                    responseMessage: "Server Error",
                    responseData: err,
                  });
                } else {
                  BusinessOrder.findOneAndUpdate(
                    { order: order._id, business: business },
                    { $set: data },
                    { new: false },
                    async function (err, doc) {
                      if (err) {
                        res.status(422).json({
                          responseCode: 422,
                          responseMessage: "Server Error",
                          responseData: err,
                        });
                      } else {
                        var updated = await BusinessOrder.findOne({
                          order: order._id,
                          business: business,
                        }).exec();
                        var activity = {
                          business: business,
                          activity_by: loggedInDetails.name,
                          activity: "Payment Recieved: " + recieved,
                          remark: "Payment Recieved",
                          created_at: new Date(),
                        };
                        businessFunctions.salesOrderLogs(order._id, activity);

                        res.status(200).json({
                          responseCode: 200,
                          responseMessage: "Payment Recieved",
                          responseData: {
                            item: {},
                            payment: transaction,
                            due: updated.due,
                          },
                        });
                      }
                    }
                  );
                }
              }
            );
          });
        } else {
          res.status(400).json({
            responseCode: 400,
            responseMessage: "Business Order not found",
            responseData: {},
          });
        }
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Order not found",
          responseData: {},
        });
      }
    }
  }
);

router.delete(
  "/order/payment/remove",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      id: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Amount & Date is required",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var business = req.headers["business"];
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var data = [];
      var loggedInDetails = await User.findById(decoded.user).exec();

      var transaction = await TransactionLog.findOne({
        _id: req.body.id,
      }).exec();
      if (transaction) {
        var order = await Order.findOne({ _id: transaction.source }).exec();
        var businessOrder = await BusinessOrder.findOne({
          order: transaction.source,
          business: business,
        }).exec();
        if (businessOrder) {
          var recieved = parseFloat(req.body.amount);

          var date = new Date();
          var payment_mode = req.body.payment_mode;
          var transaction_id = req.body.transaction_id;

          TransactionLog.remove({ _id: transaction._id }, async function (err) {
            if (err) {
              return res.status(422).json({
                responseCode: 422,
                responseMessage: "Server Error",
                responseData: err,
              });
            } else {
              var convenience_charges = 0;
              if (businessOrder.payment.convenience_charges) {
                convenience_charges = Math.ceil(
                  businessOrder.payment.convenience_charges
                );
              }

              var items = await OrderLine.find({
                order: order._id,
                business: business,
                status: { $nin: ["Cancelled"] },
              }).exec();
              var amount = _.sumBy(items, (x) => x.amount);
              var discount = _.sumBy(items, (x) => x.discount_total);
              var total = amount + discount + convenience_charges;

              var transaction_log = await TransactionLog.find({
                source: order._id,
                payment_status: "Success",
              }).exec();

              var paid_total = _.sumBy(transaction_log, (x) => x.paid_total);

              var due =
                Math.ceil(amount.toFixed(2)) +
                Math.ceil(convenience_charges) -
                paid_total;

              var data = {
                updated_at: date,
                "payment.paid_total": paid_total,
                "payment.amount": parseFloat(amount.toFixed(2)),
                "payment.discount_total": parseFloat(discount.toFixed(2)),
                "payment.total": parseFloat(total.toFixed(2)),
                due: {
                  due: due,
                },
              };

              var orderInvoice = await OrderInvoice.findOne({
                order: order._id,
                business: business,
              }).exec();
              if (orderInvoice) {
                OrderInvoice.findOneAndUpdate(
                  { order: order._id, business: business },
                  { $set: data },
                  { new: false },
                  async function (err, doc) {
                    if (err) {
                      return res.status(422).json({
                        responseCode: 422,
                        responseMessage: "Server Error",
                        responseData: err,
                      });
                    }
                  }
                );
              }

              Order.findOneAndUpdate(
                { _id: order._id },
                { $set: data },
                { new: false },
                async function (err, doc) {
                  if (err) {
                    res.status(422).json({
                      responseCode: 422,
                      responseMessage: "Server Error",
                      responseData: err,
                    });
                  } else {
                    BusinessOrder.findOneAndUpdate(
                      { order: order._id, business: business },
                      { $set: data },
                      { new: false },
                      async function (err, doc) {
                        if (err) {
                          res.status(422).json({
                            responseCode: 422,
                            responseMessage: "Server Error",
                            responseData: err,
                          });
                        } else {
                          var updated = await BusinessOrder.findOne({
                            order: order._id,
                            business: business,
                          }).exec();

                          res.status(200).json({
                            responseCode: 200,
                            responseMessage: "Payment Recieved",
                            responseData: {
                              item: {},
                              payment: updated.payment,
                              due: updated.due,
                            },
                          });
                        }
                      }
                    );
                  }
                }
              );
            }
          });
        } else {
          res.status(400).json({
            responseCode: 400,
            responseMessage: "Business Order not found",
            responseData: {},
          });
        }
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Transaction not found",
          responseData: {},
        });
      }
    }
  }
);

router.put(
  "/order/cancel",
  xAccessToken.token,
  async function (req, res, next) {
    var business = req.headers["business"];
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var date = new Date();
    var loggedInDetails = decoded.user;
    var items = [];
    var data = [];

    var item_total = 0;
    var discount = 0;
    var item_total = 0;
    var total = 0;

    var order = await Order.findById(req.body.order).exec();
    var loggedInDetails = await User.findById(decoded.user).exec();
    if (order) {
      await OrderLine.find({ business: business, order: order._id })
        .cursor()
        .eachAsync(async (item) => {
          if (item.issued == true) {
            var r = await q.all(orderItemReturn(item));
          }
        });

      var date = new Date();
      var businessOrder = await BusinessOrder.findOne({
        order: order._id,
        business: business,
      }).exec();

      var data = {
        updated_at: new Date(),
        status: "Cancelled",
      };

      Order.findOneAndUpdate(
        { _id: businessOrder.order },
        { $set: data },
        { new: false },
        async function (err, doc) {
          if (err) {
            res.status(422).json({
              responseCode: 422,
              responseMessage: "Server Error",
              responseData: err,
            });
          } else {
            BusinessOrder.findOneAndUpdate(
              { order: businessOrder.order, business: business },
              { $set: data },
              { new: false },
              async function (err, doc) {
                if (err) {
                  res.status(422).json({
                    responseCode: 422,
                    responseMessage: "Server Error",
                    responseData: err,
                  });
                } else {
                  await BusinessOrder.find({
                    order: businessOrder.order,
                    business: business,
                  })
                    .populate({
                      path: "order",
                      populate: [
                        {
                          path: "user",
                          select:
                            "name contact_no username email account_info ",
                        },
                        {
                          path: "car",
                          select:
                            "title variant registration_no _automaker _model",
                        },
                        { path: "address" },
                      ],
                    })
                    .cursor()
                    .eachAsync(async (p) => {
                      var orders = {
                        _id: p.order._id,
                        id: p.order._id,
                        items: await q.all(
                          fun.getBusinessOrderItems(
                            p.order._id,
                            business,
                            req.headers["tz"]
                          )
                        ),
                        user: p.order.user,
                        car: p.order.car,
                        address: p.order.address,
                        due_date: moment(p.due_date)
                          .tz(req.headers["tz"])
                          .format("lll"),
                        delivery_date: moment(p.delivery_date)
                          .tz(req.headers["tz"])
                          .format("lll"),
                        time_slot: p.time_slot,
                        convenience: p.order.convenience,
                        order_no: p.order.order_no,
                        address: p.order.address,
                        payment: p.payment,
                        due: p.due,
                        log: p.log,
                        status: p.status,
                        created_at: moment(p.created_at)
                          .tz(req.headers["tz"])
                          .format("lll"),
                        updated_at: moment(p.updated_at)
                          .tz(req.headers["tz"])
                          .format("lll"),
                      };

                      res.status(200).json({
                        responseCode: 200,
                        responseMessage: "success",
                        responseData: {},
                      });
                    });
                }
              }
            );
          }
        }
      );
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Order not found",
        responseData: {},
      });
    }
  }
);

router.get(
  "/order/details/get/old",
  xAccessToken.token,
  async function (req, res, next) {
    console.time("looper");
    var token = req.headers["x-access-token"];
    var business = req.headers["business"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    var p = await BusinessOrder.findOne({
      order: req.query.order,
      business: business,
    })
      .populate({
        path: "order",
        populate: [
          {
            path: "user",
            select: "name contact_no username email account_info business_info",
          },
          { path: "car", select: "value variant" },
          { path: "address" },
        ],
      })
      .populate({
        path: "business",
        select:
          "name address business_info contact_no email account_info bank_details",
      })
      .exec();

    var transactions = await q.all(
      fun.getOrderTransaction(p.order._id, business)
    );

    var has_invoice = false;
    var invoices = await OrderInvoice.find({
      order: p.order._id,
      business: business,
    })
      .select("status invoice_no")
      .exec();

    if (invoices.length > 0) {
      has_invoice = true;
    }
    var total_quantity = 0;
    var tax_Amount_CGST = 0;
    var tax_Amount_SGST = 0;
    var total_partcost = 0;
    var items = await q.all(
      fun.getBusinessOrderItems(p.order._id, business, req.headers["tz"])
    );
    for (var i = 0; i < items.length; i++) {
      total_quantity = total_quantity + items[i].quantity;
      if (items[i].tax_info) {
        var tax_info = items[i].tax_info;
        tax_Amount_CGST = tax_Amount_CGST + tax_info[0].amount;
        tax_Amount_SGST = tax_Amount_SGST + tax_info[1].amount;
      }
      total_partcost = total_partcost + items[i].amount;
    }
    // console.log("quantity  =" + total_quantity)
    var amount = (total_partcost - p.payment.order_discount).toFixed(2);
    var total = {
      total: total_partcost,
      discount: p.payment.order_discount,
      discount_type: p.payment.discount_type,
      total_quantity: total_quantity,
      tax_Amount_CGST: tax_Amount_CGST,
      tax_Amount_SGST: tax_Amount_SGST,
      due: p.due.due,
      amount: amount,
    };

    res.status(200).json({
      responseCode: 200,
      responseMessage: "success",
      responseData: {
        total: total,
        _id: p.order._id,
        id: p.order._id,
        items: await q.all(
          fun.getBusinessOrderItems(p.order._id, business, req.headers["tz"])
        ),
        user: p.order.user,
        car: p.order.car,
        address: p.order.address,
        due_date: moment(p.due_date).tz(req.headers["tz"]).format("lll"),
        delivery_date: moment(p.delivery_date)
          .tz(req.headers["tz"])
          .format("lll"),
        time_slot: p.time_slot,
        convenience: p.convenience,
        _order: p._order,
        order_no: p.order_no,
        business: p.business,
        address: p.order.address,
        payment: p.payment,
        status: p.status,
        due: p.due,
        note: p.note,
        log: p.log,
        has_invoice: has_invoice,
        invoices: invoices,
        transactions: transactions.transactions,
        created_at: moment(p.created_at).tz(req.headers["tz"]).format("lll"),
        updated_at: moment(p.updated_at).tz(req.headers["tz"]).format("lll"),
      },
    });

    console.timeEnd("looper");
  }
);

router.get(
  "/order/details/get",
  xAccessToken.token,
  async function (req, res, next) {
    businessFunctions.logs(
      "INFO: /order/details/get Api Called from order.js," +
        " " +
        "Request Headers:" +
        JSON.stringify(req.headers) +
        ", " +
        "Request Query:" +
        JSON.stringify(req.query)
    );

    console.time("looper");
    var token = req.headers["x-access-token"];
    var business = req.headers["business"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = await User.findById(decoded.user).exec();

    if (
      Log_Level == 4 ||
      Log_Level == 6 ||
      Log_Level == 8 ||
      Log_Level == 10 ||
      Log_Level == 0
    ) {
      businessFunctions.logs(
        "DEBUG: Fatching order details for the given order, OrderId:" +
          req.query.order +
          ", " +
          "User:" +
          user.name
      );
    }
    var p = await BusinessOrder.findOne({
      order: req.query.order,
      business: business,
    })
      .populate({
        path: "order",
        populate: [
          {
            path: "user",
            select: "name contact_no username email account_info business_info",
          },
          { path: "car", select: "value variant" },
          { path: "address" },
        ],
      })
      .populate({
        path: "business",
        select:
          "name address business_info contact_no email account_info bank_details",
      })

      .exec();
    var vendorOrder = await VendorOrders.findOne({ _id: p.vendorOrder })
      .select("status order_status parts sentDate ")
      .populate({ path: "vendor", select: "name contact_no address.address" })
      .exec();
    var transactions = await q.all(
      fun.getOrderTransaction(p.order._id, business)
    );

    var has_invoice = false;
    if (
      Log_Level == 4 ||
      Log_Level == 6 ||
      Log_Level == 8 ||
      Log_Level == 10 ||
      Log_Level == 0
    ) {
      businessFunctions.logs(
        "DEBUG: Fatching order Invoices and active Invoices details for the given order, OrderId:" +
          p.order._id +
          ", " +
          "User:" +
          user.name
      );
    }
    var invoices = await OrderInvoice.find({
      order: p.order._id,
      business: business,
    })
      .select("status invoice_no")
      .exec();
    var activeInvoice = await OrderInvoice.findOne({
      order: p.order._id,
      business: business,
      status: "Active",
    })
      .select("status invoice_no updated_at")
      .sort({ created_at: -1 })
      .exec();

    var isInvoiceUpToDate = false;
    if (invoices.length > 0) {
      has_invoice = true;
      // console.log("Order Date = " + new Date(p.updated_at))
      // console.log("Invoice  Date = " + new Date(activeInvoice.updated_at))
      if (activeInvoice) {
        var serverTime = moment.tz(new Date(p.updated_at), req.headers["tz"]);
        var bar = moment.tz(
          new Date(activeInvoice.updated_at),
          req.headers["tz"]
        );
        var baz = serverTime.diff(bar);
        // console.log("-- " + baz);   ///Used to take diffrence between Order updated Date and Invoice Updated Date Average time is 30 to 40 When both  updated at same time.
        if (baz < 50) {
          isInvoiceUpToDate = true;
        }
      }
    }
    var total_quantity = 0;
    var tax_Amount_CGST = 0;
    var tax_Amount_SGST = 0;
    var tax_Amount_IGST = 0;
    var total_partcost = 0;
    var requirment_total_amount = 0;

    var items = await q.all(
      fun.getBusinessOrderItems(p.order._id, business, req.headers["tz"])
    );
    // console.log(JSON.stringify(items))
    for (var i = 0; i < items.length; i++) {
      total_quantity = total_quantity + items[i].quantity;
      total_partcost = total_partcost + items[i].amount;
      if (items[i].tax_info) {
        var tax_info = items[i].tax_info;
        if (tax_info.length == 2) {
          tax_Amount_CGST = tax_Amount_CGST + tax_info[0].amount;
          tax_Amount_SGST = tax_Amount_SGST + tax_info[1].amount;
        }
        if (tax_info.length == 1) {
          tax_Amount_IGST = tax_Amount_IGST + tax_info[0] + amount;
        }
      }
    }
    if (vendorOrder) {
      for (var i = 0; i < vendorOrder.parts.length; i++) {
        requirment_total_amount =
          requirment_total_amount + vendorOrder.parts[i].amount;
      }
    }

    // console.log("quantity  =" + total_quantity)
    var amount = (
      total_partcost -
      p.payment.order_discount -
      p.payment.discount_total -
      p.payment.convenience_charges
    ).toFixed(2);
    var due = amount - p.payment.paid_total;
    var total = {
      total: total_partcost.toFixed(2),
      discount: currencyFormatter.format(p.payment.order_discount.toFixed(2), {
        code: "INR",
      }),
      discount_type: p.payment.discount_type,
      total_quantity: total_quantity,
      tax_Amount_CGST: currencyFormatter.format(tax_Amount_CGST.toFixed(2), {
        code: "INR",
      }),
      tax_Amount_SGST: currencyFormatter.format(tax_Amount_SGST.toFixed(2), {
        code: "INR",
      }),
      tax_Amount_IGST: currencyFormatter.format(tax_Amount_IGST.toFixed(2), {
        code: "INR",
      }),
      due: currencyFormatter.format(due, { code: "INR" }),
      amount: currencyFormatter.format(amount, { code: "INR" }),
    };

    // baz>   Treu
    if (
      Log_Level == 4 ||
      Log_Level == 6 ||
      Log_Level == 8 ||
      Log_Level == 10 ||
      Log_Level == 0
    ) {
      businessFunctions.logs(
        "DEBUG: Sending Order Details in Response, OrderId:" +
          req.query.order +
          ", " +
          "Order_By:" +
          p.order.user.name +
          ", " +
          "User:" +
          user.name
      );
    }
    res.status(200).json({
      responseCode: 200,
      responseMessage: "success",
      responseData: {
        total: total,
        _id: p.order._id,
        id: p.order._id,
        items: await q.all(
          fun.getBusinessOrderItems(p.order._id, business, req.headers["tz"])
        ),
        user: p.order.user,
        car: p.order.car,
        address: p.order.address,
        due_date: moment(p.due_date).tz(req.headers["tz"]).format("lll"),
        delivery_date: moment(p.delivery_date)
          .tz(req.headers["tz"])
          .format("lll"),
        time_slot: p.time_slot,
        convenience: p.convenience,
        _order: p._order,
        order_no: p.order_no,
        business: p.business,
        address: p.order.address,
        payment: p.payment,
        status: p.status,
        due: p.due,
        note: p.note,
        log: p.log,
        logs: p.logs,
        isPurchaseOrder: p.isPurchaseOrder,
        vendorOrder: vendorOrder,
        requirment_total_amount: requirment_total_amount,
        request_no: p.order.request_no,
        has_invoice: has_invoice,
        invoices: invoices,
        activeInvoice: activeInvoice,
        transactions: transactions.transactions,
        parchi: p.order.parchi,
        isParchi: p.order.isParchi,
        created_at: moment(p.created_at).tz(req.headers["tz"]).format("lll"),
        updated_at: moment(p.updated_at).tz(req.headers["tz"]).format("lll"),
        isInvoiceUpToDate: isInvoiceUpToDate,
      },
    });
    if (
      Log_Level == 3 ||
      Log_Level == 7 ||
      Log_Level == 9 ||
      Log_Level == 10 ||
      Log_Level == 0
    ) {
      businessFunctions.logs(
        "INFO: Order Details Send in Response Successfully, OrderId:" +
          req.query.order +
          ", " +
          "Order_By:" +
          p.order.user.name +
          ", " +
          "User:" +
          user.name
      );
    }
    console.timeEnd("looper");
  }
);

router.post(
  "/order/invoice/generate",
  xAccessToken.token,
  async function (req, res, next) {
    var business = req.headers["business"];
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var date = new Date();
    var loggedInDetails = decoded.user;
    var items = [];
    var data = [];

    var item_total = 0;
    var discount = 0;
    var item_total = 0;
    var total = 0;

    var order = await Order.findById(req.body.order).exec();
    var loggedInDetails = await User.findById(decoded.user).exec();
    if (order) {
      var invoice = await OrderInvoice.findOne({
        order: order._id,
        business: business,
        status: "Active",
      })
        .populate({
          path: "order",
          populate: [
            {
              path: "user",
              select:
                "name contact_no username email account_info business_info",
            },
            { path: "car", select: "variant value" },
            { path: "address" },
          ],
        })
        .exec();
      if (invoice) {
        await OrderInvoice.findOneAndUpdate(
          { _id: invoice._id },
          { $set: { status: "Cancelled" } },
          { new: true },
          async function (err, invoice) {
            if (err) {
              // res.status(200).json({
              //     responseCode: 200,
              //     responseMessage: "success",
              //     responseData: {}
              // })
            } else {
              var transactionData = {
                user: invoice.user,
                business: invoice.business,
                status: "Sale Cancelled",
                type: "Sale Cancelled",
                paid_by: "-",
                activity: "Invoice",
                source: invoice._id,
                bill_id: invoice.invoice_no,
                bill_amount:
                  parseFloat(invoice.payment.total) -
                  parseFloat(invoice.payment.discount_total),
                transaction_amount:
                  parseFloat(invoice.payment.total) -
                  parseFloat(invoice.payment.discount_total),
                balance:
                  parseFloat(invoice.payment.total) -
                  parseFloat(invoice.payment.discount_total),
                total:
                  parseFloat(invoice.payment.total) -
                  parseFloat(invoice.payment.discount_total),
                paid_total: 0,
                due: 0,
                payment_status: "Cancelled",
                payment_mode: "-",
                received_by: loggedInDetails.name,
                transaction_id: "-",
                transaction_date: new Date(),
                transaction_status: "Success",
                transaction_response: "-",
                transaction_type: "Sale Cancelled",
              };
              q.all(businessFunctions.addTransaction(transactionData));

              var activity = {
                business: business,
                activity_by: loggedInDetails.name,
                activity: "Invoice Cancelled " + "#" + invoice.invoice_no,
                remark: "Invoice Cancelled",
                created_at: new Date(),
              };
              businessFunctions.salesOrderLogs(order._id, activity);
            }
          }
        );
      }
      // if (invoice) {
      //     await OrderInvoice.findOneAndUpdate({ _id: inv._id }, { $set: { status: 'Cancelled' } }, { new: true }, async function (err, doc) {
      //         if (err) {
      //             res.status(200).json({
      //                 responseCode: 200,
      //                 responseMessage: "success",
      //                 responseData: {}
      //             })
      //         }
      //     })

      //     // console.log("Already Invoiced")
      //     // var transactions = await q.all(fun.getOrderTransaction(invoice.order._id, business));

      //     // res.status(200).json({
      //     //     responseCode: 200,
      //     //     responseMessage: "success",
      //     //     responseData: {
      //     //         _id: invoice._id,
      //     //         id: invoice._id,
      //     //         items: await q.all(fun.getBusinessOrderItems(invoice.order._id, business, req.headers['tz'])),
      //     //         user: invoice.order.user,
      //     //         car: invoice.order.car,
      //     //         address: invoice.order.address,
      //     //         due_date: moment(invoice.due_date).tz(req.headers['tz']).format('lll'),
      //     //         delivery_date: moment(invoice.delivery_date).tz(req.headers['tz']).format('lll'),
      //     //         time_slot: invoice.time_slot,
      //     //         convenience: invoice.convenience,
      //     //         order_no: invoice.order_no,
      //     //         _order: invoice._order,
      //     //         invoice_no: invoice.invoice_no,
      //     //         address: invoice.order.address,
      //     //         payment: invoice.payment,
      //     //         status: invoice.status,
      //     //         due: invoice.due,
      //     //         log: invoice.log,
      //     //         transactions: transactions.transactions,
      //     //         created_at: moment(invoice.created_at).tz(req.headers['tz']).format('lll'),
      //     //         updated_at: moment(invoice.updated_at).tz(req.headers['tz']).format('lll'),
      //     //     }
      //     // });
      // }
      // else {
      var date = new Date();
      var availablity = false;
      await OrderLine.updateMany(
        {
          order: order._id,
          business: business,
          issued: true,
          status: { $nin: ["Cancelled"] },
        },
        { $set: { isInvoice: true } }
      ).exec();
      var items = await OrderLine.find({
        order: order._id,
        business: business,
        status: { $nin: ["Cancelled"] },
      }).exec();

      var nd = _.filter(items, (status) => status.issued == true);

      if (nd.length <= 0) {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Error! Add some items",
          responseData: {},
        });
      } else {
        var businessOrder = await BusinessOrder.findOne({
          order: order._id,
          business: business,
        }).exec();

        OrderInvoice.create({
          business: business,
          user: businessOrder.user,
          order: businessOrder.order,
          source: businessOrder._id,
          delivery_date: businessOrder.delivery_date,
          due_date: businessOrder.due_date,
          _order: businessOrder._order,
          order_no: businessOrder.order_no,
          note: businessOrder.note,
          invoice_no: businessOrder.invoice_no,
          status: "Active",
          with_tax: true,
          payment: businessOrder.payment,
          due: businessOrder.due,
          created_at: new Date(),
          updated_at: new Date(),
        }).then(async function (inv) {
          var count = await OrderInvoice.find({
            _id: { $lt: inv._id },
            business: business,
          }).count();
          if (count == 0) {
            // console.log("If ")
            var last_invoice = "";
            var position = 1;
          } else {
            // console.log("ELSE " + count)

            var lv = await OrderInvoice.findOne({
              _id: { $lt: inv._id },
              business: business,
            })
              .sort({ _id: -1 })
              .exec();
            // return res.json({
            //     data: lv
            // })
            var last_invoice = lv.invoice_no;
            position = count + 1;
          }
          //console.log("Lats Invoice  -= " + last_invoice)
          var fy = {
            with_tax: inv.with_tax,
            last_invoice: last_invoice,
            position: position,
          };

          var assigned_invoice_no = await q.all(fun.fiscalyear(fy));

          /////////////////////////////Abhinav Invoice Bug Fix/////////////////////////////

          /*
                     var assigned_invoice_no = await q.all(async function(data)
    {
        console.log(data)
        if(data.with_tax==true){
            var fiscalyear ={};
            var today = new Date();
            var thisFullYear = today.getFullYear();
            var nextFullYear = today.getFullYear()+1;
 
            today.setMonth(today.getMonth());
            
            if((today.getMonth() + 1) <= 3)  
            {
                fiscalyear = (today.getFullYear() - 1) + "-" + thisFullYear.toString().slice(-2);
            } 
            else
            {
                fiscalyear = today.getFullYear() + "-" + nextFullYear.toString().slice(-2);
            }
 
 
            if(data.last_invoice==""){
                var invoice = fiscalyear+"/"+data.position;
            }
            else
            {
                var ls = data.last_invoice.split('/');
                if(ls[0]==fiscalyear)
                {
                    if(ls[1])
                    {
                        var invoice = fiscalyear+"/"+(parseInt(ls[1])+1);
                    }
                    else
                    {
                        var invoice = fiscalyear+"/"+data.position;
                    }
                }
                else
                {
                    var invoice = fiscalyear+"/1";
                }
            }
        }
        else{
            var invoice = data.position;
            // if(data.last_invoice==""){
            //     var invoice = data.position;
            // }
            // else
            // {
            //     var invoice = data.position;
            // }
        }
        return {invoice: invoice}
    });
 
 
                    */
          /////////////////////////////Abhinav Invoice Bug Fix/////////////////////////////
          //console.log("Assigned Onbocds = " + assigned_invoice_no.invoice)
          if (assigned_invoice_no) {
            if (assigned_invoice_no.invoice) {
              // console.log("Invoice no: " + assigned_invoice_no.invoice)
              await OrderInvoice.findOneAndUpdate(
                { _id: inv._id },
                { $set: { invoice_no: assigned_invoice_no.invoice } },
                { new: true },
                async function (err, doc) {
                  if (err) {
                    res.status(422).json({
                      responseCode: 422,
                      responseMessage: "Server Error",
                      responseData: err,
                    });
                  } else {
                    // status: "Shipped",
                    await Order.findOneAndUpdate(
                      { _id: order._id },
                      {
                        $set: {
                          isInvoice: true,
                          invoice: inv._id,
                          updated_at: new Date(),
                        },
                      },
                      { new: false },
                      async function (err, doc) {
                        if (err) {
                          return res.status(422).json({
                            responseCode: 422,
                            responseMessage: "Server Error",
                            responseData: err,
                          });
                        } else {
                          // ,status: "Shipped"
                          await BusinessOrder.findOneAndUpdate(
                            { order: order._id, business: business },
                            {
                              $set: {
                                isInvoice: true,
                                invoice: inv._id,
                                updated_at: new Date(),
                              },
                            },
                            { new: false },
                            async function (err, doc) {
                              if (err) {
                                return res.status(422).json({
                                  responseCode: 422,
                                  responseMessage: "Server Error",
                                  responseData: err,
                                });
                              }
                            }
                          );
                        }
                      }
                    );

                    var p = await OrderInvoice.findById(inv._id)
                      .populate({
                        path: "order",
                        populate: [
                          {
                            path: "user",
                            select:
                              "name contact_no username email account_info business_info",
                          },
                          { path: "car", select: "variant value" },
                          { path: "address" },
                        ],
                      })
                      .exec();

                    var transactions = await q.all(
                      fun.getOrderTransaction(p.order._id, business)
                    );

                    var transactionData = {
                      user: p.user,
                      business: p.business,
                      status: "Sale Created",
                      type: "Sale",
                      paid_by: "-",
                      activity: "Sales Order",
                      source: p._id,
                      bill_id: p.invoice_no,
                      bill_amount:
                        p.payment.total.toFixed(2) -
                        p.payment.discount_total.toFixed(2),
                      transaction_amount:
                        p.payment.total.toFixed(2) -
                        p.payment.discount_total.toFixed(2),
                      balance:
                        p.payment.total.toFixed(2) -
                        p.payment.discount_total.toFixed(2),
                      total:
                        p.payment.total.toFixed(2) -
                        p.payment.discount_total.toFixed(2),
                      paid_total: 0,
                      due: 0,
                      payment_status: "Pending",
                      payment_mode: "-",
                      received_by: loggedInDetails.name,
                      transaction_id: "-",
                      transaction_date: new Date(),
                      transaction_status: "Success",
                      transaction_response: "-",
                      transaction_type: "Sale",
                    };
                    q.all(businessFunctions.addTransaction(transactionData));

                    var activity = {
                      business: business,
                      activity_by: loggedInDetails.name,
                      activity:
                        "Invoice Generated " +
                        "#" +
                        assigned_invoice_no.invoice,
                      remark: "Invoice Generated",
                      created_at: new Date(),
                    };
                    businessFunctions.salesOrderLogs(order._id, activity);

                    var itemDetails = await q.all(
                      fun.getBusinessOrderItems(
                        p.order._id,
                        business,
                        req.headers["tz"]
                      )
                    );
                    fun.orderInvoice(itemDetails, p, p.order.address);

                    res.status(200).json({
                      responseCode: 200,
                      responseMessage: "Invoive Generated Successfully",
                      responseData: {
                        _id: p._id,
                        id: p._id,
                        items: await q.all(
                          fun.getBusinessOrderItems(
                            p.order._id,
                            business,
                            req.headers["tz"]
                          )
                        ),
                        user: p.order.user,
                        car: p.order.car,
                        address: p.order.address,
                        due_date: moment(p.due_date)
                          .tz(req.headers["tz"])
                          .format("lll"),
                        delivery_date: moment(p.delivery_date)
                          .tz(req.headers["tz"])
                          .format("lll"),
                        time_slot: p.time_slot,
                        convenience: p.convenience,
                        order_no: p.order_no,
                        _order: p._order,
                        invoice_no: p.invoice_no,
                        address: p.order.address,
                        payment: p.payment,
                        status: p.status,
                        due: p.due,
                        log: p.log,
                        transactions: transactions.transactions,
                        created_at: moment(p.created_at)
                          .tz(req.headers["tz"])
                          .format("lll"),
                        updated_at: moment(p.updated_at)
                          .tz(req.headers["tz"])
                          .format("lll"),
                      },
                    });
                  }
                }
              );
            } else {
              res.status(422).json({
                responseCode: 422,
                responseMessage: "Server Error",
                responseData: {},
              });
            }
          } else {
            res.status(422).json({
              responseCode: 422,
              responseMessage: "Server Error",
              responseData: {},
            });
          }
        });
      }
    }
    // }
    else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Order not found",
        responseData: {},
      });
    }
  }
);

router.get(
  "/order/invoices/get",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var business = req.headers["business"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    //paginate
    if (req.query.page == undefined) {
      var page = 0;
    } else {
      var page = req.query.page;
    }

    var page = Math.max(0, parseInt(page));

    var orders = [];

    var filters = [];
    var match = [];
    var queries = {};

    // var specification = {};
    // specification['$lookup'] = {
    //     from: "Order",
    //     localField: "order",
    //     foreignField: "_id",
    //     as: "order",
    // };
    // filters.push(specification);
    // var specification = {};
    // specification['$unwind'] = {
    //     path: "$order",
    //     preserveNullAndEmptyArrays: false
    // };

    // filters.push(specification);
    // var specification = {};
    // specification['$lookup'] = {
    //     from: "Sales",
    //     localField: "sale",
    //     foreignField: "_id",
    //     as: "sale",
    // };
    // filters.push(specification);
    // var specification = {};
    // specification['$unwind'] = {
    //     path: "$sale",
    //     preserveNullAndEmptyArrays: false
    // };
    // filters.push(specification);

    if (req.query.query) {
      req.query.query = req.query.query.replace(
        /([.?*+^$[\]\\(){}|-])/g,
        "\\$1"
      );
      var specification = {};
      specification["$lookup"] = {
        from: "User",
        localField: "user",
        foreignField: "_id",
        as: "user",
      };
      filters.push(specification);

      var specification = {};
      specification["$unwind"] = {
        path: "$user",
        preserveNullAndEmptyArrays: false,
      };
      filters.push(specification);

      var specification = {};
      specification["$match"] = {
        business: mongoose.Types.ObjectId(business),
        $or: [
          { _order: { $regex: req.query.query, $options: "i" } },
          { status: { $regex: req.query.query, $options: "i" } },
          { order_no: { $regex: req.query.query, $options: "i" } },
          { sale_no: { $regex: req.query.query, $options: "i" } },
          { "user.name": { $regex: req.query.query, $options: "i" } },
          { "user.contact_no": { $regex: req.query.query, $options: "i" } },
        ],
      };
      filters.push(specification);
    } else {
      var specification = {};
      specification["$match"] = {
        business: mongoose.Types.ObjectId(business),
      };
      filters.push(specification);
    }

    var query = filters;

    var totalResult = await OrderInvoice.aggregate(query);
    // console.log(JSON.stringify(totalResult))
    // totalResult = await Invoice.aggregate(filters);

    var all = _.filter(totalResult, (x) => x.status == "Active");
    var map_due = _.map(all, "due");
    var map_payment = _.map(all, "payment");

    var due = parseFloat(_.sumBy(map_due, (x) => x.due).toFixed(2));
    var payment_total = parseFloat(
      _.sumBy(map_payment, (x) => x.total).toFixed(2)
    );

    var due_result = await businessFunctions.numberConversion(due);
    var payment_total_result = await businessFunctions.numberConversion(
      payment_total
    );

    var specification = {};
    specification["$sort"] = {
      updated_at: -1,
    };
    filters.push(specification);

    var specification = {};
    specification["$skip"] = 6 * page;
    filters.push(specification);

    var specification = {};
    specification["$limit"] = config.perPage;
    filters.push(specification);

    await OrderInvoice.aggregate(query)
      .allowDiskUse(true)
      .cursor({ batchSize: 20 })
      .exec()
      .eachAsync(async function (p) {
        //orders.push(p)
        if (p) {
          var order = await Order.findById(p.order)
            .populate({
              path: "user",
              select:
                "name contact_no username email account_info business_info",
            })
            .populate({
              path: "car",
              select: "title variant registration_no _automaker _model",
            })
            .populate({ path: "address" })
            .exec();
          var sale = await Sales.findById(p.sale)
            .populate({
              path: "user",
              select:
                "name contact_no username email account_info business_info",
            })
            .populate({
              path: "car",
              select: "title variant registration_no _automaker _model",
            })
            .populate({ path: "address" })
            .exec();
          if (order) {
            var car = "";
            if (order.car) {
              car = order.car.variant;
            }
            orders.push({
              _id: p._id,
              // id: p._id,
              // invoice_id: p._id,
              order: order._id,
              user: order.user.name,
              car: car,
              UserId: order.user._id,
              contact_no: order.user.contact_no,
              // address: order.address,
              // due_date: moment(p.due_date).tz(req.headers['tz']).format('lll'),
              // delivery_date: moment(p.delivery_date).tz(req.headers['tz']).format('lll'),
              // time_slot: p.time_slot,
              // convenience: p.convenience,
              // order: p._order,
              // order_no: p.order_no,
              // address: p.address,
              paymentTotal: currencyFormatter.format(p.payment.total, {
                code: "INR",
              }),
              invoice_no: p.invoice_no,
              order_status: order.status,
              due: currencyFormatter.format(p.due.due, { code: "INR" }),
              // log: p.log,
              type: "salesOrder",
              status: p.status,
              created_at: moment(p.created_at)
                .tz(req.headers["tz"])
                .format("lll"),
              updated_at: moment(p.updated_at)
                .tz(req.headers["tz"])
                .format("lll"),
            });
          } else if (sale) {
            var car = "";
            if (sale.car) {
              car = sale.car.variant;
            }
            orders.push({
              _id: p._id,
              // id: p._id,
              // invoice_id: p._id,
              invoice_no: p.invoice_no,
              user: sale.user.name,
              contact_no: sale.user.contact_no,
              UserId: sale.user._id,
              order: sale._id,
              car: car,
              // address: sale.address,
              // due_date: moment(p.due_date).tz(req.headers['tz']).format('lll'),
              // delivery_date: moment(p.delivery_date).tz(req.headers['tz']).format('lll'),
              // time_slot: p.time_slot,
              // convenience: p.convenience,
              // _order: p._order,
              // order_no: p.sale_no,
              // address: p.address,
              paymentTotal: currencyFormatter.format(p.payment.total, {
                code: "INR",
              }),
              order_status: sale.status,
              due: currencyFormatter.format(p.due.due, { code: "INR" }),
              // log: p.log,
              status: p.status,
              type: "sale",
              created_at: moment(p.created_at)
                .tz(req.headers["tz"])
                .format("lll"),
              updated_at: moment(p.updated_at)
                .tz(req.headers["tz"])
                .format("lll"),
            });
          }
        }
      });

    res.status(200).json({
      responseCode: 200,
      responseMessage: "success",
      responseInfo: {
        totalResult: totalResult.length,
        payment_total: payment_total_result,
        due: due_result,
      },
      responseData: orders,
    });
  }
);

router.get(
  "/order/invoices_total/get",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var business = req.headers["business"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    var totalResult = await OrderInvoice.find({ business: business });

    var all = _.filter(totalResult, (x) => x.status == "Active");
    var map_due = _.map(all, "due");
    var map_payment = _.map(all, "payment");

    var due = parseFloat(_.sumBy(map_due, (x) => x.due).toFixed(2));
    var payment_total = parseFloat(
      _.sumBy(map_payment, (x) => x.total).toFixed(2)
    );

    var due_result = await businessFunctions.numberConversion(due);
    var payment_total_result = await businessFunctions.numberConversion(
      payment_total
    );

    res.status(200).json({
      responseCode: 200,
      responseMessage: "success",
      responseData: {
        totalResult: totalResult.length,
        payment_total: payment_total_result,
        due: due_result,
      },
    });
  }
);

router.get(
  "/order/invoice/get",
  xAccessToken.token,
  async function (req, res, next) {
    console.time("looper");
    var rules = {
      invoice: "required",
    };

    var validation = new Validator(req.query, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Invoice is required",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var business = req.headers["business"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);

      var p = await OrderInvoice.findById(req.query.invoice)
        .populate({
          path: "order",
          populate: [
            {
              path: "user",
              select:
                "name contact_no username email account_info business_info",
            },
            {
              path: "business",
              select:
                "name contact_no username email account_info business_info bank_details",
            },
            { path: "car", select: "variant value" },
            { path: "address" },
          ],
        })
        .exec();
      if (p) {
        var transactions = await q.all(
          fun.getOrderTransaction(p.order._id, business)
        );
        var business_info = await User.findById(p.business)
          .select(
            "name contact_no username email account_info business_info bank_details address"
          )
          .exec();

        res.status(200).json({
          responseCode: 200,
          responseMessage: "success",
          responseData: {
            _id: p._id,
            id: p._id,
            items: await q.all(
              fun.getBusinessOrderItems(
                p.order._id,
                business,
                req.headers["tz"]
              )
            ),
            user: p.order.user,
            car: p.order.car,
            due_date: moment(p.due_date).tz(req.headers["tz"]).format("lll"),
            delivery_date: moment(p.delivery_date)
              .tz(req.headers["tz"])
              .format("lll"),
            time_slot: p.time_slot,
            convenience: p.convenience,
            order_no: p.order_no,
            _order: p._order,
            invoice_no: p.invoice_no,
            address: p.order.address,
            payment: p.payment,
            status: p.status,
            business: business_info,
            due: p.due,
            note: p.note,
            log: p.log,
            transactions: transactions.transactions,
            created_at: moment(p.created_at)
              .tz(req.headers["tz"])
              .format("lll"),
            updated_at: moment(p.updated_at)
              .tz(req.headers["tz"])
              .format("lll"),
          },
        });
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Invoice not found",
          responseData: {},
        });
      }
    }
    console.timeEnd("looper");
  }
);

router.put(
  "/order/invoice/cancel",
  xAccessToken.token,
  async function (req, res, next) {
    var business = req.headers["business"];
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var date = new Date();
    var loggedInDetails = decoded.user;
    var items = [];
    var data = [];

    var item_total = 0;
    var discount = 0;
    var item_total = 0;
    var total = 0;

    var invoice = await OrderInvoice.findById(req.body.invoice).exec();
    var loggedInDetails = await User.findById(decoded.user).exec();
    if (invoice) {
      var date = new Date();

      var data = {
        updated_at: new Date(),
        status: "Cancelled",
      };

      OrderInvoice.findOneAndUpdate(
        { _id: invoice._id },
        { $set: data },
        { new: false },
        async function (err, doc) {
          if (err) {
            res.status(422).json({
              responseCode: 422,
              responseMessage: "Server Error",
              responseData: err,
            });
          } else {
            res.status(200).json({
              responseCode: 200,
              responseMessage: "Invoice has been Cancelled",
              responseData: {},
            });
          }
        }
      );
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Invoice Already Cancelled!",
        responseData: {},
      });
    }
  }
);

router.post("/note/add", xAccessToken.token, async function (req, res, next) {
  businessFunctions.logs(
    "INFO: /note/add Api Called from booking.js," +
      " " +
      "Request Headers:" +
      JSON.stringify(req.headers) +
      ", " +
      "Request Body:" +
      JSON.stringify(req.body)
  );

  var business = req.headers["business"];
  var token = req.headers["x-access-token"];
  var secret = config.secret;
  var decoded = jwt.verify(token, secret);
  var date = new Date();
  var loggedInDetails = decoded.user;
  var items = [];
  var data = [];

  var item_total = 0;
  var discount = 0;
  var item_total = 0;
  var total = 0;

  var data = {
    updated_at: new Date(),
    note: req.body.note,
  };

  var loggedInDetails = await User.findById(decoded.user).exec();
  if (req.body.type == "booking") {
    var source = await Booking.findById(req.body.source).exec();
    if (source) {
      Booking.findOneAndUpdate(
        { _id: source._id },
        { $set: data },
        { new: false },
        async function (err, doc) {
          if (err) {
            if (
              Log_Level == 1 ||
              Log_Level == 5 ||
              Log_Level == 6 ||
              Log_Level == 7 ||
              Log_Level == 0
            ) {
              businessFunctions.logs(
                "ERROR: Error Occured while add note for the booking, bookingId:" +
                  source._id +
                  ", " +
                  "User:" +
                  loggedInDetails.name
              );
            }
            return res.status(422).json({
              responseCode: 422,
              responseMessage: "Server Error",
              responseData: err,
            });
          } else {
            Invoice.update(
              { booking: source._id },
              { $set: { note: req.body.note } },
              { multi: true },
              async function (err, doc) {
                if (err) {
                  if (
                    Log_Level == 1 ||
                    Log_Level == 5 ||
                    Log_Level == 6 ||
                    Log_Level == 7 ||
                    Log_Level == 0
                  ) {
                    businessFunctions.logs(
                      "ERROR: Error Occured while Update note in the invoice for the booking, bookingId:" +
                        source._id +
                        ", " +
                        "User:" +
                        loggedInDetails.name
                    );
                  }
                  return res.status(422).json({
                    responseCode: 422,
                    responseMessage: "Server Error",
                    responseData: err,
                  });
                } else {
                  res.status(200).json({
                    responseCode: 200,
                    responseMessage: "Note has been updated",
                    responseData: {},
                  });
                  if (
                    Log_Level == 3 ||
                    Log_Level == 7 ||
                    Log_Level == 9 ||
                    Log_Level == 10 ||
                    Log_Level == 0
                  ) {
                    businessFunctions.logs(
                      "INFO: Note has been updated Successfully for the booking, BookingId:" +
                        req.body.source +
                        ", " +
                        "User:" +
                        loggedInDetails.name
                    );
                  }
                }
              }
            );
          }
        }
      );
    } else {
      if (
        Log_Level == 1 ||
        Log_Level == 5 ||
        Log_Level == 6 ||
        Log_Level == 7 ||
        Log_Level == 0
      ) {
        businessFunctions.logs(
          "ERROR: Booking not found for the given booking, BookingId:" +
            req.body.source +
            ", " +
            "User:" +
            loggedInDetails.name
        );
      }
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Booking not found",
        responseData: {},
      });
    }
  } else if (req.body.type == "order") {
    var source = await BusinessOrder.findOne({ order: req.body.source }).exec();
    if (source) {
      await BusinessOrder.findOneAndUpdate(
        { order: req.body.source },
        { $set: data },
        { new: false },
        async function (err, doc) {
          if (err) {
            if (
              Log_Level == 1 ||
              Log_Level == 5 ||
              Log_Level == 6 ||
              Log_Level == 7 ||
              Log_Level == 0
            ) {
              businessFunctions.logs(
                "ERROR: Error Occured while add note for the order, orderId:" +
                  source +
                  ", " +
                  "User:" +
                  loggedInDetails.name
              );
            }
            res.status(422).json({
              responseCode: 422,
              responseMessage: "Server Error",
              responseData: err,
            });
          } else {
            await OrderInvoice.update(
              { order: req.body.source },
              { $set: { note: req.body.note } },
              { multi: true },
              async function (err, doc) {
                if (err) {
                  if (
                    Log_Level == 1 ||
                    Log_Level == 5 ||
                    Log_Level == 6 ||
                    Log_Level == 7 ||
                    Log_Level == 0
                  ) {
                    businessFunctions.logs(
                      "ERROR: Error Occured while Update note in the invoice for the order, orderId:" +
                        source._id +
                        ", " +
                        "User:" +
                        loggedInDetails.name
                    );
                  }
                  return res.status(422).json({
                    responseCode: 422,
                    responseMessage: "Server Error",
                    responseData: err,
                  });
                } else {
                  var activity = {
                    business: business,
                    activity_by: loggedInDetails.name,
                    activity: "New Note : '" + req.body.note + "'",
                    remark: "New Notes Added",
                    created_at: new Date(),
                  };
                  businessFunctions.salesOrderLogs(source.order, activity);
                  res.status(200).json({
                    responseCode: 200,
                    responseMessage: "Note has been updated",
                    responseData: {},
                  });
                  if (
                    Log_Level == 3 ||
                    Log_Level == 7 ||
                    Log_Level == 9 ||
                    Log_Level == 10 ||
                    Log_Level == 0
                  ) {
                    businessFunctions.logs(
                      "INFO: Note has been updated Successfully for the order, orderId:" +
                        req.body.source +
                        ", " +
                        "User:" +
                        loggedInDetails.name
                    );
                  }
                }
              }
            );
          }
        }
      );
    } else {
      if (
        Log_Level == 2 ||
        Log_Level == 5 ||
        Log_Level == 8 ||
        Log_Level == 9 ||
        Log_Level == 0
      ) {
        businessFunctions.logs(
          "WARNING: Order not found, orderId:" +
            req.body.source +
            ", " +
            "User:" +
            loggedInDetails.name
        );
      }
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Order not found",
        responseData: {},
      });
    }
  } else if (req.body.type == "sale") {
    // console.log("Sorce = " + req.body.source + " = " + req.body.type)
    var source = await Sales.findOne({ _id: req.body.source }).exec();
    if (source) {
      await Sales.findOneAndUpdate(
        { _id: req.body.source },
        { $set: data },
        { new: true },
        async function (err, doc) {
          if (err) {
            if (
              Log_Level == 1 ||
              Log_Level == 5 ||
              Log_Level == 6 ||
              Log_Level == 7 ||
              Log_Level == 0
            ) {
              businessFunctions.logs(
                "ERROR: Error Occured while add note for the Sale, SaleId:" +
                  source +
                  ", " +
                  "User:" +
                  loggedInDetails.name
              );
            }
            res.status(422).json({
              responseCode: 422,
              responseMessage: "Server Error",
              responseData: err,
            });
          } else {
            await OrderInvoice.update(
              { sale: req.body.source },
              { $set: { note: req.body.note } },
              { multi: true },
              async function (err, doc) {
                if (err) {
                  if (
                    Log_Level == 1 ||
                    Log_Level == 5 ||
                    Log_Level == 6 ||
                    Log_Level == 7 ||
                    Log_Level == 0
                  ) {
                    businessFunctions.logs(
                      "ERROR: Error Occured while Update note in the invoice for the Sale, SaleId:" +
                        source._id +
                        ", " +
                        "User:" +
                        loggedInDetails.name
                    );
                  }
                  return res.status(422).json({
                    responseCode: 422,
                    responseMessage: "Server Error",
                    responseData: err,
                  });
                } else {
                  var activity = {
                    business: business,
                    activity_by: loggedInDetails.name,
                    activity: "New Note : '" + req.body.note + "'",
                    remark: "New Notes Added",
                    created_at: new Date(),
                  };
                  businessFunctions.salesLogs(source._id, activity);
                  res.status(200).json({
                    responseCode: 200,
                    responseMessage: "Note has been updated",
                    responseData: {},
                  });
                  if (
                    Log_Level == 3 ||
                    Log_Level == 7 ||
                    Log_Level == 9 ||
                    Log_Level == 10 ||
                    Log_Level == 0
                  ) {
                    businessFunctions.logs(
                      "INFO: Note has been updated Successfully for the Sale, SaleId:" +
                        req.body.source +
                        ", " +
                        "User:" +
                        loggedInDetails.name
                    );
                  }
                }
              }
            );
          }
        }
      );
    } else {
      if (
        Log_Level == 2 ||
        Log_Level == 5 ||
        Log_Level == 8 ||
        Log_Level == 9 ||
        Log_Level == 0
      ) {
        businessFunctions.logs(
          "WARNING: Order not found, SaleId:" +
            req.body.source +
            ", " +
            "User:" +
            loggedInDetails.name
        );
      }
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Order not found",
        responseData: {},
      });
    }
  }
});

async function getPackageDiscount(data) {
  var discount = {};
  if (data.package) {
    if (data.claim == false) {
      var package = await UserPackage.findOne({ _id: data.package }).exec();
      if (package) {
        if (package.status == true) {
          if (package.car) {
            var packageUsed = await PackageUsed.find({
              package: data.package,
              user: package.user,
              label: data.service,
              car: data.car,
            })
              .count()
              .exec();
          } else {
            var packageUsed = await PackageUsed.find({
              package: data.package,
              user: package.user,
              label: data.service,
            })
              .count()
              .exec();
          }

          var serverTime = moment.tz(new Date(), data.tz);

          var bar = package.created_at;
          bar.setDate(bar.getDate() + package.validity);
          bar = moment.tz(bar, data.tz);
          var baz = bar.diff(serverTime);
          //////////console.log(baz)
          if (baz > 0) {
            package.discount.forEach(async function (dis) {
              //////////console.log(dis);
              if (dis.for == "category") {
                if (dis.label == data.category) {
                  if (dis.type == "percent") {
                    if (!packageDiscountOn.includes(data.service)) {
                      discount = {
                        discount: dis.discount,
                        discount_type: "percent",
                      };
                    }
                  } else {
                    if (!packageDiscountOn.includes(data.service)) {
                      discount = {
                        discount: dis.discount,
                        discount_type: "price",
                      };
                    }
                  }
                }
              } else if (dis.for == "specific") {
                if (dis.label == data.service) {
                  if (dis.type == "percent") {
                    if (dis.limit > packageUsed) {
                      packageDiscountOn.push(data.service);
                      discount = {
                        discount: dis.discount,
                        discount_type: "percent",
                      };
                    }
                  } else if (dis.type == "fixed") {
                    if (dis.limit > packageUsed) {
                      packageDiscountOn.push(data.service);
                      discount = {
                        discount: dis.discount,
                        discount_type: "fixed",
                      };
                    }
                  } else {
                    if (dis.limit > packageUsed) {
                      packageDiscountOn.push(data.service);
                      discount = {
                        discount: dis.discount,
                        discount_type: "price",
                      };
                    }
                  }
                }
              }
            });
          }
        } else {
          if (package.booking.equals(data.booking)) {
            var packageUsed = await PackageUsed.find({
              package: data.package,
              user: package.user,
              label: data.service,
              car: data.car,
            })
              .count()
              .exec();
            var serverTime = moment.tz(new Date(), data.tz);

            var bar = package.created_at;
            bar.setDate(bar.getDate() + package.validity);
            bar = moment.tz(bar, data.tz);
            var baz = bar.diff(serverTime);
            //////////console.log(baz);
            if (baz > 0) {
              package.discount.forEach(async function (dis) {
                if (dis.for == "category") {
                  if (dis.label == data.category) {
                    if (dis.type == "percent") {
                      if (!packageDiscountOn.includes(data.service)) {
                        discount = {
                          discount: dis.discount,
                          discount_type: "percent",
                        };
                      }
                    } else {
                      if (!packageDiscountOn.includes(data.service)) {
                        discount = {
                          discount: dis.discount,
                          discount_type: "price",
                        };
                      }
                    }
                  }
                } else if (dis.for == "specific") {
                  if (dis.label == data.service) {
                    if (dis.type == "percent") {
                      if (dis.limit > packageUsed) {
                        packageDiscountOn.push(data.service);
                        discount = {
                          discount: dis.discount,
                          discount_type: "percent",
                        };
                      }
                    } else if (dis.type == "fixed") {
                      if (dis.limit > packageUsed) {
                        packageDiscountOn.push(data.service);
                        discount = {
                          discount: dis.discount,
                          discount_type: "fixed",
                        };
                      }
                    } else {
                      if (dis.limit > packageUsed) {
                        packageDiscountOn.push(data.service);
                        discount = {
                          discount: dis.discount,
                          discount_type: "price",
                        };
                      }
                    }
                  }
                }
              });
            }
          }
        }
      }
    }
  }
  return discount;
}

async function packageDiscount(data) {
  var labour_cost = data.labour_cost;
  var lc = data.labour_cost;
  var package = await UserPackage.findOne({ _id: data.package }).exec();
  if (data.claim == false) {
    if (package) {
      if (package.status == true) {
        if (package.car) {
          var packageUsed = await PackageUsed.find({
            package: data.package,
            user: package.user,
            label: data.service,
            car: data.car,
          })
            .count()
            .exec();
        } else {
          var packageUsed = await PackageUsed.find({
            package: data.package,
            user: package.user,
            label: data.service,
          })
            .count()
            .exec();
        }

        var serverTime = moment.tz(new Date(), data.tz);

        var bar = package.created_at;
        bar.setDate(bar.getDate() + package.validity);
        bar = moment.tz(bar, data.tz);
        var baz = bar.diff(serverTime);

        if (baz > 0) {
          package.discount.forEach(async function (dis) {
            if (dis.for == "category") {
              if (dis.label == data.category) {
                if (dis.type == "percent") {
                  if (!packageDiscountOn.includes(data.service)) {
                    labour_cost = lc - lc * (dis.discount / 100);
                  }
                } else if (dis.type == "fixed") {
                  if (!packageDiscountOn.includes(data.service)) {
                    labour_cost = lc - dis.discount;
                  }
                } else {
                  if (!packageDiscountOn.includes(data.service)) {
                    labour_cost = lc - lc * (dis.discount / 100);
                  }
                }
              }
            } else if (dis.for == "specific") {
              if (dis.label == data.service) {
                if (dis.type == "percent") {
                  if (dis.limit > packageUsed) {
                    packageDiscountOn.push(data.service);
                    labour_cost = lc - lc * (dis.discount / 100);
                  }
                } else if (dis.type == "fixed") {
                  if (dis.limit > packageUsed) {
                    packageDiscountOn.push(data.service);
                    labour_cost = dis.discount;
                  }
                } else {
                  if (dis.limit > packageUsed) {
                    packageDiscountOn.push(data.service);
                    labour_cost = lc - dis.discount;
                  }
                }
              }
            }
          });
        }
      } else {
        if (package.booking.equals(data.booking)) {
          var packageUsed = await PackageUsed.find({
            package: data.package,
            user: package.user,
            label: data.service,
            car: data.car,
          })
            .count()
            .exec();
          var serverTime = moment.tz(new Date(), data.tz);

          var bar = package.created_at;
          bar.setDate(bar.getDate() + package.validity);
          bar = moment.tz(bar, data.tz);
          var baz = bar.diff(serverTime);

          if (baz > 0) {
            package.discount.forEach(async function (dis) {
              if (dis.for == "category") {
                if (dis.label == cat) {
                  if (dis.type == "percent") {
                    if (!packageDiscountOn.includes(data.service)) {
                      labour_cost = lc - lc * (dis.discount / 100);
                    }
                  } else if (dis.type == "fixed") {
                    if (!packageDiscountOn.includes(data.service)) {
                      labour_cost = lc - dis.discount;
                    }
                  } else {
                    if (!packageDiscountOn.includes(data.service)) {
                      labour_cost = lc - lc * (dis.discount / 100);
                    }
                  }
                }
              } else if (dis.for == "specific") {
                if (dis.label == data.service) {
                  if (dis.type == "percent") {
                    if (dis.limit > packageUsed) {
                      packageDiscountOn.push(data.service);
                      labour_cost = lc - lc * (dis.discount / 100);
                    }
                  } else if (dis.type == "fixed") {
                    if (dis.limit > packageUsed) {
                      packageDiscountOn.push(data.service);
                      labour_cost = dis.discount;
                    }
                  } else {
                    if (dis.limit > packageUsed) {
                      packageDiscountOn.push(data.service);
                      labour_cost = lc - dis.discount;
                    }
                  }
                }
              }
            });
          }
        }
      }
    }
  }
  return labour_cost;
}

async function packageDeduction(id) {
  var booking = await Booking.findById(id).exec();
  if (booking.package) {
    var packageUsed = [];
    var package = await UserPackage.findOne({
      _id: booking.package,
      car: booking.car,
    }).exec();
    if (package) {
      if (package.status == false) {
        UserPackage.findOneAndUpdate(
          { _id: booking.package },
          { $set: { status: true } },
          async function () {}
        );
      }

      booking.services.forEach(async function (service) {
        package.discount.forEach(async function (dis) {
          if (dis.for == "specific") {
            if (dis.label == service.service) {
              if (dis.discount > 0) {
                packageUsed.push({
                  package: booking.package,
                  car: booking.car,
                  user: booking.user,
                  booking: booking._id,
                  for: service.type,
                  label: service.service,
                  created_at: new Date(),
                  updated_at: new Date(),
                });
              }
            }
          } else if (dis.for == "category") {
            if (dis.label == service.type) {
              packageUsed.push({
                package: booking.package,
                car: booking.car,
                user: booking.user,
                booking: booking._id,
                for: service.type,
                label: service.type,
                created_at: new Date(),
                updated_at: new Date(),
              });
            }
          }
        });
      });

      var packageUsed = _.uniqBy(packageUsed, function (o) {
        return o.label;
      });

      packageUsed.forEach(async function (p) {
        var checkUsedPackage = await PackageUsed.find({
          package: p.package,
          booking: p.booking,
          label: p.label,
        })
          .count()
          .exec();

        if (checkUsedPackage == 0) {
          PackageUsed.create({
            package: p.package,
            car: p.car,
            user: p.user,
            booking: p.booking,
            for: p.for,
            label: p.label,
            created_at: p.created_at,
            updated_at: p.updated_at,
          });
        }
      });
    }
  }
}

async function stockEntry(purchase, product, business) {
  var part_no = product.part_no;
  part_no = part_no.replace(/,/g, ", ");
  part_no = part_no.toUpperCase();

  var businessProduct = await BusinessProduct.findOne({
    part_no: part_no,
    unit: product.unit,
    business: business,
  })
    .sort({ updated_at: -1 })
    .exec();

  var margin_total = 0;
  if (businessProduct) {
    if (businessProduct.price.rate == product.rate) {
      var tax = [];
      var tax_info = await Tax.findOne({
        rate: parseFloat(product.tax_rate),
        type: "GST",
      }).exec();
      var rate = parseFloat(product.rate);
      var amount = parseFloat(product.rate);
      var tax_rate = tax_info.detail;
      var base = amount;

      /*if(product.amount_is_tax=="exclusive")
            {
                var tax_on_amount = amount;
                if(tax_rate.length>0){
                    for(var r=0; r<tax_rate.length; r++)
                    {
                        if(tax_rate[r].rate != tax_info.rate)
                        {
                            var t = tax_on_amount*(tax_rate[r].rate/100);   
                            amount = amount+t;
                            tax.push({
                                tax: tax_rate[r].tax,
                                rate: tax_rate[r].rate,
                                amount: parseFloat(t.toFixed(2))
                            })
                        }
                        else{
                            var t = tax_on_amount*(tax_info.rate/100);   
                            amount = amount+t;
                            tax.push({
                                tax: tax_info.tax,tax_rate: tax_info.rate,
                                rate: tax_info.rate,
                                amount: parseFloat(t.toFixed(2))
                            })
                        }
                    }
                }
            }  */

      if (product.amount_is_tax == "inclusive") {
        var x = (100 + tax_info.rate) / 100;
        var tax_on_amount = amount / x;
        if (tax_rate.length > 0) {
          for (var r = 0; r < tax_rate.length; r++) {
            if (tax_rate[r].rate != tax_info.rate) {
              var t = tax_on_amount * (tax_rate[r].rate / 100);
              base = base - t;
              tax.push({
                tax: tax_rate[r].tax,
                rate: tax_rate[r].rate,
                amount: parseFloat(t.toFixed(2)),
              });
            } else {
              var t = amount - tax_on_amount;
              base = base - t;
              tax.push({
                tax: tax_info.tax,
                rate: tax_info.rate,
                amount: parseFloat(t.toFixed(2)),
              });
            }
          }
        }
      }

      var tax_details = {
        tax: tax_info.tax,
        rate: tax_info.rate,
        amount: amount,
        detail: tax,
      };

      var checkSku = _.filter(
        businessProduct.sku,
        (sku) => sku.sku == product.sku
      );
      if (checkSku.length > 0) {
        var totalSkuStock =
          parseFloat(product.stock) + parseFloat(checkSku[0].total);
        var availSkuStock =
          parseFloat(product.stock) + parseFloat(checkSku[0].available);

        var sku = {
          sku: product.sku,
          total: totalSkuStock,
          available: availSkuStock,
        };
      } else {
        var sku = {
          sku: product.sku,
          total: product.stock,
          available: product.stock,
        };
      }

      var stockTotal =
        parseFloat(businessProduct.stock.total) + parseFloat(product.stock);
      var stockAvailable =
        parseFloat(businessProduct.stock.available) + parseFloat(product.stock);

      var list_type = [];
      list_type = _.concat(businessProduct.list_type, "Offline");
      list_type = _.uniq(list_type);

      var purchases = [];
      purchases = _.concat(businessProduct.purchases, purchase);
      purchases = _.uniq(purchases);

      var data = {
        purchase: purchase,
        purchases: purchases,
        business: business,
        part_no: part_no,
        stock: {
          total: stockTotal,
          consumed: businessProduct.stock.consumed,
          available: stockAvailable,
        },
        sku: sku,
        title: product.title,
        price: {
          mrp: product.mrp,
          rate: product.rate,
          amount: amount,
          sell_price: amount,
          margin: product.margin,
          margin_total: margin_total,
        },
        amount_is_tax: "inclusive",
        tax: tax_info.tax,
        tax_rate: tax_info.rate,
        tax_type: "GST",
        unit: product.unit,
        quantity: product.quantity,
        tax_info: tax_details,
        list_type: list_type,
        updated_at: new Date(),
      };

      BusinessProduct.findOneAndUpdate(
        { _id: businessProduct._id, business: business },
        { $set: data },
        { new: true },
        async function () {
          BusinessProduct.findOneAndUpdate(
            { _id: businessProduct._id, business: business },
            { $pull: { sku: { sku: product.sku } } },
            async function () {}
          );
          BusinessProduct.findOneAndUpdate(
            { _id: businessProduct._id, business: business },
            { $push: { sku: sku } },
            { new: true },
            async function () {}
          );
          return true;
        }
      );
    } else {
      var tax = [];
      var tax_info = await Tax.findOne({
        rate: product.tax_rate,
        type: "GST",
      }).exec();
      var rate = product.rate;
      var amount = product.rate;
      var tax_rate = tax_info.detail;
      var base = amount;
      /*if(product.margin){
                var margin = product.margin;
                margin = margin.toString();
                if(margin.indexOf("%")>=0)
                {
                    margin = parseFloat(margin);
                    if(!isNaN(margin) && margin>0)
                    {
                        margin_total = amount*(margin/100);
                        amount = amount+margin_total
                    }
                }
                else
                {
                    margin_total = parseFloat(margin);
                    amount = amount+margin_total
                }
            }*/

      /*if(product.amount_is_tax=="exclusive")
            {
                var tax_on_amount = amount;
                if(tax_rate.length>0){
                    for(var r=0; r<tax_rate.length; r++)
                    {
                        if(tax_rate[r].rate != tax_info.rate)
                        {
                            var t = tax_on_amount*(tax_rate[r].rate/100);   
                            amount = amount+t;
                            tax.push({
                                tax: tax_rate[r].tax,
                                rate: tax_rate[r].rate,
                                amount: parseFloat(t.toFixed(2))
                            })
                        }
                        else{
                            var t = tax_on_amount*(tax_info.rate/100);   
                            amount = amount+t;
                            tax.push({
                                tax: tax_info.tax,tax_rate: tax_info.rate,
                                rate: tax_info.rate,
                                amount: parseFloat(t.toFixed(2))
                            })
                        }
                    }
                }
            }  */

      if (product.amount_is_tax == "inclusive") {
        var x = (100 + tax_info.rate) / 100;
        var tax_on_amount = amount / x;
        if (tax_rate.length > 0) {
          for (var r = 0; r < tax_rate.length; r++) {
            if (tax_rate[r].rate != tax_info.rate) {
              var t = tax_on_amount * (tax_rate[r].rate / 100);
              base = base - t;
              tax.push({
                tax: tax_rate[r].tax,
                rate: tax_rate[r].rate,
                amount: parseFloat(t.toFixed(2)),
              });
            } else {
              var t = amount - tax_on_amount;
              base = base - t;
              tax.push({
                tax: tax_info.tax,
                rate: tax_info.rate,
                amount: parseFloat(t.toFixed(2)),
              });
            }
          }
        }
      }

      var tax_details = {
        tax: tax_info.tax,
        rate: tax_info.rate,
        amount: amount,
        detail: tax,
      };

      var sku = {
        sku: product.sku,
        total: product.stock,
        available: product.stock,
      };

      var stock = {
        total: product.stock,
        consumed: 0,
        available: product.stock,
      };

      var list_type = [];
      list_type = _.concat(businessProduct.list_type, "Offline");
      list_type = _.uniq(list_type);

      var purchases = [];
      purchases = _.concat(businessProduct.purchases, purchase);
      purchases = _.uniq(purchases);

      var data = {
        purchase: purchase,
        purchases: purchases,
        business: business,
        product: businessProduct.product,
        product_id: businessProduct.product_id,
        part_no: businessProduct.part_no,
        product_brand: businessProduct.product_brand,
        product_model: businessProduct.product_model,
        model: businessProduct.model,
        category: businessProduct.category,
        subcategory: businessProduct.subcategory,
        title: product.title,
        short_description: businessProduct.short_description,
        long_description: businessProduct.long_description,
        thumbnail: businessProduct.thumbnail,
        specification: businessProduct.specification,
        hsn_sac: businessProduct.hsn_sac,
        unit: businessProduct.unit,
        quantity: businessProduct.quantity,
        models: businessProduct.models,
        stock: stock,
        list_type: list_type,
        sku: sku,
        price: {
          mrp: parseFloat(product.mrp),
          rate: parseFloat(product.rate),
          amount: amount,
          sell_price: amount,
          margin: product.margin,
          margin_total: margin_total,
        },
        amount_is_tax: "inclusive",
        tax: tax_info.tax,
        tax_rate: tax_info.rate,
        tax_type: "GST",
        tax_info: tax_details,
        created_at: new Date(),
        updated_at: new Date(),
      };

      BusinessProduct.create(data).then(async function (bp) {});
    }
  } else {
    var tax = [];
    var tax_info = await Tax.findOne({
      rate: parseFloat(product.tax_rate),
      type: "GST",
    }).exec();
    var rate = parseFloat(product.rate);
    var amount = parseFloat(product.rate);
    var tax_rate = tax_info.detail;
    var base = amount;
    /*if(product.margin){
            var margin = product.margin;
            margin = margin.toString();
            if(margin.indexOf("%")>=0)
            {
                margin = parseFloat(margin);
                if(!isNaN(margin) && margin>0)
                {
                    margin_total = amount*(margin/100);
                    amount = amount+margin_total
                }
            }
            else
            {
                margin_total = parseFloat(margin);
                amount = amount+margin_total
            }
        }     */

    /* if(product.amount_is_tax=="exclusive")
         {
             var tax_on_amount = amount;
             if(tax_rate.length>0){
                 for(var r=0; r<tax_rate.length; r++)
                 {
                     if(tax_rate[r].rate != tax_info.rate)
                     {
                         var t = tax_on_amount*(tax_rate[r].rate/100);   
                         amount = amount+t;
                         tax.push({
                             tax: tax_rate[r].tax,
                             rate: tax_rate[r].rate,
                             amount: parseFloat(t.toFixed(2))
                         })
                     }
                     else{
                         var t = tax_on_amount*(tax_info.rate/100);   
                         amount = amount+t;
                         tax.push({
                             tax: tax_info.tax,tax_rate: tax_info.rate,
                             rate: tax_info.rate,
                             amount: parseFloat(t.toFixed(2))
                         })
                     }
                 }
             }
         }*/

    if (product.amount_is_tax == "inclusive") {
      var x = (100 + tax_info.rate) / 100;
      var tax_on_amount = amount / x;
      if (tax_rate.length > 0) {
        for (var r = 0; r < tax_rate.length; r++) {
          if (tax_rate[r].rate != tax_info.rate) {
            var t = tax_on_amount * (tax_rate[r].rate / 100);
            base = base - t;
            tax.push({
              tax: tax_rate[r].tax,
              rate: tax_rate[r].rate,
              amount: parseFloat(t.toFixed(2)),
            });
          } else {
            var t = amount - tax_on_amount;
            base = base - t;
            tax.push({
              tax: tax_info.tax,
              rate: tax_info.rate,
              amount: parseFloat(t.toFixed(2)),
            });
          }
        }
      }
    }

    var tax_details = {
      tax: tax_info.tax,
      rate: tax_info.rate,
      amount: amount,
      detail: tax,
    };

    var sku = {
      sku: product.sku,
      total: product.stock,
      available: product.stock,
    };

    var stock = {
      total: product.stock,
      consumed: 0,
      available: product.stock,
    };

    var list_type = [];
    list_type.push("Offline");

    var purchases = [];
    purchases.push(purchase);

    var data = {
      purchase: purchase,
      purchases: purchases,
      business: business,
      product: null,
      product_id:
        Math.round(+new Date() / 1000) + Math.round(Math.random() * 9999 + 1),
      part_no: part_no,
      product_brand: null,
      product_model: null,
      model: null,
      category: null,
      subcategory: null,
      title: product.title,
      short_description: "",
      long_description: "",
      thumbnail: "",
      specification: "",
      hsn_sac: product.hsn_sac,
      quantity: product.quantity,
      unit: product.unit,
      models: product.models,
      stock: stock,
      sku: sku,
      list_type: list_type,
      price: {
        mrp: product.mrp,
        rate: product.rate,
        amount: amount,
        sell_price: amount,
        margin_total: margin_total,
        margin: product.margin,
      },
      amount_is_tax: "inclusive",
      tax: tax_info.tax,
      tax_rate: tax_info.rate,
      tax_type: "GST",
      tax_info: tax_details,
      list_type: list_type,
      created_at: new Date(),
      updated_at: new Date(),
    };

    BusinessProduct.create(data).then(async function (bp) {
      Purchase.findOneAndUpdate(
        { _id: purchase, items: { $elemMatch: { part_no: product.part_no } } },
        { $set: { "items.$.product": bp._id } },
        { new: false },
        async function (err, doc) {
          if (err) {
            //////console.log(err)
          } else {
            //////console.log(bp._id)
          }
        }
      );
    });
  }
}

async function stockRemove(purchase, product, business) {
  var part_no = product.part_no;
  part_no = part_no.replace(/,/g, ", ");
  part_no = part_no.toUpperCase();
  var businessProduct = await BusinessProduct.findOne({
    purchase: purchase,
    part_no: part_no,
    business: business,
  }).exec();

  var margin_total = 0;
  if (businessProduct) {
    var checkSku = _.filter(
      businessProduct.sku,
      (sku) => sku.sku == product.sku
    );
    if (checkSku.length > 0) {
      var totalSkuStock =
        parseFloat(checkSku[0].total) - parseFloat(product.stock);
      if (totalSkuStock < 0) {
        totalSkuStock = 0;
      }
      var availSkuStock =
        parseFloat(checkSku[0].available) - parseFloat(product.stock);
      if (availSkuStock < 0) {
        availSkuStock = 0;
      }
      var sku = {
        sku: product.sku,
        total: totalSkuStock,
        available: availSkuStock,
      };
    } else {
      var sku = {
        sku: product.sku,
        total: product.stock,
        available: product.stock,
      };
    }

    var stockTotal =
      parseFloat(businessProduct.stock.total) - parseFloat(product.stock);
    if (stockTotal < 0) {
      stockTotal = 0;
    }
    var stockAvailable =
      parseFloat(businessProduct.stock.available) - parseFloat(product.stock);
    if (stockAvailable < 0) {
      stockAvailable = 0;
    }

    var data = {
      stock: {
        total: stockTotal,
        consumed: stockTotal - stockAvailable,
        available: stockAvailable,
      },
      sku: sku,
      updated_at: new Date(),
    };

    BusinessProduct.findOneAndUpdate(
      { _id: businessProduct._id, business: business },
      { $set: data },
      { new: false },
      async function () {
        ////////console.log(data)
        BusinessProduct.findOneAndUpdate(
          { _id: businessProduct._id, business: business },
          { $pull: { sku: { sku: product.sku } } },
          async function () {}
        );
        BusinessProduct.findOneAndUpdate(
          { _id: businessProduct._id, business: business },
          { $push: { sku: sku } },
          { new: true },
          async function () {}
        );
      }
    );
  }
}

async function stockDeduction(product, booking) {
  var businessProduct = await BusinessProduct.findById(product.source).exec();
  if (businessProduct) {
    if (businessProduct.stock.available >= product.quantity) {
      var id = product._id;

      var stockTotal = parseFloat(businessProduct.stock.total);
      var stockAvailable =
        parseFloat(businessProduct.stock.available) - product.quantity;
      var stockConsumed =
        parseFloat(businessProduct.stock.consumed) + product.quantity;

      if (stockAvailable < 0) {
        stockAvailable = 0;
      }

      if (stockConsumed < 0) {
        stockConsumed = 0;
      }

      var stock = {
        total: stockTotal,
        available: stockAvailable,
        consumed: stockConsumed,
      };

      BusinessProduct.findOneAndUpdate(
        { _id: product.source },
        { $set: { stock: stock } },
        { new: false },
        async function (err, doc) {
          if (err) {
            //////console.log(err)
          } else {
            Booking.findOneAndUpdate(
              {
                _id: booking,
                services: {
                  $elemMatch: {
                    parts: {
                      $elemMatch: {
                        _id: id,
                      },
                    },
                  },
                },
              },
              {
                $set: {
                  //"services.$.parts.$[].source": mongoose.Types.ObjectId(source),
                  "services.$.parts.$[].issued": true,
                },
              },
              { new: true },
              async function (err, doc) {
                if (err) {
                  //////console.log(err)
                } else {
                  //////console.log("Success")
                }
              }
            );
          }
        }
      );
    }
  }
}

async function orderItemReturn(product) {
  var businessProduct = await BusinessProduct.findById(product.product).exec();
  if (businessProduct) {
    var stockTotal = parseFloat(businessProduct.stock.total);
    var stockAvailable =
      parseFloat(businessProduct.stock.available) + product.quantity;
    var stockConsumed =
      parseFloat(businessProduct.stock.consumed) - product.quantity;

    if (stockAvailable < 0) {
      stockAvailable = 0;
    } else if (stockAvailable > stockTotal) {
      stockAvailable = stockTotal;
    }

    if (stockConsumed < 0) {
      stockConsumed = 0;
    } else if (stockConsumed > stockTotal) {
      stockConsumed = stockTotal;
    }

    var stock = {
      total: stockTotal,
      available: stockAvailable,
      consumed: stockConsumed,
    };

    BusinessProduct.findOneAndUpdate(
      { _id: businessProduct.id },
      { $set: { stock: stock } },
      { new: false },
      async function (err, doc) {
        if (err) {
          //////console.log(err)
        } else {
          OrderLine.findOneAndUpdate(
            { _id: product._id },
            { $set: { issued: false, status: "Confirmed" } },
            { new: false },
            async function (err, doc) {}
          );
        }
      }
    );
  }

  return true;
}

async function orderItemDeduct(order, business) {
  var bool = false;
  await OrderLine.find({ business: business, order: order })
    .cursor()
    .eachAsync(async (orderLine) => {
      var businessProduct = await BusinessProduct.findById(
        orderLine.product
      ).exec();
      ////console.log("available: "+businessProduct.stock.available+" Required: "+orderLine.quantity)
      if (orderLine.issued == false) {
        if (businessProduct) {
          if (businessProduct.stock.available >= orderLine.quantity) {
            ////console.log("drop")
            var stockTotal = parseFloat(businessProduct.stock.total);
            var stockAvailable =
              parseFloat(businessProduct.stock.available) - orderLine.quantity;
            var stockConsumed =
              parseFloat(businessProduct.stock.consumed) + orderLine.quantity;

            if (stockAvailable < 0) {
              stockAvailable = 0;
            }

            if (stockConsumed < 0) {
              stockConsumed = 0;
            }

            var stock = {
              total: stockTotal,
              available: stockAvailable,
              consumed: stockConsumed,
            };

            BusinessProduct.findOneAndUpdate(
              { _id: orderLine.product },
              { $set: { stock: stock } },
              { new: false },
              async function (err, doc) {
                if (err) {
                  return false;
                } else {
                  OrderLine.findOneAndUpdate(
                    { _id: orderLine._id },
                    { $set: { issued: true } },
                    { new: false },
                    async function (err, doc) {}
                  );
                }
              }
            );
          } else {
            ////console.log("drop no where")
          }
        }
      }
    });

  var not_issued = [];
  var orderLines = await OrderLine.find({
    business: business,
    order: order,
  }).exec();

  var not_issued = _.filter(orderLines, (issued) => issued.issued == false);

  if (not_issued.length == 0) {
    bool = true;
  }

  return bool;
}

async function serviceAdd(data, booking) {
  var booking = await Booking.findById(booking).exec();
  if (booking) {
    var car = await Car.findById(booking.car).populate("model").exec();
    var automaker = await Automaker.findById(car.model.automaker).exec();
    var bookingService = {
      package: data.package,
      automaker: automaker._id,
      _automaker: automaker.maker,
      model: car.model._id,
      _model: car.model.value,
      segment: car.model.segment,
      service: data.service,
      description: data.description,
      parts: data.parts,
      labour: data.labour,
      opening_fitting: data.opening_fitting,
      part_cost: data.part_cost,
      of_cost: data.of_cost,
      labour_cost: data.labour_cost,
      mileage: data.mileage,
      cost: data.labour_cost + data.part_cost,
      mrp: data.mrp,
      type: data.type,
      editable: data.editable,
      labour_cost_editable: data.labour_cost_editable,
      part_cost_editable: data.part_cost_editable,
      of_cost_editable: data.of_cost_editable,
      publish: false,
    };
    if (data.type == "services") {
      Service.create(bookingService);
    } else if (data.type == "collision") {
      Collision.create(bookingService);
    } else if (data.type == "detailing") {
      Detailing.create(bookingService);
    } else if (data.type == "customization") {
      Customization.create(bookingService);
    }
  }
}

async function getAdvisor(user, business) {
  var advisor = business;
  var role = await Management.findOne({
    user: user,
    business: business,
  }).exec();
  if (role.role == "Service Advisor") {
    advisor = role.user;
  } else {
    var advisorBooking = [];
    await Management.find({ business: business, role: "Service Advisor" })
      .cursor()
      .eachAsync(async (a) => {
        var d = await Booking.find({ business: business, advisor: a.user })
          .count()
          .exec();
        advisorBooking.push({
          user: a.user,
          count: d,
        });
      });

    if (advisorBooking.length != 0) {
      advisorBooking.sort(function (a, b) {
        return a.count > b.count;
      });

      advisor = advisorBooking[0].user;
    } else {
      advisor = role.business;
    }
  }

  return advisor;
}

async function getUser(data) {
  if (data.name != "" && data.contact_no != "") {
    var user = await User.findOne({
      contact_no: data.contact_no,
      "account_info.type": "user",
    }).exec();
    if (user) {
      return user._id;
    } else {
      var name = data.name;
      var rand = Math.ceil(Math.random() * 100000 + 1);
      var id = mongoose.Types.ObjectId();

      var firstPart = (Math.random() * 46656) | 0;
      var secondPart = (Math.random() * 46656) | 0;
      firstPart = ("000" + firstPart.toString(36)).slice(-3);
      secondPart = ("000" + secondPart.toString(36)).slice(-3);
      var referral_code = firstPart.toUpperCase() + secondPart.toUpperCase();

      User.create({
        _id: id,
        name: data.name,
        rand: Math.floor(Math.random() * 100000 + 1),
        username: shortid.generate(),
        referral_code: referral_code,
        geometry: [0, 0],
        device: [],
        otp: Math.floor(Math.random() * 90000) + 10000,
        careager_cash: 0,
        socialite: "",
        optional_info: "",
        business_info: "",
        name: _.startCase(_.toLower(data.name)),
        email: data.email,
        optional_info: {},
        business_info: {},
        uuid: uuidv1(),
        contact_no: data.contact_no,
        uuid: uuidv1(),
        account_info: {
          type: "user",
          status: "Complete",
        },
        address: {
          country: "India",
          timezone: "Asia/Kolkata",
          location: "",
        },
      }).then(async function (u) {
        event.signupSMS(u);
        //event.otpSms(u);
      });

      return id;
    }
  } else {
    return false;
  }
}

async function getCar(data) {
  var rg = data.registration_no;
  var reg_no_copy = rg.replace(/ /g, "");
  var car = await Car.findOne({
    registration_no: reg_no_copy,
    status: true,
  }).exec();
  if (car) {
    return car._id;
  } else {
    var variant = await Variant.findOne({ _id: data.variant })
      .populate("model")
      .select("-service_schedule")
      .exec();
    if (variant) {
      var reg = await Car.find({ registration_no: reg_no_copy, status: true })
        .count()
        .exec();
      if (reg == 0) {
        var id = mongoose.Types.ObjectId();
        var automaker = await Automaker.findById(
          variant.model.automaker
        ).exec();
        //////////console.log(id)
        Car.create({
          _id: id,
          geometry: [0, 0],
          registration_no: reg_no_copy,
          reg_no_copy: reg_no_copy,
          title: variant.variant,
          variant: variant._id,
          _variant: variant.value,
          automaker: variant.model.automaker,
          _automaker: automaker.maker,
          model: variant.model._id,
          _model: variant.model.value,
          segment: variant.model.segment,
          user: data.user,
          fuel_type: variant.specification.fuel_type,
          transmission: variant.specification.type,
          carId:
            Math.round(new Date() / 1000) +
            Math.round(Math.random() * 9999 + 1),
          created_at: new Date(),
          updated_at: new Date(),
        });

        return id;
      } else {
        return false;
      }
    }
  }
}

router.post(
  "/packages/get",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    var user = decoded.user;

    if (req.headers["business"]) {
      user = req.headers["business"];
    }

    var packages = [];

    if (req.body.car == "") {
      req.body.car = null;
    }

    await UserPackage.find({ user: user, car: req.body.car })
      .cursor()
      .eachAsync(async (package) => {
        var serverTime = moment.tz(new Date(), req.headers["tz"]);
        var bar = package.created_at;
        bar.setDate(bar.getDate() + package.validity);
        var e = bar;
        bar = moment.tz(bar, req.headers["tz"]);

        var baz = bar.diff(serverTime);
        if (baz > 0) {
          packages.push({
            package: package._id,
            name: package.name,
            description: package.description,
            payment: package.payment,
            discount: package.discount,
            type: "package",
            cost: package.cost,
            id: package._id,
            _id: package._id,
            category: package.category,
            label: package.label,
            validity: package.validity,
            expired_at: moment(e).tz(req.headers["tz"]).format("ll"),
          });
        }
      });

    await UserPackage.find({ user: user, car: null })
      .cursor()
      .eachAsync(async (package) => {
        var serverTime = moment.tz(new Date(), req.headers["tz"]);
        var bar = package.created_at;
        bar.setDate(bar.getDate() + package.validity);
        var e = bar;
        bar = moment.tz(bar, req.headers["tz"]);

        var baz = bar.diff(serverTime);
        if (baz > 0) {
          packages.push({
            package: package._id,
            name: package.name,
            description: package.description,
            payment: package.payment,
            discount: package.discount,
            type: "package",
            cost: package.cost,
            id: package._id,
            _id: package._id,
            category: package.category,
            label: package.label,
            validity: package.validity,
            expired_at: moment(e).tz(req.headers["tz"]).format("ll"),
          });
        }
      });

    res.status(200).json({
      responseCode: 200,
      responseMessage: "",
      responseData: packages,
    });
  }
);

router.post(
  "/booking/business/get",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      car: "required",
      isCarEager: "required",
      latitude: "required",
      longitude: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Error",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var user = decoded.user;

      if (req.headers["business"]) {
        user = req.headers["business"];
      }

      var bookingService = [];

      if (req.body.isCarEager == true) {
        var user = await User.find({ isCarEager: true })
          .select(
            "name username avatar avatar_address gender business_info account_info address"
          )
          .sort({ created_at: -1 })
          .exec();

        res.status(200).json({
          responseCode: 200,
          responseMessage: "",
          responseData: user,
        });
      } else {
        var car = await Car.findOne({ _id: req.body.car, user: user }).populate(
          { path: "model", populate: { path: "automaker" } }
        );
        if (car) {
          var company = car.model.automaker.maker;
          var user = await User.find({
            geometry: {
              $near: [
                parseFloat(req.body.longitude),
                parseFloat(req.body.latitude),
              ],
              $maxDistance: 1000,
            },
            "business_info.business_category":
              "Service Station (Authorised)" /*"business_info.company": company*/,
          })
            .select(
              "name username avatar avatar_address gender business_info account_info address"
            )
            .exec();

          res.status(200).json({
            responseCode: 200,
            responseMessage: "",
            responseData: user,
          });
        } else {
          res.status(400).json({
            responseCode: 400,
            responseMessage: "Unauthorized",
            responseData: {},
          });
        }
      }
    }
  }
);

router.get(
  "/booking/category/feature/get",
  xAccessToken.token,
  async function (req, res, next) {
    var variant = await Variant.findOne({ _id: car.variant }).exec();
    var carLength = parseInt(variant.specification.length);

    res.status(200).json({
      responseCode: 200,
      responseMessage: "",
      responseData: await BookingCategory.find({ tag: req.query.tag }).exec(),
    });
  }
);

router.post(
  "/booking/services/get",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      car: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Please select a car",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var user = decoded.user;

      if (req.headers["business"]) {
        user = req.headers["business"];
      }

      var packages = [];

      if (!req.body.package) {
        req.body.package = null;
      }

      var business = null;
      if (req.body.business) {
        business = req.body.business;
      }

      var car = await Car.findOne({ _id: req.body.car, user: user })
        .populate("model")
        .exec();
      if (car) {
        if (req.body.type == "services") {
          await Service.find({
            business: business,
            segment: car.model.segment,
            part_cost: 0,
            publish: true,
            business: business,
          })
            .cursor()
            .eachAsync(async (service) => {
              var labels = [];

              labels.push(service.type);
              labels.push(service.service);
              var coupons = await Coupon.find({
                label: { $in: labels },
                expired_at: { $gte: new Date() },
                physical: false,
              }).exec();

              var gallery = service.gallery;
              var getDiscount = {
                package: req.body.package,
                car: req.body.car,
                category: service.type,
                service: service.service,
                tz: req.headers["tz"],
                claim: false,
              };

              var package = await q.all(getPackageDiscount(getDiscount));
              var labour_list = service.labour;
              var labours = [];

              var discount_eligible_labour_cost = _.sumBy(
                labour_list,
                (x) => x.amount
              );
              if (labour_list.length > 0) {
                for (var l = 0; l < labour_list.length; l++) {
                  var quantity = 1;
                  if (labour_list[l].quantity) {
                    quantity = labour_list[l].quantity;
                  }

                  var discount_total = 0;
                  var total = 0;
                  var tax_info = await Tax.findOne({
                    tax: labour_list[l].tax,
                  }).exec();

                  var tax = [];
                  var rate = labour_list[l].rate;
                  var amount = parseFloat(labour_list[l].amount);
                  var tax_rate = tax_info.detail;
                  var base = amount;

                  if (Object.keys(package).length > 0) {
                    if (package.discount_type == "percent") {
                      discount = parseFloat(package.discount);
                      if (!isNaN(discount) && discount > 0) {
                        var discount_total = amount * (discount / 100);
                        amount = amount - parseFloat(discount_total.toFixed(2));
                        if (amount < 0) {
                          amount = 0;
                        }
                      }
                    } else if (package.discount_type == "fixed") {
                      discount = parseFloat(package.discount);
                      if (!isNaN(discount) && discount > 0) {
                        var discount_total =
                          (amount / discount_eligible_labour_cost) * discount;
                        amount = parseFloat(discount_total.toFixed(2));
                        discount = amount - discount_total;
                        if (amount < 0) {
                          amount = 0;
                        }
                      }
                    } else {
                      discount = parseFloat(package.discount);
                      if (!isNaN(discount) && discount > 0) {
                        var discount_total =
                          (amount / discount_eligible_labour_cost) * discount;
                        amount = amount - parseFloat(discount_total.toFixed(2));
                        if (amount < 0) {
                          amount = 0;
                        }
                      }
                    }
                  }

                  if (labour_list[l].amount_is_tax == "inclusive") {
                    var x = (100 + tax_info.rate) / 100;
                    var tax_on_amount = amount / x;
                    if (tax_rate.length > 0) {
                      for (var r = 0; r < tax_rate.length; r++) {
                        if (tax_rate[r].rate != tax_info.rate) {
                          var t = tax_on_amount * (tax_rate[r].rate / 100);
                          base = base - t;
                          tax.push({
                            tax: tax_rate[r].tax,
                            rate: tax_rate[r].rate,
                            amount: parseFloat(t.toFixed(2)),
                          });
                        } else {
                          var t = amount - tax_on_amount;
                          base = base - t;
                          tax.push({
                            tax: tax_info.tax,
                            tax_rate: tax_info.rate,
                            rate: tax_info.rate,
                            amount: parseFloat(t.toFixed(2)),
                          });
                        }
                      }

                      //base = base - discount_total;
                    }
                    total = total + amount;
                  }

                  var tax_details = {
                    tax: tax_info.tax,
                    rate: tax_info.rate,
                    amount: total,
                    detail: tax,
                  };

                  labours.push({
                    item: labour_list[l].item,
                    source: labour_list[l].source,
                    rate: parseFloat(labour_list[l].rate),
                    quantity: 1,
                    base: parseFloat(total.toFixed(2)),
                    discount: parseFloat(discount_total.toFixed(2)),
                    amount: total,
                    customer_dep: 100,
                    insurance_dep: 0,
                    tax_amount: parseFloat(
                      _.sumBy(tax, (x) => x.amount).toFixed(2)
                    ),
                    amount_is_tax: labour_list[l].amount_is_tax,
                    tax: tax_info.tax,
                    tax_rate: tax_info.rate,
                    tax_info: tax_details,
                  });
                }
              }

              if (service.opening_fitting.length != 0) {
                service.opening_fitting[0].customer_dep = 100;
                service.opening_fitting[0].insurance_dep = 0;
              }

              if (service.parts.length != 0) {
                service.parts[0].customer_dep = 100;
                service.parts[0].insurance_dep = 0;
              }

              packages.push({
                package: service.package,
                service: service.service,
                labour: labours,
                labour_cost: _.sumBy(labours, (x) => x.amount),
                parts: service.parts,
                part_cost: Math.ceil(service.part_cost),
                opening_fitting: service.opening_fitting,
                of_cost: Math.ceil(service.of_cost),
                exceeded_cost: 0,
                mrp:
                  _.sumBy(labours, (x) => x.amount) +
                  _.sumBy(labours, (x) => x.amount) * (40 / 100),
                cost:
                  Math.ceil(service.part_cost) +
                  _.sumBy(labours, (x) => x.amount) +
                  service.of_cost,
                doorstep: service.doorstep,
                unit: service.unit,
                quantity: service.quantity,
                part_cost_editable: service.part_cost_editable,
                labour_cost_editable: service.labour_cost_editable,
                of_cost_editable: service.of_cost_editable,
                type: service.type,
                source: service.id,
                gallery: gallery.length,
                description: service.description,
                coupons: coupons,
                id: service.id,
                _id: service._id,
              });
            });

          await Service.find({
            business: business,
            model: car.model._id,
            publish: true,
            business: business,
          })
            .cursor()
            .eachAsync(async (service) => {
              var labels = [];

              labels.push(service.type);
              labels.push(service.service);
              var coupons = await Coupon.find({
                label: { $in: labels },
                expired_at: { $gte: new Date() },
                physical: false,
              }).exec();

              var gallery = service.gallery;
              var getDiscount = {
                package: req.body.package,
                car: req.body.car,
                category: service.type,
                service: service.service,
                tz: req.headers["tz"],
                claim: false,
              };

              var package = await q.all(getPackageDiscount(getDiscount));
              var labour_list = service.labour;
              var labours = [];

              var discount_eligible_labour_cost = _.sumBy(
                labour_list,
                (x) => x.amount
              );
              if (labour_list.length > 0) {
                for (var l = 0; l < labour_list.length; l++) {
                  var quantity = 1;
                  if (labour_list[l].quantity) {
                    quantity = labour_list[l].quantity;
                  }

                  var discount_total = 0;
                  var total = 0;
                  var tax_info = await Tax.findOne({
                    tax: labour_list[l].tax,
                  }).exec();

                  var tax = [];
                  var rate = labour_list[l].rate;
                  var amount = parseFloat(labour_list[l].amount);
                  var tax_rate = tax_info.detail;
                  var base = amount;

                  if (Object.keys(package).length > 0) {
                    if (package.discount_type == "percent") {
                      discount = parseFloat(package.discount);
                      if (!isNaN(discount) && discount > 0) {
                        var discount_total = amount * (discount / 100);
                        amount = amount - parseFloat(discount_total.toFixed(2));
                        if (amount < 0) {
                          amount = 0;
                        }
                      }
                    } else if (package.discount_type == "fixed") {
                      discount = parseFloat(package.discount);
                      if (!isNaN(discount) && discount > 0) {
                        var discount_total =
                          (amount / discount_eligible_labour_cost) * discount;
                        amount = parseFloat(discount_total.toFixed(2));
                        discount = amount - discount_total;
                        if (amount < 0) {
                          amount = 0;
                        }
                      }
                    } else {
                      discount = parseFloat(package.discount);
                      if (!isNaN(discount) && discount > 0) {
                        var discount_total =
                          (amount / discount_eligible_labour_cost) * discount;
                        amount = amount - parseFloat(discount_total.toFixed(2));
                        if (amount < 0) {
                          amount = 0;
                        }
                      }
                    }
                  }

                  if (labour_list[l].amount_is_tax == "inclusive") {
                    var x = (100 + tax_info.rate) / 100;
                    var tax_on_amount = amount / x;
                    if (tax_rate.length > 0) {
                      for (var r = 0; r < tax_rate.length; r++) {
                        if (tax_rate[r].rate != tax_info.rate) {
                          var t = tax_on_amount * (tax_rate[r].rate / 100);
                          base = base - t;
                          tax.push({
                            tax: tax_rate[r].tax,
                            rate: tax_rate[r].rate,
                            amount: parseFloat(t.toFixed(2)),
                          });
                        } else {
                          var t = amount - tax_on_amount;
                          base = base - t;
                          tax.push({
                            tax: tax_info.tax,
                            tax_rate: tax_info.rate,
                            rate: tax_info.rate,
                            amount: parseFloat(t.toFixed(2)),
                          });
                        }
                      }

                      //base = base - discount_total;
                    }
                    total = total + amount;
                  }

                  var tax_details = {
                    tax: tax_info.tax,
                    rate: tax_info.rate,
                    amount: total,
                    detail: tax,
                  };

                  labours.push({
                    item: labour_list[l].item,
                    source: labour_list[l].source,
                    rate: parseFloat(labour_list[l].rate),
                    quantity: 1,
                    base: parseFloat(total.toFixed(2)),
                    discount: parseFloat(discount_total.toFixed(2)),
                    amount: total,
                    customer_dep: 100,
                    insurance_dep: 0,
                    tax_amount: parseFloat(
                      _.sumBy(tax, (x) => x.amount).toFixed(2)
                    ),
                    amount_is_tax: labour_list[l].amount_is_tax,
                    tax: tax_info.tax,
                    tax_rate: tax_info.rate,
                    tax_info: tax_details,
                  });
                }
              }

              if (service.opening_fitting.length != 0) {
                service.opening_fitting[0].customer_dep = 100;
                service.opening_fitting[0].insurance_dep = 0;
              }

              if (service.parts.length != 0) {
                service.parts[0].customer_dep = 100;
                service.parts[0].insurance_dep = 0;
              }

              packages.push({
                package: service.package,
                service: service.service,
                labour: labours,
                labour_cost: _.sumBy(labours, (x) => x.amount),
                parts: service.parts,
                part_cost: Math.ceil(service.part_cost),
                opening_fitting: service.opening_fitting,
                of_cost: Math.ceil(service.of_cost),
                exceeded_cost: 0,
                mrp:
                  _.sumBy(labours, (x) => x.amount) +
                  _.sumBy(labours, (x) => x.amount) * (40 / 100),
                cost:
                  Math.ceil(service.part_cost) +
                  _.sumBy(labours, (x) => x.amount) +
                  service.of_cost,
                doorstep: service.doorstep,
                unit: service.unit,
                quantity: service.quantity,
                part_cost_editable: service.part_cost_editable,
                labour_cost_editable: service.labour_cost_editable,
                of_cost_editable: service.of_cost_editable,
                type: service.type,
                source: service.id,
                gallery: gallery.length,
                description: service.description,
                coupons: coupons,
                id: service.id,
                _id: service._id,
              });
            });

          packages = _(packages)
            .groupBy((x) => x.package)
            .map((value, key) => ({ package: key, services: value }))
            .value();

          res.status(200).json({
            responseCode: 200,
            responseMessage:
              "Please hold on, we're about to update the database of discontinued cars.",
            responseData: packages,
          });
        }

        if (req.body.type == "collision") {
          await Collision.find({
            business: business,
            segment: car.model.segment,
            publish: true,
            business: business,
          })
            .cursor()
            .eachAsync(async (service) => {
              var labels = [];

              labels.push(service.type);
              labels.push(service.service);
              var coupons = await Coupon.find({
                label: { $in: labels },
                expired_at: { $gte: new Date() },
                physical: false,
              }).exec();

              var getDiscount = {
                package: req.body.package,
                car: req.body.car,
                category: service.type,
                service: service.service,
                tz: req.headers["tz"],
                claim: false,
              };

              var package = await q.all(getPackageDiscount(getDiscount));
              var labour_list = service.labour;
              var labours = [];

              var discount_eligible_labour_cost = _.sumBy(
                labour_list,
                (x) => x.amount
              );
              if (labour_list.length > 0) {
                for (var l = 0; l < labour_list.length; l++) {
                  var quantity = 1;
                  if (labour_list[l].quantity) {
                    quantity = labour_list[l].quantity;
                  }

                  var discount_total = 0;
                  var total = 0;
                  var tax_info = await Tax.findOne({
                    tax: labour_list[l].tax,
                  }).exec();

                  var tax = [];
                  var rate = labour_list[l].rate;
                  var amount = parseFloat(labour_list[l].amount);
                  var tax_rate = tax_info.detail;
                  var base = amount;

                  if (Object.keys(package).length > 0) {
                    if (package.discount_type == "percent") {
                      discount = parseFloat(package.discount);
                      if (!isNaN(discount) && discount > 0) {
                        var discount_total = amount * (discount / 100);
                        amount = amount - parseFloat(discount_total.toFixed(2));
                        if (amount < 0) {
                          amount = 0;
                        }
                      }
                    } else if (package.discount_type == "fixed") {
                      discount = parseFloat(package.discount);
                      if (!isNaN(discount) && discount > 0) {
                        var discount_total =
                          (amount / discount_eligible_labour_cost) * discount;
                        amount = parseFloat(discount_total.toFixed(2));
                        discount = amount - discount_total;
                        if (amount < 0) {
                          amount = 0;
                        }
                      }
                    } else {
                      discount = parseFloat(package.discount);
                      if (!isNaN(discount) && discount > 0) {
                        var discount_total =
                          (amount / discount_eligible_labour_cost) * discount;
                        amount = amount - parseFloat(discount_total.toFixed(2));
                        if (amount < 0) {
                          amount = 0;
                        }
                      }
                    }
                  }

                  if (labour_list[l].amount_is_tax == "inclusive") {
                    var x = (100 + tax_info.rate) / 100;
                    var tax_on_amount = amount / x;
                    if (tax_rate.length > 0) {
                      for (var r = 0; r < tax_rate.length; r++) {
                        if (tax_rate[r].rate != tax_info.rate) {
                          var t = tax_on_amount * (tax_rate[r].rate / 100);
                          base = base - t;
                          tax.push({
                            tax: tax_rate[r].tax,
                            rate: tax_rate[r].rate,
                            amount: parseFloat(t.toFixed(2)),
                          });
                        } else {
                          var t = amount - tax_on_amount;
                          base = base - t;
                          tax.push({
                            tax: tax_info.tax,
                            tax_rate: tax_info.rate,
                            rate: tax_info.rate,
                            amount: parseFloat(t.toFixed(2)),
                          });
                        }
                      }

                      //base = base - discount_total;
                    }
                    total = total + amount;
                  }

                  var tax_details = {
                    tax: tax_info.tax,
                    rate: tax_info.rate,
                    amount: total,
                    detail: tax,
                  };

                  labours.push({
                    item: labour_list[l].item,
                    source: labour_list[l].source,
                    rate: parseFloat(labour_list[l].rate),
                    quantity: 1,
                    base: parseFloat(total.toFixed(2)),
                    discount: parseFloat(discount_total.toFixed(2)),
                    amount: total,
                    customer_dep: 100,
                    insurance_dep: 0,
                    tax_amount: parseFloat(
                      _.sumBy(tax, (x) => x.amount).toFixed(2)
                    ),
                    amount_is_tax: labour_list[l].amount_is_tax,
                    tax: tax_info.tax,
                    tax_rate: tax_info.rate,
                    tax_info: tax_details,
                  });
                }
              }

              if (service.opening_fitting.length != 0) {
                service.opening_fitting[0].customer_dep = 100;
                service.opening_fitting[0].insurance_dep = 0;
              }

              if (service.parts.length != 0) {
                service.parts[0].customer_dep = 100;
                service.parts[0].insurance_dep = 0;
              }

              packages.push({
                package: service.package,
                service: service.service,
                labour: labours,
                labour_cost: _.sumBy(labours, (x) => x.amount),
                parts: service.parts,
                part_cost: Math.ceil(service.part_cost),
                opening_fitting: service.opening_fitting,
                of_cost: Math.ceil(service.of_cost),
                exceeded_cost: 0,
                mrp:
                  _.sumBy(labours, (x) => x.amount) +
                  _.sumBy(labours, (x) => x.amount) * (40 / 100),
                cost:
                  Math.ceil(service.part_cost) +
                  _.sumBy(labours, (x) => x.amount) +
                  service.of_cost,
                doorstep: service.doorstep,
                unit: service.unit,
                quantity: service.quantity,
                part_cost_editable: service.part_cost_editable,
                labour_cost_editable: service.labour_cost_editable,
                of_cost_editable: service.of_cost_editable,
                type: service.type,
                source: service.id,
                gallery: 0,
                description: service.description,
                coupons: coupons,
                id: service.id,
                _id: service._id,
              });
            });

          packages = _(packages)
            .groupBy((x) => x.package)
            .map((value, key) => ({ package: key, services: value }))
            .value();

          res.status(200).json({
            responseCode: 200,
            responseMessage:
              "Please hold on, we're about to update the database of discontinued cars.",
            responseData: packages,
          });
        } else if (req.body.type == "detailing") {
          await Detailing.find({
            business: business,
            segment: car.model.segment,
            publish: true,
            business: business,
          })
            .cursor()
            .eachAsync(async (service) => {
              var labels = [];

              labels.push(service.type);
              labels.push(service.service);
              var coupons = await Coupon.find({
                label: { $in: labels },
                expired_at: { $gte: new Date() },
                physical: false,
              }).exec();

              var gallery = service.gallery;
              var getDiscount = {
                package: req.body.package,
                car: req.body.car,
                category: service.type,
                service: service.service,
                tz: req.headers["tz"],
                claim: false,
              };

              var package = await q.all(getPackageDiscount(getDiscount));
              var labour_list = service.labour;
              var labours = [];

              var discount_eligible_labour_cost = _.sumBy(
                labour_list,
                (x) => x.amount
              );
              if (labour_list.length > 0) {
                for (var l = 0; l < labour_list.length; l++) {
                  var quantity = 1;
                  if (labour_list[l].quantity) {
                    quantity = labour_list[l].quantity;
                  }

                  var discount_total = 0;
                  var total = 0;
                  var tax_info = await Tax.findOne({
                    tax: labour_list[l].tax,
                  }).exec();

                  var tax = [];
                  var rate = labour_list[l].rate;
                  var amount = parseFloat(labour_list[l].amount);
                  var tax_rate = tax_info.detail;
                  var base = amount;

                  if (Object.keys(package).length > 0) {
                    if (package.discount_type == "percent") {
                      discount = parseFloat(package.discount);
                      if (!isNaN(discount) && discount > 0) {
                        var discount_total = amount * (discount / 100);
                        amount = amount - parseFloat(discount_total.toFixed(2));
                        if (amount < 0) {
                          amount = 0;
                        }
                      }
                    } else if (package.discount_type == "fixed") {
                      discount = parseFloat(package.discount);
                      if (!isNaN(discount) && discount > 0) {
                        var discount_total =
                          (amount / discount_eligible_labour_cost) * discount;
                        amount = parseFloat(discount_total.toFixed(2));
                        discount = amount - discount_total;
                        if (amount < 0) {
                          amount = 0;
                        }
                      }
                    } else {
                      discount = parseFloat(package.discount);
                      if (!isNaN(discount) && discount > 0) {
                        var discount_total =
                          (amount / discount_eligible_labour_cost) * discount;
                        amount = amount - parseFloat(discount_total.toFixed(2));
                        if (amount < 0) {
                          amount = 0;
                        }
                      }
                    }
                  }

                  if (labour_list[l].amount_is_tax == "inclusive") {
                    var x = (100 + tax_info.rate) / 100;
                    var tax_on_amount = amount / x;
                    if (tax_rate.length > 0) {
                      for (var r = 0; r < tax_rate.length; r++) {
                        if (tax_rate[r].rate != tax_info.rate) {
                          var t = tax_on_amount * (tax_rate[r].rate / 100);
                          base = base - t;
                          tax.push({
                            tax: tax_rate[r].tax,
                            rate: tax_rate[r].rate,
                            amount: parseFloat(t.toFixed(2)),
                          });
                        } else {
                          var t = amount - tax_on_amount;
                          base = base - t;
                          tax.push({
                            tax: tax_info.tax,
                            tax_rate: tax_info.rate,
                            rate: tax_info.rate,
                            amount: parseFloat(t.toFixed(2)),
                          });
                        }
                      }

                      //base = base - discount_total;
                    }
                    total = total + amount;
                  }

                  var tax_details = {
                    tax: tax_info.tax,
                    rate: tax_info.rate,
                    amount: total,
                    detail: tax,
                  };

                  labours.push({
                    item: labour_list[l].item,
                    source: labour_list[l].source,
                    rate: parseFloat(labour_list[l].rate),
                    quantity: 1,
                    base: parseFloat(total.toFixed(2)),
                    discount: parseFloat(discount_total.toFixed(2)),
                    amount: total,
                    customer_dep: 100,
                    insurance_dep: 0,
                    tax_amount: parseFloat(
                      _.sumBy(tax, (x) => x.amount).toFixed(2)
                    ),
                    amount_is_tax: labour_list[l].amount_is_tax,
                    tax: tax_info.tax,
                    tax_rate: tax_info.rate,
                    tax_info: tax_details,
                  });
                }
              }

              if (service.opening_fitting.length != 0) {
                service.opening_fitting[0].customer_dep = 100;
                service.opening_fitting[0].insurance_dep = 0;
              }

              if (service.parts.length != 0) {
                service.parts[0].customer_dep = 100;
                service.parts[0].insurance_dep = 0;
              }

              packages.push({
                package: service.package,
                service: service.service,
                labour: labours,
                labour_cost: _.sumBy(labours, (x) => x.amount),
                parts: service.parts,
                part_cost: Math.ceil(service.part_cost),
                opening_fitting: service.opening_fitting,
                of_cost: Math.ceil(service.of_cost),
                exceeded_cost: 0,
                mrp:
                  _.sumBy(labours, (x) => x.amount) +
                  _.sumBy(labours, (x) => x.amount) * (40 / 100),
                cost:
                  Math.ceil(service.part_cost) +
                  _.sumBy(labours, (x) => x.amount) +
                  service.of_cost,
                doorstep: service.doorstep,
                unit: service.unit,
                quantity: service.quantity,
                part_cost_editable: service.part_cost_editable,
                labour_cost_editable: service.labour_cost_editable,
                of_cost_editable: service.of_cost_editable,
                type: service.type,
                source: service.id,
                gallery: gallery.length,
                description: service.description,
                coupons: coupons,
                id: service.id,
                _id: service._id,
              });
            });

          packages = _(packages)
            .groupBy((x) => x.package)
            .map((value, key) => ({ package: key, services: value }))
            .value();

          res.status(200).json({
            responseCode: 200,
            responseMessage:
              "Please hold on, we're about to update the database of discontinued cars.",
            responseData: packages,
          });
        } else if (req.body.type == "customization") {
          await Customization.find({
            business: business,
            segment: car.model.segment,
            publish: true,
            business: business,
          })
            .cursor()
            .eachAsync(async (service) => {
              var labels = [];

              labels.push(service.type);
              labels.push(service.service);
              var coupons = await Coupon.find({
                label: { $in: labels },
                expired_at: { $gte: new Date() },
                physical: false,
              }).exec();

              var getDiscount = {
                package: req.body.package,
                car: req.body.car,
                category: service.type,
                service: service.service,
                tz: req.headers["tz"],
                claim: false,
              };

              var package = await q.all(getPackageDiscount(getDiscount));
              var labour_list = service.labour;
              var labours = [];

              var discount_eligible_labour_cost = _.sumBy(
                labour_list,
                (x) => x.amount
              );
              if (labour_list.length > 0) {
                for (var l = 0; l < labour_list.length; l++) {
                  var quantity = 1;
                  if (labour_list[l].quantity) {
                    quantity = labour_list[l].quantity;
                  }

                  var discount_total = 0;
                  var total = 0;
                  var tax_info = await Tax.findOne({
                    tax: labour_list[l].tax,
                  }).exec();

                  var tax = [];
                  var rate = labour_list[l].rate;
                  var amount = parseFloat(labour_list[l].amount);
                  var tax_rate = tax_info.detail;
                  var base = amount;

                  if (Object.keys(package).length > 0) {
                    if (package.discount_type == "percent") {
                      discount = parseFloat(package.discount);
                      if (!isNaN(discount) && discount > 0) {
                        var discount_total = amount * (discount / 100);
                        amount = amount - parseFloat(discount_total.toFixed(2));
                        if (amount < 0) {
                          amount = 0;
                        }
                      }
                    } else if (package.discount_type == "fixed") {
                      discount = parseFloat(package.discount);
                      if (!isNaN(discount) && discount > 0) {
                        var discount_total =
                          (amount / discount_eligible_labour_cost) * discount;
                        amount = parseFloat(discount_total.toFixed(2));
                        discount = amount - discount_total;
                        if (amount < 0) {
                          amount = 0;
                        }
                      }
                    } else {
                      discount = parseFloat(package.discount);
                      if (!isNaN(discount) && discount > 0) {
                        var discount_total =
                          (amount / discount_eligible_labour_cost) * discount;
                        amount = amount - parseFloat(discount_total.toFixed(2));
                        if (amount < 0) {
                          amount = 0;
                        }
                      }
                    }
                  }

                  if (labour_list[l].amount_is_tax == "inclusive") {
                    var x = (100 + tax_info.rate) / 100;
                    var tax_on_amount = amount / x;
                    if (tax_rate.length > 0) {
                      for (var r = 0; r < tax_rate.length; r++) {
                        if (tax_rate[r].rate != tax_info.rate) {
                          var t = tax_on_amount * (tax_rate[r].rate / 100);
                          base = base - t;
                          tax.push({
                            tax: tax_rate[r].tax,
                            rate: tax_rate[r].rate,
                            amount: parseFloat(t.toFixed(2)),
                          });
                        } else {
                          var t = amount - tax_on_amount;
                          base = base - t;
                          tax.push({
                            tax: tax_info.tax,
                            tax_rate: tax_info.rate,
                            rate: tax_info.rate,
                            amount: parseFloat(t.toFixed(2)),
                          });
                        }
                      }

                      //base = base - discount_total;
                    }
                    total = total + amount;
                  }

                  var tax_details = {
                    tax: tax_info.tax,
                    rate: tax_info.rate,
                    amount: total,
                    detail: tax,
                  };

                  labours.push({
                    item: labour_list[l].item,
                    source: labour_list[l].source,
                    rate: parseFloat(labour_list[l].rate),
                    quantity: 1,
                    base: parseFloat(total.toFixed(2)),
                    discount: parseFloat(discount_total.toFixed(2)),
                    amount: total,
                    customer_dep: 100,
                    insurance_dep: 0,
                    tax_amount: parseFloat(
                      _.sumBy(tax, (x) => x.amount).toFixed(2)
                    ),
                    amount_is_tax: labour_list[l].amount_is_tax,
                    tax: tax_info.tax,
                    tax_rate: tax_info.rate,
                    tax_info: tax_details,
                  });
                }
              }

              if (service.opening_fitting.length != 0) {
                service.opening_fitting[0].customer_dep = 100;
                service.opening_fitting[0].insurance_dep = 0;
              }

              if (service.parts.length != 0) {
                service.parts[0].customer_dep = 100;
                service.parts[0].insurance_dep = 0;
              }

              packages.push({
                package: service.package,
                service: service.service,
                labour: labours,
                labour_cost: _.sumBy(labours, (x) => x.amount),
                parts: service.parts,
                part_cost: Math.ceil(service.part_cost),
                opening_fitting: service.opening_fitting,
                of_cost: Math.ceil(service.of_cost),
                exceeded_cost: 0,
                mrp: Math.ceil(service.mrp),
                cost:
                  Math.ceil(service.part_cost) +
                  _.sumBy(labours, (x) => x.amount) +
                  service.of_cost,
                doorstep: service.doorstep,
                unit: service.unit,
                quantity: service.quantity,
                part_cost_editable: service.part_cost_editable,
                labour_cost_editable: service.labour_cost_editable,
                of_cost_editable: service.of_cost_editable,
                type: service.type,
                source: service.id,
                gallery: 0,
                description: service.description,
                coupons: coupons,
                id: service.id,
                _id: service._id,
              });
            });

          packages = _(packages)
            .groupBy((x) => x.package)
            .map((value, key) => ({ package: key, services: value }))
            .value();

          res.status(200).json({
            responseCode: 200,
            responseMessage:
              "Please hold on, we're about to update the database of discontinued cars.",
            responseData: packages,
          });
        } else if (req.body.type == "package") {
          await Package.find({ business: business, label: "special" })
            .cursor()
            .eachAsync(async (service) => {
              var serverTime = moment.tz(new Date(), req.headers["tz"]);

              var bar = service.created_at;
              bar.setDate(bar.getDate() + service.validity);

              var e = bar;
              bar = moment.tz(bar, req.headers["tz"]);

              var baz = bar.diff(serverTime);

              var check = await UserPackage.find({
                user: user,
                package: service._id,
                car: req.body.car,
              })
                .count()
                .exec();
              if (check <= 0) {
                if (baz > 0) {
                  if (service.category == "addOn") {
                    packages.push({
                      service: service.name,
                      mrp: 0,
                      discount: service.discount,
                      labour_cost: service.cost,
                      part_cost: 0,
                      of_cost: 0,
                      type: "addOn",
                      cost: service.cost,
                      id: service.id,
                      _id: service._id,
                      label: service.label,
                      doorstep: false,
                      validity: service.validity,
                      gallery: await Gallery.count({
                        source: service._id,
                      }).exec(),
                      doorstep: service.doorstep,
                      expired_at: moment(service.expired_at)
                        .tz(req.headers["tz"])
                        .format("ll"),
                    });
                  } else {
                    packages.push({
                      service: service.name,
                      mrp: 0,
                      discount: service.discount,
                      labour_cost: service.cost,
                      part_cost: 0,
                      of_cost: 0,
                      type: "package",
                      cost: service.cost,
                      id: service.id,
                      _id: service._id,
                      label: service.label,
                      doorstep: false,
                      validity: service.validity,
                      gallery: await Gallery.count({
                        source: service._id,
                      }).exec(),
                      doorstep: service.doorstep,
                      expired_at: moment(service.expired_at)
                        .tz(req.headers["tz"])
                        .format("ll"),
                    });
                  }
                }
              }
            });

          res.status(200).json({
            responseCode: 200,
            responseMessage:
              "Either you have already enjoyed the existing offers, or they are unavailable at the moment",
            responseData: packages,
          });
        }
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Unauthorized",
          responseData: {},
        });
      }
    }
  }
);

router.post(
  "/new/booking/add/",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      car: "required",
      services: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Error",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      if (req.body.package == "") {
        req.body.package = null;
      }

      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);

      var user = req.headers["business"];

      var total = 0;
      var labourCost = 0;
      var part_cost = 0;
      var is_services = true;
      var doorstep = true;
      var bookingService = [];

      var services = req.body.services;
      var countBooking = await Booking.find({}).count().exec();
      var checkCar = await Car.findOne({
        _id: req.body.car,
        user: user,
      }).exec();
      var insurance_info = {
        driver: null,
        accident_place: "",
        accident_date: null,
        accident_time: "",
        accident_cause: "",
        fir: "",
        branch: "",
        cashless: "true",
        claim: "false",
        contact_no: "",
        claim_no: "",
        driver_accident: "",
        expire: null,
        gstin: "",
        insurance_company: "",
        manufacture_year: "",
        policy_holder: "",
        policy_no: "",
        policy_type: "",
        premium: 0,
        spot_survey: "",
        state: "",
      };

      if (checkCar) {
        var advisorBooking = [];
        await Management.find({
          business: req.body.business,
          role: "Service Advisor",
        })
          .cursor()
          .eachAsync(async (a) => {
            var d = await Booking.find({
              business: req.body.business,
              advisor: a.user,
            })
              .count()
              .exec();
            advisorBooking.push({
              user: a.user,
              count: await Booking.find({
                business: req.body.business,
                advisor: a.user,
              })
                .count()
                .exec(),
            });
          });

        if (advisorBooking.length != 0) {
          var min = advisorBooking.reduce(function (prev, current) {
            return prev.count < current.count ? prev : current;
          });
          var advisor = min.user;
        } else {
          var advisor = req.body.business;
        }

        var customer_requirements = [];
        if (req.body.requirements) {
          customer_requirements.push({
            user: user,
            requirement: req.body.requirements,
          });
        }
        if (req.body.is_services == false) {
          var baz = 1;
        } else {
          var checkBooking = await Booking.findOne({
            car: checkCar._id,
            date: new Date(req.body.date).toISOString(),
            status: {
              $in: [
                "Confirmed",
                "Pending",
                "Approval",
                "Approved",
                "Failed",
                "JobInitiated",
              ],
            },
            is_services: true,
          }).exec();

          if (checkBooking) {
            var serverTime = moment.tz(
              new Date(req.body.date).toISOString(),
              req.headers["tz"]
            );
            var bar = moment(checkBooking.date)
              .tz(req.headers["tz"])
              .format("YYYY-MM-DD");
            bar = moment.tz(new Date(bar).toISOString(), req.headers["tz"]);
            var baz = bar.diff(serverTime);
          } else {
            var baz = 1;
          }
        }

        if (baz > 0) {
          var checkVendor = await User.findOne({
            _id: req.body.business,
          }).exec();
          if (checkVendor) {
            for (var i = 0; i < services.length; i++) {
              if (services[i].type == "package") {
                await Package.find({ _id: services[i].id })
                  .cursor()
                  .eachAsync(async (service) => {
                    if (service) {
                      var tax_info = await Tax.findOne({
                        tax: "18.0% GST",
                      }).exec();
                      var tax_rate = tax_info.detail;
                      var amount = service.cost;
                      var base = amount;
                      var labour_tax = [];
                      var labours = [];

                      var x = (100 + tax_info.rate) / 100;
                      var tax_on_amount = amount / x;
                      if (tax_rate.length > 0) {
                        for (var r = 0; r < tax_rate.length; r++) {
                          if (tax_rate[r].rate != tax_info.rate) {
                            var t = tax_on_amount * (tax_rate[r].rate / 100);
                            base = base - t;
                            labour_tax.push({
                              tax: tax_rate[r].tax,
                              rate: parseFloat(tax_rate[r].rate.toFixed(2)),
                              amount: parseFloat(t.toFixed(2)),
                            });
                          } else {
                            base = base - t;
                            labour_tax.push({
                              tax: tax_info.tax,
                              tax_rate: tax_info.rate,
                              rate: parseFloat(tax_info.rate.toFixed(2)),
                              amount: parseFloat(tax_on_amount.toFixed(2)),
                            });
                          }
                        }
                      }

                      labours.push({
                        item: service.name,
                        quantity: 1,
                        rate: parseFloat(service.cost),
                        base: parseFloat(base.toFixed(2)),
                        amount: parseFloat(amount),
                        discount: 0,
                        amount_is_tax: "inclusive",
                        tax_amount: _.sumBy(labour_tax, (x) => x.amount),
                        tax: tax_info.tax,
                        tax_rate: tax_info.rate,
                        tax_info: {
                          tax: tax_info.tax,
                          tax_rate: tax_info.rate,
                          rate: tax_info.rate,
                          base: parseFloat(base.toFixed(2)),
                          detail: labour_tax,
                        },
                      });

                      is_services = false;

                      bookingService.push({
                        source: services[i].id,
                        service: service.name,
                        description: service.description,
                        cost: Math.ceil(service.cost),
                        labour_cost: Math.ceil(service.cost),
                        part_cost: 0,
                        of_cost: 0,
                        discount: 0,
                        parts: [],
                        labour: labours,
                        opening_fitting: [],
                        type: "package",
                        customer_approval: true,
                        surveyor_approval: false,
                      });

                      ////////console.log(bookingService)
                    } else {
                      res.status(400).json({
                        responseCode: 400,
                        responseMessage: "Service Not Found",
                        responseData: {},
                      });
                    }
                  });
              } else if (services[i].type == "addOn") {
                await Package.find({ _id: services[i].id })
                  .cursor()
                  .eachAsync(async (service) => {
                    if (service) {
                      var tax_info = await Tax.findOne({
                        tax: "18.0% GST",
                      }).exec();
                      var tax_rate = tax_info.detail;
                      var amount = service.cost;
                      var base = amount;
                      var labour_tax = [];
                      var labours = [];

                      var x = (100 + tax_info.rate) / 100;
                      var tax_on_amount = amount / x;
                      if (tax_rate.length > 0) {
                        for (var r = 0; r < tax_rate.length; r++) {
                          if (tax_rate[r].rate != tax_info.rate) {
                            var t = tax_on_amount * (tax_rate[r].rate / 100);
                            base = base - t;
                            labour_tax.push({
                              tax: tax_rate[r].tax,
                              rate: parseFloat(tax_rate[r].rate.toFixed(2)),
                              amount: parseFloat(t.toFixed(2)),
                            });
                          } else {
                            base = base - t;
                            labour_tax.push({
                              tax: tax_info.tax,
                              tax_rate: tax_info.rate,
                              rate: parseFloat(tax_info.rate.toFixed(2)),
                              amount: parseFloat(tax_on_amount.toFixed(2)),
                            });
                          }
                        }
                      }

                      labours.push({
                        item: service.name,
                        quantity: 1,
                        rate: parseFloat(service.cost),
                        base: parseFloat(base.toFixed(2)),
                        amount: parseFloat(amount),
                        discount: 0,
                        amount_is_tax: "inclusive",
                        tax_amount: _.sumBy(labour_tax, (x) => x.amount),
                        tax: tax_info.tax,
                        tax_rate: tax_info.rate,
                        tax_info: {
                          tax: tax_info.tax,
                          tax_rate: tax_info.rate,
                          rate: tax_info.rate,
                          base: parseFloat(base.toFixed(2)),
                          detail: labour_tax,
                        },
                      });

                      is_services = true;

                      bookingService.push({
                        source: service._id,
                        service: service.name,
                        description: service.description,
                        cost: Math.ceil(service.cost),
                        labour_cost: Math.ceil(service.cost),
                        part_cost: 0,
                        of_cost: 0,
                        discount: 0,
                        parts: [],
                        labour: labours,
                        opening_fitting: [],
                        type: "addOn",
                        customer_approval: true,
                        surveyor_approval: false,
                      });
                    } else {
                      res.status(400).json({
                        responseCode: 400,
                        responseMessage: "Service Not Found",
                        responseData: {},
                      });
                    }
                  });
              } else if (services[i].type == "services") {
                is_services = true;
                await Service.find({ _id: services[i].id, publish: true })
                  .cursor()
                  .eachAsync(async (service) => {
                    var getDiscount = {
                      package: req.body.package,
                      car: req.body.car,
                      category: service.type,
                      service: service.service,
                      tz: req.headers["tz"],
                      claim: false,
                    };

                    if (
                      typeof services[i].quantity != "number" ||
                      parseInt(services[i].quantity) <= 0
                    ) {
                      var quantity = 1;
                    } else {
                      var quantity = parseInt(services[i].quantity);
                    }

                    var package = await q.all(getPackageDiscount(getDiscount));

                    var labour_list = service.labour;
                    var labours = [];

                    var discount_eligible_labour_cost = _.sumBy(
                      labour_list,
                      (x) => x.amount * quantity
                    );
                    if (labour_list.length > 0) {
                      for (var l = 0; l < labour_list.length; l++) {
                        var discount_total = 0;
                        var total = 0;
                        var tax_info = await Tax.findOne({
                          tax: labour_list[l].tax,
                        }).exec();

                        var tax = [];
                        var rate = labour_list[l].rate;
                        var amount =
                          parseFloat(labour_list[l].amount) * quantity;
                        var tax_rate = tax_info.detail;
                        var base = amount;

                        if (Object.keys(package).length > 0) {
                          if (package.discount_type == "percent") {
                            discount = parseFloat(package.discount);
                            if (!isNaN(discount) && discount > 0) {
                              var discount_total = amount * (discount / 100);
                              amount =
                                amount - parseFloat(discount_total.toFixed(2));
                              if (amount < 0) {
                                amount = 0;
                              }
                            }
                          } else if (package.discount_type == "fixed") {
                            discount = parseFloat(package.discount);
                            if (!isNaN(discount) && discount > 0) {
                              var discount_total =
                                (amount / discount_eligible_labour_cost) *
                                discount;
                              amount = parseFloat(discount_total.toFixed(2));
                              discount = amount - discount_total;
                              if (amount < 0) {
                                amount = 0;
                              }
                            }
                          } else {
                            discount = parseFloat(package.discount);
                            if (!isNaN(discount) && discount > 0) {
                              var discount_total =
                                (amount / discount_eligible_labour_cost) *
                                discount;
                              amount =
                                amount - parseFloat(discount_total.toFixed(2));
                              if (amount < 0) {
                                amount = 0;
                              }
                            }
                          }
                        }

                        if (labour_list[l].amount_is_tax == "inclusive") {
                          var x = (100 + tax_info.rate) / 100;
                          var tax_on_amount = amount / x;
                          if (tax_rate.length > 0) {
                            for (var r = 0; r < tax_rate.length; r++) {
                              if (tax_rate[r].rate != tax_info.rate) {
                                var t =
                                  tax_on_amount * (tax_rate[r].rate / 100);
                                base = base - t;
                                tax.push({
                                  tax: tax_rate[r].tax,
                                  rate: tax_rate[r].rate,
                                  amount: parseFloat(t.toFixed(2)),
                                });
                              } else {
                                var t = amount - tax_on_amount;
                                base = base - t;
                                tax.push({
                                  tax: tax_info.tax,
                                  tax_rate: tax_info.rate,
                                  rate: tax_info.rate,
                                  amount: parseFloat(t.toFixed(2)),
                                });
                              }
                            }

                            //base = base - discount_total;
                          }
                          total = total + amount;
                        }

                        var tax_details = {
                          tax: tax_info.tax,
                          rate: tax_info.rate,
                          amount: total,
                          detail: tax,
                        };

                        labours.push({
                          item: labour_list[l].item,
                          source: labour_list[l].source,
                          rate: parseFloat(labour_list[l].rate),
                          quantity: quantity,
                          base: parseFloat(total.toFixed(2)),
                          discount: parseFloat(discount_total.toFixed(2)),
                          amount: total,
                          tax_amount: parseFloat(
                            _.sumBy(tax, (x) => x.amount).toFixed(2)
                          ),
                          amount_is_tax: labour_list[l].amount_is_tax,
                          tax: tax_info.tax,
                          tax_rate: tax_info.rate,
                          tax_info: tax_details,
                        });
                      }
                    }

                    bookingService.push({
                      service: service.service,
                      labour: labours,
                      labour_cost: _.sumBy(labours, (x) => x.amount),
                      discount: _.sumBy(labours, (x) => x.discount),
                      parts: service.parts,
                      part_cost: Math.ceil(service.part_cost),
                      opening_fitting: service.opening_fitting,
                      of_cost: Math.ceil(service.of_cost),
                      exceeded_cost: 0,
                      mrp: Math.ceil(service.mrp),
                      cost:
                        service.part_cost +
                        _.sumBy(labours, (x) => x.amount) +
                        service.of_cost,
                      doorstep: service.doorstep,
                      unit: service.unit,
                      quantity: quantity,
                      part_cost_editable: service.part_cost_editable,
                      labour_cost_editable: service.labour_cost_editable,
                      of_cost_editable: service.of_cost_editable,
                      type: service.type,
                      source: service.id,
                      description: service.description,
                      claim: false,
                      customer_approval: true,
                      surveyor_approval: false,
                    });
                  });
              } else if (services[i].type == "collision") {
                is_services = true;
                await Collision.find({ _id: services[i].id, publish: true })
                  .cursor()
                  .eachAsync(async (service) => {
                    var getDiscount = {
                      package: req.body.package,
                      car: req.body.car,
                      category: service.type,
                      service: service.service,
                      tz: req.headers["tz"],
                      claim: false,
                    };

                    if (
                      typeof services[i].quantity != "number" ||
                      parseInt(services[i].quantity) <= 0
                    ) {
                      var quantity = 1;
                    } else {
                      var quantity = parseInt(services[i].quantity);
                    }

                    var package = await q.all(getPackageDiscount(getDiscount));
                    var labour_list = service.labour;
                    var labours = [];

                    var discount_eligible_labour_cost = _.sumBy(
                      labour_list,
                      (x) => x.amount * quantity
                    );
                    if (labour_list.length > 0) {
                      for (var l = 0; l < labour_list.length; l++) {
                        var discount_total = 0;
                        var total = 0;
                        var tax_info = await Tax.findOne({
                          tax: labour_list[l].tax,
                        }).exec();

                        var tax = [];
                        var rate = labour_list[l].rate;
                        var amount =
                          parseFloat(labour_list[l].amount) * quantity;
                        var tax_rate = tax_info.detail;
                        var base = amount;

                        if (Object.keys(package).length > 0) {
                          if (package.discount_type == "percent") {
                            discount = parseFloat(package.discount);
                            if (!isNaN(discount) && discount > 0) {
                              var discount_total = amount * (discount / 100);
                              amount =
                                amount - parseFloat(discount_total.toFixed(2));
                              if (amount < 0) {
                                amount = 0;
                              }
                            }
                          } else if (package.discount_type == "fixed") {
                            discount = parseFloat(package.discount);
                            if (!isNaN(discount) && discount > 0) {
                              var discount_total =
                                (amount / discount_eligible_labour_cost) *
                                discount;
                              amount = parseFloat(discount_total.toFixed(2));
                              discount = amount - discount_total;
                              if (amount < 0) {
                                amount = 0;
                              }
                            }
                          } else {
                            discount = parseFloat(package.discount);
                            if (!isNaN(discount) && discount > 0) {
                              var discount_total =
                                (amount / discount_eligible_labour_cost) *
                                discount;
                              amount =
                                amount - parseFloat(discount_total.toFixed(2));
                              if (amount < 0) {
                                amount = 0;
                              }
                            }
                          }
                        }

                        if (labour_list[l].amount_is_tax == "inclusive") {
                          var x = (100 + tax_info.rate) / 100;
                          var tax_on_amount = amount / x;
                          if (tax_rate.length > 0) {
                            for (var r = 0; r < tax_rate.length; r++) {
                              if (tax_rate[r].rate != tax_info.rate) {
                                var t =
                                  tax_on_amount * (tax_rate[r].rate / 100);
                                base = base - t;
                                tax.push({
                                  tax: tax_rate[r].tax,
                                  rate: tax_rate[r].rate,
                                  amount: parseFloat(t.toFixed(2)),
                                });
                              } else {
                                var t = amount - tax_on_amount;
                                base = base - t;
                                tax.push({
                                  tax: tax_info.tax,
                                  tax_rate: tax_info.rate,
                                  rate: tax_info.rate,
                                  amount: parseFloat(t.toFixed(2)),
                                });
                              }
                            }

                            //base = base - discount_total;
                          }
                          total = total + amount;
                        }

                        var tax_details = {
                          tax: tax_info.tax,
                          rate: tax_info.rate,
                          amount: total,
                          detail: tax,
                        };

                        labours.push({
                          item: labour_list[l].item,
                          source: labour_list[l].source,
                          rate: parseFloat(labour_list[l].rate),
                          quantity: quantity,
                          base: parseFloat(total.toFixed(2)),
                          discount: parseFloat(discount_total.toFixed(2)),
                          amount: total,
                          tax_amount: parseFloat(
                            _.sumBy(tax, (x) => x.amount).toFixed(2)
                          ),
                          amount_is_tax: labour_list[l].amount_is_tax,
                          tax: tax_info.tax,
                          tax_rate: tax_info.rate,
                          tax_info: tax_details,
                        });
                      }
                    }

                    bookingService.push({
                      service: service.service,
                      labour: labours,
                      labour_cost: _.sumBy(labours, (x) => x.amount),
                      discount: _.sumBy(labours, (x) => x.discount),
                      parts: service.parts,
                      part_cost: Math.ceil(service.part_cost),
                      opening_fitting: service.opening_fitting,
                      of_cost: Math.ceil(service.of_cost),
                      exceeded_cost: 0,
                      mrp: Math.ceil(service.mrp),
                      cost:
                        service.part_cost +
                        _.sumBy(labours, (x) => x.amount) +
                        service.of_cost,
                      doorstep: service.doorstep,
                      unit: service.unit,
                      quantity: quantity,
                      part_cost_editable: service.part_cost_editable,
                      labour_cost_editable: service.labour_cost_editable,
                      of_cost_editable: service.of_cost_editable,
                      type: service.type,
                      source: service.id,
                      description: service.description,
                      claim: false,
                      customer_approval: true,
                      surveyor_approval: false,
                    });
                  });
              } else if (services[i].type == "detailing") {
                is_services = true;
                await Detailing.find({ _id: services[i].id, publish: true })
                  .cursor()
                  .eachAsync(async (service) => {
                    var getDiscount = {
                      package: req.body.package,
                      car: req.body.car,
                      category: service.type,
                      service: service.service,
                      tz: req.headers["tz"],
                      claim: false,
                    };

                    //////console.log(getDiscount)

                    if (
                      typeof services[i].quantity != "number" ||
                      parseInt(services[i].quantity) <= 0
                    ) {
                      var quantity = 1;
                    } else {
                      var quantity = parseInt(services[i].quantity);
                    }

                    var package = await q.all(getPackageDiscount(getDiscount));

                    //////console.log(package)

                    var labour_list = service.labour;
                    var labours = [];

                    var discount_eligible_labour_cost = _.sumBy(
                      labour_list,
                      (x) => x.amount * quantity
                    );
                    if (labour_list.length > 0) {
                      for (var l = 0; l < labour_list.length; l++) {
                        var discount_total = 0;
                        var total = 0;
                        var tax_info = await Tax.findOne({
                          tax: labour_list[l].tax,
                        }).exec();

                        var tax = [];
                        var rate = labour_list[l].rate;
                        var amount =
                          parseFloat(labour_list[l].amount) * quantity;
                        var tax_rate = tax_info.detail;
                        var base = amount;

                        if (Object.keys(package).length > 0) {
                          if (package.discount_type == "percent") {
                            discount = parseFloat(package.discount);
                            if (!isNaN(discount) && discount > 0) {
                              var discount_total = amount * (discount / 100);
                              amount =
                                amount - parseFloat(discount_total.toFixed(2));
                              if (amount < 0) {
                                amount = 0;
                              }
                            }
                          } else if (package.discount_type == "fixed") {
                            discount = parseFloat(package.discount);
                            if (!isNaN(discount) && discount > 0) {
                              var discount_total =
                                (amount / discount_eligible_labour_cost) *
                                discount;
                              amount = parseFloat(discount_total.toFixed(2));
                              discount = amount - discount_total;
                              if (amount < 0) {
                                amount = 0;
                              }
                            }
                          } else {
                            discount = parseFloat(package.discount);
                            if (!isNaN(discount) && discount > 0) {
                              var discount_total =
                                (amount / discount_eligible_labour_cost) *
                                discount;
                              amount =
                                amount - parseFloat(discount_total.toFixed(2));
                              if (amount < 0) {
                                amount = 0;
                              }
                            }
                          }
                        }

                        if (labour_list[l].amount_is_tax == "inclusive") {
                          var x = (100 + tax_info.rate) / 100;
                          var tax_on_amount = amount / x;
                          if (tax_rate.length > 0) {
                            for (var r = 0; r < tax_rate.length; r++) {
                              if (tax_rate[r].rate != tax_info.rate) {
                                var t =
                                  tax_on_amount * (tax_rate[r].rate / 100);
                                base = base - t;
                                tax.push({
                                  tax: tax_rate[r].tax,
                                  rate: tax_rate[r].rate,
                                  amount: parseFloat(t.toFixed(2)),
                                });
                              } else {
                                var t = amount - tax_on_amount;
                                base = base - t;
                                tax.push({
                                  tax: tax_info.tax,
                                  tax_rate: tax_info.rate,
                                  rate: tax_info.rate,
                                  amount: parseFloat(t.toFixed(2)),
                                });
                              }
                            }

                            //base = base - discount_total;
                          }
                          total = total + amount;
                        }

                        var tax_details = {
                          tax: tax_info.tax,
                          rate: tax_info.rate,
                          amount: total,
                          detail: tax,
                        };

                        labours.push({
                          item: labour_list[l].item,
                          source: labour_list[l].source,
                          rate: parseFloat(labour_list[l].rate),
                          quantity: quantity,
                          base: parseFloat(total.toFixed(2)),
                          discount: parseFloat(discount_total.toFixed(2)),
                          amount: total,
                          tax_amount: parseFloat(
                            _.sumBy(tax, (x) => x.amount).toFixed(2)
                          ),
                          amount_is_tax: labour_list[l].amount_is_tax,
                          tax: tax_info.tax,
                          tax_rate: tax_info.rate,
                          tax_info: tax_details,
                        });
                      }
                    }

                    bookingService.push({
                      service: service.service,
                      labour: labours,
                      labour_cost: _.sumBy(labours, (x) => x.amount),
                      discount: _.sumBy(labours, (x) => x.discount),
                      parts: service.parts,
                      part_cost: Math.ceil(service.part_cost),
                      opening_fitting: service.opening_fitting,
                      of_cost: Math.ceil(service.of_cost),
                      exceeded_cost: 0,
                      mrp: Math.ceil(service.mrp),
                      cost:
                        service.part_cost +
                        _.sumBy(labours, (x) => x.amount) +
                        service.of_cost,
                      doorstep: service.doorstep,
                      unit: service.unit,
                      quantity: quantity,
                      part_cost_editable: service.part_cost_editable,
                      labour_cost_editable: service.labour_cost_editable,
                      of_cost_editable: service.of_cost_editable,
                      type: service.type,
                      source: service.id,
                      description: service.description,
                      claim: false,
                      customer_approval: true,
                      surveyor_approval: false,
                    });
                  });
              } else if (services[i].type == "customization") {
                is_services = true;
                await Customization.find({ _id: services[i].id, publish: true })
                  .cursor()
                  .eachAsync(async (service) => {
                    var getDiscount = {
                      package: req.body.package,
                      car: req.body.car,
                      category: service.type,
                      service: service.service,
                      tz: req.headers["tz"],
                      claim: false,
                    };

                    if (
                      typeof services[i].quantity != "number" ||
                      parseInt(services[i].quantity) <= 0
                    ) {
                      var quantity = 1;
                    } else {
                      var quantity = parseInt(services[i].quantity);
                    }

                    var package = await q.all(getPackageDiscount(getDiscount));
                    var labour_list = service.labour;
                    var labours = [];

                    var discount_eligible_labour_cost = _.sumBy(
                      labour_list,
                      (x) => x.amount * quantity
                    );
                    if (labour_list.length > 0) {
                      for (var l = 0; l < labour_list.length; l++) {
                        var discount_total = 0;
                        var total = 0;
                        var tax_info = await Tax.findOne({
                          tax: labour_list[l].tax,
                        }).exec();

                        var tax = [];
                        var rate = labour_list[l].rate;
                        var amount =
                          parseFloat(labour_list[l].amount) * quantity;
                        var tax_rate = tax_info.detail;
                        var base = amount;

                        if (Object.keys(package).length > 0) {
                          if (package.discount_type == "percent") {
                            discount = parseFloat(package.discount);
                            if (!isNaN(discount) && discount > 0) {
                              var discount_total = amount * (discount / 100);
                              amount =
                                amount - parseFloat(discount_total.toFixed(2));
                              if (amount < 0) {
                                amount = 0;
                              }
                            }
                          } else if (package.discount_type == "fixed") {
                            discount = parseFloat(package.discount);
                            if (!isNaN(discount) && discount > 0) {
                              var discount_total =
                                (amount / discount_eligible_labour_cost) *
                                discount;
                              amount = parseFloat(discount_total.toFixed(2));
                              discount = amount - discount_total;
                              if (amount < 0) {
                                amount = 0;
                              }
                            }
                          } else {
                            discount = parseFloat(package.discount);
                            if (!isNaN(discount) && discount > 0) {
                              var discount_total =
                                (amount / discount_eligible_labour_cost) *
                                discount;
                              amount =
                                amount - parseFloat(discount_total.toFixed(2));
                              if (amount < 0) {
                                amount = 0;
                              }
                            }
                          }
                        }

                        if (labour_list[l].amount_is_tax == "inclusive") {
                          var x = (100 + tax_info.rate) / 100;
                          var tax_on_amount = amount / x;
                          if (tax_rate.length > 0) {
                            for (var r = 0; r < tax_rate.length; r++) {
                              if (tax_rate[r].rate != tax_info.rate) {
                                var t =
                                  tax_on_amount * (tax_rate[r].rate / 100);
                                base = base - t;
                                tax.push({
                                  tax: tax_rate[r].tax,
                                  rate: tax_rate[r].rate,
                                  amount: parseFloat(t.toFixed(2)),
                                });
                              } else {
                                var t = amount - tax_on_amount;
                                base = base - t;
                                tax.push({
                                  tax: tax_info.tax,
                                  tax_rate: tax_info.rate,
                                  rate: tax_info.rate,
                                  amount: parseFloat(t.toFixed(2)),
                                });
                              }
                            }

                            //base = base - discount_total;
                          }
                          total = total + amount;
                        }

                        var tax_details = {
                          tax: tax_info.tax,
                          rate: tax_info.rate,
                          amount: total,
                          detail: tax,
                        };

                        labours.push({
                          item: labour_list[l].item,
                          source: labour_list[l].source,
                          rate: parseFloat(labour_list[l].rate),
                          quantity: quantity,
                          base: parseFloat(total.toFixed(2)),
                          discount: parseFloat(discount_total.toFixed(2)),
                          amount: total,
                          tax_amount: parseFloat(
                            _.sumBy(tax, (x) => x.amount).toFixed(2)
                          ),
                          amount_is_tax: labour_list[l].amount_is_tax,
                          tax: tax_info.tax,
                          tax_rate: tax_info.rate,
                          tax_info: tax_details,
                        });
                      }
                    }

                    bookingService.push({
                      service: service.service,
                      labour: labours,
                      labour_cost: _.sumBy(labours, (x) => x.amount),
                      discount: _.sumBy(labours, (x) => x.discount),
                      parts: service.parts,
                      part_cost: Math.ceil(service.part_cost),
                      opening_fitting: service.opening_fitting,
                      of_cost: Math.ceil(service.of_cost),
                      exceeded_cost: 0,
                      mrp: Math.ceil(service.mrp),
                      cost:
                        service.part_cost +
                        _.sumBy(labours, (x) => x.amount) +
                        service.of_cost,
                      doorstep: service.doorstep,
                      unit: service.unit,
                      quantity: quantity,
                      part_cost_editable: service.part_cost_editable,
                      labour_cost_editable: service.labour_cost_editable,
                      of_cost_editable: service.of_cost_editable,
                      type: service.type,
                      source: service.id,
                      description: service.description,
                      claim: false,
                      customer_approval: true,
                      surveyor_approval: false,
                    });
                  });
              }
            }

            if (bookingService.length > 0) {
              var labour_cost = _.sumBy(bookingService, (x) => x.labour_cost);
              var part_cost = _.sumBy(bookingService, (x) => x.part_cost);
              var of_cost = _.sumBy(bookingService, (x) => x.of_cost);
              var discount_total = _.sumBy(bookingService, (x) => x.discount);
              var pick_up_charges = 0;
              if (req.body.charges) {
                pick_up_charges = parseFloat(req.body.charges);
              }
            } else {
              return res.status(400).json({
                responseCode: 400,
                responseMessage: "Services not found",
                responseData: {},
              });
            }

            if (doorstep) {
              var paid_total =
                part_cost + labour_cost + of_cost + pick_up_charges;
              var total =
                part_cost +
                labour_cost +
                of_cost +
                discount_total +
                pick_up_charges;
              var payment = {
                estimate_cost: paid_total,
                payment_mode: req.body.payment_mode,
                payment_status: "Pending",
                careager_cash: 0,
                discount_type: "",
                coupon: "",
                coupon_type: "",
                discount: discount_total.toFixed(2),
                discount_total: discount_total.toFixed(2),
                terms: checkVendor.business_info.terms,
                pick_up_limit: checkVendor.business_info.pick_up_limit,
                pick_up_charges: pick_up_charges,
                part_cost: parseFloat(part_cost.toFixed(2)),
                labour_cost: parseFloat(labour_cost.toFixed(2)),
                of_cost: parseFloat(of_cost.toFixed(2)),
                paid_total: 0,
                total: parseFloat(total.toFixed(2)),
                discount_applied: false,
                transaction_id: "",
                transaction_date: "",
                transaction_status: "",
                transaction_response: "",
                policy_clause: 0,
                salvage: 0,
              };

              var due = {
                due: Math.ceil(paid_total.toFixed(2)),
              };

              if (req.body.is_services == false) {
                var date = new Date();
              } else {
                if (req.body.date) {
                  var date = new Date(req.body.date).toISOString();
                } else {
                  var d = new Date();
                  var date = new Date(
                    d.getFullYear(),
                    d.getMonth(),
                    d.getDate() + 2
                  );
                }
              }

              var lastBooking = await Booking.findOne({
                user: user,
                status: " Inactive",
              })
                .sort({ created_at: -1 })
                .exec();

              if (lastBooking) {
                var data = {
                  package: req.body.package,
                  car: req.body.car,
                  advisor: advisor,
                  business: req.body.business,
                  user: user,
                  services: bookingService,
                  booking_no: lastBooking.booking_no,
                  date: date,
                  customer_requirements: customer_requirements,
                  time_slot: req.body.time_slot,
                  convenience: req.body.convenience,
                  status: "Inactive",
                  payment: payment,
                  due: due,
                  insurance_info: insurance_info,
                  address: req.body.address,
                  is_services: is_services,
                  created_at: new Date(),
                  updated_at: new Date(),
                };

                Booking.findOneAndUpdate(
                  { _id: lastBooking._id },
                  { $set: data },
                  { new: true },
                  async function (err, doc) {
                    if (!err) {
                      var booking = await Booking.findById(
                        lastBooking._id
                      ).exec();
                      if (booking.is_services == true) {
                        res.status(200).json({
                          responseCode: 200,
                          responseMessage: "Service Request has been booked",
                          responseData: booking,
                        });
                      } else {
                        res.status(200).json({
                          responseCode: 200,
                          responseMessage:
                            "Package successfully purchased, Book Services Now for added benefits",
                          responseData: booking,
                        });
                      }
                    } else {
                      res.status(400).json({
                        responseCode: 400,
                        responseMessage: "Server Error",
                        responseData: err,
                      });
                    }
                  }
                );
              } else {
                var data = {
                  package: req.body.package,
                  car: req.body.car,
                  advisor: advisor,
                  business: req.body.business,
                  user: user,
                  services: bookingService,
                  booking_no:
                    Math.round(+new Date() / 1000) +
                    Math.round(Math.random() * 9999 + 1),
                  date: date,
                  time_slot: req.body.time_slot,
                  convenience: req.body.convenience,
                  status: "Inactive",
                  payment: payment,
                  due: due,
                  customer_requirements: customer_requirements,
                  address: req.body.address,
                  insurance_info: insurance_info,
                  is_services: is_services,
                  created_at: new Date(),
                  updated_at: new Date(),
                };

                Booking.create(data).then(async function (booking) {
                  if (booking.is_services == true) {
                    res.status(200).json({
                      responseCode: 200,
                      responseMessage: "Service Request has been booked",
                      responseData: booking,
                    });
                  } else {
                    res.status(200).json({
                      responseCode: 200,
                      responseMessage:
                        "Package successfully purchased, Book Services Now for added benefits",
                      responseData: booking,
                    });
                  }
                });
              }
            } else {
              res.status(422).json({
                responseCode: 422,
                responseMessage:
                  "Doorstep is not available for selected service",
                responseData: {},
              });
            }
          } else {
            res.status(400).json({
              responseCode: 400,
              responseMessage: "Business Not Found",
              responseData: {},
            });
          }
        } else {
          res.status(422).json({
            responseCode: 422,
            responseMessage:
              "Booking already exists for the same day. Please choose a different date or ask the advisor if anything needs to be added.",
            responseData: {},
          });
        }
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Unauthorized",
          responseData: {},
        });
      }
    }
  }
);

router.post(
  "/my/booking/package/add/",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      package: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Error",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var user = decoded.user;

      if (req.headers["business"]) {
        user = req.headers["business"];
      }

      var total = 0;
      var labourCost = 0;
      var part_cost = 0;
      var bookingService = [];
      var services = req.body.services;
      var countBooking = await Booking.find({}).count().exec();
      var checkPackage = await UserPackage.findOne({
        _id: req.body.package,
        user: user,
      }).exec();
      var car = await Car.findOne({ _id: checkPackage.car, user: user })
        .populate("model")
        .exec();
      var checkVendor = await User.findOne({
        _id: checkPackage.business,
      }).exec();

      if (car && checkPackage) {
        var checkBooking = await Booking.findOne({
          car: car._id,
          date: new Date(req.body.date).toISOString(),
          status: {
            $in: [
              "Confirmed",
              "Pending",
              "Approval",
              "Approved",
              "Failed",
              "JobInitiated",
            ],
          },
          is_services: true,
        }).exec();

        if (checkBooking) {
          var serverTime = moment.tz(
            new Date(req.body.date).toISOString(),
            req.headers["tz"]
          );
          var bar = moment(checkBooking.date)
            .tz(req.headers["tz"])
            .format("YYYY-MM-DD");
          bar = moment.tz(new Date(bar).toISOString(), req.headers["tz"]);
          var baz = bar.diff(serverTime);
        } else {
          var baz = 1;
        }

        if (baz > 0) {
          var advisorBooking = [];
          await Management.find({
            business: checkPackage.business,
            role: "Service Advisor",
          })
            .cursor()
            .eachAsync(async (a) => {
              var d = await Booking.find({
                business: checkPackage.business,
                advisor: a.user,
              })
                .count()
                .exec();
              advisorBooking.push({
                user: a.user,
                count: await Booking.find({
                  business: checkPackage.business,
                  advisor: a.user,
                })
                  .count()
                  .exec(),
              });
            });

          if (advisorBooking.length != 0) {
            var min = advisorBooking.reduce(function (prev, current) {
              return prev.count < current.count ? prev : current;
            });
            var advisor = min.user;
          } else {
            var advisor = checkPackage.business;
          }

          if (
            req.body.label == "Wheel Alignment" ||
            req.body.label ==
              "Wheel Balancing (cost per tyre, weights excluded)"
          ) {
            var cond = {
              service: req.body.label,
              model: car.model,
              publish: true,
            };
          } else {
            var cond = {
              service: req.body.label,
              model: car.model._id,
              publish: true,
            };
          }

          await Service.find(cond)
            .cursor()
            .eachAsync(async (service) => {
              var getDiscount = {
                package: checkPackage._id,
                car: car._id,
                category: service.type,
                service: service.service,
                tz: req.headers["tz"],
              };

              var package = await q.all(getPackageDiscount(getDiscount));
              var labour_list = service.labour;
              var labours = [];

              var discount_eligible_labour_cost = _.sumBy(
                labour_list,
                (x) => x.amount
              );
              if (labour_list.length > 0) {
                for (var l = 0; l < labour_list.length; l++) {
                  var quantity = 1;
                  if (labour_list[l].quantity) {
                    quantity = labour_list[l].quantity;
                  }

                  var discount_total = 0;
                  var total = 0;
                  var tax_info = await Tax.findOne({
                    tax: labour_list[l].tax,
                  }).exec();

                  var tax = [];
                  var rate = labour_list[l].rate;
                  var amount = parseFloat(labour_list[l].amount);
                  var tax_rate = tax_info.detail;
                  var base = amount;

                  if (Object.keys(package).length > 0) {
                    if (package.discount_type == "percent") {
                      discount = parseFloat(package.discount);
                      if (!isNaN(discount) && discount > 0) {
                        var discount_total = amount * (discount / 100);
                        amount = amount - parseFloat(discount_total.toFixed(2));
                        if (amount < 0) {
                          amount = 0;
                        }
                      }
                    } else if (package.discount_type == "fixed") {
                      discount = parseFloat(package.discount);
                      if (!isNaN(discount) && discount > 0) {
                        var discount_total =
                          (amount / discount_eligible_labour_cost) * discount;
                        amount = parseFloat(discount_total.toFixed(2));
                        discount = amount - discount_total;
                        if (amount < 0) {
                          amount = 0;
                        }
                      }
                    } else {
                      discount = parseFloat(package.discount);
                      if (!isNaN(discount) && discount > 0) {
                        var discount_total =
                          (amount / discount_eligible_labour_cost) * discount;
                        amount = amount - parseFloat(discount_total.toFixed(2));
                        if (amount < 0) {
                          amount = 0;
                        }
                      }
                    }
                  }

                  if (labour_list[l].amount_is_tax == "inclusive") {
                    var x = (100 + tax_info.rate) / 100;
                    var tax_on_amount = amount / x;
                    if (tax_rate.length > 0) {
                      for (var r = 0; r < tax_rate.length; r++) {
                        if (tax_rate[r].rate != tax_info.rate) {
                          var t = tax_on_amount * (tax_rate[r].rate / 100);
                          base = base - t;
                          tax.push({
                            tax: tax_rate[r].tax,
                            rate: tax_rate[r].rate,
                            amount: parseFloat(t.toFixed(2)),
                          });
                        } else {
                          var t = amount - tax_on_amount;
                          base = base - t;
                          tax.push({
                            tax: tax_info.tax,
                            tax_rate: tax_info.rate,
                            rate: tax_info.rate,
                            amount: parseFloat(t.toFixed(2)),
                          });
                        }
                      }

                      //base = base - discount_total;
                    }
                    total = total + amount;
                  }

                  var tax_details = {
                    tax: tax_info.tax,
                    rate: tax_info.rate,
                    amount: total,
                    detail: tax,
                  };

                  labours.push({
                    item: labour_list[l].item,
                    source: labour_list[l].source,
                    rate: parseFloat(labour_list[l].rate),
                    quantity: 1,
                    base: parseFloat(total.toFixed(2)),
                    discount: parseFloat(discount_total.toFixed(2)),
                    amount: total,
                    customer_dep: labour_list[l].customer_dep,
                    insurance_dep: labour_list[l].insurance_dep,
                    tax_amount: parseFloat(
                      _.sumBy(tax, (x) => x.amount).toFixed(2)
                    ),
                    amount_is_tax: labour_list[l].amount_is_tax,
                    tax: tax_info.tax,
                    tax_rate: tax_info.rate,
                    tax_info: tax_details,
                  });
                }
              }
              bookingService.push({
                service: service.service,
                labour: labours,
                labour_cost: _.sumBy(labours, (x) => x.amount),
                discount: _.sumBy(labours, (x) => x.discount),
                parts: service.parts,
                part_cost: Math.ceil(service.part_cost),
                opening_fitting: service.opening_fitting,
                of_cost: Math.ceil(service.of_cost),
                exceeded_cost: 0,
                mrp: Math.ceil(service.mrp),
                cost:
                  service.part_cost +
                  _.sumBy(labours, (x) => x.amount) +
                  service.of_cost,
                doorstep: service.doorstep,
                unit: service.unit,
                quantity: service.quantity,
                part_cost_editable: service.part_cost_editable,
                labour_cost_editable: service.labour_cost_editable,
                of_cost_editable: service.of_cost_editable,
                type: service.type,
                source: service.id,
                description: service.description,
                claim: false,
                customer_approval: true,
                surveyor_approval: false,
              });
            });

          await Collision.find({
            service: req.body.label,
            model: car.model._id,
          })
            .cursor()
            .eachAsync(async (service) => {
              var getDiscount = {
                package: checkPackage._id,
                car: car._id,
                category: service.type,
                service: service.service,
                tz: req.headers["tz"],
              };

              var package = await q.all(getPackageDiscount(getDiscount));
              var labour_list = service.labour;
              var labours = [];

              var discount_eligible_labour_cost = _.sumBy(
                labour_list,
                (x) => x.amount
              );
              if (labour_list.length > 0) {
                for (var l = 0; l < labour_list.length; l++) {
                  var quantity = 1;
                  if (labour_list[l].quantity) {
                    quantity = labour_list[l].quantity;
                  }

                  var discount_total = 0;
                  var total = 0;
                  var tax_info = await Tax.findOne({
                    tax: labour_list[l].tax,
                  }).exec();

                  var tax = [];
                  var rate = labour_list[l].rate;
                  var amount = parseFloat(labour_list[l].amount);
                  var tax_rate = tax_info.detail;
                  var base = amount;

                  if (Object.keys(package).length > 0) {
                    if (package.discount_type == "percent") {
                      discount = parseFloat(package.discount);
                      if (!isNaN(discount) && discount > 0) {
                        var discount_total = amount * (discount / 100);
                        amount = amount - parseFloat(discount_total.toFixed(2));
                        if (amount < 0) {
                          amount = 0;
                        }
                      }
                    } else if (package.discount_type == "fixed") {
                      discount = parseFloat(package.discount);
                      if (!isNaN(discount) && discount > 0) {
                        var discount_total =
                          (amount / discount_eligible_labour_cost) * discount;
                        amount = parseFloat(discount_total.toFixed(2));
                        discount = amount - discount_total;
                        if (amount < 0) {
                          amount = 0;
                        }
                      }
                    } else {
                      discount = parseFloat(package.discount);
                      if (!isNaN(discount) && discount > 0) {
                        var discount_total =
                          (amount / discount_eligible_labour_cost) * discount;
                        amount = amount - parseFloat(discount_total.toFixed(2));
                        if (amount < 0) {
                          amount = 0;
                        }
                      }
                    }
                  }

                  if (labour_list[l].amount_is_tax == "inclusive") {
                    var x = (100 + tax_info.rate) / 100;
                    var tax_on_amount = amount / x;
                    if (tax_rate.length > 0) {
                      for (var r = 0; r < tax_rate.length; r++) {
                        if (tax_rate[r].rate != tax_info.rate) {
                          var t = tax_on_amount * (tax_rate[r].rate / 100);
                          base = base - t;
                          tax.push({
                            tax: tax_rate[r].tax,
                            rate: tax_rate[r].rate,
                            amount: parseFloat(t.toFixed(2)),
                          });
                        } else {
                          var t = amount - tax_on_amount;
                          base = base - t;
                          tax.push({
                            tax: tax_info.tax,
                            tax_rate: tax_info.rate,
                            rate: tax_info.rate,
                            amount: parseFloat(t.toFixed(2)),
                          });
                        }
                      }

                      //base = base - discount_total;
                    }
                    total = total + amount;
                  }

                  var tax_details = {
                    tax: tax_info.tax,
                    rate: tax_info.rate,
                    amount: total,
                    detail: tax,
                  };

                  labours.push({
                    item: labour_list[l].item,
                    source: labour_list[l].source,
                    rate: parseFloat(labour_list[l].rate),
                    quantity: 1,
                    base: parseFloat(total.toFixed(2)),
                    discount: parseFloat(discount_total.toFixed(2)),
                    amount: total,
                    customer_dep: labour_list[l].customer_dep,
                    insurance_dep: labour_list[l].insurance_dep,
                    tax_amount: parseFloat(
                      _.sumBy(tax, (x) => x.amount).toFixed(2)
                    ),
                    amount_is_tax: labour_list[l].amount_is_tax,
                    tax: tax_info.tax,
                    tax_rate: tax_info.rate,
                    tax_info: tax_details,
                  });
                }
              }
              bookingService.push({
                service: service.service,
                labour: labours,
                labour_cost: _.sumBy(labours, (x) => x.amount),
                discount: _.sumBy(labours, (x) => x.discount),
                parts: service.parts,
                part_cost: Math.ceil(service.part_cost),
                opening_fitting: service.opening_fitting,
                of_cost: Math.ceil(service.of_cost),
                exceeded_cost: 0,
                mrp: Math.ceil(service.mrp),
                cost:
                  service.part_cost +
                  _.sumBy(labours, (x) => x.amount) +
                  service.of_cost,
                doorstep: service.doorstep,
                unit: service.unit,
                quantity: service.quantity,
                part_cost_editable: service.part_cost_editable,
                labour_cost_editable: service.labour_cost_editable,
                of_cost_editable: service.of_cost_editable,
                type: service.type,
                source: service.id,
                description: service.description,
                claim: false,
                customer_approval: true,
                surveyor_approval: false,
              });
            });

          await Detailing.find({
            service: req.body.label,
            segment: car.model.segment,
          })
            .cursor()
            .eachAsync(async (service) => {
              var getDiscount = {
                package: checkPackage._id,
                car: car._id,
                category: service.type,
                service: service.service,
                tz: req.headers["tz"],
              };

              var package = await q.all(getPackageDiscount(getDiscount));
              var labour_list = service.labour;
              var labours = [];

              var discount_eligible_labour_cost = _.sumBy(
                labour_list,
                (x) => x.amount
              );
              if (labour_list.length > 0) {
                for (var l = 0; l < labour_list.length; l++) {
                  var quantity = 1;
                  if (labour_list[l].quantity) {
                    quantity = labour_list[l].quantity;
                  }

                  var discount_total = 0;
                  var total = 0;
                  var tax_info = await Tax.findOne({
                    tax: labour_list[l].tax,
                  }).exec();

                  var tax = [];
                  var rate = labour_list[l].rate;
                  var amount = parseFloat(labour_list[l].amount);
                  var tax_rate = tax_info.detail;
                  var base = amount;

                  if (Object.keys(package).length > 0) {
                    if (package.discount_type == "percent") {
                      discount = parseFloat(package.discount);
                      if (!isNaN(discount) && discount > 0) {
                        var discount_total = amount * (discount / 100);
                        amount = amount - parseFloat(discount_total.toFixed(2));
                        if (amount < 0) {
                          amount = 0;
                        }
                      }
                    } else if (package.discount_type == "fixed") {
                      discount = parseFloat(package.discount);
                      if (!isNaN(discount) && discount > 0) {
                        var discount_total =
                          (amount / discount_eligible_labour_cost) * discount;
                        amount = parseFloat(discount_total.toFixed(2));
                        discount = amount - discount_total;
                        if (amount < 0) {
                          amount = 0;
                        }
                      }
                    } else {
                      discount = parseFloat(package.discount);
                      if (!isNaN(discount) && discount > 0) {
                        var discount_total =
                          (amount / discount_eligible_labour_cost) * discount;
                        amount = amount - parseFloat(discount_total.toFixed(2));
                        if (amount < 0) {
                          amount = 0;
                        }
                      }
                    }
                  }

                  if (labour_list[l].amount_is_tax == "inclusive") {
                    var x = (100 + tax_info.rate) / 100;
                    var tax_on_amount = amount / x;
                    if (tax_rate.length > 0) {
                      for (var r = 0; r < tax_rate.length; r++) {
                        if (tax_rate[r].rate != tax_info.rate) {
                          var t = tax_on_amount * (tax_rate[r].rate / 100);
                          base = base - t;
                          tax.push({
                            tax: tax_rate[r].tax,
                            rate: tax_rate[r].rate,
                            amount: parseFloat(t.toFixed(2)),
                          });
                        } else {
                          var t = amount - tax_on_amount;
                          base = base - t;
                          tax.push({
                            tax: tax_info.tax,
                            tax_rate: tax_info.rate,
                            rate: tax_info.rate,
                            amount: parseFloat(t.toFixed(2)),
                          });
                        }
                      }

                      //base = base - discount_total;
                    }
                    total = total + amount;
                  }

                  var tax_details = {
                    tax: tax_info.tax,
                    rate: tax_info.rate,
                    amount: total,
                    detail: tax,
                  };

                  labours.push({
                    item: labour_list[l].item,
                    source: labour_list[l].source,
                    rate: parseFloat(labour_list[l].rate),
                    quantity: 1,
                    base: parseFloat(total.toFixed(2)),
                    discount: parseFloat(discount_total.toFixed(2)),
                    amount: total,
                    customer_dep: labour_list[l].customer_dep,
                    insurance_dep: labour_list[l].insurance_dep,
                    tax_amount: parseFloat(
                      _.sumBy(tax, (x) => x.amount).toFixed(2)
                    ),
                    amount_is_tax: labour_list[l].amount_is_tax,
                    tax: tax_info.tax,
                    tax_rate: tax_info.rate,
                    tax_info: tax_details,
                  });
                }
              }
              bookingService.push({
                service: service.service,
                labour: labours,
                labour_cost: _.sumBy(labours, (x) => x.amount),
                discount: _.sumBy(labours, (x) => x.discount),
                parts: service.parts,
                part_cost: Math.ceil(service.part_cost),
                opening_fitting: service.opening_fitting,
                of_cost: Math.ceil(service.of_cost),
                exceeded_cost: 0,
                mrp: Math.ceil(service.mrp),
                cost:
                  service.part_cost +
                  _.sumBy(labours, (x) => x.amount) +
                  service.of_cost,
                doorstep: service.doorstep,
                unit: service.unit,
                quantity: service.quantity,
                part_cost_editable: service.part_cost_editable,
                labour_cost_editable: service.labour_cost_editable,
                of_cost_editable: service.of_cost_editable,
                type: service.type,
                source: service.id,
                description: service.description,
                claim: false,
                customer_approval: true,
                surveyor_approval: false,
              });
            });

          await Customization.find({
            service: req.body.label,
            model: car.model._id,
          })
            .cursor()
            .eachAsync(async (service) => {
              var getDiscount = {
                package: checkPackage._id,
                car: car._id,
                category: service.type,
                service: service.service,
                tz: req.headers["tz"],
              };

              var package = await q.all(getPackageDiscount(getDiscount));
              var labour_list = service.labour;
              var labours = [];

              var discount_eligible_labour_cost = _.sumBy(
                labour_list,
                (x) => x.amount
              );
              if (labour_list.length > 0) {
                for (var l = 0; l < labour_list.length; l++) {
                  var quantity = 1;
                  if (labour_list[l].quantity) {
                    quantity = labour_list[l].quantity;
                  }

                  var discount_total = 0;
                  var total = 0;
                  var tax_info = await Tax.findOne({
                    tax: labour_list[l].tax,
                  }).exec();

                  var tax = [];
                  var rate = labour_list[l].rate;
                  var amount = parseFloat(labour_list[l].amount);
                  var tax_rate = tax_info.detail;
                  var base = amount;

                  if (Object.keys(package).length > 0) {
                    if (package.discount_type == "percent") {
                      discount = parseFloat(package.discount);
                      if (!isNaN(discount) && discount > 0) {
                        var discount_total = amount * (discount / 100);
                        amount = amount - parseFloat(discount_total.toFixed(2));
                        if (amount < 0) {
                          amount = 0;
                        }
                      }
                    } else if (package.discount_type == "fixed") {
                      discount = parseFloat(package.discount);
                      if (!isNaN(discount) && discount > 0) {
                        var discount_total =
                          (amount / discount_eligible_labour_cost) * discount;
                        amount = parseFloat(discount_total.toFixed(2));
                        discount = amount - discount_total;
                        if (amount < 0) {
                          amount = 0;
                        }
                      }
                    } else {
                      discount = parseFloat(package.discount);
                      if (!isNaN(discount) && discount > 0) {
                        var discount_total =
                          (amount / discount_eligible_labour_cost) * discount;
                        amount = amount - parseFloat(discount_total.toFixed(2));
                        if (amount < 0) {
                          amount = 0;
                        }
                      }
                    }
                  }

                  if (labour_list[l].amount_is_tax == "inclusive") {
                    var x = (100 + tax_info.rate) / 100;
                    var tax_on_amount = amount / x;
                    if (tax_rate.length > 0) {
                      for (var r = 0; r < tax_rate.length; r++) {
                        if (tax_rate[r].rate != tax_info.rate) {
                          var t = tax_on_amount * (tax_rate[r].rate / 100);
                          base = base - t;
                          tax.push({
                            tax: tax_rate[r].tax,
                            rate: tax_rate[r].rate,
                            amount: parseFloat(t.toFixed(2)),
                          });
                        } else {
                          var t = amount - tax_on_amount;
                          base = base - t;
                          tax.push({
                            tax: tax_info.tax,
                            tax_rate: tax_info.rate,
                            rate: tax_info.rate,
                            amount: parseFloat(t.toFixed(2)),
                          });
                        }
                      }

                      //base = base - discount_total;
                    }
                    total = total + amount;
                  }

                  var tax_details = {
                    tax: tax_info.tax,
                    rate: tax_info.rate,
                    amount: total,
                    detail: tax,
                  };

                  labours.push({
                    item: labour_list[l].item,
                    source: labour_list[l].source,
                    rate: parseFloat(labour_list[l].rate),
                    quantity: 1,
                    base: parseFloat(total.toFixed(2)),
                    discount: parseFloat(discount_total.toFixed(2)),
                    amount: total,
                    customer_dep: labour_list[l].customer_dep,
                    insurance_dep: labour_list[l].insurance_dep,
                    tax_amount: parseFloat(
                      _.sumBy(tax, (x) => x.amount).toFixed(2)
                    ),
                    amount_is_tax: labour_list[l].amount_is_tax,
                    tax: tax_info.tax,
                    tax_rate: tax_info.rate,
                    tax_info: tax_details,
                  });
                }
              }
              bookingService.push({
                service: service.service,
                labour: labours,
                labour_cost: _.sumBy(labours, (x) => x.amount),
                discount: _.sumBy(labours, (x) => x.discount),
                parts: service.parts,
                part_cost: Math.ceil(service.part_cost),
                opening_fitting: service.opening_fitting,
                of_cost: Math.ceil(service.of_cost),
                exceeded_cost: 0,
                mrp: Math.ceil(service.mrp),
                cost:
                  service.part_cost +
                  _.sumBy(labours, (x) => x.amount) +
                  service.of_cost,
                doorstep: service.doorstep,
                unit: service.unit,
                quantity: service.quantity,
                part_cost_editable: service.part_cost_editable,
                labour_cost_editable: service.labour_cost_editable,
                of_cost_editable: service.of_cost_editable,
                type: service.type,
                source: service.id,
                description: service.description,
                claim: false,
                customer_approval: true,
                surveyor_approval: false,
              });
            });

          /*var pick_up_charges = 0;
                if(req.body.convenience){
                    if(req.body.convenience!="Self Drop")
                    {
                        var checkTotal = part_cost+labourCost;
                        if(checkTotal<=checkVendor.business_info.pick_up_limit)
                        {
                            pick_up_charges= Math.ceil(checkVendor.business_info.pick_up_charges);
                        }
                    }
                }*/

          var labour_cost = _.sumBy(bookingService, (x) => x.labour_cost);
          var part_cost = _.sumBy(bookingService, (x) => x.part_cost);
          var of_cost = _.sumBy(bookingService, (x) => x.of_cost);
          var discount_total = _.sumBy(bookingService, (x) => x.discount);
          var pick_up_charges = 0;
          if (req.body.charges) {
            pick_up_charges = parseFloat(req.body.charges);
          }

          var paid_total = part_cost + labour_cost + of_cost + pick_up_charges;
          var total = part_cost + labour_cost + of_cost + discount_total;

          var payment = {
            estimate_cost: paid_total,
            payment_mode: "Online",
            payment_status: "Pending",
            discount_type: "",
            coupon: "",
            coupon_type: "",
            discount: discount_total,
            discount_total: discount_total,
            terms: checkVendor.business_info.terms,
            pick_up_limit: checkVendor.business_info.pick_up_limit,
            pick_up_charges: pick_up_charges,
            part_cost: parseFloat(part_cost.toFixed(2)),
            labour_cost: parseFloat(labour_cost.toFixed(2)),
            of_cost: parseFloat(of_cost.toFixed(2)),
            paid_total: 0,
            total: parseFloat(total.toFixed(2)),
            discount_applied: false,
            transaction_id: "",
            transaction_date: "",
            transaction_status: "",
            transaction_response: "",
            policy_clause: 0,
            salvage: 0,
          };

          var due = {
            due: parseFloat(paid_total.toFixed(2)),
          };
          packageDiscountOn = [];

          var data = {
            package: checkPackage._id,
            car: checkPackage.car,
            advisor: advisor,
            business: checkPackage.business,
            user: user,
            services: bookingService,
            booking_no:
              Math.round(+new Date() / 1000) +
              Math.round(Math.random() * 9999 + 1),
            date: new Date(req.body.date).toISOString(),
            time_slot: req.body.time_slot,
            convenience: req.body.convenience,
            status: "Inactive",
            payment: payment,
            due: due,
            customer_requirements: [],
            address: req.body.address,
            is_services: true,
            created_at: new Date(),
            updated_at: new Date(),
          };

          Booking.create(data).then(async function (booking) {
            if (booking.is_services == true) {
              event.zohoLead(booking._id);
              res.status(200).json({
                responseCode: 200,
                responseMessage: "Service Request has been booked",
                responseData: booking,
              });
            } else {
              res.status(200).json({
                responseCode: 200,
                responseMessage:
                  "Package successfully purchased, Book Services Now for added benefits",
                responseData: booking,
              });
            }
          });
        } else {
          res.status(422).json({
            responseCode: 422,
            responseMessage:
              "Booking already exists for the same day. Please choose a different date or ask the advisor if anything needs to be added.",
            responseData: {},
          });
        }
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Unauthorized",
          responseData: {},
        });
      }
    }
  }
);

router.post(
  "/my/approved/services/add",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      booking: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Validation Error",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);

      var user = req.headers["business"];

      var business = req.headers["business"];
      var bookingService = [];
      var loggedInDetails = await User.findById(decoded.user).exec();
      var booking = await Booking.findOne({
        _id: req.body.booking,
        user: user,
      }).exec();
      if (booking) {
        var services = req.body.services;
        for (var i = 0; i < services.length; i++) {
          var parts_visible = true;
          var part_tax = [];
          var labour_tax = [];
          var fitting_tax = [];
          var tax_detail = {};
          if (
            typeof services[i].quantity != "number" ||
            parseInt(services[i].quantity) <= 0
          ) {
            var quantity = 1;
          } else {
            var quantity = parseInt(services[i].quantity);
          }

          var parts = services[i].parts;
          var part = [];
          if (parts.length > 0) {
            part = services[i].parts;
          } else {
            if (services[i].part_cost != 0) {
              parts_visible = false;
              var tax_info = await Tax.findOne({ tax: "0% GST" }).exec();
              var tax_rate = tax_info.detail;
              var service = services[i].service;
              var amount = Math.ceil(services[i].part_cost) * quantity;
              var base = amount;
              var part_tax = [];

              var x = (100 + tax_info.rate) / 100;
              var tax_on_amount = amount / x;
              if (tax_rate.length > 0) {
                for (var r = 0; r < tax_rate.length; r++) {
                  if (tax_rate[r].rate != tax_info.rate) {
                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                    base = base - t;
                    part_tax.push({
                      tax: tax_rate[r].tax,
                      rate: tax_rate[r].rate,
                      amount: parseFloat(t.toFixed(2)),
                    });
                  } else {
                    base = base - t;
                    part_tax.push({
                      tax: tax_info.tax,
                      tax_rate: tax_info.rate,
                      rate: tax_info.rate,
                      amount: parseFloat(tax_on_amount.toFixed(2)),
                    });
                  }
                }
              }

              tax_detail = {
                tax: tax_info.tax,
                tax_rate: tax_info.rate,
                rate: tax_info.rate,
                base: parseFloat(base.toFixed(2)),
                detail: part_tax,
              };

              part.push({
                item: services[i].service,
                hsn_sac: "",
                part_no: "",
                quantity: quantity,
                rate: parseFloat(services[i].part_cost),
                base: parseFloat(base.toFixed(2)),
                amount: parseFloat(amount),
                customer_dep: 100,
                insurance_dep: 0,
                tax_amount: _.sumBy(part_tax, (x) => x.amount),
                amount_is_tax: "inclusive",
                discount: 0,
                tax: tax_info.tax,
                tax_rate: tax_info.rate,
                tax_info: tax_detail,
              });
            }
          }

          var labours = services[i].labour;
          var labour = [];

          if (labours.length > 0) {
            labour = labours;
          } else {
            var tax_info = await Tax.findOne({ tax: "18.0% GST" }).exec();
            var tax_rate = tax_info.detail;
            var service = services[i].service;
            var amount = Math.ceil(services[i].labour_cost) * quantity;
            var base = amount;
            var labour_tax = [];

            var x = (100 + tax_info.rate) / 100;
            var tax_on_amount = amount / x;
            if (tax_rate.length > 0) {
              for (var r = 0; r < tax_rate.length; r++) {
                if (tax_rate[r].rate != tax_info.rate) {
                  var t = tax_on_amount * (tax_rate[r].rate / 100);
                  base = base - t;
                  labour_tax.push({
                    tax: tax_rate[r].tax,
                    rate: parseFloat(tax_rate[r].rate.toFixed(2)),
                    amount: parseFloat(t.toFixed(2)),
                  });
                } else {
                  base = base - t;
                  labour_tax.push({
                    tax: tax_info.tax,
                    tax_rate: tax_info.rate,
                    rate: parseFloat(tax_info.rate.toFixed(2)),
                    amount: parseFloat(tax_on_amount.toFixed(2)),
                  });
                }
              }
            }

            labour.push({
              item: services[i].service,
              quantity: quantity,
              rate: parseFloat(services[i].labour_cost),
              base: parseFloat(base.toFixed(2)),
              amount: parseFloat(amount),
              discount: 0,
              customer_dep: 100,
              insurance_dep: 0,
              amount_is_tax: "inclusive",
              tax_amount: _.sumBy(labour_tax, (x) => x.amount),
              tax: tax_info.tax,
              tax_rate: tax_info.rate,
              tax_info: {
                tax: tax_info.tax,
                tax_rate: tax_info.rate,
                rate: tax_info.rate,
                base: parseFloat(base.toFixed(2)),
                detail: labour_tax,
              },
            });
          }

          var opening_fittings = services[i].opening_fitting;
          var opening_fitting = [];

          if (opening_fittings.length > 0) {
            opening_fitting = opening_fittings;
          } else {
            if (services[i].of_cost != 0) {
              var tax_info = await Tax.findOne({ tax: "18.0% GST" }).exec();
              var tax_rate = tax_info.detail;
              var service = services[i].service;
              var amount = Math.ceil(services[i].of_cost) * quantity;
              var base = amount;
              var fitting_tax = [];

              var x = (100 + tax_info.rate) / 100;
              var tax_on_amount = amount / x;
              if (tax_rate.length > 0) {
                for (var r = 0; r < tax_rate.length; r++) {
                  if (tax_rate[r].rate != tax_info.rate) {
                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                    base = base - t;
                    fitting_tax.push({
                      tax: tax_rate[r].tax,
                      rate: tax_rate[r].rate,
                      amount: parseFloat(t.toFixed(2)),
                    });
                  } else {
                    base = base - t;
                    fitting_tax.push({
                      tax: tax_info.tax,
                      tax_rate: tax_info.rate,
                      rate: tax_info.rate,
                      amount: parseFloat(tax_on_amount.toFixed(2)),
                    });
                  }
                }
              }

              opening_fitting.push({
                item: services[i].service,
                quantity: quantity,
                rate: parseFloat(services[i].of_cost),
                base: parseFloat(base.toFixed(2)),
                discount: 0,
                amount: parseFloat(amount),
                amount_is_tax: "inclusive",
                customer_dep: 100,
                insurance_dep: 0,
                tax_amount: _.sumBy(fitting_tax, (x) => x.amount),
                tax: tax_info.tax,
                tax_rate: tax_info.rate,
                tax_info: {
                  tax: tax_info.tax,
                  tax_rate: tax_info.rate,
                  rate: tax_info.rate,
                  base: parseFloat(base.toFixed(2)),
                  detail: fitting_tax,
                },
              });
            }
          }

          bookingService.push({
            source: services[i].source,
            service: services[i].service,
            mileage: services[i].mileage,
            parts: part,
            labour: labour,
            opening_fitting: opening_fitting,
            hours: services[i].hours,
            parts_visible: parts_visible,
            quantity: quantity,
            description: services[i].description,
            part_cost: _.sumBy(part, (x) => x.amount),
            labour_cost: _.sumBy(labour, (x) => x.amount),
            of_cost: _.sumBy(opening_fitting, (x) => x.amount),
            exceeded_cost: services[i].exceeded_cost,
            cost:
              _.sumBy(part, (x) => x.amount) +
              _.sumBy(labour, (x) => x.amount) +
              _.sumBy(opening_fitting, (x) => x.amount),
            discount:
              _.sumBy(labour, (x) => x.discount) +
              _.sumBy(opening_fitting, (x) => x.discount) +
              _.sumBy(part, (x) => x.discount),
            part_cost_editable: services[i].part_cost_editable,
            labour_cost_editable: services[i].labour_cost_editable,
            of_cost_editable: services[i].of_cost_editable,
            type: services[i].type,
            customer_approval: services[i].customer_approval,
            surveyor_approval: services[i].surveyor_approval,
            claim: services[i].claim,
            custom: services[i].custom,
          });
        }

        var approved = _.filter(
          bookingService,
          (customer_approval) => customer_approval.customer_approval == true
        );
        if (approved.length > 0) {
          var policy_clause = 0;
          if (booking.payment.policy_clause) {
            policy_clause = booking.payment.policy_clause;
          }
          var salvage = 0;
          if (booking.payment.salvage) {
            salvage = booking.payment.salvage;
          }

          var paid_total = booking.payment.paid_total;
          var labour_cost = _.sumBy(bookingService, (x) => x.labour_cost);
          var part_cost = _.sumBy(bookingService, (x) => x.part_cost);
          var of_cost = _.sumBy(bookingService, (x) => x.of_cost);
          var discount_total = _.sumBy(bookingService, (x) => x.discount);
          var pick_up_charges = booking.payment.pick_up_charges;

          var payment_total =
            labour_cost +
            part_cost +
            of_cost +
            discount_total +
            policy_clause +
            salvage +
            pick_up_charges;

          var estimate_cost =
            labour_cost +
            part_cost +
            of_cost +
            policy_clause +
            salvage +
            pick_up_charges -
            careager_cash;
          var careager_cash = await q.all(
            fun.getBookingCarEagerCash(booking._id)
          );

          var due_amount =
            _.sumBy(approved, (x) => x.labour_cost) +
            _.sumBy(approved, (x) => x.part_cost) +
            _.sumBy(approved, (x) => x.of_cost) +
            policy_clause +
            salvage +
            pick_up_charges -
            (paid_total + careager_cash);

          var due = {
            due: Math.ceil(due_amount.toFixed(2)),
          };

          var payment = {
            estimate_cost: estimate_cost,
            total: parseFloat(payment_total.toFixed(2)),
            careager_cash: careager_cash,
            of_cost: parseFloat(of_cost.toFixed(2)),
            labour_cost: parseFloat(labour_cost.toFixed(2)),
            part_cost: parseFloat(part_cost.toFixed(2)),
            payment_mode: booking.payment.payment_mode,
            payment_status: booking.payment.payment_status,
            coupon: booking.payment.coupon,
            coupon_type: booking.payment.coupon_type,
            discount_by: booking.payment.discount_by,
            discount_type: booking.payment.discount_type,
            discount: booking.payment.discount,
            discount_total: discount_total,
            terms: booking.payment.terms,
            pick_up_limit: booking.payment.pick_up_limit,
            policy_clause: policy_clause,
            salvage: salvage,
            pick_up_charges: pick_up_charges,
            paid_total: booking.payment.paid_total,
            discount_applied: booking.payment.discount_applied,
            transaction_id: booking.payment.transaction_id,
            transaction_date: booking.payment.transaction_date,
            transaction_status: booking.payment.transaction_status,
            transaction_response: booking.payment.transaction_response,
          };

          if (booking.job_no == "") {
            if (booking.date && booking.time_slot) {
              var stage = "Booking";
              var status = "Confirmed";
            } else {
              var stage = "Estimation";
              var status = "Approved";
            }
          } else {
            if (booking.status != "JobOpen") {
              var stage = "";
              var status = "";
            } else {
              var stage = "In-Process";
              var status = "In-Process";
            }
          }

          Booking.findOneAndUpdate(
            { _id: booking._id },
            {
              $set: {
                services: bookingService,
                payment: payment,
                due: due,
                updated_at: new Date(),
              },
            },
            { new: false },
            async function (err, doc) {
              if (err) {
                res.status(400).json({
                  responseCode: 400,
                  responseMessage: "Error Occurred Try again",
                  responseData: err,
                });
              } else {
                if (status != "") {
                  Booking.findOneAndUpdate(
                    { _id: booking._id },
                    { $set: { status: status, updated_at: new Date() } },
                    { new: false },
                    async function (err, doc) {
                      if (err) {
                        return res.status(400).json({
                          responseCode: 400,
                          responseMessage: "Error Occurred Try again",
                          responseData: err,
                        });
                      } else {
                        var activity = {
                          user: loggedInDetails._id,
                          name: loggedInDetails.name,
                          stage: stage,
                          activity: status,
                        };

                        fun.bookingLog(booking._id, activity);
                      }
                    }
                  );
                }

                var activity = {
                  user: loggedInDetails._id,
                  name: loggedInDetails.name,
                  stage: "ServiceApproved",
                  activity: "ServiceApproved",
                };

                fun.bookingLog(booking._id, activity);

                var notify = {
                  receiver: [booking.advisor],
                  activity: "booking",
                  tag: "Approved",
                  source: booking._id,
                  sender: booking.user,
                  points: 0,
                };

                fun.newNotification(notify);

                if (booking.converted) {
                  if (booking.manager) {
                    var notify = {
                      receiver: [booking.manager],
                      activity: "booking",
                      tag: "Approved",
                      source: booking._id,
                      sender: booking.user,
                      points: 0,
                    };

                    fun.newNotification(notify);
                  }
                }
                event.jobSms(notify);

                var updated = await Booking.findById(booking.id).exec();

                res.status(200).json({
                  responseCode: 200,
                  responseMessage: "Service has been added...",
                  responseData: updated,
                });
              }
            }
          );
        } else {
          res.status(400).json({
            responseCode: 400,
            responseMessage: "Approve service before save...",
            responseData: {},
          });
        }
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Booking not found",
          responseData: {},
        });
      }
    }
  }
);

router.get(
  "/service/description/get",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      id: "required",
    };

    var validation = new Validator(req.query, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Service not mention",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      if (req.query.type == "services") {
        var data = await Service.findById(req.query.id).exec();
        if (data) {
          var description = "";
          if (data.description) {
            description = data.description;
          }
          res.status(200).json({
            responseCode: 200,
            responseMessage: description,
            responseData: {},
          });
        } else {
          res.status(200).json({
            responseCode: 200,
            responseMessage: "",
            responseData: {},
          });
        }
      } else if (req.query.type == "collision") {
        var data = await Collision.findById(req.query.id).exec();
        if (data) {
          var description = "";
          if (data.description) {
            description = data.description;
          }
          res.status(200).json({
            responseCode: 200,
            responseMessage: description,
            responseData: {},
          });
        } else {
          res.status(200).json({
            responseCode: 200,
            responseMessage: "",
            responseData: {},
          });
        }
      } else if (req.query.type == "washing") {
        var data = await Washing.findById(req.query.id).exec();
        if (data) {
          var description = "";
          if (data.description) {
            description = data.description;
          }
          res.status(200).json({
            responseCode: 200,
            responseMessage: description,
            responseData: {},
          });
        } else {
          res.status(200).json({
            responseCode: 200,
            responseMessage: "",
            responseData: {},
          });
        }
      } else if (req.query.type == "detailing") {
        var data = await Detailing.findById(req.query.id).exec();
        if (data) {
          var description = "";
          if (data.description) {
            description = data.description;
          }
          res.status(200).json({
            responseCode: 200,
            responseMessage: description,
            responseData: {},
          });
        } else {
          res.status(200).json({
            responseCode: 200,
            responseMessage: "",
            responseData: {},
          });
        }
      } else if (req.query.type == "customization") {
        var data = await Customization.findById(req.query.id).exec();
        if (data) {
          var description = "";
          if (data.description) {
            description = data.description;
          }
          res.status(200).json({
            responseCode: 200,
            responseMessage: description,
            responseData: {},
          });
        } else {
          res.status(200).json({
            responseCode: 200,
            responseMessage: "",
            responseData: {},
          });
        }
      } else if (req.query.type == "product") {
        var data = await Product.findById(req.query.id).exec();
        if (data) {
          var description = "";
          if (data.description) {
            description = data.description;
          }
          res.status(200).json({
            responseCode: 200,
            responseMessage: description,
            responseData: {},
          });
        } else {
          res.status(200).json({
            responseCode: 200,
            responseMessage: "",
            responseData: {},
          });
        }
      } else if (req.query.type == "package") {
        var data = await Package.findById(req.query.id).exec();
        if (data) {
          var description = "";
          if (data.description) {
            description = data.description;
          }
          res.status(200).json({
            responseCode: 200,
            responseMessage: description,
            responseData: {},
          });
        } else {
          res.status(200).json({
            responseCode: 200,
            responseMessage: "",
            responseData: {},
          });
        }
      } else if (req.query.type == "addOn") {
        var data = await Package.findById(req.query.id).exec();
        if (data) {
          var description = "";
          if (data.description) {
            description = data.description;
          }
          res.status(200).json({
            responseCode: 200,
            responseMessage: description,
            responseData: {},
          });
        } else {
          res.status(200).json({
            responseCode: 200,
            responseMessage: "",
            responseData: {},
          });
        }
      } else {
        res.status(422).json({
          responseCode: 422,
          responseMessage: "Invalid request",
          responseData: {},
        });
      }
    }
  }
);

router.get("/service/gallery/get", async function (req, res, next) {
  var rules = {
    id: "required",
  };

  var validation = new Validator(req.query, rules);

  if (validation.fails()) {
    res.status(422).json({
      responseCode: 422,
      responseMessage: "Service not mention",
      responseData: {
        res: validation.errors.all(),
      },
    });
  } else {
    var gallery = [];
    if (req.query.type == "services") {
      var data = await Service.findById(req.query.id).exec();
      if (data) {
        if (Object.keys(data.gallery).length > 0) {
          gallery = data.gallery;
        }
      }
    } else if (req.query.type == "collision") {
      var data = await Collision.findById(req.query.id).exec();
      if (data) {
        if (Object.keys(data.gallery).length > 0) {
          gallery = data.gallery;
        }
      }
    } else if (req.query.type == "detailing") {
      var data = await Detailing.findById(req.query.id).exec();
      if (data) {
        if (Object.keys(data.gallery).length > 0) {
          gallery = data.gallery;
        }
      }
    } else if (req.query.type == "customization") {
      var data = await Customization.findById(req.query.id).exec();
      if (data) {
        if (Object.keys(data.gallery).length > 0) {
          gallery = data.gallery;
        }
      }
    }

    if (gallery.length > 0) {
      var data = [];
      for (var i = 0; i < gallery.length; i++) {
        data.push({
          id: gallery[i]._id,
          type: gallery[i].type,
          source: req.query.id,
          file_address: gallery[i].file,
        });
      }

      res.status(200).json({
        responseCode: 200,
        responseMessage: "",
        responseData: data,
      });
    } else {
      res.status(200).json({
        responseCode: 200,
        responseMessage: "",
        responseData: {},
      });
    }
  }
});

router.post(
  "/bookings/time-slot/",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      business: "required",
      date: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Service not mention",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var business = req.body.business;
      var date = new Date(new Date(req.body.date).setHours(0, 0, 0, 0));
      var next = new Date(new Date(req.body.date).setHours(0, 0, 0, 0));
      next.setDate(date.getDate() + 1);

      var check = await BookingTiming.find({ business: business })
        .count()
        .exec();

      if (req.body.booking) {
        var booking = await Booking.findById(req.body.booking).exec();
        if (booking) {
          var body = booking.services;
          if (body.length <= 0) {
            body.push({
              type: "services",
            });
          }
        }
      } else if (req.body.label) {
        var body = await q.all(
          businessFunctions.getPackageService(req.body.label)
        );
      } else {
        var body = req.body.services;
      }

      body = _.uniqBy(body, "type");

      var slots = [];

      for (var i = 0; i < body.length; i++) {
        if (body[i].type == "addOn") {
          body[i].type = "services";
        }

        if (check > 0) {
          await BookingTiming.find({
            business: business,
            category: body[i].type,
          })
            .sort({ sort: 1 })
            .cursor()
            .eachAsync(async (timing) => {
              var slot = await Booking.find({
                time_slot: timing.slot,
                is_services: true,
                business: business,
                date: { $gte: date, $lt: next },
                services: { $elemMatch: { type: body[i].type } },
                status: {
                  $nin: [
                    "Inactive",
                    "Rejected",
                    "Cancelled",
                    "Completed",
                    "Closed",
                  ],
                },
              })
                .count()
                .exec();

              if (slot < timing.booking_per_slot) {
                slot = timing.booking_per_slot - slot;
                slots.push({
                  slot: timing.slot,
                  count: slot,
                  sort: timing.sort,
                  type: timing.category,
                  status: true,
                });
              } else {
                slots.push({
                  slot: timing.slot,
                  count: slot,
                  sort: timing.sort,
                  type: timing.category,
                  status: false,
                });
              }
            });
        } else {
          var a = await BookingTiming.find({
            business: null,
            category: body[i].type,
          }).exec();

          await BookingTiming.find({ business: null, category: body[i].type })
            .sort({ sort: 1 })
            .cursor()
            .eachAsync(async (timing) => {
              // console.log(timing)
              var slot = await Booking.find({
                time_slot: timing.slot,
                is_services: true,
                business: business,
                date: { $gte: date, $lt: next },
                services: { $elemMatch: { type: body[i].type } },
                status: {
                  $nin: [
                    "Inactive",
                    "Rejected",
                    "Cancelled",
                    "Completed",
                    "Closed",
                  ],
                },
              })
                .count()
                .exec();

              if (slot < timing.booking_per_slot) {
                slot = timing.booking_per_slot - slot;
                slots.push({
                  slot: timing.slot,
                  count: slot,
                  sort: timing.sort,
                  type: timing.category,
                  status: true,
                });
              } else {
                slots.push({
                  slot: timing.slot,
                  count: slot,
                  sort: timing.sort,
                  type: timing.category,
                  status: false,
                });
              }
            });
        }
      }

      slots = _.orderBy(slots, "count", "desc");
      slots = _.uniqBy(slots, "slot");
      slots = _.orderBy(slots, "sort", "asc");

      res.status(200).json({
        responseCode: 200,
        responseMessage: "",
        responseData: slots,
      });
    }
  }
);

router.post(
  "/booking/coupon/remove",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      id: "required",
      type: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Coupon Code is required",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var user = decoded.user;

      if (req.headers["business"]) {
        user = req.headers["business"];
      }

      var data = new Object();
      var discount = 0;
      var booking = await Booking.findById(req.body.id).exec();
      var coupon = await Coupon.findOne({
        code: req.body.coupon,
        is_product: false,
      }).exec();

      if (booking) {
        if (booking.status == "Inactive") {
          data = {
            payment: {
              payment_mode: "",
              discount_type: "",
              coupon: "",
              coupon_type: "",
              discount: 0,
              discount_total: 0,
              terms: booking.payment.terms,
              pick_up_limit: Math.ceil(booking.payment.pick_up_limit),
              pick_up_charges: Math.ceil(booking.payment.pick_up_charges),
              labour_cost: Math.ceil(booking.payment.labour_cost),
              part_cost: Math.ceil(booking.payment.part_cost),
              paid_total: Math.ceil(booking.payment.paid_total),
              total: Math.ceil(booking.payment.total),
              discount_applied: false,
              transaction_id: "",
              transaction_date: "",
              transaction_status: "",
              transaction_response: "",
            },
          };

          Booking.findOneAndUpdate(
            { _id: booking._id },
            { $set: data },
            { new: false },
            async function (err, doc) {
              if (err) {
                res.status(422).json({
                  responseCode: 422,
                  responseMessage: "Something went wrong",
                  responseData: err,
                });
              } else {
                if (req.body.type == "coupon") {
                  await CouponUsed.remove({
                    user: user,
                    booking: booking._id,
                  }).exec();
                }

                res.status(200).json({
                  responseCode: 200,
                  responseMessage: "Coupon Removed",
                  responseData: data.payment,
                });
              }
            }
          );
        } else {
          res.status(400).json({
            responseCode: 400,
            responseMessage: "Unauthorized",
            responseData: {},
          });
        }
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Booking not found",
          responseData: {},
        });
      }
    }
  }
);

router.get(
  "/booking/coupon/list",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;

    if (req.headers["business"]) {
      user = req.headers["business"];
    }

    var data = [];
    await Coupon.findOne({ is_product: false })
      .cursor()
      .eachAsync(async (coupon) => {
        if (coupon) {
          var used = await CouponUsed.findOne({ code: coupon.code, user: user })
            .count()
            .exec();
          if (used < coupon.usage_limit) {
            var serverTime = moment.tz(new Date(), req.headers["tz"]);
            var bar = moment.tz(coupon.expired_at, req.headers["tz"]);
            var baz = bar.diff(serverTime);
            //////console.log(baz);
            if (baz > 0) {
              var limit = await CouponUsed.findOne({ code: coupon.code })
                .count()
                .exec();
              if (limit < coupon.limit) {
                data.push({
                  _id: coupon._id,
                  id: coupon.id,
                  code: coupon.code,
                  limit: coupon.limit,
                  description: coupon.description,
                });
              }
            }
          }
        }
      });
    res.status(200).json({
      responseCode: 200,
      responseMessage: "Coupons",
      responseData: data,
    });
  }
);

router.get(
  "/payment/data",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;

    if (req.headers["business"]) {
      user = req.headers["business"];
    }

    var paramarray = new Object();
    var discount = 0;
    var booking = await Booking.findById(req.query.id).exec();
    var getUser = await User.findById(user).exec();
    if (booking) {
      Booking.findOneAndUpdate(
        { _id: req.query.id },
        { $set: { order_id: Math.round(+new Date() / 1000) } },
        { new: false },
        async function (err, doc) {
          if (err) {
            res.status(422).json({
              responseCode: 422,
              responseMessage: "Error Occurred",
              responseData: {},
            });
          } else {
            var booking = await Booking.findById(req.query.id).exec();
            if (booking.user == user) {
              if (booking.due) {
                var total = booking.due.due;
                total = total.toFixed(2);
              } else {
                var total = booking.payment.paid_total;
                total = total.toFixed(2);
              }

              const payload = {
                ORDER_ID: booking.order_id.toString(),
                CUST_ID: user.toString(),
                ACCESS_CODE: "AVYT82GA63AD63TYDA",
                MERCHANT_ID: "203679",
                CURRENCY: "INR",
                TXN_AMOUNT: total.toString(),
                EMAIL: getUser.email,
                MOBILE_NO: getUser.contact_no,
              };

              var token = jwt.sign(payload, secret);

              var paramarray = {
                ORDER_ID: booking.order_id.toString(),
                CUST_ID: user.toString(),
                ACCESS_CODE: "AVYT82GA63AD63TYDA",
                MERCHANT_ID: "203679",
                CURRENCY: "INR",
                TXN_AMOUNT: total.toString(),
                EMAIL: getUser.email,
                MOBILE_NO: getUser.contact_no,
                MERCHANT_PARAM1: token,
                REDIRECT_URL:
                  "http://13.233.36.16/hdfc/ccavResponseHandler.php",
                CANCEL_URL: "http://13.233.36.16/hdfc/ccavResponseHandler.php",
                RSA_KEY_URL: "http://13.233.36.16/hdfc/GetRSA.php",
              };

              res.status(200).json({
                responseCode: 200,
                responseMessage: "Payment Success",
                responseData: paramarray,
              });
            } else {
              res.status(400).json({
                responseCode: 400,
                responseMessage: "Unauthorized",
                responseData: {},
              });
            }
          }
        }
      );
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Booking Not Found",
        responseData: {},
      });
    }
  }
);

router.post("/payment/gateway/request", async function (req, res, next) {
  var booking = await Booking.findOne({ order_id: req.body.id }).exec();

  if (booking) {
    if (booking.due != null) {
      if (addZeroes(booking.due.due) == addZeroes(req.body.amount)) {
        var paid_total = booking.payment.paid_total + booking.due.due;
        var transaction = addZeroes(req.body.amount);
      } else {
        var paid_total = booking.payment.paid_total + booking.due.due;
        var transaction = addZeroes(req.body.amount);

        var status = "Failure";
        req.body.order_status = "Decline";
        req.body.status_message = "Amount tampering found";
      }
    } else {
      if (addZeroes(booking.payment.paid_total) == addZeroes(req.body.amount)) {
        var paid_total = booking.payment.paid_total;
        var transaction = addZeroes(req.body.amount);
      } else {
        var paid_total = booking.payment.paid_total;
        var transaction = addZeroes(req.body.amount);

        var status = "Failure";
        req.body.order_status = "Decline";
        req.body.status_message = "Amount tampering found";
      }
    }

    var d1 = booking.date;
    var date = new Date();
    var d2 = new Date(date.getFullYear(), date.getMonth(), date.getDate());
    var seconds = (d1.getTime() - d2.getTime()) / 1000;

    if (req.body.order_status == "Success") {
      if (seconds >= 172800) {
        var status = "Confirmed";
      } else {
        var status = "Pending";
      }

      var data = {
        status: status,
        payment: {
          payment_mode: booking.payment.payment_mode,
          payment_status: req.body.order_status,
          discount_type: booking.payment.discount_type,
          coupon: booking.payment.coupon,
          coupon_type: booking.payment.coupon_type,
          discount: booking.payment.discount,
          discount_total: booking.payment.discount_total,
          labour_cost: Math.ceil(booking.payment.labour_cost),
          part_cost: Math.ceil(booking.payment.part_cost),
          paid_total: Math.ceil(paid_total),
          total: Math.ceil(booking.payment.total),
          discount_applied: booking.payment.discount_applied,
          transaction_id: req.body.bank_ref_no,
          transaction_date: booking.payment.transaction_date,
          transaction_status: req.body.order_status,
          transaction_response: req.body.status_message,
        },
        due: {
          due: 0,
        },
        updated_at: new Date(),
      };

      Booking.findOneAndUpdate(
        { _id: booking._id },
        { $set: data },
        { new: false },
        async function (err, doc) {
          if (err) {
            res.status(422).json({
              responseCode: 422,
              responseMessage: "Error Occurred",
              responseData: {},
            });
          } else {
            fun.transactionLog(booking._id, transaction);
            event.zohoLead(booking._id);

            booking.services.forEach(async function (service) {
              if (service.type == "package") {
                var package = await Package.findOne({
                  _id: service.source,
                }).exec();
                var expired_at = new Date();
                expired_at.setDate(expired_at.getDate() + package.validity);
                var check = await UserPackage.find({
                  package: service.source,
                  category: "free",
                  user: booking.user,
                  car: booking.car,
                })
                  .count()
                  .exec();

                if (check <= 0) {
                  UserPackage.create({
                    user: booking.user,
                    car: booking.car,
                    name: package.name,
                    booking: booking._id,
                    business: booking.business,
                    description: package.description,
                    category: package.category,
                    package: package._id,
                    payment: {
                      total: service.cost,
                      paid_total: service.cost,
                    },
                    discount: package.discount,
                    validity: package.validity,
                    expired_at: expired_at,
                    created_at: new Date(),
                    updated_at: new Date(),
                  });

                  if (booking.is_services == true) {
                    Booking.update(
                      { _id: booking._id },
                      { $pull: { services: { source: service.source } } },
                      function (err, numAffected) {
                        if (err) {
                          //////////console.log(err);
                        }
                      }
                    );
                  }
                }
              }
            });

            if (booking.package) {
              var package = await UserPackage.findOne({
                _id: booking.package,
                car: booking.car,
              }).exec();
              if (package) {
                booking.services.forEach(async function (service) {
                  package.discount.forEach(async function (dis) {
                    if (dis.for == "specific") {
                      if (dis.label == service.service) {
                        PackageUsed.create({
                          package: booking.package,
                          car: booking.car,
                          user: booking.user,
                          booking: booking._id,
                          for: service.type,
                          label: service.service,
                          created_at: new Date(),
                          updated_at: new Date(),
                        });
                      }
                    } else if (dis.for == "category") {
                      if (dis.label == service.type) {
                        var cpu = await PackageUsed.find({
                          package: booking.package,
                          booking: booking._id,
                        })
                          .count()
                          .exec();
                        ////////////console.log(cpu)
                        if (cpu == 0) {
                          PackageUsed.create({
                            package: booking.package,
                            car: booking.car,
                            user: booking.user,
                            booking: booking._id,
                            for: service.type,
                            label: service.service,
                            created_at: new Date(),
                            updated_at: new Date(),
                          });
                        }
                      }
                    }
                  });
                });
              }
            }

            if (booking.payment.discount_applied == false) {
              if (booking.payment.discount_type == "coins") {
                var getCoins = await User.findById(booking.user)
                  .select("careager_cash")
                  .exec();
                var remain = getCoins.careager_cash - booking.payment.discount;

                if (booking.payment.discount > 0) {
                  var point = {
                    status: true,
                    user: booking.user,
                    activity: "booking",
                    tag: "usedInBooking",
                    points: booking.payment.discount,
                    source: booking._id,
                    created_at: new Date(),
                    updated_at: new Date(),
                    type: "debit",
                  };

                  Point.create(point).then(async function (point) {
                    User.findOneAndUpdate(
                      { _id: booking.user },
                      { $set: { careager_cash: remain } },
                      { new: false },
                      async function (err, doc) {}
                    );

                    Booking.findOneAndUpdate(
                      { _id: booking._id },
                      { $set: { "payment.discount_applied": true } },
                      { new: false },
                      async function (err, doc) {}
                    );
                  });
                }
              } else if (
                booking.payment.discount_type == "coupon" &&
                booking.payment.discount_total != 0 &&
                booking.payment.discount_total
              ) {
                var coupon = await Coupon.findOne({
                  code: booking.payment.coupon,
                }).exec();
                var used = await CouponUsed.findOne({
                  code: booking.payment.coupon,
                  user: booking.user,
                })
                  .count()
                  .exec();
                if (used == 0) {
                  CouponUsed.create({
                    coupon: coupon._id,
                    code: coupon.code,
                    booking: booking._id,
                    user: booking.user,
                    created_at: new Date(),
                    updated_at: new Date(),
                  });

                  Booking.findOneAndUpdate(
                    { _id: booking._id },
                    { $set: { "payment.discount_applied": true } },
                    { new: false },
                    async function (err, doc) {}
                  );
                }
              }
            }

            if (booking.is_services == true) {
              var notify = {
                receiver: [booking.business],
                activity: "booking",
                tag: "newBooking",
                source: booking._id,
                sender: booking.user,
                points: 0,
              };

              fun.newNotification(notify);
              event.bookingMail(booking._id);

              if (booking.advisor) {
                var advisor = await User.findById(booking.advisor).exec();
                var notify = {
                  receiver: [advisor._id],
                  activity: "booking",
                  tag: "newBooking",
                  source: booking._id,
                  sender: booking.user,
                  points: 0,
                };

                fun.newNotification(notify);
              }

              res.status(200).json({
                responseCode: 200,
                responseMessage: "Service has been booked",
                responseData: {
                  booking_no: booking.booking_no,
                  is_services: booking.is_services,
                },
              });
            } else {
              var notify = {
                receiver: [booking.business],
                activity: "package",
                tag: "newPackage",
                source: booking._id,
                sender: booking.user,
                points: 0,
              };

              fun.newNotification(notify);
              event.bookingMail(booking._id);

              res.status(200).json({
                responseCode: 200,
                responseMessage:
                  "Package successfully purchased, Book Services Now for added benefits",
                responseData: {
                  booking_no: booking.booking_no,
                  is_services: booking.is_services,
                },
              });
            }
          }
        }
      );
    } else {
      if (booking.due) {
        var data = {
          status: "Failure",
          payment: {
            payment_mode: booking.payment.payment_mode,
            payment_status: req.body.order_status,
            discount_type: booking.payment.discount_type,
            coupon: booking.payment.coupon,
            coupon_type: booking.payment.coupon_type,
            discount: booking.payment.discount,
            discount_total: booking.payment.discount_total,
            labour_cost: Math.ceil(booking.payment.labour_cost),
            part_cost: Math.ceil(booking.payment.part_cost),
            paid_total: Math.ceil(booking.payment.paid_total),
            total: Math.ceil(booking.payment.total),
            discount_applied: booking.payment.discount_applied,
            transaction_id: req.body.bank_ref_no,
            transaction_date: booking.payment.transaction_date,
            transaction_status: req.body.order_status,
            transaction_response: req.body.status_message,
          },
          due: booking.due,
        };
      } else {
        var data = {
          status: "Failure",
          payment: {
            payment_mode: booking.payment.payment_mode,
            payment_status: req.body.order_status,
            discount_type: booking.payment.discount_type,
            coupon: booking.payment.coupon,
            coupon_type: booking.payment.coupon_type,
            discount: booking.payment.discount,
            discount_total: booking.payment.discount_total,
            labour_cost: 0,
            part_cost: 0,
            paid_total: 0,
            total: 0,
            discount_applied: booking.payment.discount_applied,
            transaction_id: req.body.bank_ref_no,
            transaction_date: booking.payment.transaction_date,
            transaction_status: req.body.order_status,
            transaction_response: req.body.status_message,
          },
          due: {
            labour_cost: booking.payment.labour_cost,
            part_cost: booking.payment.part_cost,
            due: booking.payment.paid_total,
          },
        };
      }

      Booking.findOneAndUpdate(
        { _id: booking._id },
        { $set: data },
        { new: false },
        async function (err, doc) {
          fun.transactionLog(booking._id, req.body.amount);
          if (err) {
            res.status(422).json({
              responseCode: 422,
              responseMessage: "Error Occurred",
              responseData: {},
            });
          }

          if (booking.payment.discount_applied == false) {
            if (booking.payment.discount_type == "coins") {
              var getCoins = await User.findById(booking.user)
                .select("careager_cash")
                .exec();
              var remain = getCoins.careager_cash - booking.payment.discount;

              if (booking.payment.discount > 0) {
                var point = {
                  status: true,
                  user: booking.user,
                  activity: "booking",
                  tag: "usedInBooking",
                  points: booking.payment.discount,
                  source: booking._id,
                  created_at: new Date(),
                  updated_at: new Date(),
                  type: "debit",
                };

                Point.create(point).then(async function (point) {
                  User.findOneAndUpdate(
                    { _id: booking.user },
                    { $set: { careager_cash: remain } },
                    { new: false },
                    async function (err, doc) {}
                  );

                  Booking.findOneAndUpdate(
                    { _id: booking._id },
                    { $set: { "payment.discount_applied": true } },
                    { new: false },
                    async function (err, doc) {}
                  );
                });
              }
            } else if (
              booking.payment.discount_type == "coupon" &&
              booking.payment.discount_total != 0 &&
              booking.payment.discount_total
            ) {
              var coupon = await Coupon.findOne({
                code: booking.payment.coupon,
              }).exec();
              var used = await CouponUsed.findOne({
                code: booking.payment.coupon,
                user: booking.user,
              })
                .count()
                .exec();
              if (used == 0) {
                CouponUsed.create({
                  coupon: coupon._id,
                  code: coupon.code,
                  booking: booking._id,
                  user: booking.user,
                  created_at: new Date(),
                  updated_at: new Date(),
                });

                Booking.findOneAndUpdate(
                  { _id: booking._id },
                  { $set: { "payment.discount_applied": true } },
                  { new: false },
                  async function (err, doc) {}
                );
              }
            }
          }

          UserPackage.findOneAndUpdate(
            { booking: booking._id },
            { $set: { status: false, updated_at: new Date() } },
            { new: false },
            async function (err, doc) {}
          );
        }
      );

      res.status(200).json({
        responseCode: 200,
        responseMessage: "Your transaction has been declined",
        responseData: req.body,
      });
    }
  } else {
    res.status(400).json({
      responseCode: 400,
      responseMessage: "Booking not found",
      responseData: req.body,
    });
  }
});

router.get(
  "/booking/convenience",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var data = [];
    var a = null;
    var u = null;
    var c = "";
    var booking = await Booking.findById(req.query.booking).exec();
    if (booking) {
      if (booking.address) {
        a = booking.address;
      }

      if (booking.convenience) {
        c = booking.convenience;
      }
    }

    var addresses = [];
    await Address.find({ user: decoded.user })
      .cursor()
      .eachAsync(async (address) => {
        if (address._id.equals(a)) {
          var checked = true;
        } else {
          var checked = false;
        }

        addresses.push({
          _id: address._id,
          id: address.id,
          user: address.user,
          address: address.address,
          area: address.area,
          landmark: address.landmark,
          zip: address.zip,
          city: address.city,
          state: address.state,
          checked: checked,
        });
      });

    var conveniences = [];
    await BusinessConvenience.find({ business: req.query.business })
      .cursor()
      .eachAsync(async (convenience) => {
        if (convenience.convenience == c) {
          var checked = true;
        } else {
          var checked = false;
        }

        conveniences.push({
          _id: convenience._id,
          id: convenience.id,
          convenience: convenience.convenience,
          charges: convenience.charges,
          business: convenience.business,
          checked: checked,
        });
      });

    res.status(200).json({
      responseCode: 200,
      responseMessage: "",
      responseData: {
        address: addresses,
        convenience: conveniences,
      },
    });
  }
);

function addZeroes(num) {
  var num = Number(num);
  if (
    String(num).split(".").length < 2 ||
    String(num).split(".")[1].length <= 2
  ) {
    num = num.toFixed(2);
  }
  return num;
}

router.get(
  "/payment/checksum/generate",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;

    if (req.headers["business"]) {
      user = req.headers["business"];
    }

    var paramarray = new Object();
    var discount = 0;

    var checkBooking = await Booking.findById(req.query.id).exec();
    var getUser = await User.findById(user).exec();
    if (checkBooking) {
      if (req.query.pay) {
        var data = {
          due: {
            due: checkBooking.due.due,
            pay: parseFloat(req.query.pay),
          },
          order_id: Math.round(+new Date() / 1000),
          updated_at: new Date(),
        };
      } else {
        var data = {
          order_id: Math.round(+new Date() / 1000),
          updated_at: new Date(),
        };
      }

      Booking.findOneAndUpdate(
        { _id: req.query.id },
        { $set: data },
        { new: false },
        async function (err, doc) {
          if (err) {
            res.status(422).json({
              responseCode: 422,
              responseMessage: "Error Occurred",
              responseData: {},
            });
          } else {
            var booking = await Booking.findById(req.query.id).exec();
            if (booking.user == user) {
              if (booking.due) {
                if (req.query.pay) {
                  var total = booking.due.pay;
                  total = parseFloat(total.toFixed(2));
                } else {
                  var total = booking.due.due;
                  total = parseFloat(total.toFixed(2));
                }
              } else {
                var total = booking.payment.paid_total;
                total = parseFloat(total.toFixed(2));
              }

              var paramarray = {
                MID: paytm_config.MID,
                ORDER_ID: booking.order_id.toString(),
                CUST_ID: user.toString(),
                INDUSTRY_TYPE_ID: paytm_config.INDUSTRY_TYPE_ID,
                CHANNEL_ID: "WAP",
                TXN_AMOUNT: total.toString(),
                WEBSITE: paytm_config.WEBSITE,
                CALLBACK_URL:
                  paytm_config.CALLBACK +
                  "theia/paytmCallback?ORDER_ID=" +
                  booking.order_id.toString(),
                EMAIL: getUser.email,
                MOBILE_NO: getUser.contact_no,
              };

              //res.json(paramarray)

              paytm_checksum.genchecksum(
                paramarray,
                paytm_config.MERCHANT_KEY,
                function (err, data) {
                  if (err) {
                    res.status(422).json({
                      responseCode: 422,
                      responseMessage: "failure",
                      responseData: err,
                    });
                  } else {
                    res.status(200).json({
                      responseCode: 200,
                      responseMessage: "Checksum generated",
                      responseData: data,
                    });
                  }
                }
              );
            } else {
              res.status(400).json({
                responseCode: 400,
                responseMessage: "Unauthorized",
                responseData: {},
              });
            }
          }
        }
      );
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Booking Not Found",
        responseData: {},
      });
    }
  }
);

router.get(
  "/payment/transaction/status",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;

    if (req.headers["business"]) {
      user = req.headers["business"];
    }

    var paramarray = new Object();
    var discount = 0;
    var booking = await Booking.findOne({
      order_id: req.query.id,
      user: user,
    }).exec();
    var getUser = await User.findById(user).exec();
    if (booking) {
      if (booking.user == user) {
        var payment_paid_total = booking.payment.paid_total;
        if (booking.due != null) {
          if (booking.due.pay) {
            var due_pay = booking.due.pay;
            var paid_total =
              parseFloat(payment_paid_total.toFixed(2)) +
              parseFloat(due_pay.toFixed(2));
          } else {
            var payment_due = booking.due.due;
            var paid_total =
              parseFloat(payment_paid_total.toFixed(2)) +
              parseFloat(payment_due.toFixed(2));
          }
        } else {
          var paid_total = parseFloat(payment_paid_total.toFixed(2));

          User.findOneAndUpdate(
            { _id: booking.user },
            {
              $push: {
                bookings: booking._id,
              },
            },
            { new: true },
            async function (err, doc) {
              if (err) {
                ////////console.log(err)
              } else {
                //////////console.log(doc)
              }
            }
          );
        }

        var paramarray = {
          MID: paytm_config.MID,
          ORDER_ID: booking.order_id.toString(),
          CUST_ID: user.toString(),
          INDUSTRY_TYPE_ID: paytm_config.INDUSTRY_TYPE_ID,
          CHANNEL_ID: "WAP",
          TXN_AMOUNT: paid_total.toString(),
          WEBSITE: paytm_config.WEBSITE,
          CALLBACK_URL:
            paytm_config.CALLBACK +
            "theia/paytmCallback?ORDER_ID=" +
            req.query.id,
          EMAIL: getUser.email,
          MOBILE_NO: getUser.contact_no,
        };

        paytm_checksum.genchecksum(
          paramarray,
          paytm_config.MERCHANT_KEY,
          async function (err, result) {
            result["CHECKSUMHASH"] = encodeURIComponent(result["CHECKSUMHASH"]);
            var finalstring = "JsonData=" + JSON.stringify(result);
            request.post(
              {
                url:
                  paytm_config.CALLBACK +
                  "merchant-status/getTxnStatus?" +
                  finalstring,
              },
              async function (error, httpResponse, body) {
                if (error) {
                  res.status(422).json({
                    responseCode: 422,
                    responseMessage: "failure",
                    responseData: err,
                  });
                } else {
                  var paytmRes = JSON.parse(body);
                  if (paytmRes.STATUS == "TXN_SUCCESS") {
                    if (booking.sub_status != "") {
                      var stage = "In-Process";
                      var status = booking.status;
                    } else {
                      if (booking.date) {
                        var d1 = booking.date;
                        var date = new Date();
                        var d2 = new Date(
                          date.getFullYear(),
                          date.getMonth(),
                          date.getDate()
                        );
                        var seconds = (d1.getTime() - d2.getTime()) / 1000;
                        if (seconds >= 172800) {
                          var stage = "Booking";
                          var status = "Confirmed";
                        } else {
                          var stage = "Booking";
                          var status = "Pending";
                        }
                      } else {
                        var stage = "Booking";
                        var status = "Pending";
                      }
                    }

                    if (booking.due) {
                      if (booking.due.pay) {
                        var due =
                          booking.due.due - parseFloat(paytmRes.TXNAMOUNT);
                        if (due > 0) {
                          var due_info = {
                            due: Math.ceil(due.toFixed(2)),
                            pay: 0,
                          };
                        } else {
                          var due_info = null;
                        }
                      }
                    } else {
                      var due_info = null;
                    }

                    var data = {
                      status: status,
                      payment: {
                        payment_mode: booking.payment.payment_mode,
                        payment_status: "Success",
                        discount_type: booking.payment.discount_type,
                        coupon: booking.payment.coupon,
                        coupon_type: booking.payment.coupon_type,
                        discount: booking.payment.discount,
                        discount_total: booking.payment.discount_total,
                        discount_applied: booking.payment.discount_applied,
                        terms: booking.payment.terms,
                        pick_up_limit: booking.payment.pick_up_limit,
                        pick_up_charges: booking.payment.pick_up_charges,
                        labour_cost: booking.payment.labour_cost,
                        of_cost: booking.payment.of_cost,
                        part_cost: booking.payment.part_cost,
                        paid_total: paid_total,
                        total: booking.payment.total,
                        policy_clause: booking.payment.policy_clause,
                        salvage: booking.payment.salvage,
                        transaction_id: paytmRes.TXNID,
                        transaction_date: paytmRes.TXNDATE,
                        transaction_status: paytmRes.STATUS,
                        transaction_response: paytmRes.RESPMSG,
                      },
                      due: due_info,
                      updated_at: new Date(),
                    };

                    Booking.findOneAndUpdate(
                      { _id: booking._id },
                      { $set: data },
                      { new: false },
                      async function (err, doc) {
                        if (err) {
                          res.status(422).json({
                            responseCode: 422,
                            responseMessage: "Error Occurred",
                            responseData: {},
                          });
                        } else {
                          var activity = {
                            user: getUser._id,
                            name: getUser.name,
                            stage: stage,
                            activity: status,
                          };

                          fun.bookingLog(booking._id, activity);

                          fun.transactionLog(
                            booking._id,
                            parseFloat(paytmRes.TXNAMOUNT)
                          );
                          event.zohoLead(booking._id);

                          booking.services.forEach(async function (service) {
                            if (service.type == "package") {
                              var package = await Package.findOne({
                                _id: service.source,
                              }).exec();
                              var expired_at = new Date();
                              expired_at.setDate(
                                expired_at.getDate() + package.validity
                              );
                              var check = await UserPackage.find({
                                package: service.source,
                                category: "free",
                                user: booking.user,
                                car: booking.car,
                              })
                                .count()
                                .exec();

                              if (check <= 0) {
                                UserPackage.create({
                                  user: booking.user,
                                  car: booking.car,
                                  booking: booking._id,
                                  name: package.name,
                                  business: booking.business,
                                  description: package.description,
                                  category: package.category,
                                  package: package._id,
                                  payment: {
                                    total: service.cost,
                                    paid_total: service.cost,
                                  },
                                  discount: package.discount,
                                  validity: package.validity,
                                  expired_at: expired_at,
                                  created_at: new Date(),
                                  updated_at: new Date(),
                                });

                                if (package.cashback) {
                                  var point = {
                                    user: booking.user,
                                    activity: "coin",
                                    tag: "cashback",
                                    source: booking._id,
                                    sender: null,
                                    points: package.cashback,
                                    title: "",
                                    body: "",
                                    status: true,
                                  };

                                  fun.addPoints(point);
                                }
                              }
                            }
                          });

                          if (booking.package) {
                            var packageUsed = [];
                            var package = await UserPackage.findOne({
                              _id: booking.package,
                              car: booking.car,
                            }).exec();
                            if (package) {
                              booking.services.forEach(async function (
                                service
                              ) {
                                package.discount.forEach(async function (dis) {
                                  if (dis.for == "specific") {
                                    if (dis.label == service.service) {
                                      if (dis.discount > 0) {
                                        packageUsed.push({
                                          package: booking.package,
                                          car: booking.car,
                                          user: booking.user,
                                          booking: booking._id,
                                          for: service.type,
                                          label: service.service,
                                          created_at: new Date(),
                                          updated_at: new Date(),
                                        });
                                      }
                                    }
                                  } else if (dis.for == "category") {
                                    if (dis.label == service.type) {
                                      packageUsed.push({
                                        package: booking.package,
                                        car: booking.car,
                                        user: booking.user,
                                        booking: booking._id,
                                        for: service.type,
                                        label: service.type,
                                        created_at: new Date(),
                                        updated_at: new Date(),
                                      });
                                    }
                                  }
                                });
                              });

                              var packageUsed = _.uniqBy(
                                packageUsed,
                                function (o) {
                                  return o.label;
                                }
                              );

                              packageUsed.forEach(async function (p) {
                                var checkUsedPackage = await PackageUsed.find({
                                  package: p.package,
                                  booking: p.booking,
                                  label: p.label,
                                })
                                  .count()
                                  .exec();

                                if (checkUsedPackage == 0) {
                                  PackageUsed.create({
                                    package: p.package,
                                    car: p.car,
                                    user: p.user,
                                    booking: p.booking,
                                    for: p.for,
                                    label: p.label,
                                    created_at: p.created_at,
                                    updated_at: p.updated_at,
                                  });
                                }
                              });
                            }
                          }

                          if (booking.payment.discount_applied == false) {
                            if (booking.payment.discount_type == "coins") {
                              var getCoins = await User.findById(booking.user)
                                .select("careager_cash")
                                .exec();
                              var remain =
                                getCoins.careager_cash -
                                booking.payment.discount;

                              if (booking.payment.discount > 0) {
                                var point = {
                                  status: true,
                                  user: booking.user,
                                  activity: "booking",
                                  tag: "usedInBooking",
                                  points: booking.payment.discount,
                                  source: booking._id,
                                  created_at: new Date(),
                                  updated_at: new Date(),
                                  type: "debit",
                                };

                                Point.create(point).then(async function (
                                  point
                                ) {
                                  User.findOneAndUpdate(
                                    { _id: booking.user },
                                    { $set: { careager_cash: remain } },
                                    { new: false },
                                    async function (err, doc) {}
                                  );

                                  Booking.findOneAndUpdate(
                                    { _id: booking._id },
                                    {
                                      $set: {
                                        "payment.discount_applied": true,
                                      },
                                    },
                                    { new: false },
                                    async function (err, doc) {}
                                  );
                                });
                              }
                            } else if (
                              booking.payment.discount_type == "coupon" &&
                              booking.payment.discount_total != 0 &&
                              booking.payment.discount_total
                            ) {
                              var coupon = await Coupon.findOne({
                                code: booking.payment.coupon,
                              }).exec();
                              var used = await CouponUsed.findOne({
                                code: booking.payment.coupon,
                                user: booking.user,
                              })
                                .count()
                                .exec();
                              if (used == 0) {
                                CouponUsed.create({
                                  coupon: coupon._id,
                                  code: coupon.code,
                                  booking: booking._id,
                                  user: booking.user,
                                  created_at: new Date(),
                                  updated_at: new Date(),
                                });

                                Booking.findOneAndUpdate(
                                  { _id: booking._id },
                                  {
                                    $set: { "payment.discount_applied": true },
                                  },
                                  { new: false },
                                  async function (err, doc) {}
                                );
                              }
                            }
                          }

                          if (booking.is_services == true) {
                            var notify = {
                              receiver: [booking.business],
                              activity: "booking",
                              tag: "newBooking",
                              source: booking._id,
                              sender: booking.user,
                              points: 0,
                            };

                            fun.newNotification(notify);
                            event.bookingMail(booking._id);

                            if (booking.advisor) {
                              var advisor = await User.findById(
                                booking.advisor
                              ).exec();
                              var notify = {
                                receiver: [advisor._id],
                                activity: "booking",
                                tag: "newBooking",
                                source: booking._id,
                                sender: booking.user,
                                points: 0,
                              };

                              fun.newNotification(notify);
                            }

                            res.status(200).json({
                              responseCode: 200,
                              responseMessage: "Payment Done",
                              responseData: paytmRes,
                            });
                          } else {
                            var notify = {
                              receiver: [booking.business],
                              activity: "package",
                              tag: "newPackage",
                              source: booking._id,
                              sender: booking.user,
                              points: 0,
                            };

                            fun.newNotification(notify);
                            event.bookingMail(booking._id);

                            res.status(200).json({
                              responseCode: 200,
                              responseMessage:
                                "Package successfully purchased, Book Services Now for added benefits",
                              responseData: paytmRes,
                            });
                          }
                        }
                      }
                    );
                  } else {
                    var data = {
                      status: "Failure",
                      payment: {
                        careager_cash: booking.payment.careager_cash,
                        payment_mode: booking.payment.payment_mode,
                        payment_status: "Failure",
                        discount_type: booking.payment.discount_type,
                        coupon: booking.payment.coupon,
                        coupon_type: booking.payment.coupon_type,
                        discount: booking.payment.discount,
                        terms: booking.payment.terms,
                        pick_up_limit: booking.payment.pick_up_limit,
                        pick_up_charges: booking.payment.pick_up_charges,
                        discount_total: booking.payment.discount_total,
                        labour_cost: booking.payment.labour_cost,
                        of_cost: booking.payment.of_cost,
                        part_cost: booking.payment.part_cost,
                        paid_total: booking.payment.paid_total,
                        total: booking.payment.total,
                        discount_applied: booking.payment.discount_applied,
                        policy_clause: booking.payment.policy_clause,
                        salvage: booking.payment.salvage,
                        transaction_id: paytmRes.TXNID,
                        transaction_date: paytmRes.TXNDATE,
                        transaction_status: paytmRes.STATUS,
                        transaction_response: paytmRes.RESPMSG,
                        transaction_response: paytmRes.TXNAMOUNT,
                      },
                      due: {
                        due:
                          booking.payment.part_cost +
                          booking.payment.labour_cost +
                          booking.payment.of_cost +
                          booking.payment.salvage +
                          booking.payment.pick_up_charges +
                          booking.payment.policy_clause -
                          booking.payment.careager_cash,
                      },
                      updated_at: new Date(),
                    };

                    Booking.findOneAndUpdate(
                      { _id: booking._id },
                      { $set: data },
                      { new: false },
                      async function (err, doc) {
                        fun.transactionLog(
                          booking._id,
                          parseFloat(paytmRes.TXNAMOUNT)
                        );
                        if (err) {
                          res.status(422).json({
                            responseCode: 422,
                            responseMessage: "Error Occurred",
                            responseData: {},
                          });
                        }

                        if (booking.payment.discount_applied == false) {
                          if (booking.payment.discount_type == "coins") {
                            var getCoins = await User.findById(booking.user)
                              .select("careager_cash")
                              .exec();
                            var remain =
                              getCoins.careager_cash - booking.payment.discount;

                            if (booking.payment.discount > 0) {
                              var point = {
                                status: true,
                                user: booking.user,
                                activity: "booking",
                                tag: "usedInBooking",
                                points: booking.payment.discount,
                                source: booking._id,
                                created_at: new Date(),
                                updated_at: new Date(),
                                type: "debit",
                              };

                              Point.create(point).then(async function (point) {
                                User.findOneAndUpdate(
                                  { _id: booking.user },
                                  { $set: { careager_cash: remain } },
                                  { new: false },
                                  async function (err, doc) {}
                                );

                                Booking.findOneAndUpdate(
                                  { _id: booking._id },
                                  {
                                    $set: { "payment.discount_applied": true },
                                  },
                                  { new: false },
                                  async function (err, doc) {}
                                );
                              });
                            }
                          } else if (
                            booking.payment.discount_type == "coupon" &&
                            booking.payment.discount_total != 0 &&
                            booking.payment.discount_total
                          ) {
                            var coupon = await Coupon.findOne({
                              code: booking.payment.coupon,
                            }).exec();
                            var used = await CouponUsed.findOne({
                              code: booking.payment.coupon,
                              user: booking.user,
                            })
                              .count()
                              .exec();
                            if (used == 0) {
                              CouponUsed.create({
                                coupon: coupon._id,
                                code: coupon.code,
                                booking: booking._id,
                                user: booking.user,
                                created_at: new Date(),
                                updated_at: new Date(),
                              });

                              Booking.findOneAndUpdate(
                                { _id: booking._id },
                                { $set: { "payment.discount_applied": true } },
                                { new: false },
                                async function (err, doc) {}
                              );
                            }
                          }
                        }

                        event.zohoLead(booking._id);
                      }
                    );

                    res.status(200).json({
                      responseCode: 200,
                      responseMessage: "Your transaction has been declined",
                      responseData: paytmRes,
                    });
                  }
                }
              }
            );
          }
        );
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Unauthorized",
          responseData: {},
        });
      }
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Booking Not Found",
        responseData: {},
      });
    }
  }
);

router.post(
  "/payment/gateway/response",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      id: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Error",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var user = decoded.user;

      if (req.headers["business"]) {
        user = req.headers["business"];
      }

      var booking = await Booking.findById(req.body.id).exec();

      if (booking) {
        var transaction = await TransactionLog.findOne({ source: booking._id })
          .sort({ created_at: -1 })
          .exec();
        if (
          booking.payment.payment_status == "Success" ||
          booking.payment.payment_status == "success"
        ) {
          res.status(200).json({
            responseCode: 200,
            responseMessage: "Payment Done",
            responseData: {
              booking_no: booking.booking_no,
              payment: transaction,
              is_services: booking.is_services,
            },
          });
        } else {
          res.status(200).json({
            responseCode: 200,
            responseMessage: "Payment Failure",
            responseData: {
              booking_no: booking.booking_no,
              payment: transaction,
              is_services: booking.is_services,
            },
          });
        }
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Booking not found",
          responseData: {},
        });
      }
    }
  }
);

router.post(
  "/payment/gateway/tampering",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      id: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Error",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var booking = await Booking.findOne({ _id: req.body.id }).exec();

      if (booking) {
        var data = {
          status: "Failure",
          payment: {
            payment_mode: booking.payment.payment_mode,
            payment_status: req.body.order_status,
            discount_type: booking.payment.discount_type,
            coupon: booking.payment.coupon,
            coupon_type: booking.payment.coupon_type,
            terms: booking.payment.terms,
            pick_up_limit: booking.payment.pick_up_limit,
            pick_up_charges: booking.payment.pick_up_charges,
            discount: booking.payment.discount,
            discount_total: booking.payment.discount_total,
            labour_cost: booking.payment.labour_cost,
            part_cost: booking.payment.part_cost,
            paid_total: 0,
            //paid_total: booking.payment.paid_total,
            total: booking.payment.total,
            discount_applied: booking.payment.discount_applied,
            transaction_id: req.body.bank_ref_no,
            transaction_date: booking.payment.transaction_date,
            transaction_status: req.body.order_status,
            transaction_response: req.body.status_message,
          },
          due: booking.due,
        };

        Booking.findOneAndUpdate(
          { _id: booking._id },
          { $set: data },
          { new: false },
          async function (err, doc) {
            fun.transactionLog(booking._id, req.body.amount);
            if (err) {
              res.status(422).json({
                responseCode: 422,
                responseMessage: "Error Occurred",
                responseData: {},
              });
            }

            if (booking.payment.discount_applied == false) {
              if (booking.payment.discount_type == "coins") {
                var getCoins = await User.findById(booking.user)
                  .select("careager_cash")
                  .exec();
                var remain = getCoins.careager_cash - booking.payment.discount;

                if (booking.payment.discount > 0) {
                  var point = {
                    status: true,
                    user: booking.user,
                    activity: "booking",
                    tag: "usedInBooking",
                    points: booking.payment.discount,
                    source: booking._id,
                    created_at: new Date(),
                    updated_at: new Date(),
                    type: "debit",
                  };

                  Point.create(point).then(async function (point) {
                    User.findOneAndUpdate(
                      { _id: booking.user },
                      { $set: { careager_cash: remain } },
                      { new: false },
                      async function (err, doc) {}
                    );

                    Booking.findOneAndUpdate(
                      { _id: booking._id },
                      { $set: { "payment.discount_applied": true } },
                      { new: false },
                      async function (err, doc) {}
                    );
                  });
                }
              } else if (
                booking.payment.discount_type == "coupon" &&
                booking.payment.discount_total != 0 &&
                booking.payment.discount_total
              ) {
                var coupon = await Coupon.findOne({
                  code: booking.payment.coupon,
                }).exec();
                var used = await CouponUsed.findOne({
                  code: booking.payment.coupon,
                  user: booking.user,
                })
                  .count()
                  .exec();
                if (used == 0) {
                  CouponUsed.create({
                    coupon: coupon._id,
                    code: coupon.code,
                    booking: booking._id,
                    user: booking.user,
                    created_at: new Date(),
                    updated_at: new Date(),
                  });

                  Booking.findOneAndUpdate(
                    { _id: booking._id },
                    { $set: { "payment.discount_applied": true } },
                    { new: false },
                    async function (err, doc) {}
                  );
                }
              }

              var checkPackage = UserPackage.findOne({
                booking: booking.id,
              }).exec();
              if (checkPackage) {
                UserPackage.findOneAndUpdate(
                  { booking: booking._id },
                  { $set: { status: false, updated_at: new Date() } },
                  { new: false },
                  async function (err, doc) {}
                );
              }
            }

            //event.zohoLead(booking._id);
          }
        );

        res.status(200).json({
          responseCode: 200,
          responseMessage: "Your transaction has been declined",
          responseData: req.body,
        });
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Booking not found",
          responseData: req.body,
        });
      }
    }
  }
);

router.post("/pay/later", xAccessToken.token, async function (req, res, next) {
  var rules = {
    id: "required",
  };

  var validation = new Validator(req.body, rules);

  if (validation.fails()) {
    res.status(422).json({
      responseCode: 422,
      responseMessage: "Error",
      responseData: {
        res: validation.errors.all(),
      },
    });
  } else {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;

    if (req.headers["business"]) {
      user = req.headers["business"];
    }

    var loggedInDetails = await User.findById(user).exec();
    var booking = await Booking.findById(req.body.id).exec();
    var coupon = await Coupon.findOne({ code: req.body.coupon }).exec();

    if (booking) {
      var package = _.filter(
        booking.services,
        (type) => type.type == "package"
      );

      if (Object.keys(package).length <= 0) {
        var d1 = booking.date;
        var date = new Date();
        var d2 = new Date(date.getFullYear(), date.getMonth(), date.getDate());
        var seconds = (d1.getTime() - d2.getTime()) / 1000;
        //////////console.log(seconds)
        if (seconds >= 172800) {
          var status = "Confirmed";
        } else {
          var status = "Pending";
        }

        var data = {
          status: status,
          updated_at: new Date(),
        };

        Booking.findOneAndUpdate(
          { _id: req.body.id },
          { $set: data },
          { new: false },
          async function (err, doc) {
            if (err) {
              res.status(422).json({
                responseCode: 422,
                responseMessage: "Error Occurred",
                responseData: {},
              });
            } else {
              User.findOneAndUpdate(
                { _id: booking.user },
                {
                  $push: {
                    bookings: booking._id,
                  },
                },
                { new: true },
                async function (err, doc) {
                  if (err) {
                    ////////console.log(err)
                  } else {
                    //////////console.log(doc)
                  }
                }
              );

              var activity = {
                user: loggedInDetails._id,
                name: loggedInDetails.name,
                stage: "Booking",
                activity: status,
              };

              fun.bookingLog(booking._id, activity);

              booking.services.forEach(async function (service) {
                if (service.type == "package") {
                  var package = await Package.findOne({
                    _id: service.source,
                  }).exec();
                  var expired_at = new Date();
                  expired_at.setDate(expired_at.getDate() + package.validity);
                  var check = await UserPackage.find({
                    package: service.source,
                    category: "free",
                    user: user,
                    car: booking.car,
                  })
                    .count()
                    .exec();

                  if (check <= 0) {
                    UserPackage.create({
                      user: user,
                      car: booking.car,
                      name: package.name,
                      booking: booking._id,
                      business: booking.business,
                      description: package.description,
                      category: package.category,
                      package: package._id,
                      payment: {
                        total: service.cost,
                        paid_total: service.cost,
                      },
                      discount: package.discount,
                      validity: package.validity,
                      expired_at: expired_at,
                      created_at: new Date(),
                      updated_at: new Date(),
                    });

                    if (booking.is_services == true) {
                      Booking.update(
                        { _id: booking._id },
                        { $pull: { services: { source: service.source } } },
                        function (err, numAffected) {
                          if (err) {
                            //////////console.log(err);
                          }
                        }
                      );
                    }
                  }
                }
              });

              if (booking.package) {
                var packageUsed = [];
                var package = await UserPackage.findOne({
                  _id: booking.package,
                  car: booking.car,
                }).exec();
                if (package) {
                  booking.services.forEach(async function (service) {
                    package.discount.forEach(async function (dis) {
                      if (dis.for == "specific") {
                        if (dis.label == service.service) {
                          if (dis.discount > 0) {
                            packageUsed.push({
                              source: service.source,
                              package: booking.package,
                              car: booking.car,
                              user: booking.user,
                              booking: booking._id,
                              for: service.type,
                              label: service.service,
                              created_at: new Date(),
                              updated_at: new Date(),
                            });
                          }
                        }
                      } else if (dis.for == "category") {
                        if (dis.label == service.type) {
                          if (dis.discount > 0) {
                            packageUsed.forEach(async function (c) {
                              if (c.source != service.source) {
                                packageUsed.push({
                                  source: service.source,
                                  package: booking.package,
                                  car: booking.car,
                                  user: booking.user,
                                  booking: booking._id,
                                  for: service.type,
                                  label: service.type,
                                  created_at: new Date(),
                                  updated_at: new Date(),
                                });
                              }
                            });
                          }
                        }
                      }
                    });
                  });

                  var packageUsed = _.uniqBy(packageUsed, function (o) {
                    return o.label;
                  });

                  //////////console.log(packageUsed)

                  packageUsed.forEach(async function (p) {
                    var check = await PackageUsed.find({
                      package: p.package,
                      car: p.car,
                      user: p.user,
                      booking: p.booking,
                      label: p.label,
                    })
                      .count()
                      .exec();
                    if (check == 0) {
                      PackageUsed.create({
                        package: p.package,
                        car: p.car,
                        user: p.user,
                        booking: p.booking,
                        for: p.for,
                        label: p.label,
                        created_at: p.created_at,
                        updated_at: p.updated_at,
                      });
                    }
                  });
                }
              }

              if (booking.payment.careager_cash > 0) {
                var point = {
                  user: booking.user,
                  activity: "booking",
                  tag: "booking",
                  title: "",
                  body: "",
                  points: booking.payment.careager_cash,
                  status: true,
                };

                fun.deductPoints(point);
              } else if (
                booking.payment.discount_type == "coupon" &&
                booking.payment.discount_total != 0 &&
                booking.payment.discount_total
              ) {
                var coupon = await Coupon.findOne({
                  code: booking.payment.coupon,
                }).exec();

                CouponUsed.create({
                  coupon: coupon._id,
                  code: coupon.code,
                  booking: booking._id,
                  user: user,
                  created_at: new Date(),
                  updated_at: new Date(),
                });
              }

              if (booking.is_services == true) {
                var notify = {
                  receiver: [booking.business],
                  activity: "booking",
                  tag: "newBooking",
                  source: booking._id,
                  sender: user,
                  points: 0,
                };

                fun.newNotification(notify);
                event.bookingMail(booking._id);

                if (booking.advisor) {
                  var advisor = await User.findById(booking.advisor).exec();
                  var notify = {
                    receiver: [advisor._id],
                    activity: "booking",
                    tag: "newBooking",
                    source: booking._id,
                    sender: user,
                    points: 0,
                  };

                  fun.newNotification(notify);
                }

                res.status(200).json({
                  responseCode: 200,
                  responseMessage: "Service has been booked",
                  responseData: {
                    booking_no: booking.booking_no,
                    is_services: booking.is_services,
                  },
                });
              } else {
                var notify = {
                  receiver: [booking.business],
                  activity: "package",
                  tag: "newPackage",
                  source: booking._id,
                  sender: user,
                  points: 0,
                };

                fun.newNotification(notify);
                event.bookingMail(booking._id);

                res.status(200).json({
                  responseCode: 200,
                  responseMessage:
                    "Package successfully purchased, Book Services Now for added benefits",
                  responseData: {
                    booking_no: booking.booking_no,
                    is_services: booking.is_services,
                  },
                });
              }
            }
          }
        );
      } else {
        res.status(422).json({
          responseCode: 422,
          responseMessage: "'Pay Later' is not applicable for packages.",
          responseData: {},
        });
      }
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Booking not found",
        responseData: {},
      });
    }
  }
});

router.get("/wallet/get", xAccessToken.token, async function (req, res, next) {
  var token = req.headers["x-access-token"];
  var secret = config.secret;
  var decoded = jwt.verify(token, secret);
  var user = decoded.user;
  if (req.headers["business"]) {
    user = req.headers["business"];
  }
  var points = [];
  var total = 0,
    used = 0;
  var unused = await User.findOne({ _id: user })
    .select("careager_cash referral_code")
    .exec();
  await Point.find({ user: user })
    .sort({ created_at: -1 })
    .cursor()
    .eachAsync(async (point) => {
      if (point.type == "credit") {
        total = total + point.points;
      }

      if (point.type == "debit") {
        used = used + point.points;
      }

      if (point.tag == "commission") {
        var booking = await Booking.findById(point.source)
          .populate({
            path: "user",
            populate: { path: "user", select: "_id id name contact_no" },
          })
          .exec();
        if (booking) {
          var booking_no = booking.booking_no;
          if (booking.user) {
            var name = booking.user.name;
          } else {
            var booking_no = "";
            var name = "";
          }
        } else {
          var booking_no = "";
          var name = "";
        }
        var tag = "Commission - " + name + " - #" + booking_no;
      } else if (point.tag == "referNEarn") {
        var user = await User.findById(point.source).exec();
        var tag = "Refer & Earn - " + user.name;
      } else {
        var tag = _.startCase(point.tag);
      }

      points.push({
        _id: point._id,
        points: Math.ceil(point.points),
        type: point.type,
        tag: tag,
        status: point.status,
        activity: _.startCase(point.activity),
        user: point.user,
        month: moment(point.created_at)
          .tz(req.headers["tz"])
          .format("MMMM YYYY"),
        created_at: moment(point.created_at).tz(req.headers["tz"]).format("Do"),
        updated_at: moment(point.updated_at).tz(req.headers["tz"]).format("Do"),
      });
    });

  var group = _(points)
    .groupBy((x) => x.month)
    .map((value, key) => ({ month: key, transaction: value }))
    .value();

  var uu = unused.careager_cash;

  res.status(200).json({
    responseCode: 200,
    responseMessage: "success",
    responseData: {
      total: Math.ceil(total),
      used: Math.ceil(used),
      unused: Math.ceil(uu),
      referral_code: unused.referral_code,
      total_refferal: await Referral.find({ owner: user }).count(),
      list: group,
    },
  });
});

router.put(
  "/my/booking/reschedule/",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      id: "required",
      date: "required",
      time_slot: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Error",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      if (req.body.package == "") {
        req.body.package = null;
      }

      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var user = req.headers["business"];
      var total = 0;
      var labour_cost = 0;
      var part_cost = 0;
      var bookingService = [];
      var services = req.body.services;
      var loggedInDetails = await User.findById(user).exec();

      var booking = await Booking.findOne({
        _id: req.body.id,
        user: user,
        is_services: true,
      }).exec();

      if (booking) {
        var d1 = new Date(req.body.date);
        var date = new Date();
        var d2 = new Date(date.getFullYear(), date.getMonth(), date.getDate());
        var seconds = (d1.getTime() - d2.getTime()) / 1000;
        //////console.log(seconds)
        if (seconds >= 172800) {
          var status = "Confirmed";
        } else {
          var status = "Pending";
        }

        var data = {
          date: new Date(req.body.date).toISOString(),
          time_slot: req.body.time_slot,
          status: status,
          updated_at: new Date(),
        };

        Booking.findOneAndUpdate(
          { _id: booking._id },
          { $set: data },
          { new: false },
          async function (err, doc) {
            if (err) {
              var json = {
                responseCode: 400,
                responseMessage: "Error occured",
                responseData: {},
              };
              res.status(400).json(json);
            } else {
              if (loggedInDetails.account_info.type == "user") {
                var notify = {
                  receiver: [booking.business],
                  activity: "booking",
                  tag: "bookingReschedule",
                  source: booking._id,
                  sender: user,
                  points: 0,
                  tz: req.headers["tz"],
                };
                fun.newNotification(notify);
                var activity = {
                  user: loggedInDetails._id,
                  name: loggedInDetails.name,
                  stage: "Booking",
                  activity: "BookingReschedule",
                };

                fun.bookingLog(booking._id, activity);
              } else {
                var notify = {
                  receiver: [booking.user],
                  activity: "booking",
                  tag: "bookingReschedule",
                  source: booking._id,
                  sender: user,
                  points: 0,
                  tz: req.headers["tz"],
                };
                fun.newNotification(notify);

                var activity = {
                  user: loggedInDetails._id,
                  name: loggedInDetails.name,
                  stage: "Booking",
                  activity: "BookingReschedule",
                };

                fun.bookingLog(booking._id, activity);
              }

              event.rescheduleMail(
                booking._id,
                loggedInDetails.account_info.type
              );

              var activity = {
                user: user,
                model: "Booking",
                activity: "bookingReschedule",
                source: booking._id,
                modified:
                  moment(booking.date).tz(req.headers["tz"]).format("ll") +
                  " (" +
                  booking.time_slot +
                  ")" +
                  " to " +
                  moment(data.date).tz(req.headers["tz"]).format("ll") +
                  " (" +
                  data.time_slot +
                  ")",
                created_at: data.updated_at,
                updated_at: data.updated_at,
              };
              fun.bookingLog(activity);

              var json = {
                responseCode: 200,
                responseMessage: "Booking rescheduled",
                responseData: {
                  date: moment(data.date).tz(req.headers["tz"]).format("ll"),
                  time_slot: data.time_slot,
                  updated_at: data.updated_at,
                },
              };
              res.status(200).json(json);
            }
          }
        );
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Unauthorized",
          responseData: {},
        });
      }
    }
  }
);

router.put(
  "/my/booking/status",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      id: "required",
      status: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Error",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var user = req.headers["business"];
      if (req.body.status == "Cancelled" || req.body.status == "Confirmed") {
        var check = await Booking.findOne({
          _id: req.body.id,
          user: user,
          is_services: true,
        }).exec();
      }

      var getUser = await User.findById(user).exec();

      if (!check) {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Unauthorized",
          responseData: {},
        });
      } else {
        var status = check.status;
        var data = {
          status: req.body.status,
          updated_at: new Date(),
        };

        Booking.findOneAndUpdate(
          { _id: req.body.id },
          { $set: data },
          { new: true },
          async function (err, doc) {
            if (err) {
              var json = {
                responseCode: 422,
                responseMessage: "Error occured",
                responseData: {},
              };

              res.status(422).json(json);
            } else {
              var booking = await Booking.findOne({ _id: check._id }).exec();
              var activity = {
                user: user,
                model: "Booking",
                activity: "updateBookingStatus",
                source: booking._id,
                modified: check.status + " to " + data.status,
                created_at: data.updated_at,
                updated_at: data.updated_at,
              };

              fun.bookingLog(activity);

              event.zohoLead(booking._id);

              if (booking.payment.careager_cash > 0) {
                var point = {
                  status: true,
                  user: user,
                  activity: "coin",
                  tag: "BookingCancelled",
                  points: booking.payment.careager_cash,
                  source: booking._id,
                  title: "",
                  body: "",
                  sender: null,
                };
                fun.addPoints(point);
              }

              if (booking.package) {
                var package = await UserPackage.findOne({
                  _id: booking.package,
                  user: user,
                  car: booking.car,
                }).exec();
                if (package) {
                  var checkPackageUsed = await PackageUsed.find({
                    package: booking.package,
                    user: user,
                    booking: booking._id,
                    car: booking.car,
                  })
                    .count()
                    .exec();

                  if (checkPackageUsed > 0) {
                    await PackageUsed.remove({
                      package: booking.package,
                      user: user,
                      booking: booking._id,
                      car: booking.car,
                    }).exec();
                  }
                }
              }

              if (booking.payment.coupon) {
                var checkCouponUsed = await CouponUsed.find({
                  user: user,
                  booking: booking._id,
                })
                  .count()
                  .exec();
                if (checkCouponUsed > 0) {
                  await CouponUsed.remove({
                    user: user,
                    booking: booking._id,
                  }).exec();
                }
              }

              Booking.findOneAndUpdate(
                { _id: req.body.id },
                { $set: { due: { due: 0 } } },
                { new: true },
                async function (err, doc) {}
              );

              var notify = {
                receiver: [booking.advisor],
                activity: "booking",
                tag: "userCancelledBooking",
                source: booking._id,
                sender: user,
                points: 0,
              };

              fun.newNotification(notify);

              if (booking.converted) {
                if (booking.manager) {
                  var notify = {
                    receiver: [booking.manager],
                    activity: "booking",
                    tag: "userCancelledBooking",
                    source: booking._id,
                    sender: user,
                    points: 0,
                  };
                  fun.newNotification(notify);
                }
              }
            }

            event.zohoLead(booking._id);

            var json = {
              responseCode: 200,
              responseMessage: "Booking has been " + booking.status,
              responseData: {},
            };
            res.status(200).json(json);
          }
        );
      }
    }
  }
);

router.get(
  "/my/bookings/get",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    var user = req.headers["business"];
    var orders = [];

    var country = await Country.findOne({
      timezone: { $in: req.headers["tz"] },
    }).exec();

    if (req.query.page == undefined) {
      var page = 0;
    } else {
      var page = req.query.page;
    }

    var page = Math.max(0, parseInt(page));

    var sortBy = new Object();

    if (req.query.sortBy) {
      if (req.query.sortBy == "date") {
        sortBy = { date: -1 };
      }
    } else {
      sortBy = { created_at: -1 };
    }

    var thumbnail = [];

    await Booking.find({
      user: user,
      status: {
        $in: [
          "Cancelled",
          "Confirmed",
          "Pending",
          "Rejected",
          "Closed",
          "Completed",
          "Failure",
          "In-Process",
          "Dissatisfied",
          "Approval",
          "Approved",
          "Failed",
          "JobInitiated",
          "JobOpen",
          "EstimateRequested",
          "ApprovalAwaited",
          "StartWork",
          "CloseWork",
          "CompleteWork",
          "QC",
          "StoreApproval",
          "GMApproval",
          "Rework",
          "Ready",
        ],
      },
      is_services: true,
    })
      .populate({
        path: "business",
        populate: { path: "user", select: "_id id name contact_no" },
      })
      .populate({
        path: "car",
        select: "_id id title registration_no ic rc",
        populate: { path: "thumbnails" },
      })
      .sort(sortBy)
      .skip(config.perPage * page)
      .limit(config.perPage)
      .cursor()
      .eachAsync(async (booking) => {
        var car = null;
        var address = await Address.findOne({ _id: booking.address }).exec();
        if (booking.car) {
          var thumbnail = [];
          if (booking.car.thumbnails[0]) {
            var thumbnail = [booking.car.thumbnails[0]];
          }

          car = {
            title: booking.car.title,
            _id: booking.car._id,
            id: booking.car.id,
            ic: booking.car.ic,
            rc: booking.car.rc,
            ic_address: booking.car.ic_address,
            rc_address: booking.car.rc_address,
            registration_no: booking.car.registration_no,
            thumbnails: thumbnail,
          };
        }

        orders.push({
          _id: booking._id,
          id: booking._id,
          car: car,
          business: {
            name: booking.business.name,
            _id: booking.business._id,
            id: booking.business.id,
            contact_no: booking.business.contact_no,
          },
          services: booking.services,
          convenience: booking.convenience,
          date: moment(booking.date).tz(req.headers["tz"]).format("ll"),
          time_slot: booking.time_slot,
          status: booking.status,
          booking_no: booking.booking_no,
          job_no: booking.job_no,
          payment: booking.payment,
          due: booking.due,
          address: address,
          txnid: booking.txnid,
          __v: booking.__v,
          address: address,
          created_at: booking.updated_at,
          updated_at: booking.updated_at,
          listing: "booking",
        });
      });

    res.status(200).json({
      responseCode: 200,
      responseMessage: country.countryName,
      responseData: orders,
      responseInfo: {
        totalResult: await Booking.find({
          user: user,
          status: {
            $in: [
              "Cancelled",
              "Confirmed",
              "Pending",
              "Rejected",
              "Closed",
              "Completed",
              "Failure",
              "In-Process",
              "Dissatisfied",
              "Approval",
              "Approved",
              "Failed",
              "JobInitiated",
              "JobOpen",
              "EstimatePrepared",
              "ApprovalAwaited",
              "StartWork",
              "CloseWork",
              "CompleteWork",
              "QC",
              "StoreApproval",
              "GMApproval",
              "Rework",
              "Ready",
            ],
          },
          is_services: true,
        })
          .count()
          .exec(),
      },
    });
  }
);

router.post("/car/add", xAccessToken.token, async function (req, res, next) {
  var token = req.headers["x-access-token"];
  var secret = config.secret;
  var decoded = jwt.verify(token, secret);

  var business = req.headers["business"];

  var limit = await q.all(businessPlanLimit(business, req.headers["tz"]));

  var added = await Car.find({ user: business, status: true }).count().exec();
  if (limit) {
    if (limit.cars > added) {
      var result = new Object();
      var userInfo = await User.findById(business).exec();
      var currentDate = new Date();
      var variant = await Variant.findOne({ _id: req.body.variant })
        .populate("model")
        .select("-service_schedule")
        .exec();
      var rg = req.body.registration_no;
      req.body.registration_no = rg.replace(/ /g, "");

      if (variant != null && variant) {
        var reg = await Car.find({
          registration_no: req.body.registration_no,
          status: true,
        })
          .count()
          .exec();
        if (reg == 0) {
          var count = await Car.find({}).count().exec();

          if (
            req.body.longitude != undefined ||
            (req.body.longitude != null && req.body.latitude != undefined) ||
            req.body.latitude != null
          ) {
            req.body.geometry = [req.body.longitude, req.body.latitude];
          } else {
            req.body.geometry = [0, 0];
          }

          var automaker = await Automaker.findById(
            variant.model.automaker
          ).exec();

          req.body.created_at = currentDate;
          req.body.updated_at = currentDate;

          req.body.title = variant.variant;
          req.body._variant = variant.value;
          req.body.automaker = variant.model.automaker;
          req.body._automaker = automaker.maker;
          req.body.model = variant.model._id;
          req.body._model = variant.model.value;
          req.body.segment = variant.model.segment;
          req.body.user = business;
          req.body.fuel_type = variant.specification.fuel_type;
          req.body.transmission = variant.specification.type;
          (req.body.carId =
            Math.round(+new Date() / 1000) +
            Math.round(Math.random() * 9999 + 1)),
            Car.create(req.body).then(async function (car) {
              User.findOneAndUpdate(
                { _id: business },
                {
                  $push: {
                    cars: car._id,
                  },
                },
                { new: true },
                async function (err, doc) {
                  if (err) {
                    //////console.log(err)
                  } else {
                    //////console.log(err)
                  }
                }
              );

              //fun.addMember(b,variant.model);

              await Car.find({ _id: car._id })
                .populate("bookmark")
                .populate("thumbnails")
                .populate({
                  path: "user",
                  select: "name username avatar avatar_address address",
                })
                .populate({ path: "variant", populate: { path: "model" } })
                .cursor()
                .eachAsync(async (doc) => {
                  result = {
                    __v: 0,
                    _id: doc._id,
                    id: doc.id,
                    title: doc.title,
                    variant: doc.variant._id,
                    model: doc.model,
                    modelName: doc.variant.model.model,
                    price: price(doc.price),
                    numericPrice: doc.price,
                    accidental: doc.accidental,
                    body_style: doc.body_style,
                    description: doc.description,
                    driven: doc.driven,
                    carId: doc.carId,
                    fuel_type: doc.fuel_type,
                    insurance_info: doc.insurance_info,
                    location: doc.location,
                    manufacture_year: doc.manufacture_year,
                    mileage: doc.mileage,
                    owner: doc.owner,
                    registration_no: doc.registration_no,
                    service_history: doc.service_history,
                    transmission: doc.transmission,
                    vehicle_color: doc.vehicle_color,
                    vehicle_status: doc.vehicle_status,
                    geometry: doc.geometry,
                    publish: doc.publish,
                    status: doc.status,
                    premium: doc.premium,
                    is_bookmarked: doc.is_bookmarked,
                    thumbnails: doc.thumbnails,
                    user: doc.user,
                    created_at: doc.created_at,
                    updated_at: doc.updated_at,
                  };
                });

              res.status(200).json({
                responseCode: 200,
                responseMessage: "Car has been added",
                responseData: {
                  item: result,
                },
              });
            });
        } else {
          res.status(422).json({
            responseCode: 422,
            responseMessage: "Registration no already exist",
            responseData: {},
          });
        }
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Unprocessable Entity",
          responseData: {},
        });
      }
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Limit Exceed!",
        responseData: {},
      });
    }
  } else {
    res.status(400).json({
      responseCode: 400,
      responseMessage: "Plan expired",
      responseData: {},
    });
  }
});

router.put("/car/edit", xAccessToken.token, async function (req, res, next) {
  var rules = {
    car: "required",
  };

  var validation = new Validator(req.body, rules);

  if (validation.fails()) {
    res.status(422).json({
      responseCode: 422,
      responseMessage: "Car is required",
      responseData: {},
    });
  } else {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    var user = req.headers["business"];
    var result;

    var loggedInDetails = await User.findOne({ _id: decoded.user }).exec();
    var car = await Car.findOne({ _id: req.body.car, user: user })
      .populate("user")
      .exec();
    var variant = await Variant.findOne({ _id: req.body.variant })
      .populate("model")
      .select("-service_schedule")
      .exec();
    if (car) {
      var rg = req.body.registration_no;
      req.body.registration_no = rg.replace(/ /g, "");

      var check_rn = await Car.findOne({
        _id: { $ne: car._id },
        registration_no: req.body.registration_no,
        status: true,
      }).exec();

      if (check_rn) {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Car registration no already exist",
          responseData: {},
        });
      } else {
        if (variant) {
          var automaker = await Automaker.findById(
            variant.model.automaker
          ).exec();

          var publish = false;
          if (req.body.publish == true) {
            publish = true;
          }

          if (car.user.partner) {
            if (car.user.partner.partner == true) {
              req.body.is_package == true;
            }
          }

          var package = null;

          if (publish == true) {
            if (req.body.is_package == true) {
              var getpackage = await Package.findOne({
                name: "#CarEagerClub Membership",
              }).exec();
              package = getpackage._id;
            }
          }

          if (variant.specification.type) {
            req.body.transmission = variant.specification.type;
          }

          req.body.geometry = [req.body.longitude, req.body.latitude];
          req.body.automaker = variant.model.automaker;
          req.body._automaker = automaker.maker;
          req.body.model = variant.model.id;
          req.body._model = variant.model.value;
          req.body.title = variant.variant;
          req.body._variant = variant.value;
          req.body.fuel_type = variant.specification.fuel_type;
          req.body.package = package;
          req.body.posted_by = "business";
          req.body.updated_at = new Date();

          Car.findOneAndUpdate(
            { _id: req.body.car, user: user },
            { $set: req.body },
            { new: false },
            async function (err, s) {
              if (err) {
                res.status(400).json({
                  responseCode: 400,
                  responseMessage: "Error occured",
                  responseData: err,
                });
              } else {
                if (publish == true) {
                  var log = {
                    user: loggedInDetails._id,
                    name: loggedInDetails.name,
                    status: "Published",
                    remark: "",
                    updated_at: new Date(),
                    created_at: new Date(),
                  };

                  var sell = await CarSell.findOne({
                    car: car._id,
                    sold: false,
                  }).exec();
                  if (sell) {
                    CarSell.findOneAndUpdate(
                      { car: car._id, sold: false },
                      {
                        $set: {
                          otp: Math.floor(Math.random() * 90000) + 10000,
                          user_verified: true,
                          admin_verified: false,
                        },
                      },
                      { new: false },
                      async function (err, doc) {
                        if (err) {
                          //////console.log(err)
                        } else {
                          event.sellerApproval(sell._id, req.headers["tz"]);
                        }
                      }
                    );
                  } else {
                    CarSell.create({
                      car: car._id,
                      seller: car.user,
                      owner: car.user,
                      buyer: null,
                      otp: Math.floor(Math.random() * 90000) + 10000,
                      user_verified: true,
                      admin_verified: false,
                      created_at: new Date(),
                      updated_at: new Date(),
                    }).then(function (d) {
                      event.sellerApproval(d._id, req.headers["tz"]);
                    });
                  }
                }

                fun.addMember(user, variant.model);

                await Car.findOne({ _id: req.body.car })
                  .populate("bookmark")
                  .populate("thumbnails")
                  .populate({
                    path: "user",
                    select: "name username avatar avatar_address address",
                  })
                  .populate({ path: "variant", populate: { path: "model" } })
                  .cursor()
                  .eachAsync(async (doc) => {
                    result = {
                      __v: 0,
                      _id: doc._id,
                      id: doc.id,
                      title: doc.title,
                      variant: doc.variant._id,
                      model: doc.model,
                      modelName: doc.variant.model.model,
                      price: price(doc.price),
                      numericPrice: doc.price,
                      accidental: doc.accidental,
                      body_style: doc.body_style,
                      description: doc.description,
                      driven: doc.driven,
                      carId: doc.carId,
                      odometer: doc.odometer,
                      fuel_type: doc.fuel_type,
                      insurance_info: doc.insurance_info,
                      location: doc.location,
                      manufacture_year: doc.manufacture_year,
                      mileage: doc.mileage,
                      owner: doc.owner,
                      registration_no: doc.registration_no,
                      service_history: doc.service_history,
                      transmission: doc.transmission,
                      vehicle_color: doc.vehicle_color,
                      vehicle_status: doc.vehicle_status,
                      geometry: doc.geometry,
                      link: "/car/" + slugify(doc.title + " " + doc._id),
                      publish: doc.publish,
                      status: doc.status,
                      premium: doc.premium,
                      is_bookmarked: doc.is_bookmarked,
                      thumbnails: doc.thumbnails,
                      user: doc.user,
                      created_at: doc.created_at,
                      updated_at: doc.updated_at,
                    };
                  });

                var responseMessage = "Successfully updated";

                if (publish == true) {
                  responseMessage = "Car has been sent to admin for approval";
                }

                res.status(200).json({
                  responseCode: 200,
                  responseMessage: responseMessage,
                  responseData: {
                    item: result,
                  },
                });
              }
            }
          );
        } else {
          res.status(400).json({
            responseCode: 400,
            responseMessage: "Unprocessable Entity",
            responseData: {},
          });
        }
      }
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Car not found",
        responseData: {},
      });
    }
  }
});

router.delete(
  "/car/delete",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      car: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Car is required",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);

      var user = req.headers["business"];

      var car = await Car.findOne({ _id: req.body.car, user: user })
        .populate("user")
        .exec();
      if (car) {
        var data = {
          status: false,
          updated_at: new Date(),
        };

        Car.findOneAndUpdate(
          { _id: req.body.car, user: user },
          { $set: data },
          { new: false },
          async function (err, s) {
            if (err) {
              res.status(400).json({
                responseCode: 400,
                responseMessage: "Error occured",
                responseData: err,
              });
            } else {
              var cars = [];
              await Car.find({ user: user, status: true })
                .cursor()
                .eachAsync(async (car) => {
                  cars.push(mongoose.Types.ObjectId(car._id));
                });

              var newvalues = {
                $set: { cars: cars },
              };

              User.findOneAndUpdate(
                { _id: user },
                newvalues,
                { new: false },
                async function (err, s) {
                  if (err) {
                    res.status(400).json({
                      responseCode: 400,
                      responseMessage: "Error occured",
                      responseData: err,
                    });
                  } else {
                    res.status(200).json({
                      responseCode: 200,
                      responseMessage: "Car has been deleted",
                      responseData: {},
                    });
                  }
                }
              );
            }
          }
        );
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Unauthorized",
          responseData: {},
        });
      }
    }
  }
);

router.post(
  "/car/publish",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var business = req.headers["business"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    var published = await Car.find({ user: business, publish: true })
      .count()
      .exec();

    var car = await Car.findById(req.body.car).populate("user").exec();
    var business = req.headers["business"];
    var limit = await q.all(businessPlanLimit(business, req.headers["tz"]));
    if (limit.car_publish > published) {
      if (car) {
        if (loggedInDetails) {
          var check_listing = await CarSell.findOne({
            car: car._id,
            buyer: null,
            sold: false,
          }).exec();
          if (check_listing) {
            if (!check_listing.seller.equals(check_listing.owner)) {
              event.otp(car.user.contact_no, check_listing.otp);

              res.status(200).json({
                responseCode: 200,
                responseMessage:
                  "OTP has been sent to owner. Kindly Verify it.",
                responseData: {
                  sell: check_listing._id,
                },
              });
            } else {
              res.status(200).json({
                responseCode: 200,
                responseMessage: "Admin approval pending",
                responseData: {
                  sell: null,
                },
              });
            }
          } else {
            var log = {
              user: loggedInDetails._id,
              name: loggedInDetails.name,
              status: "Published",
              remark: "",
              updated_at: new Date(),
              created_at: new Date(),
            };

            var user_verified = false;

            if (loggedInDetails._id.equals(car.user._id)) {
              user_verified = true;
            }

            CarSell.create({
              car: car._id,
              seller: business,
              owner: car.user._id,
              buyer: null,
              otp: Math.floor(Math.random() * 90000) + 10000,
              user_verified: user_verified,
              admin_verified: false,
              logs: log,
              created_at: new Date(),
              updated_at: new Date(),
            }).then(async function (sell) {
              var variant = await Variant.findOne({ _id: car.variant })
                .populate("model")
                .select("-service_schedule")
                .exec();
              var automaker = await Automaker.findById(
                variant.model.automaker
              ).exec();

              Car.findOneAndUpdate(
                { _id: car._id },
                {
                  $set: {
                    posted_by: "business",
                    user: sell.seller,
                    variant: variant._id,
                    _variant: variant.value,
                    model: variant.model._id,
                    _model: variant.model.value,
                    automaker: variant.model.automaker,
                    _automaker: automaker.maker,
                    title: variant.variant,
                    publish: false,
                    updated_at: new Date(),
                  },
                },
                { new: false },
                function (err, doc) {
                  if (err) {
                    res.status(400).json({
                      responseCode: 400,
                      responseMessage: "Server Error",
                      responseData: err,
                    });
                  } else {
                    if (user_verified == false) {
                      event.otp(car.user.contact_no, check_listing.otp);
                      res.status(200).json({
                        responseCode: 200,
                        responseMessage:
                          "OTP has been sent to owner. Kindly Verify it.",
                        responseData: {
                          sell: sell._id,
                        },
                      });
                    } else {
                      res.status(200).json({
                        responseCode: 200,
                        responseMessage: "Admin approval pending",
                        responseData: {
                          sell: null,
                        },
                      });
                    }
                  }
                }
              );
            });
          }
        } else {
          res.status(400).json({
            responseCode: 400,
            responseMessage: "Seller not found",
            responseData: {},
          });
        }
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Unauthorized",
          responseData: {},
        });
      }
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Limit Exceed",
        responseData: {},
      });
    }
  }
);

router.post(
  "/car/sell/verification",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    var loggedInDetails = await User.findById(decoded.user).exec();
    var sell = await CarSell.findOne({
      _id: req.body.sell,
      otp: req.body.otp,
      buyer: null,
      sold: false,
    }).exec();

    var validation = false;
    if (sell) {
      var car = await Car.findById(sell.car).exec();
      if (car) {
        var data = {
          user_verified: true,
          admin_verified: false,
          updated_at: new Date(),
        };

        CarSell.findOneAndUpdate(
          { _id: req.body.sell },
          { $set: data },
          { new: false },
          async function (err, doc) {
            if (err) {
              res.status(400).json({
                responseCode: 400,
                responseMessage: "Server Error",
                responseData: err,
              });
            } else {
              CarSell.findOneAndUpdate(
                { _id: req.body.sell },
                {
                  $push: {
                    user: loggedInDetails._id,
                    name: loggedInDetails.name,
                    status: "SellerVerfied",
                    remark: "",
                    created_at: new Date(),
                    updated_at: new Date(),
                  },
                },
                { new: false },
                async function (err, doc) {
                  if (err) {
                    res.status(400).json({
                      responseCode: 400,
                      responseMessage: "Error Occured",
                      responseData: err,
                    });
                  } else {
                    Car.findOneAndUpdate(
                      { _id: car._id },
                      {
                        $set: {
                          publish: true,
                          updated_at: new Date(),
                        },
                      },
                      { new: false },
                      function (err, doc) {
                        if (err) {
                          res.status(400).json({
                            responseCode: 400,
                            responseMessage: "Server Error",
                            responseData: err,
                          });
                        } else {
                          res.status(200).json({
                            responseCode: 200,
                            responseMessage: "Admin approval pending",
                            responseData: {},
                          });
                        }
                      }
                    );
                  }
                }
              );
            }
          }
        );
      } else {
        return res.status(400).json({
          responseCode: 400,
          responseMessage: "Car not found",
          responseData: {},
        });
      }
    } else {
      return res.status(400).json({
        responseCode: 400,
        responseMessage: "Listing not found",
        responseData: {},
      });
    }
  }
);

router.get(
  "/sold/cars/get",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var business = req.headers["business"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var result = [];
    if (req.query.page == undefined) {
      var page = 0;
    } else {
      var page = req.query.page;
    }
    var page = Math.max(0, parseInt(page));

    await CarSell.find({ seller: business })
      .populate({ path: "car" })
      .populate({
        path: "seller",
        select: "name username avatar avatar_address address contact_no email ",
      })
      .populate({
        path: "buyer",
        select: "name username avatar avatar_address address contact_no email ",
      })
      .populate({
        path: "owner",
        select: "name username avatar avatar_address address contact_no email",
      })
      .skip(25 * page)
      .limit(25)
      .cursor()
      .eachAsync(async (p) => {
        var buyer = null;
        if (p.buyer) {
          buyer = {
            _id: p.buyer._id,
            id: p.buyer._id,
            name: p.buyer.name,
            contact_no: p.buyer.contact_no,
            email: p.buyer.email,
          };
        }

        var refurbishment_cost = 0;
        if (parseFloat(p.refurbishment_cost) > 0) {
          refurbishment_cost = parseFloat(p.refurbishment_cost);
        }
        var purchase_price = 0;
        if (p.purchase_price > 0) {
          purchase_price = p.purchase_price;
        }

        var price = 0;
        if (p.price > 0) {
          price = p.price;
        }

        var revenue = 0;
        if (p.sold) {
          revenue =
            parseFloat(purchase_price) +
            parseFloat(refurbishment_cost) +
            parseFloat(p.package_cost) -
            price;
        }

        result.push({
          _id: p._id,
          id: p._id,
          car: {
            _id: p.car._id,
            id: p.car._id,
            title: p.car.title,
            _automaker: p.car._automaker,
            _model: p.car._model,
            registration_no: p.car.registration_no,
          },
          owner: {
            _id: p.owner._id,
            id: p.owner._id,
            name: p.owner.name,
            contact_no: p.owner.contact_no,
            email: p.owner.email,
          },
          seller: {
            _id: p.seller._id,
            id: p.seller._id,
            name: p.seller.name,
            contact_no: p.seller.contact_no,
            email: p.seller.email,
          },
          buyer: buyer,
          logs: p.logs,
          price: price,
          purchase_price: purchase_price,
          refurbishment_cost: parseFloat(refurbishment_cost),
          package_cost: p.package_cost,
          revenue: revenue,
          sold: p.sold,
          package_sold: p.package_sold,
          user_verified: p.user_verified,
          buyer_verified: p.buyer_verified,
          admin_verified: p.admin_verified,
          created_at: moment(p.created_at).tz(req.headers["tz"]).format("LLL"),
          updated_at: moment(p.updated_at).tz(req.headers["tz"]).format("LLL"),
        });
      });

    res.status(200).json({
      responseCode: 200,
      responseMessage: "",
      responseData: result,
    });
  }
);

router.post("/car/sold/", xAccessToken.token, async function (req, res, next) {
  var rules = {
    car: "required",
    price: "required",
  };

  var validation = new Validator(req.body, rules);

  if (validation.fails()) {
    res.status(422).json({
      responseCode: 422,
      responseMessage: "Car and Sold Price is required",
      responseData: {},
    });
  } else {
    var token = req.headers["x-access-token"];
    var business = req.headers["business"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    var loggedInDetails = await User.findById(decoded.user).exec();
    var sell = await CarSell.findOne({
      car: req.body.car,
      sold: false,
      seller: business,
    }).exec();

    if (sell) {
      var logs = sell.logs;
      var car = await Car.findById(sell.car).exec();
      if (car) {
        var buyer = await User.findById(req.body.buyer).exec();
        if (buyer) {
          var otp = Math.floor(Math.random() * 90000) + 10000;
          logs.push({
            user: loggedInDetails._id,
            name: loggedInDetails.name,
            status: "BuyerAdded",
            remark: "",
            created_at: new Date(),
            updated_at: new Date(),
          });

          var data = {
            buyer_otp: otp,
            buyer: buyer._id,
            logs: logs,
            price: req.body.price,
            purchase_price: car.purchase_price,
            refurbishment_cost: car.refurbishment_cost,
            user_verified: true,
            admin_verified: true,
            buyer_verified: false,
            updated_at: new Date(),
          };

          CarSell.findOneAndUpdate(
            { _id: sell._id },
            { $set: data },
            { new: false },
            async function (err, doc) {
              if (err) {
                res.status(400).json({
                  responseCode: 400,
                  responseMessage: "Server Error",
                  responseData: err,
                });
              } else {
                event.otp(buyer.contact_no, otp);
                Car.findOneAndUpdate(
                  { _id: car._id },
                  {
                    $set: {
                      price: req.body.price,
                      publish: true,
                      admin_approved: true,
                      updated_at: new Date(),
                    },
                  },
                  { new: false },
                  function (err, doc) {
                    if (err) {
                      res.status(400).json({
                        responseCode: 400,
                        responseMessage: "Server Error",
                        responseData: err,
                      });
                    } else {
                      res.status(200).json({
                        responseCode: 200,
                        responseMessage: "OTP Sent to Buyer",
                        responseData: {},
                      });
                    }
                  }
                );
              }
            }
          );
        } else {
          return res.status(400).json({
            responseCode: 400,
            responseMessage: "Buyer not found",
            responseData: {},
          });
        }
      } else {
        return res.status(400).json({
          responseCode: 400,
          responseMessage: "Car not found",
          responseData: {},
        });
      }
    } else {
      return res.status(400).json({
        responseCode: 400,
        responseMessage: "Listing not found",
        responseData: {},
      });
    }
  }
});

router.post(
  "/car/buyer/verification",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      car: "required",
      otp: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Car and OTP is required",
        responseData: {
          /*res: validation.errors.all()*/
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var business = req.headers["business"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);

      var loggedInDetails = await User.findById(decoded.user).exec();
      var sell = await CarSell.findOne({
        car: req.body.car,
        sold: false,
        seller: business,
      })
        .populate("seller")
        .populate("buyer")
        .populate("car")
        .exec();

      if (sell) {
        var logs = sell.logs;

        if (sell.buyer_otp == req.body.otp) {
          logs.push({
            user: loggedInDetails._id,
            name: loggedInDetails.name,
            status: "BuyerVerified",
            remark: "",
            created_at: new Date(),
            updated_at: new Date(),
          });

          var data = {
            buyer_otp: null,
            logs: logs,
            buyer_verified: true,
            sold: true,
            updated_at: new Date(),
          };

          CarSell.findOneAndUpdate(
            { _id: sell._id },
            { $set: data },
            { new: false },
            async function (err, doc) {
              if (err) {
                res.status(400).json({
                  responseCode: 400,
                  responseMessage: "Server Error",
                  responseData: err,
                });
              } else {
                Car.findOneAndUpdate(
                  { _id: sell.car._id },
                  {
                    $set: {
                      user: sell.buyer,
                      publish: false,
                      admin_approved: false,
                      updated_at: new Date(),
                    },
                  },
                  { new: false },
                  async function (err, doc) {
                    if (err) {
                      res.status(400).json({
                        responseCode: 400,
                        responseMessage: "Server Error",
                        responseData: err,
                      });
                    } else {
                      var updated = await CarSell.findById(sell._id)
                        .populate("car")
                        .exec();

                      var owner = sell.seller.referral_code;

                      var checkReferral = await Referral.find({
                        user: sell.buyer._id,
                      })
                        .count()
                        .exec();
                      if (checkReferral == 0) {
                        Referral.create({
                          code: sell.seller.referral_code,
                          owner: sell.seller._id,
                          user: sell.buyer._id,
                          created_at: new Date(),
                          updated_at: new Date(),
                        });
                      }

                      res.status(200).json({
                        responseCode: 200,
                        responseMessage: "Car has been sold successfully",
                        responseData: updated,
                      });
                    }
                  }
                );
              }
            }
          );
        } else {
          return res.status(400).json({
            responseCode: 400,
            responseMessage: "OTP not match",
            responseData: {},
          });
        }
      } else {
        return res.status(400).json({
          responseCode: 400,
          responseMessage: "Listing not found",
          responseData: {},
        });
      }
    }
  }
);

router.get(
  "/sell/car/package/checksum",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      sell: "required",
    };

    var validation = new Validator(req.query, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Car  is required",
        responseData: {},
      });
    } else {
      var token = req.headers["x-access-token"];
      var business = req.headers["business"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);

      var loggedInDetails = await User.findById(decoded.user).exec();
      var sell = await CarSell.findOne({
        _id: req.query.sell,
        seller: business,
      })
        .populate("seller")
        .populate("car")
        .exec();

      if (sell) {
        if (sell.car.package) {
          var discount = 0;
          if (sell.seller.partner) {
            if (sell.seller.partner.partner == true) {
              discount = sell.seller.partner.package_discount;
            }
          }
          var package = await Package.findById(sell.car.package).exec();
          var data = {
            package: package._id,
            package_cost: package.cost - discount,
          };

          CarSell.findOneAndUpdate(
            { _id: sell._id },
            { $set: data },
            { new: false },
            async function (err, doc) {
              if (err) {
                res.status(422).json({
                  responseCode: 422,
                  responseMessage: "failure",
                  responseData: err,
                });
              } else {
                var paramarray = {
                  MID: paytm_config.MID,
                  ORDER_ID: sell._id.toString(),
                  CUST_ID: sell.seller._id.toString(),
                  INDUSTRY_TYPE_ID: paytm_config.INDUSTRY_TYPE_ID,
                  CHANNEL_ID: "WAP",
                  TXN_AMOUNT: data.package_cost.toString(),
                  WEBSITE: paytm_config.WEBSITE,
                  CALLBACK_URL:
                    paytm_config.CALLBACK +
                    "theia/paytmCallback?ORDER_ID=" +
                    sell._id.toString(),
                  EMAIL: sell.seller.email,
                  MOBILE_NO: sell.seller.contact_no,
                };

                paytm_checksum.genchecksum(
                  paramarray,
                  paytm_config.MERCHANT_KEY,
                  function (err, data) {
                    if (err) {
                      res.status(422).json({
                        responseCode: 422,
                        responseMessage: "failure",
                        responseData: err,
                      });
                    } else {
                      res.status(200).json({
                        responseCode: 200,
                        responseMessage: "Checksum generated",
                        responseData: data,
                      });
                    }
                  }
                );
              }
            }
          );
        } else {
          return res.status(400).json({
            responseCode: 400,
            responseMessage: "Package not found",
            responseData: {},
          });
        }
      } else {
        return res.status(400).json({
          responseCode: 400,
          responseMessage: "Listing not found",
          responseData: {},
        });
      }
    }
  }
);

router.get(
  "/sell/car/package/transaction/",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var business = req.headers["business"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var paramarray = new Object();
    var discount = 0;
    var sell = await CarSell.findOne({ _id: req.query.id, seller: business })
      .populate("seller")
      .exec();
    var getUser = await User.findById(user).exec();
    if (sell) {
      var package = await Package.findOne({ _id: sell.package }).exec();

      var paramarray = {
        MID: paytm_config.MID,
        ORDER_ID: sell._id.toString(),
        CUST_ID: sell.seller._id.toString(),
        INDUSTRY_TYPE_ID: paytm_config.INDUSTRY_TYPE_ID,
        CHANNEL_ID: "WAP",
        TXN_AMOUNT: sell.package_cost.toString(),
        WEBSITE: paytm_config.WEBSITE,
        CALLBACK_URL:
          paytm_config.CALLBACK +
          "theia/paytmCallback?ORDER_ID=" +
          sell._id.toString(),
        EMAIL: sell.seller.email,
        MOBILE_NO: sell.seller.contact_no,
      };

      paytm_checksum.genchecksum(
        paramarray,
        paytm_config.MERCHANT_KEY,
        async function (err, result) {
          result["CHECKSUMHASH"] = encodeURIComponent(result["CHECKSUMHASH"]);
          var finalstring = "JsonData=" + JSON.stringify(result);
          request.post(
            {
              url:
                paytm_config.CALLBACK +
                "merchant-status/getTxnStatus?" +
                finalstring,
            },
            async function (error, httpResponse, body) {
              if (error) {
                res.status(422).json({
                  responseCode: 422,
                  responseMessage: "failure",
                  responseData: err,
                });
              } else {
                var paytmRes = JSON.parse(body);
                if (paytmRes.STATUS == "TXN_SUCCESS") {
                  CarSell.findOneAndUpdate(
                    { _id: sell._id },
                    { $set: { package_sold: true } },
                    { new: false },
                    async function (err, doc) {
                      if (err) {
                        res.status(422).json({
                          responseCode: 422,
                          responseMessage: "Error Occurred",
                          responseData: err,
                        });
                      } else {
                        var expired_at = new Date();
                        expired_at.setDate(
                          expired_at.getDate() + package.validity
                        );
                        var check = await UserPackage.find({
                          package: sell.package,
                          category: "free",
                          user: sell.buyer,
                          car: sell.car,
                        })
                          .count()
                          .exec();

                        if (check <= 0) {
                          UserPackage.create({
                            user: sell.buyer,
                            car: sell.car,
                            booking: null,
                            name: package.name,
                            business: "5bfec47ef651033d1c99fbca",
                            description: package.description,
                            category: package.category,
                            package: package._id,
                            payment: {
                              total: package.cost,
                              paid_total: package.cost,
                            },
                            discount: package.discount,
                            validity: package.validity,
                            expired_at: expired_at,
                            created_at: new Date(),
                            updated_at: new Date(),
                          });

                          if (package.cashback) {
                            var point = {
                              user: sell.buyer,
                              activity: "coin",
                              tag: "cashback",
                              source: sell._id,
                              sender: null,
                              title: "",
                              body: "",
                              points: package.cashback,
                              status: true,
                            };

                            fun.addPoints(point);
                          }

                          res.status(200).json({
                            responseCode: 200,
                            responseMessage:
                              "Your transaction has been successfully done",
                            responseData: paytmRes,
                          });
                        }
                      }
                    }
                  );
                } else {
                  res.status(200).json({
                    responseCode: 200,
                    responseMessage: "Your transaction has been declined",
                    responseData: paytmRes,
                  });
                }
              }
            }
          );
        }
      );
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Car Not Found",
        responseData: {},
      });
    }
  }
);

router.delete(
  "/car/unpublish",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var business = req.headers["business"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    var loggedInDetails = await User.findById(decoded.user).exec();
    var car = await Car.findById(req.body.car).populate("user").exec();

    if (car) {
      if (loggedInDetails) {
        var check_listing = await CarSell.findOne({
          car: car._id,
          seller: business,
          sold: false,
        }).exec();
        if (check_listing) {
          Car.findOneAndUpdate(
            { _id: car._id },
            {
              $set: {
                user: check_listing.owner,
                publish: false,
                package: null,
                admin_approved: false,
                updated_at: new Date(),
              },
            },
            { new: false },
            async function (err, doc) {
              if (err) {
                res.status(400).json({
                  responseCode: 400,
                  responseMessage: "Server Error",
                  responseData: err,
                });
              } else {
                CarSell.findByIdAndRemove(check_listing._id).exec();
                res.status(200).json({
                  responseCode: 200,
                  responseMessage: "Successfully unpublished",
                  responseData: {},
                });
              }
            }
          );
        } else {
          res.status(400).json({
            responseCode: 400,
            responseMessage: "Unauthorized",
            responseData: {},
          });
        }
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Seller not found",
          responseData: {},
        });
      }
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Unauthorized",
        responseData: {},
      });
    }
  }
);

router.put("/car/rc/add", xAccessToken.token, function (req, res, next) {
  var token = req.headers["x-access-token"];
  var secret = config.secret;
  var decoded = jwt.verify(token, secret);
  var user = req.headers["business"];
  let extension = "";
  var upload = multer({
    storage: multerS3({
      s3: s3,
      bucket: config.BUCKET_NAME + "/car",
      acl: "public-read",
      contentType: multerS3.AUTO_CONTENT_TYPE,
      // contentDisposition: 'attachment',
      key: function (req, file, cb) {
        let extArray = file.mimetype.split("/");
        extension = extArray[extArray.length - 1];

        var filename = uuidv1() + "." + extension;
        if (
          extension == "png" ||
          extension == "jpg" ||
          extension == "jpeg" ||
          extension == "gif"
        ) {
          cb(null, filename);
        } else {
          var params = {
            Bucket: config.BUCKET_NAME + "/car",
            Key: filename,
          };
          s3.deleteObject(params, async function (err, data) {
            var json = {
              responseCode: 422,
              responseMessage: "Invalid extension",
              responseData: {},
            };
            res.status(422).json(json);
          });
        }
      },
    }),
  }).array("media", 1);

  upload(req, res, async function (error) {
    if (error) {
      var json = {
        responseCode: 400,
        responseMessage: "Error occured",
        responseData: {},
      };
      res.status(400).json(json);
    }

    if (req.files.length == 0) {
      var json = {
        responseCode: 400,
        responseMessage: "Media is required",
        responseData: err,
      };
      res.status(400).json(json);
    } else {
      var car = await Car.findOne({ _id: req.body.id, user: user }).exec();
      if (car) {
        if (car.ic) {
          var params = {
            Bucket: config.BUCKET_NAME + "/car",
            Key: car.rc,
          };
          s3.deleteObject(params, async function (err, data) {
            if (err) {
              res.status(400).json({
                responseCode: 400,
                responseMessage: "Error occured",
                responseData: {
                  res: {
                    next: "",
                    errors: "",
                    rld: false,
                  },
                },
              });
            }
          });
        }

        var data = {
          rc: req.files[0].key,
          updated_at: new Date(),
        };

        Car.findOneAndUpdate(
          { _id: req.body.id, user: user },
          { $set: data },
          { new: true },
          function (err, doc) {}
        );

        var data = {
          user: req.headers["business"],
          car: req.body.id,
          file_type: extension.toUpperCase(),
          caption: "Registration No",
          file: req.files[0].key,
          created_at: new Date(),
          updated_at: new Date(),
        };

        var carDocument = new CarDocument(data);
        carDocument.save();

        res.status(200).json({
          responseCode: 200,
          responseMessage: "File has been uploaded",
          responseData: {
            file_address:
              "https://s3.ap-south-1.amazonaws.com/" +
              config.BUCKET_NAME +
              "/car/" +
              req.files[0].key,
          },
        });
      }
    }
  });
});

router.put("/car/ic/add", xAccessToken.token, async function (req, res, next) {
  var token = req.headers["x-access-token"];
  var secret = config.secret;
  var decoded = jwt.verify(token, secret);
  var user = req.headers["business"];
  let extension = "";
  // var car = await Car.findById().exec();
  // res.json(req.body)
  var upload = multer({
    storage: multerS3({
      s3: s3,
      bucket: config.BUCKET_NAME + "/car",
      acl: "public-read",
      contentType: multerS3.AUTO_CONTENT_TYPE,
      // contentDisposition: 'attachment',
      key: function (req, file, cb) {
        let extArray = file.mimetype.split("/");
        extension = extArray[extArray.length - 1];

        var filename = uuidv1() + "." + extension;
        if (
          extension == "png" ||
          extension == "jpg" ||
          extension == "jpeg" ||
          extension == "gif"
        ) {
          cb(null, filename);
        } else {
          var params = {
            Bucket: config.BUCKET_NAME + "/car",
            Key: filename,
          };
          s3.deleteObject(params, async function (err, data) {
            var json = {
              responseCode: 422,
              responseMessage: "Invalid extension",
              responseData: {},
            };
            res.status(422).json(json);
          });
        }
      },
    }),
  }).array("media", 1);

  upload(req, res, async function (error) {
    if (error) {
      var json = {
        responseCode: 400,
        responseMessage: "Error occured",
        responseData: {},
      };
      res.status(400).json(json);
    }

    if (req.files.length == 0) {
      var json = {
        responseCode: 400,
        responseMessage: "Media is required",
        responseData: {},
      };
      res.status(400).json(json);
    } else {
      var car = await Car.findOne({ _id: req.body.id, user: user }).exec();
      if (car) {
        if (car.ic) {
          var params = {
            Bucket: config.BUCKET_NAME + "/car",
            Key: car.ic,
          };
          s3.deleteObject(params, async function (err, data) {
            if (err) {
              res.status(400).json({
                responseCode: 400,
                responseMessage: "Error occured",
                responseData: {
                  res: {
                    next: "",
                    errors: "",
                    rld: false,
                  },
                },
              });
            }
          });
        }

        var data = {
          ic: req.files[0].key,
          updated_at: new Date(),
        };

        Car.findOneAndUpdate(
          { _id: req.body.id, user: user },
          { $set: data },
          { new: true },
          function (err, doc) {}
        );

        CarDocument.create({
          user: req.headers["business"],
          car: req.body.id,
          file_type: extension.toUpperCase(),
          caption: "Insurance",
          file: req.files[0].key,
          created_at: new Date(),
          updated_at: new Date(),
        });

        res.status(200).json({
          responseCode: 200,
          responseMessage: "File has been uploaded",
          responseData: {
            file_address:
              "https://s3.ap-south-1.amazonaws.com/" +
              config.BUCKET_NAME +
              "/car/" +
              req.files[0].key,
          },
        });
      }
    }
  });
});

router.delete(
  "/car/rc/delete",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = req.headers["business"];

    if (!req.body.id) {
      var json = {
        responseCode: 422,
        responseMessage: "Invalid Car",
        responseData: {},
      };
      res.status(422).json(json);
    } else {
      var car = await Car.findOne({ _id: req.body.id, user: user }).exec();
      if (car) {
        if (car.ic) {
          var params = {
            Bucket: config.BUCKET_NAME + "/car",
            Key: car.rc,
          };
          s3.deleteObject(params, async function (err, data) {
            if (err) {
              res.status(400).json({
                responseCode: 400,
                responseMessage: "Error occured",
                responseData: {
                  res: {
                    next: "",
                    errors: "",
                    rld: false,
                  },
                },
              });
            }
          });
        }

        var data = {
          rc: "",
          updated_at: new Date(),
        };

        Car.findOneAndUpdate(
          { _id: req.body.id, user: user },
          { $set: data },
          { new: true },
          function (err, doc) {}
        );

        res.status(200).json({
          responseCode: 200,
          responseMessage: "File has been deleted",
          responseData: {},
        });
      }
    }
  }
);

router.delete(
  "/car/ic/delete",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = req.headers["business"];

    if (!req.body.id) {
      var json = {
        responseCode: 422,
        responseMessage: "Invalid Car",
        responseData: {},
      };
      res.status(422).json(json);
    } else {
      var car = await Car.findOne({ _id: req.body.id, user: user }).exec();
      if (car) {
        if (car.ic) {
          var params = {
            Bucket: config.BUCKET_NAME + "/car",
            Key: car.ic,
          };
          s3.deleteObject(params, async function (err, data) {
            if (err) {
              res.status(400).json({
                responseCode: 400,
                responseMessage: "Error occured",
                responseData: {
                  res: {
                    next: "",
                    errors: "",
                    rld: false,
                  },
                },
              });
            }
          });
        }

        var data = {
          ic: "",
          updated_at: new Date(),
        };

        Car.findOneAndUpdate(
          { _id: req.body.id, user: user },
          { $set: data },
          { new: true },
          function (err, doc) {}
        );

        res.status(200).json({
          responseCode: 200,
          responseMessage: "File has been deleted",
          responseData: {},
        });
      }
    }
  }
);

router.post("/car/add/image", xAccessToken.token, function (req, res, next) {
  var token = req.headers["x-access-token"];
  var secret = config.secret;
  var decoded = jwt.verify(token, secret);

  var upload = multer({
    storage: multerS3({
      s3: s3,
      bucket: config.BUCKET_NAME + "/car",
      acl: "public-read",
      contentType: multerS3.AUTO_CONTENT_TYPE,
      // contentDisposition: 'attachment',
      key: function (req, file, cb) {
        let extArray = file.mimetype.split("/");
        let extension = extArray[extArray.length - 1];

        var filename = uuidv1() + "." + extension;
        if (
          extension == "png" ||
          extension == "jpg" ||
          extension == "jpeg" ||
          extension == "gif"
        ) {
          cb(null, filename);
        } else {
          var params = {
            Bucket: config.BUCKET_NAME + "/car",
            Key: filename,
          };
          s3.deleteObject(params, async function (err, data) {
            var json = {
              responseCode: 422,
              responseMessage: "Invalid extension",
              responseData: {},
            };
            res.status(422).json(json);
          });
        }
      },
    }),
  }).array("media", 1);

  upload(req, res, function (error) {
    if (error) {
      var json = {
        responseCode: 400,
        responseMessage: "Error occured",
        responseData: {},
      };
      res.status(400).json(json);
    }

    if (req.files.length == 0) {
      var json = {
        responseCode: 400,
        responseMessage: "Media is required",
        responseData: {},
      };
      res.status(400).json(json);
    } else {
      var data = {
        car: req.body.id,
        file: req.files[0].key,
        created_at: new Date(),
        updated_at: new Date(),
      };

      var carImage = new CarImage(data);
      carImage.save();

      res.status(200).json({
        responseCode: 200,
        responseMessage: "File has been uploaded",
        responseData: {
          item: carImage,
        },
      });
    }
  });
});

router.post(
  "/car/document/add/",
  xAccessToken.token,
  function (req, res, next) {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    let extension = "";
    var upload = multer({
      storage: multerS3({
        s3: s3,
        bucket: config.BUCKET_NAME + "/car",
        acl: "public-read",
        contentType: multerS3.AUTO_CONTENT_TYPE,
        // contentDisposition: 'attachment',
        key: function (req, file, cb) {
          let extArray = file.mimetype.split("/");
          extension = extArray[extArray.length - 1];
          var filename = uuidv1() + "." + extension;

          if (extension == "msword") {
            extension = "doc";
          }
          if (
            extension ==
            "vnd.openxmlformats-officedocument.wordprocessingml.document"
          ) {
            extension = "docx";
          }

          if (
            extension == "png" ||
            extension == "jpg" ||
            extension == "jpeg" ||
            extension == "gif" ||
            extension == "pdf" ||
            extension == "doc" ||
            extension == "docx"
          ) {
            cb(null, filename);
          } else {
            var params = {
              Bucket: config.BUCKET_NAME + "/car",
              Key: filename,
            };
            s3.deleteObject(params, async function (err, data) {
              var json = {
                responseCode: 422,
                responseMessage: "Invalid extension",
                responseData: filename,
              };
              res.status(422).json(json);
            });
          }
        },
      }),
    }).array("media", 1);

    upload(req, res, function (error) {
      if (error) {
        var json = {
          responseCode: 400,
          responseMessage: "Error occured",
          responseData: {},
        };
        res.status(400).json(json);
      }

      if (req.files.length == 0) {
        var json = {
          responseCode: 400,
          responseMessage: "Media is required",
          responseData: {},
        };
        res.status(400).json(json);
      } else {
        var data = {
          user: req.headers["business"],
          car: req.body.id,
          file_type: extension.toUpperCase(),
          caption: _.startCase(_.toLower(req.body.caption)),
          file: req.files[0].key,
          created_at: new Date(),
          updated_at: new Date(),
        };

        var carDocument = new CarDocument(data);
        carDocument.save();

        res.status(200).json({
          responseCode: 200,
          responseMessage: "File has been uploaded",
          responseData: carDocument,
        });
      }
    });
  }
);

router.delete(
  "/car/document/delete",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    var image_id = req.body.id;
    const media = await CarDocument.findById(image_id).exec();

    if (media) {
      var params = {
        Bucket: config.BUCKET_NAME + "/car",
        Key: media.file,
      };
      s3.deleteObject(params, async function (err, data) {
        if (err) {
          res.status(400).json({
            responseCode: 400,
            responseMessage: "Error occured",
            responseData: {},
          });
        } else {
          await CarDocument.findByIdAndRemove(image_id).exec();
          res.status(200).json({
            responseCode: 200,
            responseMessage: "File has been deleted",
            responseData: {},
          });
        }
      });
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Wrong image",
        responseData: {},
      });
    }
  }
);

router.get(
  "/car/documents/get",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var business = req.headers["business"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    var document = await CarDocument.find({
      user: business,
      car: req.query.car,
    }).exec();

    res.status(200).json({
      responseCode: 200,
      responseMessage: "",
      responseData: document,
    });
  }
);

router.delete(
  "/car/image/delete",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    var image_id = req.body.id;
    const media = await CarImage.findById(image_id).exec();

    if (media) {
      var params = {
        Bucket: config.BUCKET_NAME + "/car",
        Key: media.file,
      };
      s3.deleteObject(params, async function (err, data) {
        if (err) {
          res.status(400).json({
            responseCode: 400,
            responseMessage: "Error occured",
            responseData: {},
          });
        } else {
          await CarImage.findByIdAndRemove(image_id).exec();
          res.status(200).json({
            responseCode: 200,
            responseMessage: "File has been deleted",
            responseData: {},
          });
        }
      });
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Wrong image",
        responseData: {},
      });
    }
  }
);

router.get(
  "/explore/used/car",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    var filterBy = new Object();

    var business = req.headers["business"];
    var result = [];
    var geo, range;

    if (req.query.page == undefined) {
      var page = 0;
    } else {
      var page = req.query.page;
    }

    var range = 100000;

    if (req.query.range) {
      var range = parseInt(req.query.range) * 10000;
    }

    var near = [0, 0];
    if (req.query.longitude && req.query.longitude) {
      near = [parseFloat(req.query.longitude), parseFloat(req.query.latitude)];
    }

    var query = Car.find({
      geometry: {
        $near: near,
        $maxDistance: range,
      },
      publish: true,
      admin_approved: true,
      status: true,
      user: { $ne: business },
    });

    if (req.query.fuel) {
      fuel = req.query.fuel;
      query = query.where("fuel_type").in(fuel.split(","));
    }

    if (req.query.transmission) {
      transmissions = req.query.transmission;
      query = query.where("transmission").in(transmissions.split(","));
    }

    if (req.query.postedBy) {
      posted_by = req.query.postedBy;
      query = query.where("posted_by").in(posted_by.split(","));
    }

    if (req.query.body) {
      body_style = req.query.body;
      query = query.where("body_style").in(body_style.split(","));
    }

    if (req.query.model) {
      models = req.query.model;
      filterBy.model = models.split(",");
      query = query.where("_model").in(models.split(","));
    }

    if (req.query.color) {
      colors = req.query.color;
      filterBy.colors = colors.split(",");
      query = query.where("vehicle_color").in(colors.split(","));
    }

    if (req.query.min && req.query.max) {
      query = query
        .where("price")
        .gte(req.query.min * 100000)
        .lte(req.query.max * 100000);
    }

    var totalResult = await query.count().exec();

    await query
      .populate({ path: "thumbnails" })
      .populate("bookmark")
      .populate("package")
      .populate({
        path: "user",
        select: "name avatar avatar_address account_info business_info partner",
      })
      .sort({ updated_at: -1 })
      .limit(config.perPage)
      .skip(config.perPage * page)
      .cursor()
      .eachAsync(async (doc) => {
        result.push({
          __v: 0,
          title: doc.title,
          variant: doc.variant,
          model: doc.model,
          price: price(doc.price),
          accidental: doc.accidental,
          body_style: doc.body_style,
          description: doc.description,
          driven: doc.driven,
          carId: doc.carId,
          fuel_type: doc.fuel_type,
          location: doc.location,
          manufacture_year: doc.manufacture_year,
          odometer: doc.odometer,
          owner: doc.owner,
          registration_no: doc.registration_no,
          service_history: doc.service_history,
          transmission: doc.transmission,
          vehicle_color: doc.vehicle_color,
          vehicle_status: doc.vehicle_status,
          geometry: doc.geometry,
          created_at: moment(doc.created_at).tz(req.headers["tz"]).format("ll"),
          updated_at: moment(doc.updated_at).tz(req.headers["tz"]).format("ll"),
          user: doc.user,
          _id: doc._id,
          link: "/car/" + slugify(doc.title + " " + doc._id),
          publish: doc.publish,
          status: doc.status,
          careager_rating: doc.careager_rating,
          video_url: doc.video_url,
          is_bookmarked: doc.is_bookmarked,
          isChatEnable: await q.all(
            fun.isChatEnable(doc.user._id, req.headers["tz"])
          ),
          id: doc.id,
          package: doc.package,
          thumbnails: doc.thumbnails,
        });
      });

    res.status(200).json({
      responseCode: 200,
      responseInfo: {
        totalResult: totalResult,
      },
      responseMessage: "success",
      responseData: result,
    });
  }
);

async function businessPlan(business, category) {
  var plans = await BusinessPlan.find({
    business: business,
    category: category,
  })
    .populate("suite")
    .exec();
  var suite = _.map(plans, "suite");

  for (var i = 0; i < suite.length; i++) {
    var defaults = suite[i].default;
    for (var j = 0; j < defaults.length; j++) {
      var foundIndex = def.findIndex((x) => x.action == defaults[j].action);
      if (foundIndex == -1) {
        def.push({
          tag: defaults[j].tag,
          module: defaults[j].module,
          action: defaults[j].action,
          enable: defaults[j].enable,
          activityTab: defaults[j].activityTab,
        });
      }
    }

    var serverTime = moment.tz(new Date(), req.headers["tz"]);
    var bar = plans[i].created_at;
    bar.setDate(bar.getDate() + plans[i].validity);
    var e = bar;
    bar = moment.tz(bar, req.headers["tz"]);

    var baz = bar.diff(serverTime);

    if (baz > 0) {
      var mains = suite[i].main;
      for (var k = 0; k < mains.length; k++) {
        var foundIndex = main.findIndex((x) => x.action == mains[k].action);
        if (foundIndex >= 0) {
          main[foundIndex] = {
            tag: mains[k].tag,
            module: mains[k].action,
            action: mains[k].action,
            enable: mains[k].enable,
            activityTab: mains[k].activityTab,
          };
        } else {
          main.push({
            tag: mains[k].tag,
            module: mains[k].module,
            action: mains[k].action,
            enable: mains[k].enable,
            activityTab: mains[k].activityTab,
          });
        }
      }
    }

    if (suite[i].chat == true) {
      chat = true;
    }
  }
}

async function businessPlanCategory(business) {
  var plans = await BusinessPlan.find({ business: business })
    .populate("suite")
    .exec();
  var suite = _.map(plans, "suite");

  var category = [];

  for (var i = 0; i < suite.length; i++) {
    category.push(suite[i].category);
  }

  return category;
}

async function businessPlanLimit(business, tz) {
  var plans = await BusinessPlan.find({ business: business })
    .populate("suite")
    .exec();
  var suite = _.map(plans, "suite");

  var limits = [];
  for (var i = 0; i < suite.length; i++) {
    var serverTime = moment.tz(new Date(), tz);
    var bar = plans[i].created_at;
    bar.setDate(bar.getDate() + plans[i].validity);
    var e = bar;
    bar = moment.tz(bar, tz);

    var baz = bar.diff(serverTime);

    if (baz > 0) {
      limits.push(suite[i].limits[0]);
    }
  }

  result = limits.reduce((r, o) => {
    if (!typeof o === "object" || o === null) {
      return r;
    }

    Object.keys(o).forEach(
      (key) =>
        (r[key] = r[key] !== undefined ? Math.max(r[key], o[key]) : o[key])
    );
    return r;
  }, {});

  return result;
}

function price(value) {
  var val = Math.abs(value);
  if (val >= 10000000) {
    val = (val / 10000000).toFixed(2) + "Cr";
  } else if (val >= 100000) {
    val = (val / 100000).toFixed(2) + "L";
  } else if (val >= 1000) {
    val = (val / 1000).toFixed(2) + "K";
  }
  return val.toString();
}

function slugify(string) {
  return string
    .toString()
    .trim()
    .toLowerCase()
    .replace(/\s+/g, "-")
    .replace(/[^\w\-]+/g, "")
    .replace(/\-\-+/g, "-")
    .replace(/^-+/, "")
    .replace(/-+$/, "");
}

async function getAssignee(user, business) {
  var role = await Management.findOne({
    user: user,
    business: business,
  }).exec();
  if (role.role == "CRE") {
    advisor = role.user;
  } else {
    var assigneeLead = [];
    await Management.find({ business: business, role: "CRE" })
      .cursor()
      .eachAsync(async (a) => {
        // var d = await Lead.find({ business: business, assignee: a.user }).count().exec();
        var open = await Lead.find({
          business: business,
          assignee: a.user,
          "remark.status": { $in: ["Open"] },
        })
          .count()
          .exec();
        var follow_up = await Lead.find({
          business: business,
          assignee: a.user,
          "remark.status": { $in: ["Follow-Up"] },
          "follow_up.date": { $lte: new Date() },
        })
          .count()
          .exec();
        var d = open + follow_up;

        assigneeLead.push({
          user: a.user,
          count: d,
        });
      });

    if (assigneeLead.length != 0) {
      assigneeLead.sort(function (a, b) {
        return a.count > b.count;
      });

      advisor = assigneeLead[0].user;
    } else {
      advisor = role.business;
    }
  }

  return advisor;
}

router.get(
  "/user/wallet/get",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    var points = [];
    var total = 0,
      used = 0;
    var unused = await User.findOne({ _id: req.query.user })
      .select("careager_cash referral_code")
      .exec();
    await Point.find({ user: req.query.user })
      .sort({ created_at: -1 })
      .cursor()
      .eachAsync(async (point) => {
        if (point.type == "credit") {
          total = total + point.points;
        }

        if (point.type == "debit") {
          used = used + point.points;
        }

        if (point.tag == "commission") {
          var booking = await Booking.findById(point.source)
            .populate({
              path: "user",
              populate: { path: "user", select: "_id id name contact_no" },
            })
            .exec();
          if (booking) {
            var booking_no = booking.booking_no;
            if (booking.user) {
              var name = booking.user.name;
            } else {
              var booking_no = "";
              var name = "";
            }
          } else {
            var booking_no = "";
            var name = "";
          }
          var tag = "Commission - " + name + " - #" + booking_no;
        } else if (point.tag == "referNEarn") {
          var user = await User.findById(point.source).exec();
          var tag = "Refer & Earn - " + user.name;
        } else {
          var tag = _.startCase(point.tag);
        }

        points.push({
          _id: point._id,
          points: Math.ceil(point.points),
          type: point.type,
          tag: tag,
          status: point.status,
          activity: _.startCase(point.activity),
          user: point.user,
          month: moment(point.created_at)
            .tz(req.headers["tz"])
            .format("MMMM YYYY"),
          created_at: moment(point.created_at)
            .tz(req.headers["tz"])
            .format("Do"),
          updated_at: moment(point.updated_at)
            .tz(req.headers["tz"])
            .format("Do"),
        });
      });

    var group = _(points)
      .groupBy((x) => x.month)
      .map((value, key) => ({ month: key, transaction: value }))
      .value();

    var uu = unused.careager_cash;

    res.status(200).json({
      responseCode: 200,
      responseMessage: "success",
      responseData: {
        total: Math.ceil(total),
        used: Math.ceil(used),
        unused: Math.ceil(uu),
        referral_code: unused.referral_code,
        total_refferal: await Referral.find({ owner: req.query.user }).count(),
        list: group,
      },
    });
  }
);

router.put("/logo/update", xAccessToken.token, async function (req, res, next) {
  var token = req.headers["x-access-token"];
  var secret = config.secret;
  var decoded = jwt.verify(token, secret);
  var user = decoded.user;
  var business = req.headers["business"];
  var bookings = [];
  var totalResult = 0;
  var loggedInDetails = await User.findById(decoded.user).exec();
  if (loggedInDetails) {
    var management = await Management.findOne({
      user: decoded.user,
      business: business,
      role: "Admin",
    })
      .populate("user")
      .exec();
    if (management) {
      var upload = multer({
        storage: multerS3({
          s3: s3,
          bucket: config.BUCKET_NAME + "/avatar",
          acl: "public-read",
          contentType: multerS3.AUTO_CONTENT_TYPE,
          // contentDisposition: 'attachment',
          key: function (req, file, cb) {
            let extArray = file.mimetype.split("/");
            let extension = extArray[extArray.length - 1];

            var filename = uuidv1() + "." + extension;
            if (
              extension == "png" ||
              extension == "jpg" ||
              extension == "jpeg" ||
              extension == "gif"
            ) {
              cb(null, filename);
            } else {
              var params = {
                Bucket: config.BUCKET_NAME + "/avatar",
                Key: filename,
              };
              s3.deleteObject(params, async function (err, data) {
                var json = {
                  responseCode: 422,
                  responseMessage: "Invalid extension",
                  responseData: {},
                };
                res.status(422).json(json);
              });
            }
          },
        }),
      }).array("media", 1);

      upload(req, res, async function (error) {
        if (error) {
          var json = {
            responseCode: 400,
            responseMessage: "Error occured",
            responseData: {},
          };
          res.status(400).json(json);
        }

        if (req.files.length == 0) {
          var json = {
            responseCode: 400,
            responseMessage: "Media is required",
            responseData: {},
          };
          res.status(400).json(json);
        } else {
          var data = {
            "business_info.company_logo":
              "https://s3.ap-south-1.amazonaws.com/" +
              config.BUCKET_NAME +
              "/avatar/" +
              req.files[0].key,
            updated_at: new Date(),
          };

          User.findOneAndUpdate(
            { _id: business },
            { $set: data },
            { new: false },
            async function (err, doc) {
              if (err) {
                res.status(422).json({
                  responseCode: 422,
                  responseMessage: "Server Error",
                  responseData: err,
                });
              } else {
                var updated = await User.findOne({ _id: business }).exec();
                res.status(200).json({
                  responseCode: 200,
                  responseMessage: "Business Setting",
                  responseData: updated,
                });
              }
            }
          );
        }
      });
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Authorization Error",
        responseData: {},
      });
    }
  } else {
    res.status(400).json({
      responseCode: 400,
      responseMessage: "User not found",
      responseData: {},
    });
  }
});

router.put(
  "/qr-code/update",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers["business"];
    var bookings = [];
    var totalResult = 0;
    var loggedInDetails = await User.findById(decoded.user).exec();
    if (loggedInDetails) {
      var management = await Management.findOne({
        user: decoded.user,
        business: business,
        role: "Admin",
      })
        .populate("user")
        .exec();
      if (management) {
        var upload = multer({
          storage: multerS3({
            s3: s3,
            bucket: config.BUCKET_NAME + "/avatar",
            acl: "public-read",
            contentType: multerS3.AUTO_CONTENT_TYPE,
            // contentDisposition: 'attachment',
            key: function (req, file, cb) {
              let extArray = file.mimetype.split("/");
              let extension = extArray[extArray.length - 1];

              var filename = uuidv1() + "." + extension;
              if (
                extension == "png" ||
                extension == "jpg" ||
                extension == "jpeg" ||
                extension == "gif"
              ) {
                cb(null, filename);
              } else {
                var params = {
                  Bucket: config.BUCKET_NAME + "/avatar",
                  Key: filename,
                };
                s3.deleteObject(params, async function (err, data) {
                  var json = {
                    responseCode: 422,
                    responseMessage: "Invalid extension",
                    responseData: {},
                  };
                  res.status(422).json(json);
                });
              }
            },
          }),
        }).array("media", 1);

        upload(req, res, async function (error) {
          if (error) {
            var json = {
              responseCode: 400,
              responseMessage: "Error occured",
              responseData: {},
            };
            res.status(400).json(json);
          }

          if (req.files.length == 0) {
            var json = {
              responseCode: 400,
              responseMessage: "Media is required",
              responseData: {},
            };
            res.status(400).json(json);
          } else {
            var data = {
              "business_info.qr_code":
                "https://s3.ap-south-1.amazonaws.com/" +
                config.BUCKET_NAME +
                "/avatar/" +
                req.files[0].key,
              updated_at: new Date(),
            };

            User.findOneAndUpdate(
              { _id: business },
              { $set: data },
              { new: false },
              async function (err, doc) {
                if (err) {
                  res.status(422).json({
                    responseCode: 422,
                    responseMessage: "Server Error",
                    responseData: err,
                  });
                } else {
                  var updated = await User.findOne({ _id: business }).exec();
                  res.status(200).json({
                    responseCode: 200,
                    responseMessage: "Business Setting",
                    responseData: updated,
                  });
                }
              }
            );
          }
        });
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Authorization Error",
          responseData: {},
        });
      }
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "User not found",
        responseData: {},
      });
    }
  }
);

router.delete(
  "/qr-code/delete",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers["business"];
    var bookings = [];
    var totalResult = 0;
    var loggedInDetails = await User.findById(decoded.user).exec();
    if (loggedInDetails) {
      var management = await Management.findOne({
        user: decoded.user,
        business: business,
        role: "Admin",
      })
        .populate("user")
        .exec();
      if (management) {
        var info = await User.findById(business).exec();

        var file = info.business_info.qr_code;

        var x = file.split("avatar/");

        if (x[1]) {
          var params = {
            Bucket: config.BUCKET_NAME + "/avatar",
            Key: x[1],
          };

          //console.log(params);

          s3.deleteObject(params, async function (err, data) {
            if (err) {
              res.status(422).json({
                responseCode: 422,
                responseMessage: "Invalid extension",
                responseData: {},
              });
            } else {
              User.findOneAndUpdate(
                { _id: business },
                { $set: { "business_info.qr_code": "" } },
                { new: false },
                async function (err, doc) {
                  if (err) {
                    res.status(422).json({
                      responseCode: 422,
                      responseMessage: "Invalid extension",
                      responseData: {},
                    });
                  } else {
                    res.status(200).json({
                      responseCode: 200,
                      responseMessage: "Deleted Successfully",
                      responseData: {},
                    });
                  }
                }
              );
            }
          });
        } else {
          res.status(400).json({
            responseCode: 400,
            responseMessage: "File not Found",
            responseData: {},
          });
        }
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Authorization Error",
          responseData: {},
        });
      }
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "User not found",
        responseData: {},
      });
    }
  }
);

router.put("/info/update", xAccessToken.token, async function (req, res, next) {
  var token = req.headers["x-access-token"];
  var secret = config.secret;
  var decoded = jwt.verify(token, secret);
  var user = decoded.user;
  var business = req.headers["business"];
  var bookings = [];
  var totalResult = 0;
  var loggedInDetails = await User.findById(decoded.user).exec();
  if (loggedInDetails) {
    var management = await Management.findOne({
      user: decoded.user,
      business: business,
      role: "Admin",
    })
      .populate("user")
      .exec();
    if (management) {
      var data = {
        "business_info.company_name": req.body.company_name,
        "business_info.gst_registration_type": req.body.gst_registration_type,
        "business_info.gstin": req.body.gstin,
        "business_info.policy": req.body.policy,
        "business_info.terms": req.body.terms,
        "business_info.order_terms": req.body.order_terms,
        "business_info.pick_up_limit": req.body.pick_up_limit,
        updated_at: new Date(),
      };

      User.findOneAndUpdate(
        { _id: business },
        { $set: data },
        { new: false },
        async function (err, doc) {
          if (err) {
            res.status(422).json({
              responseCode: 422,
              responseMessage: "Server Error",
              responseData: err,
            });
          } else {
            var updated = await User.findOne({ _id: business }).exec();
            res.status(200).json({
              responseCode: 200,
              responseMessage: "Business Setting",
              responseData: updated,
            });
          }
        }
      );
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Authorization Error",
        responseData: {},
      });
    }
  } else {
    res.status(400).json({
      responseCode: 400,
      responseMessage: "User not found",
      responseData: {},
    });
  }
});

router.put(
  "/address/update",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers["business"];
    var bookings = [];
    var totalResult = 0;
    var loggedInDetails = await User.findById(decoded.user).exec();
    if (loggedInDetails) {
      var management = await Management.findOne({
        user: decoded.user,
        business: business,
        role: "Admin",
      })
        .populate("user")
        .exec();
      if (management) {
        var data = {
          "address.country": req.body.country,
          "address.state": req.body.state,
          "address.zip": req.body.zip,
          "address.area": req.body.area,
          "address.city": req.body.city,
          "address.address": req.body.address,
          updated_at: new Date(),
        };

        User.findOneAndUpdate(
          { _id: business },
          { $set: data },
          { new: false },
          async function (err, doc) {
            if (err) {
              res.status(422).json({
                responseCode: 422,
                responseMessage: "Server Error",
                responseData: err,
              });
            } else {
              var updated = await User.findOne({ _id: business }).exec();
              res.status(200).json({
                responseCode: 200,
                responseMessage: "Business Setting",
                responseData: updated,
              });
            }
          }
        );
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Authorization Error",
          responseData: {},
        });
      }
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "User not found",
        responseData: {},
      });
    }
  }
);

router.put(
  "/bank-details/update",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers["business"];
    var bookings = [];
    var totalResult = 0;
    var loggedInDetails = await User.findById(decoded.user).exec();
    if (loggedInDetails) {
      var management = await Management.findOne({
        user: decoded.user,
        business: business,
        role: "Admin",
      })
        .populate("user")
        .exec();
      if (management) {
        var data = [
          {
            bank: req.body.bank,
            branch: req.body.branch,
            ifsc: req.body.ifsc,
            account_no: req.body.account_no,
            account_holder: req.body.account_holder,
          },
        ];

        User.findOneAndUpdate(
          { _id: business },
          { $set: { bank_details: data } },
          { new: false },
          async function (err, doc) {
            if (err) {
              res.status(422).json({
                responseCode: 422,
                responseMessage: "Server Error",
                responseData: err,
              });
            } else {
              var updated = await User.findOne({ _id: business }).exec();
              res.status(200).json({
                responseCode: 200,
                responseMessage: "Business Setting",
                responseData: updated,
              });
            }
          }
        );
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Authorization Error",
          responseData: {},
        });
      }
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "User not found",
        responseData: {},
      });
    }
  }
);

router.put(
  "/job/setting/update",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers["business"];
    var bookings = [];
    var totalResult = 0;
    var loggedInDetails = await User.findById(decoded.user).exec();
    if (loggedInDetails) {
      var management = await Management.findOne({
        user: decoded.user,
        business: business,
        role: "Admin",
      })
        .populate("user")
        .exec();
      if (management) {
        var businessSetting = await BusinessSetting.findOne({
          business: business,
        }).exec();
        if (businessSetting) {
          req.body.updated_at = new Date();

          BusinessSetting.findOneAndUpdate(
            { business: business },
            { $set: req.body },
            { new: false },
            async function (err, doc) {
              if (err) {
                res.status(422).json({
                  responseCode: 422,
                  responseMessage: "Server Error",
                  responseData: err,
                });
              } else {
                var updated = await BusinessSetting.findOne({
                  business: business,
                }).exec();
                res.status(200).json({
                  responseCode: 200,
                  responseMessage: "Business Setting",
                  responseData: updated,
                });
              }
            }
          );
        } else {
          req.body.business = business;
          req.body.created_at = new Date();
          req.body.updated_at = new Date();

          BusinessSetting.create(req.body).then(async function (e) {
            res.status(200).json({
              responseCode: 200,
              responseMessage: "Added",
              responseData: e,
            });
          });
        }
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Authorization Error",
          responseData: {},
        });
      }
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "User not found",
        responseData: {},
      });
    }
  }
);

router.put(
  "/profile/update",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var business = req.headers["business"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var loggedInDetails = await User.findById(decoded.user).exec();
    if (loggedInDetails) {
      var management = await Management.findOne({
        user: decoded.user,
        business: business,
        role: "Admin",
      })
        .populate("user")
        .exec();
      if (management) {
        var data = {
          name: req.body.name,
          contact_no: req.body.contact_no,
          optional_info: {
            email: req.body.secondary_email,
            contact_no: req.body.secondary_contact_no,
            overview: req.body.overview,
          },
        };

        var rules = {
          name: "required",
        };

        var validation = new Validator(data, rules);

        if (validation.fails()) {
          res.status(422).json({
            responseCode: 422,
            responseMessage: "Error",
            responseData: {
              res: validation.errors.all(),
            },
          });
        } else {
          User.findOneAndUpdate(
            { _id: business },
            { $set: data },
            { new: true },
            function (err, doc) {
              if (err) {
                var json = {
                  responseCode: 400,
                  responseMessage: "Error Occurred",
                  responseData: err,
                };

                res.status(400).json(json);
              } else {
                var json = {
                  responseCode: 200,
                  responseMessage: "Profile has been updated",
                  responseData: {},
                };
                res.status(200).json(json);
              }
            }
          );
        }
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Authorization Error",
          responseData: {},
        });
      }
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "User not found",
        responseData: {},
      });
    }
  }
);

router.put(
  "/timing/update",
  xAccessToken.token,
  async function (req, res, next) {
    var business = req.headers["business"];
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var loggedInDetails = await User.findById(decoded.user).exec();
    if (loggedInDetails) {
      var management = await Management.findOne({
        user: decoded.user,
        business: business,
        role: "Admin",
      })
        .populate("user")
        .exec();
      if (management) {
        var timings = req.body;

        BusinessTiming.remove({ business: business }, function (err) {
          if (!err) {
            timings.forEach(function (u) {
              var timing = new BusinessTiming({
                business: business,
                day: u.day,
                open: u.open,
                close: u.close,
                is_closed: u.is_closed,
                created_at: new Date(),
                updated_at: new Date(),
              });
              timing.save();
            });

            var json = {
              responseCode: 200,
              responseMessage: "Timing has been updated",
              responseData: {},
            };
            res.status(200).json(json);
          } else {
            var json = {
              responseCode: 400,
              responseMessage: "Error Occurred",
              responseData: {},
            };
            res.status(400).json(json);
          }
        });
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Authorization Error",
          responseData: {},
        });
      }
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "User not found",
        responseData: {},
      });
    }
  }
);

router.put(
  "/booking/timings/update",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var business = req.headers["business"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var loggedInDetails = await User.findById(decoded.user).exec();
    if (loggedInDetails) {
      var management = await Management.findOne({
        user: decoded.user,
        business: business,
        role: "Admin",
      })
        .populate("user")
        .exec();
      if (management) {
        var timings = req.body;
        BookingTiming.remove({ business: business }, function (err) {
          if (!err) {
            timings.forEach(function (u) {
              var timing = new BookingTiming({
                business: business,
                slot: u.slot,
                sort: u.index,
                booking_per_slot: u.bookings,
                status: u.status,
                created_at: new Date(),
                updated_at: new Date(),
              });
              timing.save();
            });

            var json = {
              responseCode: 200,
              responseMessage: "Booking timing has been updated",
              responseData: {},
            };
            res.status(200).json(json);
          } else {
            var json = {
              responseCode: 400,
              responseMessage: "Error Occurred",
              responseData: {},
            };
            res.status(400).json(json);
          }
        });
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Authorization Error",
          responseData: {},
        });
      }
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "User not found",
        responseData: {},
      });
    }
  }
);

function segmentSort(segment) {
  var s = 0;
  if (segment == "Small") {
    s = 1;
  } else if (segment == "Medium") {
    s = 2;
  } else if (segment == "Premium") {
    s = 3;
  } else if (segment == "Premium XL") {
    s = 4;
  } else if (segment == "Luxury") {
    s = 5;
  } else if (segment == "Luxury XL") {
    s = 6;
  } else if (segment == "Sports") {
    s = 7;
  }

  return s;
}

router.get("/country/details/get", async function (req, res, next) {
  var tz = req.headers["tz"];

  if (tz) {
    var country = await Country.findOne({ timezone: { $in: tz } }).exec();
    if (country) {
      res.status(200).json({
        responseCode: 200,
        responseMessage: "Country Details",

        responseData: country,
      });
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Time zone error",
        responseData: {},
      });
    }
  } else {
    res.status(400).json({
      responseCode: 400,
      responseMessage: "Time zone error",
      responseData: {},
    });
  }
});

router.get("/company/category/get", async function (req, res, next) {
  console.log("Category Called Common .js");
  const categories = await Category.find({}).exec();
  res.status(200).json({
    responseCode: 200,
    responseMessage: "success",
    responseData: categories,
  });
});

router.get(
  "/cars/brand/get",
  /* xAccessToken.token,*/ async function (req, res, next) {
    // var rules = {
    //     query: 'required'
    // };
    // var validation = new Validator(req.query, rules);

    // if (validation.fails()) {
    //     res.status(422).json({
    //         responseCode: 422,
    //         responseMessage: "Error",
    //         responseData: {
    //             res: validation.errors.all()
    //         }
    //     })
    // }
    // else {
    console.time("looper");
    // var token = req.headers['x-access-token'];
    // var secret = config.secret;
    // var decoded = jwt.verify(token, secret);
    // var user = decoded.user;
    var data = [];
    // data=await Automaker.find({ maker: {$ne:null}}).exec()
    // await Automaker.find({
    //     maker: new RegExp(req.query.query, "i")

    // }).cursor()
    //     .eachAsync(async function (o) {
    //         data.push({
    //             _id: o._id,
    //             logo: o.logo,
    //             maker: o.maker,
    //         })
    //     });
    await Automaker.find({
      maker: { $ne: null },
    })
      .cursor()
      .eachAsync(async function (o) {
        data.push({
          _id: o._id,
          logo: o.logo,
          maker: o.maker,
        });
      });
    console.timeEnd("looper");
    let field = "maker";
    //console.log(data.sort((a, b) => (a[field] || "").toString().localeCompare((b[field] || "").toString())));
    data = data.sort((a, b) =>
      (a[field] || "").toString().localeCompare((b[field] || "").toString())
    );
    res.status(200).json({
      responseCode: 200,
      responseMessage: "",
      responseData: data,
    });
    /**/
    // }
  }
);

router.get("/registration/postals/get", async function (req, res, next) {
  var rules = {
    zip: "required",
  };
  console.log("zip ", req.query.zip);
  var validation = new Validator(req.query, rules);

  if (validation.fails()) {
    res.status(422).json({
      responseCode: 422,
      responseMessage: "Error",
      responseData: {
        res: validation.errors.all(),
      },
    });
  } else {
    // var token = req.headers['x-access-token'];
    // var secret = config.secret;
    // var decoded = jwt.verify(token, secret);
    // var user = decoded.user;
    var data = [];

    await Location.find({ zip: req.query.zip })
      .cursor()
      .eachAsync(async function (o) {
        data.push({
          _id: o._id,
          id: o._id,
          zip: o.zip,
          city: o.city,
          region: o.region,
          state: o.state,
          latitude: o.latitude,
          longitude: o.longitude,
          country: o.country,
        });
      });

    res.status(200).json({
      responseCode: 200,
      responseMessage: "",
      responseData: data,
    });
    /**/
  }
});

router.post("/signup", async function (req, res, next) {
  var rules = {
    contact_no: "required",
  };
  // console.log("3.0 SignUp Called")
  var validation = new Validator(req.body, rules);
  req.body["whatsAppChannelId"] = "4f1e778f-9f3b-41e0-8bf4-db6ffb15b0c2";
  if (validation.fails()) {
    res.status(422).json({
      responseCode: 422,
      responseMessage: "Mobile Number is required",
      responseData: {
        res: validation.errors.all(),
      },
    });
  } else {
    if (req.body.name) {
      var busuness_name = await User.find({ name: req.body.name })
        .count()
        .exec();
    } else {
      var busuness_name = 0;
    }

    if (req.body.email) {
      var checkEmail = await User.find({ email: req.body.email })
        .count()
        .exec();
    } else {
      var checkEmail = 0;
    }

    if (checkEmail) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Email already in use.",
        responseData: {},
      });
    } else if (busuness_name) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Business name already taken.",
        responseData: {},
      });
    } else {
      // var checkUsername = await User.find({ username: req.body.name }).collation({ locale: 'en', strength: 2 }).exec();
      // if (checkUsername.length == 0) {
      //     var regexp = /^[a-zA-Z0-9._]+$/;
      //     var check = req.body.username;
      //     if (check.search(regexp) == -1) {
      //         res.status(422).json({
      //             responseCode: 422,
      //             responseMessage: "Use Only Alphabet, Numbers and dot & underscore",
      //             responseData: {},
      //         });
      //     }
      //     else {
      var checkPhone = await User.find({
        contact_no: req.body.contact_no,
        "account_info.type": "business",
      })
        .count()
        .exec();
      if (checkPhone == 0) {
        var firstPart = (Math.random() * 46656) | 0;
        var secondPart = (Math.random() * 46656) | 0;
        firstPart = ("000" + firstPart.toString(36)).slice(-3);
        secondPart = ("000" + secondPart.toString(36)).slice(-3);
        req.body.referral_code =
          firstPart.toUpperCase() + secondPart.toUpperCase();

        var otp = Math.floor(Math.random() * 90000) + 10000;

        req.body.username = shortid.generate();

        req.body.socialite = {};
        req.body.optional_info = {};

        var address = req.body.address;

        var country = await Country.findOne({
          timezone: { $in: req.headers["tz"] },
        }).exec();
        var count = await User.find({
          "account_info.type": "business",
          visibility: true,
        }).count();
        // req.body.business_id = count + 10000; //
        var rand = Math.ceil(Math.random() * 100000 + 1);

        req.body.name = _.startCase(_.toLower(req.body.name));

        var name = req.body.name;

        req.body.address = {
          // country: country.countryName,
          timezone: req.headers["tz"],
          location: req.body.location,
          address: address,
          state: req.body.state,
          city: req.body.city,
          zip: req.body.zip,
          area: req.body.area,
          landmark: req.body.landmark,
          country_code: req.body.country_code,
        };
        req.body.bank_details = {
          ifsc: req.body.ifsc,
          account_no: req.body.account_no,
          account_holder: req.body.account_holder,
        };
        req.body.account_info = {
          type: "business",
          status: "Complete",
          added_by: null,
          phone_verified: false,
          verified_account: false,
          approved_by_admin: false,
          is_password: true,
        };
        req.body.geometry = [0, 0];
        if (req.body.longitude && req.body.latitude) {
          req.body.geometry = [req.body.longitude, req.body.latitude];
        }
        req.body.device = [];
        req.body.otp = otp;
        //console.log("Categotry = " + req.body.category,)
        req.body.business_info = {
          company_name: req.body.name,
          // business_category:req.body.business_category,
          business_id: count + 10000, //
          category: req.body.category,
          brand: req.body.carBrand,
          company: req.body.company,
          account_no: req.body.account_no,
          gst_registration_type: req.body.gst_registration_type,
          gstin: req.body.gstin,
          is_claimed: true,
          tax_registration_no: req.body.tax_registration_no,
          pan_no: req.body.pan_no,
        };
        req.body.optional_info = {
          reg_by: req.body.name,
        };
        var started_at = null;
        if (req.body.started_at) {
          started_at = new Date(req.body.started_at).toISOString();
        }

        var expired_at = null;
        if (req.body.expired_at) {
          expired_at = new Date(req.body.expired_at).toISOString();
        }

        req.body.uuid = uuidv1();
        // var newhash = bcrypt.hashSync(req.body.password);
        // req.body.password = newhash

        User.create(req.body).then(async function (user) {
          var days = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
          console.log("test");
          for (var i = 0; i < 7; i++) {
            var timing = new BusinessTiming({
              business: user._id,
              day: days[i],
              open: "09:30 AM",
              close: "06:30 PM",
              is_closed: false,
              created_at: new Date(),
              updated_at: new Date(),
            });
            timing.save();
          }
          await whatsAppEvent.autroidBusinessReg(
            user.name,
            user.contact_no,
            user._id
          );
          var passwordData = {
            password: bcrypt.hashSync(req.body.password),
          };

          await User.findOneAndUpdate(
            { _id: user._id },
            { $set: passwordData },
            { new: true },
            async function (err, doc) {
              if (err) {
                var json = {
                  responseCode: 400,
                  responseMessage: "Please Try Again",
                  responseData: err,
                };

                res.status(400).json(json);
              } else {
                var data = {
                  otp: otp,
                  account_info: {
                    phone_verified: false,
                    status: "Active",
                    approved_by_admin: false,
                    verified_account: false,
                    // added_by: user.account_info.added_by,
                    type: "business",
                    is_page: user.account_info.is_page,
                  },
                };

                await User.findOneAndUpdate(
                  { _id: user._id },
                  { $set: data },
                  function (err, doc) {}
                );
              }
            }
          );
          if (req.body.planCategory != "others") {
            var freePlan = await SuitePlan.findOne({
              plan: "Free",
              category: req.body.planCategory,
            }).exec();

            if (freePlan) {
              var plans = await BusinessPlan.find({
                business: user._id,
                suite: freePlan.id,
              })
                .count()
                .exec();
              if (plans == 0) {
                console.log("Inside Plan = " + freePlan.id);
                await SuitePlan.find({ _id: freePlan.id })
                  .cursor()
                  .eachAsync(async (plan) => {
                    if (plan) {
                      var plan_no =
                        Math.round(+new Date() / 1000) +
                        Math.round(Math.random() * 9999 + 10);
                      // console.log("Plans detail" + plan, business._id)
                      var expired_at = new Date();
                      // var status = ""
                      // if (plan.price - req.body.paid > 0) {

                      //     status = "Pending"
                      // } else if (plan.price - req.body.paid == 0) {

                      var status = "Success";

                      // }
                      expired_at.setDate(expired_at.getDate() + plan.validity);
                      await BusinessPlan.create({
                        suite: plan._id,
                        plan: plan.plan,
                        name: plan.name,
                        short_name: plan.short_name,
                        price: plan.price,
                        default: plan.default,
                        main: plan.main,
                        limits: plan.limits,
                        category: plan.category,
                        validity: plan.validity,
                        expired_at: expired_at,
                        "payment.paid_total": parseInt(plan.price),
                        "payment.due": plan.price - parseInt(plan.price),
                        "payment.mode": "Free",
                        "payment.total": plan.price,
                        "payment.price": plan.price,
                        "payment.payment_status": status,
                        "due.due": plan.price - parseInt(plan.price),
                        "due.pay": parseInt(plan.price),
                        plan_no: plan_no,
                        sold_by: user.name,
                        created_at: new Date(),
                        updated_at: new Date(),
                        business: user._id,
                      });

                      // .cursor().eachAsync(async (business) => {
                      await TransactionLog.create({
                        user: user._id,
                        activity: "Business-Plan",
                        status: "Purchase",
                        received_by: "Self Registered",
                        // source: plan._id,
                        // source: plan[0]._id,
                        source: user._id,
                        plan_no: plan_no,
                        // source: order_id,
                        business: user._id,
                        // paid_by: req.body.paid_by,
                        paid_by: "Customer",
                        // paid_total: req.body.paid,
                        // paid_total: parseInt(req.body.paid),
                        paid_total: plan.price,
                        total: plan.price,
                        // payment_mode: req.body.payment_mode,
                        payment_mode: "Free Account",
                        payment_status: "Success",
                        order_id: null,
                        // transaction_id: req.body.transaction_id,
                        transaction_id: "free Account",
                        transaction_date: new Date(),
                        transaction_status: "Success",
                        transaction_response: "Success",
                        created_at: new Date(),
                        updated_at: new Date(),
                      });
                    }
                  });

                // res.status(200).json({
                //     responseCode: 200,
                //     responseMessage: "Suite plans has been added.",
                //     responseData: {}
                // });
                console.log("Suite plans has been added.");
              } else {
                // res.status(400).json({
                //     responseCode: 400,
                //     responseMessage: "Some Plans already active.",
                //     responseData: {}
                // });
                console.log("Some Plans already active.");
              }
            }
          }
          await Management.create({
            business: user._id,
            user: user._id,
            role: "Admin",
            created_at: new Date(),
            updated_at: new Date(),
          });

          await Address.create({
            user: user._id,
            address: address,
            area: req.body.area,
            landmark: req.body.landmark,
            zip: req.body.zip,
            city: req.body.city,
            state: req.body.state,
            created_at: new Date(),
            updated_at: new Date(),
          });
          await BusinessSetting.create({
            discount_on: "Labour",
            business: user._id,
            job_inspection_pics_limit: 11,
            qc_inspection_limit: 11,
            skip_insurance_info: true,
            skip_store_approval: true,
            skip_qc: true,
            tax_invoice: true,
            gst_invoice: true,
          });

          event.autroidSignUpMail(user);
          event.autroidSignUpSMS(user);
          event.autroidOnboardings(user);
          event.otpSms(user);
          whatsAppEvent.welOnBoard(user.name, user.contact_no, user._id);
          // Type.find({}).then(function(BT){
          //     BT.forEach(function (u) {
          //         var businessType = new BusinessType({
          //             business: user._id,
          //             business_type: u._id,
          //             is_added: false,
          //         });
          //         businessType.save();
          //     });
          // });

          //event.signupSMS(user);
          //event.otpSms(user);

          res.status(200).json({
            responseCode: 200,
            responseMessage: "Business registered successfully",
            responseData: {
              user: user,
              // manifest: manifest,
            },
          });
        });
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Phone number already in use.",
          responseData: {},
        });
      }
    }
    // }
    // else {
    //     res.status(422).json({
    //         responseCode: 422,
    //         responseMessage: "Username already in use.",
    //         responseData: {},
    //     });
    // }
    // }
  }
});

router.get(
  "/insurance/due/get",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers["business"];
    var cars = [];
    var filters = [];
    var totalResult = 0;

    var role = await Management.findOne({
      user: user,
      business: business,
    }).exec();
    if (req.query.page == undefined) {
      var page = 0;
    } else {
      var page = req.query.page;
    }

    var specification = {};
    specification["$lookup"] = {
      from: "User",
      localField: "user",
      foreignField: "_id",
      as: "user",
    };
    filters.push(specification);

    var specification = {};
    specification["$unwind"] = {
      path: "$user",
      preserveNullAndEmptyArrays: false,
    };
    filters.push(specification);

    var specification = {};
    specification["$lookup"] = {
      from: "Car",
      localField: "car",
      foreignField: "_id",
      as: "car",
    };
    filters.push(specification);

    var specification = {};
    specification["$unwind"] = {
      path: "$car",
      preserveNullAndEmptyArrays: true,
    };

    var bar = new Date();
    bar.setDate(bar.getDate() + 35);

    if (req.query.query) {
      req.query.query = req.query.query.replace(
        /([.?*+^$[\]\\(){}|-])/g,
        "\\$1"
      );

      var specification = {};
      specification["$match"] = {
        business: mongoose.Types.ObjectId(business),
        "car.insurance_info": { $exists: true },
        "car.insurance_info.expire": { $ne: "" },
        "car.insurance_info.expire": { $ne: null },
        "car.insurance_info.expire": { $lte: bar },
        $or: [
          { "user.name": { $regex: req.query.query, $options: "i" } },
          { "user.contact_no": { $regex: req.query.query, $options: "i" } },
          { "car.title": { $regex: req.query.query, $options: "i" } },
          { "car.registration_no": { $regex: req.query.query, $options: "i" } },
          {
            "car.insurance_info.policy_holder": {
              $regex: req.query.query,
              $options: "i",
            },
          },
          {
            "car.insurance_info.insurance_company": {
              $regex: req.query.query,
              $options: "i",
            },
          },
          {
            "car.insurance_info.policy_type": {
              $regex: req.query.query,
              $options: "i",
            },
          },
          {
            "car.insurance_info.policy_no": { $eq: Math.ceil(req.query.query) },
          },
        ],
      };
      filters.push(specification);
    } else {
      var specification = {};
      specification["$match"] = {
        "car.insurance_info": { $exists: true },
        business: mongoose.Types.ObjectId(business),
        "car.insurance_info.expire": { $ne: "" },
        "car.insurance_info.expire": { $ne: null },
        "car.insurance_info.expire": { $lte: bar },
      };
      filters.push(specification);
    }

    var specification = {};
    specification["$group"] = {
      _id: { car: "$car" },
      max: { $max: "$car.insurance_info.expire" },
      item: { $push: "$$ROOT" },
    };
    filters.push(specification);

    var specification = {};
    specification["$sort"] = {
      max: -1,
    };
    filters.push(specification);

    totalResult = await Booking.aggregate(filters);

    var specification = {};
    specification["$skip"] = config.perPage * page;
    filters.push(specification);

    var specification = {};
    specification["$limit"] = config.perPage;
    filters.push(specification);

    await Booking.aggregate(filters)
      .allowDiskUse(true)
      .cursor({ batchSize: 10 })
      .exec()
      .eachAsync(async function (booking) {
        // console.log("Booking Id " + booking._id)
        if (booking._id.car[0].insurance_info) {
          var expire = moment(booking._id.car[0].insurance_info.expire)
            .tz(req.headers["tz"])
            .format("YYYY-MM-DD");
          var insurance_info = {
            policy_holder: booking._id.car[0].insurance_info.policy_holder,
            policy_no: booking._id.car[0].insurance_info.policy_no,
            insurance_company:
              booking._id.car[0].insurance_info.insurance_company,
            policy_type: booking._id.car[0].insurance_info.policy_type,
            premium: booking._id.car[0].insurance_info.premium,
            expire: expire,
          };
        }

        /*Car.findOneAndUpdate({ _id: booking._id.car[0]._id  },{ $set:{
                insurance_info: {
                    policy_holder: booking.item[0].insurance_info.policy_holder,
                    policy_no: booking.item[0].insurance_info.policy_no,
                    insurance_company: booking.item[0].insurance_info.insurance_company,
                    policy_type: booking.item[0].insurance_info.policy_type,
                    premium: booking.item[0].insurance_info.premium,
                    expire: new Date(expire).toISOString(),
                }
            }
    
            },{new: false}, function(err, doc){});*/

        cars.push({
          _id: booking._id.car[0]._id,
          id: booking._id.car[0]._id,
          title: booking._id.car[0].title,
          modelName:
            booking._id.car[0]._automaker + " " + booking._id.car[0]._model,
          price: price(booking._id.car[0].price),
          numericPrice: booking._id.car[0].price,
          carId: booking._id.car[0].carId,
          fuel_type: booking._id.car[0].fuel_type,
          vehicle_color: booking._id.car[0].vehicle_color,
          registration_no: booking._id.car[0].registration_no,
          manufacture_year: booking._id.car[0].manufacture_year,
          user: await User.findById(booking._id.car[0].user)
            .select("name email contact_no business_info")
            .exec(),
          booking_lead: await Booking.findOne({ car: booking._id.car[0]._id })
            .select("leadManagement _id")
            .exec(),
          status: booking._id.car[0].status,
          insurance_info: insurance_info,
          created_at: booking._id.car[0].created_at,
          updated_at: booking._id.car[0].updated_at,
        });
      });

    res.status(200).json({
      responseCode: 200,
      responseMessage: "Insurance Dues",
      responseInfo: {
        totalResult: totalResult.length,
        filter: filters,
      },
      responseData: cars,
    });
  }
);

router.get(
  "/service-reminder/get",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers["business"];
    var bookings = [];
    var filters = [];
    var totalResult = 0;

    var role = await Management.findOne({
      user: user,
      business: business,
    }).exec();
    if (req.query.page == undefined) {
      var page = 0;
    } else {
      var page = req.query.page;
    }

    var specification = {};
    specification["$lookup"] = {
      from: "User",
      localField: "user",
      foreignField: "_id",
      as: "user",
    };
    filters.push(specification);

    var specification = {};
    specification["$unwind"] = {
      path: "$user",
      preserveNullAndEmptyArrays: false,
    };
    filters.push(specification);

    var specification = {};
    specification["$lookup"] = {
      from: "Car",
      localField: "car",
      foreignField: "_id",
      as: "car",
    };
    filters.push(specification);

    var specification = {};
    specification["$unwind"] = {
      path: "$car",
      preserveNullAndEmptyArrays: true,
    };

    var bar = new Date();
    bar.setDate(bar.getDate() + 20);

    if (req.query.query) {
      req.query.query = req.query.query.replace(
        /([.?*+^$[\]\\(){}|-])/g,
        "\\$1"
      );
      var specification = {};
      specification["$match"] = {
        business: mongoose.Types.ObjectId(business),
        service_reminder: { $lte: bar },
        $or: [
          { "user.name": { $regex: req.query.query, $options: "i" } },
          { "user.contact_no": { $regex: req.query.query, $options: "i" } },
          { "car.title": { $regex: req.query.query, $options: "i" } },
          { "car.registration_no": { $regex: req.query.query, $options: "i" } },
          {
            "car.insurance_info.policy_holder": {
              $regex: req.query.query,
              $options: "i",
            },
          },
        ],
      };
      filters.push(specification);
    } else {
      var specification = {};
      specification["$match"] = {
        business: mongoose.Types.ObjectId(business),
        service_reminder: { $lte: bar },
      };
      filters.push(specification);
    }

    filters.push(specification);

    totalResult = await Booking.aggregate(filters);

    var specification = {};
    specification["$sort"] = {
      service_reminder: 1,
    };
    filters.push(specification);

    var specification = {};
    specification["$skip"] = config.perPage * page;
    filters.push(specification);

    var specification = {};
    specification["$limit"] = config.perPage;
    filters.push(specification);

    await Booking.aggregate(filters)
      .allowDiskUse(true)
      .cursor({ batchSize: 10 })
      .exec()
      .eachAsync(async function (booking) {
        var remarks = booking.remarks;
        var remarksData = [];
        if (remarks) {
          for (var i = 0; i < remarks.length; i++) {
            var added_by = await User.findById(remarks[i].added_by).exec();
            remarksData.push({
              added_by: remarks[i].user,
              name: added_by.name,
              remark: remarks[i].remark,
              created_at: moment(remarks[i].created_at)
                .tz(req.headers["tz"])
                .format("lll"),
              updated_at: moment(remarks[i].updated_at)
                .tz(req.headers["tz"])
                .format("lll"),
            });
          }
        }

        bookings.push({
          _id: booking._id,
          id: booking._id,
          car: {
            title: booking.car[0].title,
            _id: booking.car[0]._id,
            id: booking.car[0].id,
            vin: booking.car[0].vin,
            engine_no: booking.car[0].engine_no,
            registration_no: booking.car[0].registration_no,
            variant: booking.car[0].variant,
            manufacture_year: booking.car[0].manufacture_year,
            purchased_year: booking.car[0].purchased_year,
          },
          user: {
            name: booking.user.name,
            _id: booking.user._id,
            id: booking.user.id,
            contact_no: booking.user.contact_no,
            email: booking.user.email,
            business_info: booking.user.business_info,
            account_info: booking.user.account_info,
          },
          insurance_info: booking.insurance_info,
          odometer: booking.odometer,
          convenience: booking.convenience,
          date: moment(booking.date).tz(req.headers["tz"]).format("ll"),
          time_slot: booking.time_slot,
          status: _.startCase(booking.status),
          _status: booking.status,
          sub_status: booking.sub_status,
          booking_no: booking.booking_no,
          job_no: booking.job_no,
          remarks: remarks,
          service_reminder: moment(booking.service_reminder)
            .tz(req.headers["tz"])
            .format("lll"),
          created_at: moment(booking.created_at)
            .tz(req.headers["tz"])
            .format("lll"),
          updated_at: moment(booking.updated_at)
            .tz(req.headers["tz"])
            .format("lll"),
        });
      });

    res.status(200).json({
      responseCode: 200,
      responseMessage: "",
      responseInfo: {
        totalResult: totalResult.length,
      },
      responseData: bookings,
    });
  }
);

router.get(
  "/lead-generation/get",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers["business"];
    var filters = [];
    var data = [];
    let startDate = req.query.start_date;
    let endDate = req.query.end_date;
    // console.log(startDate, req.query.end_date)

    if (startDate && endDate) {
      filters.push({
        $match: {
          created_at: { $gte: new Date(startDate), $lt: new Date(endDate) },
        },
      });
    } else {
      var filters = [
        {
          $match: {
            "remark.status": { $in: ["contacted", "potential"] },
            business: mongoose.Types.ObjectId(business),
          },
        },
      ];
    }
    // console.log(business)

    if (req.query.query) {
      req.query.query = req.query.query.replace(
        /([.?*+^$[\]\\(){}|-])/g,
        "\\$1"
      );
      filters = [
        {
          $match: {
            business: mongoose.Types.ObjectId(business),

            $or: [
              { name: { $regex: req.query.query, $options: "i" } },
              { contact_no: { $regex: req.query.query, $options: "i" } },
              {
                "additional_info.registration_no": {
                  $regex: req.query.query,
                  $options: "i",
                },
              },
              {
                "additional_info.location": {
                  $regex: req.query.query,
                  $options: "i",
                },
              },
              {
                "additional_info.category": {
                  $regex: req.query.query,
                  $options: "i",
                },
              },
              {
                "additional_info.alternate_no": {
                  $regex: req.query.query,
                  $options: "i",
                },
              },
              { "remark.status": { $regex: req.query.query, $options: "i" } },
              // {
              //     "remark": {
              //         $elemMatch: {
              //             "status": { $regex: req.query.query, $options: 'i' }
              //         }
              //     }
              // },
            ],
          },
        },
      ];
    }

    totalLead = await LeadGen.aggregate(filters).exec();
    // console.log("Lead remarks", filters, totalLead.length)
    var queries = {};
    if (req.query.page == undefined) {
      var page = 0;
    } else {
      var page = req.query.page;
    }
    var page = Math.max(0, parseInt(page));
    // if (req.query.query) {
    //     var specification = {};
    //     specification['$match'] = {
    //         business: mongoose.Types.ObjectId(business),
    //         $or: [
    //             { 'name': { $regex: req.query.query, $options: 'i' } },
    //             { 'contact_no': { $regex: req.query.query, $options: 'i' } },
    //             { 'additional_info.registration_no': { $regex: req.query.query, $options: 'i' } },
    //             { 'additional_info.location': { $regex: req.query.query, $options: 'i' } },
    //             { 'additional_info.category': { $regex: req.query.query, $options: 'i' } },
    //             { 'additional_info.alternate_no': { $regex: req.query.query, $options: 'i' } },
    //         ]
    //     };
    // }
    var specification = {};
    specification["$skip"] = config.perPage * page;
    filters.push(specification);

    var specification = {};
    specification["$limit"] = config.perPage;
    filters.push(specification);

    //Testing Filter End
    // res.send(filter)
    await LeadGen.aggregate(filters)
      .allowDiskUse(true)
      .cursor({ batchSize: 10 })
      .sort({ updated_at: -1 })
      .exec()
      .eachAsync(async function (result) {
        data.push({
          name: result.name,
          mobile: result.contact_no,
          id: result._id,
          additional_info: {
            address: result.additional_info.address,
            model: result.additional_info.model,
            location: result.additional_info.location,
            registration_no: result.additional_info.registration_no,
            brand: result.additional_info.brand,
            category: result.additional_info.category,
          },
          assignee: result.assignee,
          business: result.business_id,
          source: result.source,
          status: result.remark.status,
          contacted: result.contacted,
          updated_at: result.updated_at,
        });
      });
    // console.log(data)
    res.status(200).json({
      responseCode: 200,
      responseMessage: "Lead data",
      responseInfo: {
        totalResult: totalLead.length,
      },
      responseData: data,
    });
  }
);

router.get("/lead-gen/remark/get", async function (req, res, next) {
  let lead = await LeadGenRemark.find({
    lead: mongoose.Types.ObjectId(req.query.id),
  })
    .populate("assignee")
    .exec();
  res.json({
    remarks: lead,
  });
});

router.get(
  "/insurence/lead/details/get",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var business = req.headers["business"];

    var technicians = [];
    // // console.log("Car Id " + req.query.car + " Business = " + business)
    var booking = await Booking.findOne({
      car: req.query.car,
      business: business,
    }).exec();
    if (booking) {
      if (booking.leadManagement) {
        if (booking.leadManagement.status != "") {
          var assignee = await User.findById(
            booking.leadManagement.assignee
          ).exec();
          // return res.status(400).json({
          //     responseCode: 400,
          //     responseMessage: "Lead details not found",
          //     responseData: assignee
          // })
          var data = {
            user: booking.leadManagement.user,
            name: booking.leadManagement.name,
            contact_no: booking.leadManagement.contact_no,
            email: booking.leadManagement.email,
            reason: booking.leadManagement.reason,
            type: booking.leadManagement.type,
            status: booking.leadManagement.status,
            business: booking.leadManagement.business,
            assignee: assignee,
            priority: booking.leadManagement.priority,
            source: booking.leadManagement.source,
            remarks: booking.leadManagement.remarks,
            follow_up: booking.leadManagement.follow_up,
            created_at: booking.leadManagement.created_at,
            updated_at: booking.leadManagement.updated_at,
          };
          res.status(200).json({
            responseCode: 200,
            responseMessage: "Lead Data",
            responseData: data,
          });
        } else {
          res.status(400).json({
            responseCode: 400,
            responseMessage: "Lead details not found",
            responseData: data,
          });
        }
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Lead details not found",
          responseData: data,
        });
      }
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Booking not Found",
        responseData: data,
      });
    }
  }
);

router.post(
  "/insurance/leads",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var business = req.headers["business"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    var loggedInDetails = await User.findById(decoded.user).exec();
    // console.log("_____" + loggedInDetails);
    var role = await Management.findOne({
      user: decoded.user,
      business: business,
    }).exec();
    // console.log("----" + role);
    // console.log("----" + booking);
    var booking = await Booking.findOne({
      car: req.body._id,
      business:
        business /* "leadManagement.remark.status": { $nin: ["Open", "Follow-Up"] } */,
    })
      .populate({ path: "user", select: "name contact_no address _id" })
      .populate({ path: "lead", select: "follow_up, remark, source" })
      .exec();
    // // console.log("----" + req.body._id);

    if (booking) {
      // // console.log()
      async function getAssignee(user, business) {
        var role = await Management.findOne({
          user: user,
          business: business,
        }).exec();
        if (role.role == "CRE") {
          advisor = role.user;
        } else {
          var assigneeLead = [];
          await Management.find({ business: business, role: "CRE" })
            .cursor()
            .eachAsync(async (a) => {
              // var d = await Lead.find({ business: business, assignee: a.user }).count().exec();
              var open = await Lead.find({
                business: business,
                assignee: a.user,
                "remark.status": { $in: ["Open"] },
              })
                .count()
                .exec();
              var follow_up = await Lead.find({
                business: business,
                assignee: a.user,
                "remark.status": { $in: ["Follow-Up"] },
                "follow_up.date": { $lte: new Date() },
              })
                .count()
                .exec();
              var d = open + follow_up;

              assigneeLead.push({
                user: a.user,
                count: d,
              });
            });

          if (assigneeLead.length != 0) {
            assigneeLead.sort(function (a, b) {
              return a.count > b.count;
            });

            advisor = assigneeLead[0].user;
          } else {
            advisor = role.business;
          }
        }

        return advisor;
      }
      var assignee = await q.all(
        businessFunctions.getAssignee(decoded.user, business)
      );

      if (req.body.status == "Follow-Up") {
        if (req.body.date) {
          var follow_up = {
            date: new Date(req.body.date).toISOString(),
            time: req.body.time,
            created_at: new Date(),
            updated_at: new Date(),
          };
        }
      }

      //

      var leadManagement = {
        user: booking.user,
        name: booking.user.name,
        contact_no: booking.user.contact_no,
        email: booking.user.email,
        reason: req.body.reason,
        type: req.body.type,
        status: req.body.status,
        business: req.headers["business"],
        assignee: assignee,
        priority: req.body.priority,
        source: booking.lead.source,
        // remarks: remark,
        follow_up: follow_up,
        // created_at: new Date(),
        updated_at: new Date(),
      };

      await Booking.findOneAndUpdate(
        { _id: booking._id },
        { $set: { leadManagement: leadManagement } },
        { new: false },
        async function (err, doc) {
          var remark = {
            assignee: assignee,
            status: req.body.status,
            reason: req.body.reason,
            customer_remark: req.body.remark,
            assignee_remark: req.body.remark,
            color_code: "",
            created_at: new Date(),
            updated_at: new Date(),
          };
          var remarks = doc.leadManagement.remarks;
          remarks.push(remark);
          //

          //  var remarks = [];
          // console.log(remarks);
          // var leadman = booking.leadManagement._id;
          // console.log("ID...." + leadman);
          // var data= await Booking.findOneAndUpdate({ "leadManagement._id":doc.leadManagement._id}).exec();
          // return res.json({
          //   data:data
          // })
          await Booking.findOneAndUpdate(
            { _id: doc._id },
            { $set: { "leadManagement.remarks": remarks } },
            { new: true },
            async function (err, doc) {
              res.status(200).json({
                responseCode: 200,
                responseMessage: "Lead Added to booking",
                responseData: doc,
              });
            }
          );
        }
      );
      // console.log(leadManagement);

      // console.log("ID>>>" + booking.leadManagement._id);
      // console.log("@@@@@@@@" + remarks);

      //
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Booking Not not found",
        responseData: {},
      });
    }
  }
);

router.get(
  "/lead/status/get",
  xAccessToken.token,
  async function (req, res, next) {
    var leads = [];
    var status = await LeadStatus.findOne({ stage: req.query.stage }).exec();
    if (status) {
      res.status(200).json({
        responseCode: 200,
        responseMessage: "success",
        responseData: status.status,
      });
    } else {
      res.status(200).json({
        responseCode: 200,
        responseMessage: "success",
        responseData: [],
      });
    }
  }
);

router.get("/job/inspection/get", async function (req, res, next) {
  var rules = {
    booking: "required",
  };

  var validation = new Validator(req.query, rules);

  if (validation.fails()) {
    res.status(422).json({
      responseCode: 422,
      responseMessage: "Error",
      responseData: {
        res: validation.errors.all(),
      },
    });
  } else {
    var booking = await Booking.findById(req.query.booking).exec();
    if (booking) {
      var file = await JobInspection.find({ booking: booking._id })
        .select("file type stage")
        .exec();
      res.status(200).json({
        responseCode: 200,
        responseMessage: "",
        responseData: file,
      });
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Booking not found",
        responseData: {},
      });
    }
  }
});

router.get(
  "/job/payment/logs",
  xAccessToken.token,
  async function (req, res, next) {
    var business = req.headers["business"];
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    var booking = await Booking.findById(req.query.booking).exec();
    if (booking) {
      var logs = [];
      await TransactionLog.find({ source: req.query.booking })
        .sort({ updated_at: -1 })
        .cursor()
        .eachAsync(async (log) => {
          logs.push({
            _id: log._id,
            id: log._id,
            activity: log.activity,
            payment_mode: log.payment_mode,
            paid_total: log.paid_total,
            payment_status: log.payment_status,
            transaction_id: log.transaction_id,
            transaction_date: log.transaction_date,
            transaction_status: log.transaction_status,
            transaction_response: log.transaction_response,
            user: log.user,
            source: log.source,
            paid_total: log.paid_total,
            total: log.total,
            created_at: moment(log.created_at)
              .tz(req.headers["tz"])
              .format("lll"),
            updated_at: moment(log.updated_at)
              .tz(req.headers["tz"])
              .format("lll"),
          });
        });
      res.status(200).json({
        responseCode: 200,
        responseMessage: "Transaction Log",
        responseData: logs,
      });
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Booking not found",
        responseData: {},
      });
    }
  }
);

router.get(
  "/job/convenience",
  xAccessToken.token,
  async function (req, res, next) {
    var business = req.headers["business"];
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var data = [];
    var booking = await Booking.findById(req.query.booking).exec();
    if (booking) {
      var addresses = [];
      await Address.find({ user: booking.user })
        .cursor()
        .eachAsync(async (address) => {
          if (address._id.equals(booking.address)) {
            var checked = true;
          } else {
            var checked = false;
          }

          addresses.push({
            _id: address._id,
            id: address.id,
            user: address.user,
            address: address.address,
            area: address.area,
            landmark: address.landmark,
            zip: address.zip,
            city: address.city,
            state: address.state,
            checked: checked,
          });
        });

      var conveniences = [];
      // business: booking.business
      await BusinessConvenience.find({})
        .cursor()
        .eachAsync(async (convenience) => {
          if (convenience.convenience == booking.convenience) {
            var checked = true;
          } else {
            var checked = false;
          }

          conveniences.push({
            _id: convenience._id,
            id: convenience.id,
            convenience: convenience.convenience,
            charges: convenience.charges,
            business: convenience.business,
            checked: checked,
          });
        });

      res.status(200).json({
        responseCode: 200,
        responseMessage: "",
        responseData: {
          address: addresses,
          convenience: conveniences,
        },
      });
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Booking not found",
        responseData: {},
      });
    }
  }
);

router.get("/booking/details", async function (req, res, next) {
  if (req.query.by == "id") {
    var query = { _id: req.query.booking };
  } else if (req.query.by == "lead") {
    var query = { lead: req.query.booking };
  } else {
    var query = { booking_no: req.query.booking };
  }

  var bookings = [];
  var booking = await Booking.findOne(query)
    .populate({ path: "address" })
    .populate({ path: "manager", select: "_id id name contact_no email" })
    .populate({ path: "advisor", select: "_id id name contact_no email" })
    .populate({
      path: "user",
      select:
        "_id id name contact_no email account_info business_info careager_cash",
    })
    .populate({
      path: "business",
      select: "_id id name contact_no email business_info address bank_details",
    })
    .populate({ path: "driver", select: "_id id name contact_no email" })
    .populate({ path: "technician", select: "_id id name contact_no email" })
    .populate({ path: "surveyor", select: "_id id name contact_no email" })
    .populate({
      path: "lead",
      select: "_id id name contact_no email source category",
    })
    .populate({
      path: "car",
      select:
        "_id id title variant _automaker automaker registration_no ic rc vin engine_no insurance_info manufacture_year purchased_year",
    })
    .exec();
  // console.log("Cash Available = " + booking.user.careager_cash)
  if (booking) {
    var car = null;
    var manager = null;
    var advisor = null;
    var driver = null;
    var technician = null;
    var surveyor = null;
    var customer_requirements = [];
    var address = null;
    var recording = "";
    var lead = null;

    if (booking.car) {
      if (booking.car._automaker == "") {
        var automaker = await Automaker.findOne({
          _id: booking.car.automaker,
        }).exec();
        if (automaker) {
          Car.findOneAndUpdate(
            { _id: booking.car._id },
            { $set: { _automaker: automaker.maker } },
            { new: false },
            async function (err, doc) {
              if (err) {
                console.log(err);
              }
            }
          );
        }
      }

      car = {
        title: booking.car.title,
        _id: booking.car._id,
        id: booking.car.id,
        vin: booking.car.vin,
        engine_no: booking.car.engine_no,
        registration_no: booking.car.registration_no,
        ic_address: booking.car.ic_address,
        rc_address: booking.car.rc_address,
        variant: booking.car.variant,
        manufacture_year: booking.car.manufacture_year,
        purchased_year: booking.car.purchased_year,
      };
    }

    if (booking.manager) {
      var email = "";
      if (booking.manager.email) {
        email = booking.manager.email;
      }

      manager = {
        name: booking.manager.name,
        _id: booking.manager._id,
        id: booking.manager.id,
        contact_no: booking.manager.contact_no,
        email: email,
      };
    }

    if (booking.advisor) {
      var email = "";
      if (booking.advisor.email) {
        email = booking.advisor.email;
      }
      advisor = {
        name: booking.advisor.name,
        _id: booking.advisor._id,
        id: booking.advisor.id,
        contact_no: booking.advisor.contact_no,
        email: email,
      };
    }
    if (booking.lead) {
      lead = {
        name: booking.lead.name,
        _id: booking.lead._id,
        id: booking.lead.id,
        contact_no: booking.lead.contact_no,
        source: booking.lead.source,
      };
    }
    if (booking.driver) {
      var email = "";
      if (booking.driver.email) {
        email = booking.driver.email;
      }
      driver = {
        name: booking.driver.name,
        _id: booking.driver._id,
        id: booking.driver.id,
        contact_no: booking.driver.contact_no,
        email: email,
      };
    }

    if (booking.technician) {
      var email = "";
      if (booking.technician.email) {
        email = booking.technician.email;
      }

      technician = {
        name: booking.technician.name,
        _id: booking.technician._id,
        id: booking.technician.id,
        contact_no: booking.technician.contact_no,
        email: email,
      };
    }

    if (booking.surveyor) {
      var email = "";
      if (booking.surveyor.email) {
        email = booking.surveyor.email;
      }

      surveyor = {
        name: booking.surveyor.name,
        _id: booking.surveyor._id,
        id: booking.surveyor.id,
        contact_no: booking.surveyor.contact_no,
        email: email,
      };
    }

    if (booking.customer_requirements) {
      customer_requirements = booking.customer_requirements;
    }

    var tax_type = "GST";

    var bookingService = [];

    var careager_cash = await q.all(fun.getBookingCarEagerCash(booking._id));
    // var user_careager_cash = await q.all(fun.getCarEagerCash(booking._id));

    var services = booking.services;

    for (var i = 0; i < services.length; i++) {
      var part = [];
      var labours = [];
      var opening_fitting = [];

      var part_list = services[i].parts;
      var labour_list = services[i].labour;
      var of_list = services[i].opening_fitting;

      if (part_list) {
        for (var p = 0; p < part_list.length; p++) {
          var total = 0;
          var tax_info = await Tax.findOne({
            rate: part_list[p].tax_rate,
            type: tax_type,
          }).exec();
          var tax = [];
          var rate = part_list[p].rate;
          var amount =
            parseFloat(part_list[p].rate) * parseFloat(part_list[p].quantity);
          var tax_rate = tax_info.detail;
          var discount_total = 0;
          var base = amount;

          var dep = 0;

          /*if(services[i].claim==true)
                    {
                        if(parseFloat(part_list[p].insurance_dep)<=0 && parseFloat(part_list[p].customer_dep)<=0)
                        {
                            dep = 0
                        }
                        else
                        {
                            if(parseFloat(part_list[p].customer_dep) <= 0 && parseFloat(part_list[p].insurance_dep<=100))
                            {
                                dep = 100
                            }
                            else
                            {
                                dep = 100-parseFloat(part_list[p].customer_dep);
                            }
                        }

                        amount = amount-(amount*dep/100);
                        dep = base - amount;
                    }*/

          if (part_list[p].discount) {
            discount_total = part_list[p].discount;
            amount = amount - parseFloat(discount_total.toFixed(2));
          }

          if (part_list[p].amount_is_tax == "exclusive") {
            var tax_on_amount = amount;
            if (tax_rate.length > 0) {
              for (var r = 0; r < tax_rate.length; r++) {
                if (tax_rate[r].rate != tax_info.rate) {
                  var t = tax_on_amount * (tax_rate[r].rate / 100);
                  amount = amount + t;
                  parseFloat;
                  tax.push({
                    tax: tax_rate[r].tax,
                    rate: tax_rate[r].rate,
                    amount: parseFloat(t.toFixed(2)),
                  });
                } else {
                  var t = tax_on_amount * (tax_rate[r].rate / 100);
                  amount = amount + t;
                  tax.push({
                    tax: tax_info.tax,
                    tax_rate: tax_info.rate,
                    rate: tax_info.rate,
                    amount: parseFloat(t.toFixed(2)),
                  });
                }
              }
            }
            total = total + amount;
          }

          if (part_list[p].amount_is_tax == "inclusive") {
            var x = (100 + tax_info.rate) / 100;
            var tax_on_amount = amount / x;
            if (tax_rate.length > 0) {
              for (var r = 0; r < tax_rate.length; r++) {
                if (tax_rate[r].rate != tax_info.rate) {
                  var t = tax_on_amount * (tax_rate[r].rate / 100);
                  base = base - t;
                  tax.push({
                    tax: tax_rate[r].tax,
                    rate: tax_rate[r].rate,
                    amount: parseFloat(t.toFixed(2)),
                  });
                } else {
                  var t = amount - tax_on_amount;
                  base = base - t;
                  tax.push({
                    tax: tax_info.tax,
                    tax_rate: tax_info.rate,
                    rate: tax_info.rate,
                    amount: parseFloat(t.toFixed(2)),
                  });
                }
              }
            }

            //base = base - discount_total - dep;
            total = total + amount;
          }

          var tax_amount = total - parseFloat(base.toFixed(2));

          var tax_details = {
            tax: tax_info.tax,
            tax_rate: tax_info.rate,
            rate: tax_info.rate,
            amount: total,
            detail: tax,
          };

          if (
            parseFloat(part_list[p].customer_dep) == 0 &&
            parseFloat(part_list[p].insurance_dep) == 0
          ) {
            var customer_dep = 100;
            var insurance_dep = 0;
          } else {
            var customer_dep = parseFloat(part_list[p].customer_dep);
            var insurance_dep = parseFloat(part_list[p].insurance_dep);
          }

          part.push({
            _id: part_list[p]._id,
            item: part_list[p].item,
            source: part_list[p].source,
            hsn_sac: part_list[p].hsn_sac,
            part_no: part_list[p].part_no,
            rate: parseFloat(part_list[p].rate),
            quantity: parseFloat(part_list[p].quantity),
            base: parseFloat(base.toFixed(2)),
            amount: total,
            discount: part_list[p].discount,
            issued: part_list[p].issued,
            customer_dep: customer_dep,
            insurance_dep: insurance_dep,
            tax_amount: parseFloat(_.sumBy(tax, (x) => x.amount).toFixed(2)),
            amount_is_tax: part_list[p].amount_is_tax,
            tax: tax_info.tax,
            tax_rate: tax_info.rate,
            tax_info: tax_details,
          });
        }
      }

      if (labour_list) {
        for (var l = 0; l < labour_list.length; l++) {
          var total = 0;
          var tax_info = await Tax.findOne({
            rate: labour_list[l].tax_rate,
            type: tax_type,
          }).exec();
          var tax = [];
          var rate = labour_list[l].rate;
          var amount =
            parseFloat(labour_list[l].rate) *
            parseFloat(labour_list[l].quantity);
          var tax_rate = tax_info.detail;
          var discount_total = 0;
          var base = amount;
          var dep = 0;

          /* if(services[i].claim==true)
                     {       
                         if(parseFloat(labour_list[l].insurance_dep)<=0 && parseFloat(labour_list[l].customer_dep)<=0)
                         {
                             dep = 0
                         }
                         else
                         {
                             if(parseFloat(labour_list[l].customer_dep) <= 0 && parseFloat(labour_list[l].insurance_dep<=100) )
                             {
                                 dep = 100
                             }
                             else
                             {
                                 dep = 100-parseFloat(labour_list[l].customer_dep);
                             }
                         }
 
                         amount = amount-(amount*dep/100);
                         dep = base- amount;
                     }*/

          if (labour_list[l].discount) {
            discount_total = labour_list[l].discount;
            amount = amount - parseFloat(discount_total.toFixed(2));
          }

          if (labour_list[l].amount_is_tax == "exclusive") {
            var tax_on_amount = amount;
            if (tax_rate.length > 0) {
              for (var r = 0; r < tax_rate.length; r++) {
                if (tax_rate[r].rate != tax_info.rate) {
                  var t = tax_on_amount * (tax_rate[r].rate / 100);
                  amount = amount + t;
                  parseFloat;
                  tax.push({
                    tax: tax_rate[r].tax,
                    rate: tax_rate[r].rate,
                    amount: parseFloat(t.toFixed(2)),
                  });
                } else {
                  var t = tax_on_amount * (tax_rate[r].rate / 100);
                  amount = amount + t;
                  tax.push({
                    tax: tax_info.tax,
                    tax_rate: tax_info.rate,
                    rate: tax_info.rate,
                    amount: parseFloat(t.toFixed(2)),
                  });
                }
              }
            }
            //total = total+amount;
          }

          if (labour_list[l].amount_is_tax == "inclusive") {
            var x = (100 + tax_info.rate) / 100;
            var tax_on_amount = amount / x;
            if (tax_rate.length > 0) {
              for (var r = 0; r < tax_rate.length; r++) {
                if (tax_rate[r].rate != tax_info.rate) {
                  var t = tax_on_amount * (tax_rate[r].rate / 100);
                  base = base - t;
                  tax.push({
                    tax: tax_rate[r].tax,
                    rate: tax_rate[r].rate,
                    amount: parseFloat(t.toFixed(2)),
                  });
                } else {
                  var t = amount - tax_on_amount;
                  base = base - t;
                  tax.push({
                    tax: tax_info.tax,
                    tax_rate: tax_info.rate,
                    rate: tax_info.rate,
                    amount: parseFloat(t.toFixed(2)),
                  });
                }
              }
            }

            //base = base - discount_total - dep;

            total = total + amount;
          }

          var tax_amount = total - parseFloat(base.toFixed(2));

          var tax_details = {
            tax: tax_info.tax,
            rate: tax_info.rate,
            amount: total,
            detail: tax,
          };

          labours.push({
            _id: labour_list[l]._id,
            item: labour_list[l].item,
            source: labour_list[l].source,
            rate: parseFloat(labour_list[l].rate),
            quantity: parseFloat(labour_list[l].quantity),
            base: parseFloat(base.toFixed(2)),
            amount: amount,
            discount: labour_list[l].discount,
            customer_dep: parseFloat(labour_list[l].customer_dep),
            insurance_dep: parseFloat(labour_list[l].insurance_dep),
            tax_amount: parseFloat(_.sumBy(tax, (x) => x.amount).toFixed(2)),
            amount_is_tax: labour_list[l].amount_is_tax,
            tax: tax_info.tax,
            tax_rate: tax_info.rate,
            tax_info: tax_details,
          });
        }
      }

      if (of_list) {
        for (var o = 0; o < of_list.length; o++) {
          var total = 0;
          var tax_info = await Tax.findOne({
            rate: of_list[o].tax_rate,
            type: tax_type,
          }).exec();
          var tax = [];
          var rate = of_list[o].rate;
          var amount =
            parseFloat(of_list[o].rate) * parseFloat(of_list[o].quantity);
          var tax_rate = tax_info.detail;
          var discount_total = 0;
          var base = amount;
          var dep = 0;

          /*if(services[i].claim == true)
                    {
                        if(parseFloat(of_list[o].insurance_dep)<=0 && parseFloat(of_list[o].customer_dep)<=0)
                        {
                            dep = 0
                        }
                        else
                        {
                            if(parseFloat(of_list[o].customer_dep) <= 0 && parseFloat(of_list[o].insurance_dep<=100) )
                            {
                                dep = 100
                            }
                            else
                            {
                                dep = 100-parseFloat(of_list[o].customer_dep);
                            }
                        }

                        amount = amount-(amount*dep/100);
                        dep = base - amount;
                    }*/

          if (of_list[o].discount) {
            var discount_total = of_list[o].discount;
            amount = amount - parseFloat(discount_total.toFixed(2));
          }

          if (of_list[o].amount_is_tax == "exclusive") {
            var tax_on_amount = amount;
            if (tax_rate.length > 0) {
              for (var r = 0; r < tax_rate.length; r++) {
                if (tax_rate[r].rate != tax_info.rate) {
                  var t = tax_on_amount * (tax_rate[r].rate / 100);
                  amount = amount + t;
                  parseFloat;
                  tax.push({
                    tax: tax_rate[r].tax,
                    rate: tax_rate[r].rate,
                    amount: parseFloat(t.toFixed(2)),
                  });
                } else {
                  var t = tax_on_amount * (tax_rate[r].rate / 100);
                  amount = amount + t;
                  tax.push({
                    tax: tax_info.tax,
                    tax_rate: tax_info.rate,
                    rate: tax_info.rate,
                    amount: parseFloat(t.toFixed(2)),
                  });
                }
              }
            }
            total = total + amount;
          }

          if (of_list[o].amount_is_tax == "inclusive") {
            var x = (100 + tax_info.rate) / 100;
            var tax_on_amount = amount / x;
            if (tax_rate.length > 0) {
              for (var r = 0; r < tax_rate.length; r++) {
                if (tax_rate[r].rate != tax_info.rate) {
                  var t = tax_on_amount * (tax_rate[r].rate / 100);
                  base = base - t;
                  tax.push({
                    tax: tax_rate[r].tax,
                    rate: tax_rate[r].rate,
                    amount: parseFloat(t.toFixed(2)),
                  });
                } else {
                  var t = amount - tax_on_amount;
                  base = base - t;
                  tax.push({
                    tax: tax_info.tax,
                    tax_rate: tax_info.rate,
                    rate: tax_info.rate,
                    amount: parseFloat(t.toFixed(2)),
                  });
                }
              }
            }

            //base = base - discount_total - dep;

            total = total + amount;
          }

          var tax_details = {
            tax: tax_info.tax,
            rate: tax_info.rate,
            amount: total,
            detail: tax,
          };

          var tax_amount = total - parseFloat(base.toFixed(2));

          opening_fitting.push({
            _id: of_list[o]._id,
            item: of_list[o].item,
            source: of_list[o].source,
            rate: parseFloat(of_list[o].rate),
            quantity: parseFloat(of_list[o].quantity),
            base: parseFloat(base.toFixed(2)),
            amount: total,
            discount: parseFloat(of_list[o].discount),
            customer_dep: parseFloat(of_list[o].customer_dep),
            insurance_dep: parseFloat(of_list[o].insurance_dep),
            tax_amount: parseFloat(_.sumBy(tax, (x) => x.amount).toFixed(2)),
            amount_is_tax: of_list[o].amount_is_tax,
            tax: tax_info.tax,
            tax_rate: tax_info.rate,
            tax_info: tax_details,
          });
        }
      }

      var parts_visible = true;
      var firstLead = await Lead.find({
        contact_no: booking.user.contact_no,
      }).exec();
      // return res.json({ abhi: firstLead })
      if (firstLead[0]) {
        lead = {
          name: firstLead[0].name,
          _id: firstLead[0]._id,
          id: firstLead[0].id,
          contact_no: firstLead[0].contact_no,
          source: firstLead[0].source,
        };
      }
      bookingService.push({
        _id: services[i]._id,
        source: services[i].source,
        service: services[i].service,
        mileage: services[i].mileage,
        parts: part,
        labour: labours,
        opening_fitting: opening_fitting,
        hours: services[i].hours,
        parts_visible: parts_visible,
        quantity: services[i].quantity,
        discount:
          _.sumBy(labours, (x) => x.discount) +
          _.sumBy(part, (x) => x.discount) +
          _.sumBy(opening_fitting, (x) => x.discount),
        description: services[i].description,
        cost:
          _.sumBy(part, (x) => x.amount) +
          _.sumBy(labours, (x) => x.amount) +
          services[i].of_cost,
        labour_cost: _.sumBy(labours, (x) => x.amount),
        of_cost: _.sumBy(opening_fitting, (x) => x.amount),
        part_cost: _.sumBy(part, (x) => x.amount),
        exceeded_cost: parseFloat(services[i].exceeded_cost),
        part_cost_editable: services[i].part_cost_editable,
        labour_cost_editable: services[i].labour_cost_editable,
        of_cost_editable: services[i].of_cost_editable,
        type: services[i].type,
        sub_category: services[i].sub_category,
        customer_approval: services[i].customer_approval,
        surveyor_approval: services[i].surveyor_approval,
        claim: services[i].claim,
        custom: services[i].custom,
      });
    }

    /*Booking.findOneAndUpdate({_id: booking._id}, {$set:{services:bookingService}}, {new: false},async function(err, doc){
            if(err){
                console.log(err)
            }
        });*/

    var approved = _.filter(
      bookingService,
      (customer_approval) => customer_approval.customer_approval == true
    );

    var labour_cost = _.sumBy(approved, (x) => x.labour_cost);
    var part_cost = _.sumBy(approved, (x) => x.part_cost);
    var of_cost = _.sumBy(approved, (x) => x.of_cost);
    var discount_total = _.sumBy(approved, (x) => x.discount);

    var pick_up_charges = booking.payment.pick_up_charges;
    var policy_clause = booking.payment.policy_clause;
    var salvage = booking.payment.salvage;
    var paid_total = booking.payment.paid_total;

    var payment_total =
      labour_cost +
      part_cost +
      of_cost +
      discount_total +
      policy_clause +
      salvage +
      pick_up_charges;

    var estimate_cost =
      labour_cost +
      part_cost +
      of_cost +
      policy_clause +
      salvage +
      pick_up_charges -
      careager_cash;

    var due_amount =
      labour_cost +
      part_cost +
      of_cost +
      policy_clause +
      salvage +
      pick_up_charges -
      (paid_total + careager_cash);

    var due = {
      due: Math.ceil(due_amount.toFixed(2)),
    };

    var payment = {
      total: parseFloat(payment_total.toFixed(2)),
      estimate_cost: parseFloat(estimate_cost.toFixed(2)),
      careager_cash: careager_cash,
      of_cost: of_cost,
      labour_cost: labour_cost,
      part_cost: part_cost,
      payment_mode: booking.payment.payment_mode,
      payment_status: booking.payment.payment_status,
      discount_type: booking.payment.discount_type,
      coupon: booking.payment.coupon,
      coupon_type: booking.payment.coupon_type,
      discount_by: booking.payment.discount_by,
      discount: discount_total,
      discount_total: discount_total,
      policy_clause: policy_clause,
      salvage: salvage,
      terms: booking.payment.terms,
      pick_up_limit: booking.payment.pick_up_limit,
      pick_up_charges: pick_up_charges,
      paid_total: booking.payment.paid_total,
      discount_applied: booking.payment.discount_applied,
      transaction_id: booking.payment.coupon,
      transaction_date: booking.payment.transaction_date,
      transaction_status: booking.payment.transaction_status,
      transaction_response: booking.payment.transaction_response,
    };

    var logs = booking.logs;
    var logsData = [];
    for (var i = 0; i < logs.length; i++) {
      // if(logs[i].reason)
      // console.log(logs[i].activity + "At Booking get" + logs.length)
      logsData.push({
        user: logs[i].user,
        name: logs[i].name,
        stage: logs[i].stage,
        activity: logs[i].activity,
        created_at: moment(logs[i].created_at)
          .tz(req.headers["tz"])
          .format("lll"),
        updated_at: moment(logs[i].updated_at)
          .tz(req.headers["tz"])
          .format("lll"),
      });
    }

    var remarks = booking.remarks;
    var remarksData = [];
    if (remarks) {
      for (var i = 0; i < remarks.length; i++) {
        // console.log("Added by" + remarks[i].added_by)
        if (remarks[i].added_by) {
          var added_by = await User.findById(remarks[i].added_by).exec();
          // console.log("Added by name" + added_by.name)
          if (added_by) {
            remarksData.push({
              added_by: remarks[i].user,
              name: added_by.name,
              remark: remarks[i].remark,
              created_at: moment(remarks[i].created_at)
                .tz(req.headers["tz"])
                .format("lll"),
              updated_at: moment(remarks[i].updated_at)
                .tz(req.headers["tz"])
                .format("lll"),
            });
          }
        }
      }
    }

    var review = new Object();
    await Review.find({ booking: booking._id })
      .populate({
        path: "user",
        select: "name username avatar avatar_address account_info",
      })
      .cursor()
      .eachAsync(async (r) => {
        review = {
          _id: r._id,
          id: r._id,
          business: r.business,
          booking: r.booking,
          review_points: r.review_points,
          rating: r.rating,
          review: r.review,
          recommendation: r.recommendation,
          type: r.type,
          created_at: moment(r.created_at).tz(req.headers["tz"]).format("ll"),
          updated_at: moment(r.updated_at).tz(req.headers["tz"]).format("ll"),
          user: r.user,
        };
      });

    var insurance_info = {
      policy_holder: "",
      insurance_company: "",
      policy_no: "",
      premium: 0,
      expire: "",
      branch: "",
      gstin: "",
      claim: false,
      cashless: false,
      accident_place: "",
      accident_date: null,
      accident_time: "",
      accident_cause: "",
      driver_accident: "",
      spot_survey: "",
      fir: "",
      policy_type: "",
      claim_no: "",
    };

    if (booking.insurance_info) {
      insurance_info = booking.insurance_info;
    }

    if (booking.status == "Rework") {
      booking.status = "In-Process";
    }

    bookings.push({
      _id: booking._id,
      id: booking._id,
      car: car,
      user: {
        name: booking.user.name,
        _id: booking.user._id,
        id: booking.user.id,
        contact_no: booking.user.contact_no,
        email: booking.user.email,
        business_info: booking.user.business_info,
        account_info: booking.user.account_info,
        careager_cash: booking.user.careager_cash,
      },
      business: {
        name: booking.business.name,
        _id: booking.business._id,
        id: booking.business.id,
        contact_no: booking.business.contact_no,
        email: booking.business.email,
        business_info: booking.business.business_info,
        address: booking.business.address,
        bank_details: booking.business.bank_details,
      },
      advisor: advisor,
      lead: lead,
      manager: manager,
      driver: driver,
      technician: technician,
      surveyor: surveyor,
      services: bookingService,
      convenience: booking.convenience,
      date: moment(booking.date).tz(req.headers["tz"]).format("ll"),
      time_slot: booking.time_slot,
      status: _.startCase(booking.status),
      _status: booking.status,
      sub_status: booking.sub_status,
      booking_no: booking.booking_no,
      job_no: booking.job_no,
      estimation_requested: booking.estimation_requested,
      customer_requirements: customer_requirements,
      insurance_info: insurance_info,
      address: booking.address,
      remarks: remarksData,
      payment: booking.payment,
      note: booking.note,
      due: booking.due,
      approved_payment: payment,
      approved_due: due,
      important: booking.important,
      fuel_level: booking.fuel_level,
      odometer: booking.odometer,
      delivery_date: moment(booking.delivery_date)
        .tz(req.headers["tz"])
        .format("ll"),
      delivery_time: booking.delivery_time,
      assets: booking.assets,
      qc: booking.qc,
      other_assets: booking.other_assets,
      with_tax: booking.with_tax,
      recording_address: recording,
      package: booking.package,
      settlement: booking.settlement,
      advance: booking.advance,
      booking: booking.booking,
      re_booking_no: booking.re_booking_no,
      is_rework: booking.is_rework,
      logs: _(logsData)
        .groupBy((x) => x.stage)
        .map((value, key) => ({ stage: key, list: value }))
        .value(),
      review: review,
      created_at: moment(booking.created_at)
        .tz(req.headers["tz"])
        .format("lll"),
      updated_at: moment(booking.updated_at)
        .tz(req.headers["tz"])
        .format("lll"),
    });

    res.status(200).json({
      responseCode: 200,
      responseMessage: "Success",
      responseData: bookings,
    });
  } else {
    res.status(400).json({
      responseCode: 400,
      responseMessage: "booking not found",
      responseData: {},
    });
  }
});

router.get("/offer/list", xAccessToken.token, async function (req, res, next) {
  var token = req.headers["x-access-token"];
  var secret = config.secret;
  var decoded = jwt.verify(token, secret);
  var user = decoded.user;
  var data = [];
  var business = req.headers["business"];
  var status = "";
  var count = 0;
  var activeCounts = 0;
  var inActiveCounts = 0;
  var expiredCounts = 0;
  await BusinessOffer.find({ business: business })
    .sort({ created_at: -1 })
    .cursor()
    .eachAsync(async (offer) => {
      if (offer) {
        var serverTime = moment.tz(new Date(), req.headers["tz"]);
        var bar = moment.tz(new Date(offer.valid_till), req.headers["tz"]);
        var baz = bar.diff(serverTime);
        // console.l.l.log(baz);

        // if (baz > 0) {
        if (offer.publish == true && baz > 0) {
          status = "Active";
          activeCounts = activeCounts + 1;
        } else if (offer.publish == false && baz > 0) {
          status = "InActive";
          inActiveCounts = inActiveCounts + 1;
        } else {
          status = "Expired";
          expiredCounts = expiredCounts + 1;
        }
        count += 1;

        data.push({
          name: offer.name,
          _id: offer._id,
          description: offer.description,
          code: offer.code,
          limit: offer.limit,
          category: offer.category,
          discount: offer.discount,
          terms: offer.terms,
          // start_date = new Date(req.body.sDate).toISOString(),
          valid_till: offer.valid_till,

          featured: offer.featured,
          publish: offer.publish,
          validity: parseInt(offer.validity),
          status: status,
          discount: offer.discount,
          image:
            "https://s3.ap-south-1.amazonaws.com/careager/offer/" + offer.image,
        });

        // }
      }
    });
  // console.l.l.log(count)
  res.status(200).json({
    responseCode: 200,
    responseMessage: {
      total: count,
      activeCounts: activeCounts,
      inActiveCounts: inActiveCounts,
      expiredCounts: expiredCounts,
    },
    responseData: data,
  });
});

router.put("/offer/edit", xAccessToken.token, async function (req, res, next) {
  var rules = {
    id: "required",
  };

  var validation = new Validator(req.body, rules);

  if (validation.fails()) {
    res.status(422).json({
      responseCode: 422,
      responseMessage: "Error",
      responseData: {
        res: validation.errors.all(),
      },
    });
  } else {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    var business = decoded.user;
    var check = await BusinessOffer.find({
      _id: req.body.id,
      business: business,
    })
      .count()
      .exec();
    if (check == 1) {
      var expired_at = new Date();
      expired_at.setDate(expired_at.getDate() + parseInt(req.body.validity));
      var ser = [];

      // if (req.body.category == "all") {
      //     ser = ['service', 'detailing', 'customization', 'collision']
      // } else {
      //     ser = [req.body.category];
      // }
      // console.l.l.log("Discount " + req.body.discount)
      var data = {
        offer: req.body.name,
        // description: req.body.description,
        // valid_till: req.body.valid_till,
        updated_at: new Date(),

        name: req.body.name,
        offer: req.body.name,
        description: req.body.description,
        code: req.body.code,
        limit: req.body.limit,
        category: req.body.category,
        discount: req.body.discount,
        terms: req.body.terms,
        // start_date = new Date(req.body.sDate).toISOString(),
        valid_till: expired_at.toISOString(),
        // req.body.valid_till = expired_at,
        featured: req.body.featured,
        publish: true,
        validity: parseInt(req.body.validity),
      };

      //WEBSITE
      // req.body.offer_details.category = req.body.category;
      // req.body.offer_details.description =req.body.type
      // req.body.offer_details.terms = ""

      // console.l.l.log("Length of Coupon = " + ser.length)
      // for (i = 0; i < ser.length; i++) {

      //     req.body.category = ser[i];
      // console.l.l.log("Service " + ser[i])
      // }

      BusinessOffer.findOneAndUpdate(
        { _id: req.body.id, business: business },
        { $set: data },
        { new: true },
        function (err, doc) {
          if (err) {
            var json = {
              responseCode: 400,
              responseMessage: "Error occured",
              responseData: {},
            };

            res.status(400).json(json);
          } else {
            if (doc.code != "") {
              // console.l.l.log("Offer Updated " + doc.name)
              if (doc.category == "service") {
                doc.category = "services";
              }
              Coupon.findOneAndUpdate(
                { offer: req.body.id, business: business },
                {
                  $set: {
                    offer: doc.id,
                    for: "category",
                    type: "percent",
                    label: doc.category,
                    description: doc.description,
                    usage_limit: 1,
                    physical: false,
                    code: doc.code,
                    business: doc.business,
                    terms: doc.terms,
                    discount: doc.discount,
                    publish: true,
                    limit: doc.limit,
                    // start_date: new Date(req.body.sDate).toISOString(),
                    expired_at: expired_at,

                    updated_at: new Date(),
                  },
                },
                { new: true },
                function (err, cop) {
                  if (err) {
                    var json = {
                      responseCode: 400,
                      responseMessage: "Error occured",
                      responseData: {},
                    };

                    res.status(400).json(json);
                  } else {
                    // console.l.l.log("Coupon Updated" + cop.limit)
                  }
                }
              );
            }
            var json = {
              responseCode: 200,
              responseMessage: "Offer has been edited",
              responseData: {
                item: doc,
              },
            };
            res.status(200).json(json);
          }
        }
      );
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Unauthorized",
        responseData: {},
      });
    }
  }
});

router.put("/offer/pause/resume", async function (req, res, next) {
  var rules = {
    offer: "required",
    publish: "required",
  };

  var validation = new Validator(req.body, rules);

  if (validation.fails()) {
    res.status(422).json({
      responseCode: 422,
      responseMessage: "Error",
      responseData: {
        res: validation.errors.all(),
      },
    });
  } else {
    var data = [];
    var token = req.headers["x-access-token"];
    var business = req.headers["business"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    await BusinessOffer.findOneAndUpdate(
      { _id: req.body.offer, business: business },
      {
        $set: {
          publish: req.body.publish,
        },
      },
      { new: true },
      function (err, doc) {
        if (err) {
          var json = {
            responseCode: 400,
            responseMessage: "Error occured",
            responseData: {},
          };

          res.status(400).json(json);
        } else {
          // console.l.l.log("Offer Updated " + doc.name)
          if (doc.code != "") {
            Coupon.findOneAndUpdate(
              { offer: req.body.offer, business: business },
              {
                $set: {
                  publish: req.body.publish,
                },
              },
              { new: true },
              function (err, cop) {
                if (err) {
                  var json = {
                    responseCode: 400,
                    responseMessage: "Error occured",
                    responseData: {},
                  };

                  res.status(400).json(json);
                } else {
                }
              }
            );
          }
        }
      }
    );

    res.status(200).json({
      responseCode: 200,
      responseMessage: "Success",
      responseData: {},
    });
  }
});

router.delete(
  "/offer/image/delete",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      id: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Error",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      const media = await BusinessOffer.findById(req.body.id).exec();

      if (media) {
        var params = {
          Bucket: config.BUCKET_NAME + "/offer",
          Key: media.image,
        };
        s3.deleteObject(params, async function (err, data) {
          if (err) {
            res.status(400).json({
              responseCode: 400,
              responseMessage: "Error occured",
              responseData: {},
            });
          } else {
            var data = {
              image: "default.png",
            };
            // BusinessOffer.findOneAndUpdate({ _id: req.body.id }, { $set: data }, { new: true }, function (err, doc) {
            //     res.status(200).json({
            //         responseCode: 200,
            //         responseMessage: "Image has been delete",
            //         responseData: {}
            //     })
            // });
            BusinessOffer.remove({ _id: req.body.id }).exec();
            Coupon.remove({ offer: req.body.id }).exec();
            // console.l.l.log("Removed")
            res.status(200).json({
              responseCode: 200,
              responseMessage: "Offer deleted",
              responseData: {},
            });
          }
        });
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Wrong image",
          responseData: {},
        });
      }
    }
  }
);

router.post("/offer/add", xAccessToken.token, async function (req, res, next) {
  var token = req.headers["x-access-token"];
  var secret = config.secret;
  var decoded = jwt.verify(token, secret);
  var business = req.headers["business"];
  // console.l.l.log("API Called")

  var data = [];
  var multi_category_no =
    Math.round(+new Date() / 1000) + Math.round(Math.random() * 9999 + 5);
  var upload = multer({
    storage: multerS3({
      s3: s3,
      bucket: config.BUCKET_NAME + "/offer",
      acl: "public-read",
      contentType: multerS3.AUTO_CONTENT_TYPE,
      // contentDisposition: 'attachment',
      key: function (req, file, cb) {
        let extArray = file.mimetype.split("/");
        let extension = extArray[extArray.length - 1];

        var filename = uuidv1() + "." + extension;
        if (
          extension == "png" ||
          extension == "jpg" ||
          extension == "jpeg" ||
          extension == "gif"
        ) {
          cb(null, filename);
        } else {
          var params = {
            Bucket: config.BUCKET_NAME + "/offer",
            Key: filename,
          };
          s3.deleteObject(params, async function (err, data) {
            var json = {
              responseCode: 422,
              responseMessage: "Invalid extension",
              responseData: {},
            };
            res.status(422).json(json);
          });
        }
      },
    }),
  }).array("media", 1);

  upload(req, res, function (error) {
    if (error) {
      var json = {
        responseCode: 400,
        responseMessage: "Error occured",
        responseData: {},
      };
      res.status(400).json(json);
    }

    if (req.files.length == 0) {
      var json = {
        responseCode: 400,
        responseMessage: "Media is required",
        responseData: {},
      };
      res.status(400).json(json);
    } else {
      var expired_at = new Date(req.body.sDate);
      expired_at.setDate(expired_at.getDate() + parseInt(req.body.validity));
      // console.l.l.log("Multi " + multi_category_no)
      req.body.multi_category = multi_category_no;
      req.body.business = business;
      req.body.image = req.files[0].key;
      req.body.geometry = business.geometry;
      req.body.isCarEager = business.isCarEager;
      //Abhinav
      req.body.name = req.body.name;
      req.body.offer = req.body.name;
      req.body.description = req.body.description;
      req.body.terms = req.body.terms;
      req.body.code = req.body.code;
      req.body.limit = parseInt(req.body.limit);

      req.body.start_date = new Date(req.body.sDate).toISOString();
      req.body.valid_till = expired_at;
      req.body.end_date = expired_at;
      req.body.featured = req.body.featured;
      req.body.publish = true;
      req.body.validity = parseInt(req.body.validity);
      //Abhinav
      req.body.discount = parseFloat(req.body.discount);
      req.body.created_at = new Date();
      req.body.updated_at = new Date();
      var ser = [];
      ser = req.body.category.split(",");

      //WEBSITE
      // req.body.offer_details.category = req.body.category;
      // req.body.offer_details.description =req.body.type
      // req.body.offer_details.terms = ""
      // console.l.l.log("Length of Coupon = " + ser.length)

      for (i = 0; i < ser.length; i++) {
        req.body.category = ser[i];
        // console.l.l.log("Service " + ser[i])
        BusinessOffer.create(req.body).then(function (offer) {
          // console.l.l.log(offer.category)
          if (offer.category == "service") {
            offer.category = "services";
          }
          if (offer.code != "") {
            // console.l.l.log("With Code")
            Coupon.create({
              for: "category",
              type: "percent",
              label: offer.category,
              usage_limit: 1,
              physical: false,
              code: offer.code,
              business: offer.business,
              offer: offer._id,
              discount: offer.discount,
              // discount: 30,
              publish: true,
              limit: offer.limit,
              terms: offer.terms,
              description: offer.description,
              start_date: new Date(req.body.sDate).toISOString(),
              expired_at: expired_at.toISOString(),
              created_at: new Date(offer.start_date),
            }).then(function (offer11) {});
          }
          // console.l.l.log("Without Code")

          // console.l.l.l.log(dataa)
          // data = dataa
        });
      }
      res.status(200).json({
        responseCode: 200,
        responseMessage: "Offer has been added",
        responseData: {},
      });

      // res.status(200).json({
      //     responseCode: 200,
      //     responseMessage: "Offer has been added",
      //     responseData: offerss
      // });
    }

    // console.l.l.log("Offer  " + name + "   --  " + business)
  });
  // console.l.l.log(" == = = " + multi_category_no)
  // var offerss = await q.all(offerGet(multi_category_no, business));
  // var offerss = await BusinessOffer.findOne({ business: business })
  //     .sort({ _id: -1 }).exec();
  // console.l.l.log(offerss)
  // res.status(200).json({
  //     responseCode: 200,
  //     responseMessage: "Offer has been added",
  //     responseData: offerss
  // });
});

router.get(
  "/all/services/get",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers["business"];
    // console.log("Business" + business)
    var totalResult = 0;
    var search_query = {};
    var search_query_model = {};

    if (req.query.page == undefined) {
      var page = 0;
    } else {
      var page = req.query.page;
    }
    var page = Math.max(0, parseInt(page));

    if (req.query.limit == undefined) {
      var limit = 2;
    } else {
      var limit = parseInt(req.query.limit);
    }
    if (req.query.search) {
      req.query.search = req.query.search.replace(
        /([.?*+^$[\]\\(){}|-])/g,
        "\\$1"
      );
    }

    if (req.query.type == "standard") {
      search_query = { publish: true, business: business };
      search_query_model = {
        publish: { $nin: [true, false] },
        business: business,
      };
      if (req.query.query == "All") {
        search_query = { publish: true, business: business };
      } else if (req.query.category) {
        if (req.query.category == "services") {
          search_query = {
            publish: true,
            business: business,
            type: "services",
          };
        } else if (req.query.category == "collision") {
          search_query = {
            publish: true,
            business: business,
            type: "collision",
          };
        } else if (req.query.category == "customization") {
          search_query = {
            publish: true,
            business: business,
            type: "customization",
          };
        } else if (req.query.category == "detailing") {
          search_query = {
            publish: true,
            business: business,
            type: "detailing",
          };
        }
      } else if (req.query.car) {
        var car = await Variant.findById(req.query.car)
          .populate("model")
          .exec();
        if (car) {
          // console.log("Service = " + car.model.segment)
          // console.log("Car = " + req.query.car)
          search_query = {
            segment: car.model.segment,
            part_cost: 0,
            publish: true,
            business: business,
          };
          search_query_model = {
            model: car.model._id,
            part_cost: { $gt: 0 },
            publish: true,
            business: business,
          };
        }
      } else if (req.query.search) {
        search_query = null;
        search_query = {
          $and: [
            {
              publish: true,
              business: business,
              $or: [
                {
                  service: { $regex: req.query.search, $options: "i" },
                },
                {
                  type: { $regex: req.query.search, $options: "i" },
                },
              ],
            },
          ],
        };
      }
    } else if (req.query.type == "custom") {
      search_query = { custom: true, business: business };
      search_query_model = {
        custom: { $nin: [true, false] },
        business: business,
      };
      if (req.query.query == "All") {
        search_query = { custom: true, business: business };
      } else if (req.query.category) {
        if (req.query.category == "services") {
          search_query = { custom: true, business: business, type: "services" };
        } else if (req.query.category == "collision") {
          search_query = {
            custom: true,
            business: business,
            type: "collision",
          };
        } else if (req.query.category == "customization") {
          search_query = {
            custom: true,
            business: business,
            type: "customization",
          };
        } else if (req.query.category == "detailing") {
          search_query = {
            custom: true,
            business: business,
            type: "detailing",
          };
        }
      } else if (req.query.car) {
        // console.log("Car = " + req.query.car)
        var car = await Variant.findById(req.query.car)
          .populate("model")
          .exec();
        if (car) {
          // console.log("Car = " + req.query.car)
          search_query = {
            segment: car.model.segment,
            part_cost: 0,
            custom: true,
            business: business,
          };
          search_query_model = {
            model: car.model._id,
            part_cost: { $gt: 0 },
            custom: true,
            business: business,
          };
        }
      } else if (req.query.search) {
        search_query = null;
        search_query = {
          $and: [
            {
              custom: true,
              business: business,
              $or: [
                {
                  service: { $regex: req.query.search, $options: "i" },
                },
                {
                  type: { $regex: req.query.search, $options: "i" },
                },
              ],
            },
          ],
        };
      }
    } else {
      search_query = {
        custom: { $nin: [true, false] },
        publish: { $nin: [true, false] },
        business: business,
      };
      search_query_model = {
        custom: { $nin: [true, false] },
        publish: { $nin: [true, false] },
        business: business,
      };
    }
    // return res.json({ s1: search_query, s2: search_query_model })
    var quantity = 1;
    // var car = await Variant.findById(req.query.car).populate('model').exec();
    // if (car) {
    var packages = [];

    // if (req.query.type == "services") {
    await Service.find(search_query_model)
      .skip(limit * page)
      .limit(limit)
      .cursor()
      .eachAsync(async (service) => {
        packages.push({
          package: service.package,
          segment: service.segment,
          service: service.service,
          labour: service.abours,
          labour_cost: parseFloat(service.labour_cost),
          parts: service.parts,
          discount: service.discount,
          part_cost: parseFloat(service.part_cost),
          opening_fitting: service.opening_fitting,
          of_cost: parseFloat(service.of_cost),
          exceeded_cost: 0,
          mrp: parseFloat(service.mrp),
          cost: (
            parseFloat(service.part_cost) + parseFloat(service.labour_cost)
          ).toFixed(2),
          doorstep: service.doorstep,
          unit: service.unit,
          quantity: service.quantity,
          part_cost_editable: service.part_cost_editable,
          labour_cost_editable: service.labour_cost_editable,
          of_cost_editable: service.of_cost_editable,
          type: service.type,
          source: service.id,
          publish: service.publish,
          description: service.description,
          id: service.id,
          _id: service._id,
          profile: service.profile,
          custom: service.custom,
        });
      });

    await Service.find(search_query)
      .skip(limit * page)
      .limit(limit)
      .cursor()
      .eachAsync(async (service) => {
        packages.push({
          package: service.package,
          segment: service.segment,
          service: service.service,
          labour: service.abours,
          labour_cost: parseFloat(service.labour_cost),
          parts: service.parts,
          discount: service.discount,
          part_cost: parseFloat(service.part_cost),
          opening_fitting: service.opening_fitting,
          of_cost: parseFloat(service.of_cost),
          exceeded_cost: 0,
          mrp: parseFloat(service.mrp),
          cost: (
            parseFloat(service.part_cost) + parseFloat(service.labour_cost)
          ).toFixed(2),
          doorstep: service.doorstep,
          unit: service.unit,
          quantity: service.quantity,
          part_cost_editable: service.part_cost_editable,
          labour_cost_editable: service.labour_cost_editable,
          of_cost_editable: service.of_cost_editable,
          type: service.type,
          source: service.id,
          description: service.description,
          id: service.id,
          _id: service._id,
          profile: service.profile,
          publish: service.publish,
          custom: service.custom,
        });
      });
    // }

    // else if (req.query.type == "collision") {
    // console.log("Working.....")

    await Collision.find(search_query)
      .skip(limit * page)
      .limit(limit)
      .cursor()
      .eachAsync(async (service) => {
        packages.push({
          package: service.package,
          segment: service.segment,
          service: service.service,
          labour: service.abours,
          labour_cost: parseFloat(service.labour_cost),
          parts: service.parts,
          discount: service.discount,
          part_cost: parseFloat(service.part_cost),
          opening_fitting: service.opening_fitting,
          of_cost: parseFloat(service.of_cost),
          exceeded_cost: 0,
          mrp: parseFloat(service.mrp),
          cost: (
            parseFloat(service.part_cost) + parseFloat(service.labour_cost)
          ).toFixed(2),
          doorstep: service.doorstep,
          unit: service.unit,
          quantity: service.quantity,
          part_cost_editable: service.part_cost_editable,
          labour_cost_editable: service.labour_cost_editable,
          of_cost_editable: service.of_cost_editable,
          type: service.type,
          source: service.id,
          description: service.description,
          id: service.id,
          _id: service._id,
          profile: service.profile,
          publish: service.publish,
          custom: service.custom,
        });
      });

    await Collision.find(search_query_model)
      .skip(limit * page)
      .limit(limit)
      .cursor()
      .eachAsync(async (service) => {
        packages.push({
          package: service.package,
          segment: service.segment,
          service: service.service,
          labour: service.abours,
          labour_cost: parseFloat(service.labour_cost),
          parts: service.parts,
          discount: service.discount,
          part_cost: parseFloat(service.part_cost),
          opening_fitting: service.opening_fitting,
          of_cost: parseFloat(service.of_cost),
          exceeded_cost: 0,
          mrp: parseFloat(service.mrp),
          cost: (
            parseFloat(service.part_cost) + parseFloat(service.labour_cost)
          ).toFixed(2),
          doorstep: service.doorstep,
          unit: service.unit,
          quantity: service.quantity,
          part_cost_editable: service.part_cost_editable,
          labour_cost_editable: service.labour_cost_editable,
          of_cost_editable: service.of_cost_editable,
          type: service.type,
          source: service.id,
          description: service.description,
          id: service.id,
          _id: service._id,
          profile: service.profile,
          publish: service.publish,
          custom: service.custom,
        });
      });
    // }

    // else if (req.query.type == "customization") {

    await Customization.find(search_query)
      .skip(limit * page)
      .limit(limit)
      .cursor()
      .eachAsync(async (service) => {
        packages.push({
          package: service.package,
          segment: service.segment,
          service: service.service,
          labour: service.abours,
          labour_cost: parseFloat(service.labour_cost),
          parts: service.parts,
          discount: service.discount,
          part_cost: parseFloat(service.part_cost),
          opening_fitting: service.opening_fitting,
          of_cost: parseFloat(service.of_cost),
          exceeded_cost: 0,
          mrp: parseFloat(service.mrp),
          cost: (
            parseFloat(service.part_cost) + parseFloat(service.labour_cost)
          ).toFixed(2),
          doorstep: service.doorstep,
          unit: service.unit,
          quantity: service.quantity,
          part_cost_editable: service.part_cost_editable,
          labour_cost_editable: service.labour_cost_editable,
          of_cost_editable: service.of_cost_editable,
          type: service.type,
          source: service.id,
          description: service.description,
          id: service.id,
          _id: service._id,
          profile: service.profile,
          publish: service.publish,
          custom: service.custom,
        });
      });

    await Customization.find(search_query_model)
      .skip(limit * page)
      .limit(limit)
      .cursor()
      .eachAsync(async (service) => {
        packages.push({
          package: service.package,
          segment: service.segment,
          service: service.service,
          labour: service.abours,
          labour_cost: parseFloat(service.labour_cost),
          parts: service.parts,
          discount: service.discount,
          part_cost: parseFloat(service.part_cost),
          opening_fitting: service.opening_fitting,
          of_cost: parseFloat(service.of_cost),
          exceeded_cost: 0,
          mrp: parseFloat(service.mrp),
          cost: (
            parseFloat(service.part_cost) + parseFloat(service.labour_cost)
          ).toFixed(2),
          doorstep: service.doorstep,
          unit: service.unit,
          quantity: service.quantity,
          part_cost_editable: service.part_cost_editable,
          labour_cost_editable: service.labour_cost_editable,
          of_cost_editable: service.of_cost_editable,
          type: service.type,
          source: service.id,
          description: service.description,
          id: service.id,
          _id: service._id,
          profile: service.profile,
          publish: service.publish,
          custom: service.custom,
        });
      });
    // }

    // else if (req.query.type == "detailing") {

    await Detailing.find(search_query)
      .skip(limit * page)
      .limit(limit)
      .cursor()
      .eachAsync(async (service) => {
        packages.push({
          package: service.package,
          segment: service.segment,
          service: service.service,
          labour: service.abours,
          labour_cost: parseFloat(service.labour_cost),
          parts: service.parts,
          discount: service.discount,
          part_cost: parseFloat(service.part_cost),
          opening_fitting: service.opening_fitting,
          of_cost: parseFloat(service.of_cost),
          exceeded_cost: 0,
          mrp: parseFloat(service.mrp),
          cost: (
            parseFloat(service.part_cost) + parseFloat(service.labour_cost)
          ).toFixed(2),
          doorstep: service.doorstep,
          unit: service.unit,
          quantity: service.quantity,
          part_cost_editable: service.part_cost_editable,
          labour_cost_editable: service.labour_cost_editable,
          of_cost_editable: service.of_cost_editable,
          type: service.type,
          source: service.id,
          description: service.description,
          id: service.id,
          _id: service._id,
          profile: service.profile,
          publish: service.publish,
          custom: service.custom,
        });
      });

    // console.log("Data search_query_model = " + JSON.stringify(search_query_model))
    // console.log("Data search_query = " + JSON.stringify(search_query))
    await Detailing.find(search_query_model)
      .skip(limit * page)
      .limit(limit)
      .cursor()
      .eachAsync(async (service) => {
        packages.push({
          package: service.package,
          segment: service.segment,
          service: service.service,
          labour: service.abours,
          labour_cost: parseFloat(service.labour_cost),
          parts: service.parts,
          discount: service.discount,
          part_cost: parseFloat(service.part_cost),
          opening_fitting: service.opening_fitting,
          of_cost: parseFloat(service.of_cost),
          exceeded_cost: 0,
          mrp: parseFloat(service.mrp),
          cost: (
            parseFloat(service.part_cost) + parseFloat(service.labour_cost)
          ).toFixed(2),
          doorstep: service.doorstep,
          unit: service.unit,
          quantity: service.quantity,
          part_cost_editable: service.part_cost_editable,
          labour_cost_editable: service.labour_cost_editable,
          of_cost_editable: service.of_cost_editable,
          type: service.type,
          source: service.id,
          description: service.description,
          id: service.id,
          _id: service._id,
          profile: service.profile,
          publish: service.publish,
          custom: service.custom,
        });
      });

    // }

    res.status(200).json({
      responseCode: 200,
      responseMessage: "Success",
      responseData: packages,
    });
    // }
    // else {
    //     res.status(400).json({
    //         responseCode: 400,
    //         responseMessage: "Car not found",
    //         responseData: {}
    //     });
    // }
  }
);

router.get(
  "/totalServices/counts/get",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers["business"];

    var standard = "standard";
    var custom = "custom";
    var search_query = {};
    var search_query_model = {};

    if (standard) {
      search_query = { publish: true, business: business };
      search_query_model = {
        publish: { $nin: [true, false] },
        business: business,
      };

      var total_services_model = await Service.find(search_query_model).count();
      var total_services = await Service.find(search_query).count();
      var total_collision = await Collision.find(search_query).count();
      var total_collision_model = await Collision.find(
        search_query_model
      ).count();
      var total_customization = await Customization.find(search_query).count();
      var total_customization_model = await Customization.find(
        search_query_model
      ).count();
      var total_detailing = await Detailing.find(search_query).count();
      var total_detailing_model = await Detailing.find(
        search_query_model
      ).count();

      var total_satndard_services =
        total_detailing +
        total_customization +
        total_collision +
        total_services +
        total_services_model +
        total_detailing_model +
        total_customization_model +
        total_collision_model;
    }
    if (custom) {
      search_query = { custom: true, business: business };
      search_query_model = {
        custom: { $nin: [true, false] },
        business: business,
      };

      var total_services_model = await Service.find(search_query_model).count();
      var total_services = await Service.find(search_query).count();
      var total_collision = await Collision.find(search_query).count();
      var total_collision_model = await Collision.find(
        search_query_model
      ).count();
      var total_customization = await Customization.find(search_query).count();
      var total_customization_model = await Customization.find(
        search_query_model
      ).count();
      var total_detailing = await Detailing.find(search_query).count();
      var total_detailing_model = await Detailing.find(
        search_query_model
      ).count();

      var total_custom_services =
        total_detailing +
        total_customization +
        total_collision +
        total_services +
        total_services_model +
        total_detailing_model +
        total_customization_model +
        total_collision_model;
    }

    res.status(200).json({
      responseCode: 200,
      responseMessage: "Success",
      responseData: {
        total_satndard_services: total_satndard_services,
        total_custom_services: total_custom_services,
        total_live_services: 0,
      },
    });
  }
);

router.get(
  "/booking/category/get",
  xAccessToken.token,
  async function (req, res, next) {
    var data = [];
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;

    if (req.headers["business"]) {
      user = req.headers["business"];
    }

    await BookingCategory.find({ tag: { $ne: "package" } })
      .sort({ position: 1 })
      .cursor()
      .eachAsync(async (d) => {
        var enable = true;

        data.push({
          _id: d._id,
          id: d._id,
          tag: d.tag,
          position: d.position,
          icon: d.icon,
          title: d.title,
          image: d.image,
          video: d.video,
          home_visibility: d.home_visibility,
          id: d._id,
          nested: d.nested,
          enable: enable,
          features: d.features,
        });
      });

    res.status(200).json({
      responseCode: 200,
      responseMessage: "",
      responseData: data,
    });
  }
);

router.get(
  "/services/category/details/get",
  xAccessToken.token,
  async function (req, res, next) {
    var category = [];
    if (req.query.type == "service") {
      var sub_cat = [
        "Brakes & Suspension",
        "General",
        "Roadside Assistance",
        "Periodic Service",
        "AC",
        "Engine",
        "General",
      ];
      var segments = [
        "Sports",
        "Luxury XL",
        "Luxury",
        "Premium XL",
        "Premium",
        "Medium",
        "Small",
      ];
      category.push({
        type: req.query.type,
        sub_categorys: sub_cat,
        segments: segments,
      });
      res.status(200).json({
        responseCode: 200,
        responseMessage: "Services Sub-Categories",
        responseData: category,
      });
    } else if (req.query.type == "collision") {
      var sub_cat = [
        "Front Side",
        "Right Side",
        "Left Side",
        "Rear Side",
        "General",
      ];
      var segments = [
        "Sports",
        "Luxury XL",
        "Luxury",
        "Premium XL",
        "Premium",
        "Medium",
        "Small",
      ];
      category.push({
        type: req.query.type,
        sub_categorys: sub_cat,
        segments: segments,
      });
      res.status(200).json({
        responseCode: 200,
        responseMessage: "Services Sub-Categories",
        responseData: category,
      });
    } else if (req.query.type == "customization") {
      var sub_cat = ["Wheels", "Package", "Graphics"];
      var segments = [
        "Sports",
        "Luxury XL",
        "Luxury",
        "Premium XL",
        "Premium",
        "Medium",
        "Small",
      ];
      category.push({
        type: req.query.type,
        sub_categorys: sub_cat,
        segments: segments,
      });
      res.status(200).json({
        responseCode: 200,
        responseMessage: "Services Sub-Categories",
        responseData: category,
      });
    } else if (req.query.type == "detailing") {
      var sub_cat = [
        "Washing",
        "Interior Detailing",
        "Exterior Detailing",
        "Protection Coatings",
      ];
      var segments = [
        "Sports",
        "Luxury XL",
        "Luxury",
        "Premium XL",
        "Premium",
        "Medium",
        "Small",
      ];
      category.push({
        type: req.query.type,
        sub_categorys: sub_cat,
        segments: segments,
      });
      res.status(200).json({
        responseCode: 200,
        responseMessage: "Services Sub-Categories",
        responseData: category,
      });
    }
    // var status = await LeadStatus.findOne({ stage: req.query.stage }).exec();
    // if (status) {
    //     res.status(200).json({
    //         responseCode: 200,
    //         responseMessage: "success",
    //         responseData: status.status
    //     });
    // }
    else {
      res.status(200).json({
        responseCode: 200,
        responseMessage: "Service not Matched",
        responseData: [],
      });
    }
  }
);

router.post("/custom/collision/services/add", async function (req, res, next) {
  var token = req.headers["x-access-token"];
  var secret = config.secret;
  var decoded = jwt.verify(token, secret);
  var user = decoded.user;
  var business = req.headers["business"];
  var lb = req.body.labour_cost;
  var pc = req.body.part_cost;
  var pg = req.body._package;
  var sg = req.body.segment;
  // console.log("Labour= " + lb + "Part= " + pc + "Business Id " + business)
  var not_inserted = [];

  var automaker = null;
  var _automaker = "";
  var model = null;
  var _model = "";

  if (req.body._model) {
    var model = await Model.findOne({ value: req.body._model }).exec();
    if (model) {
      var automaker = await Automaker.findById(model.automaker).exec();

      model = model._id;
      _model = model.value;
      automaker = automaker._id;
      _automaker = automaker.maker;
    }
  }
  var tax_info = {};
  var tax_info = await Tax.findOne({
    rate: parseFloat(18),
    type: "GST",
  }).exec();
  var tax_rate = tax_info.detail;

  var parts = [];
  var labours = [];
  var opening_fitting = [];

  if (parseFloat(req.body.part_cost) > 0) {
    parts_visible = false;
    var service = req.body.service;
    var amount = Math.ceil(req.body.part_cost);
    var base = amount;
    var part_tax = [];

    var x = (100 + tax_info.rate) / 100;
    var tax_on_amount = amount / x;
    if (tax_rate.length > 0) {
      for (var r = 0; r < tax_rate.length; r++) {
        if (tax_rate[r].rate != tax_info.rate) {
          var t = tax_on_amount * (tax_rate[r].rate / 100);
          base = base - t;
          part_tax.push({
            tax: tax_rate[r].tax,
            rate: tax_rate[r].rate,
            amount: parseFloat(t.toFixed(2)),
          });
        } else {
          base = base - t;
          part_tax.push({
            tax: tax_info.tax,
            tax_rate: tax_info.rate,
            rate: tax_info.rate,
            amount: parseFloat(tax_on_amount.toFixed(2)),
          });
        }
      }
    }

    tax_detail = {
      tax: tax_info.tax,
      tax_rate: tax_info.rate,
      rate: tax_info.rate,
      base: parseFloat(base.toFixed(2)),
      detail: part_tax,
    };

    parts.push({
      source: null,
      item: req.body.service + " Material",
      // hsn_sac: req.body.part_hsn_sac,
      part_no: "",
      quantity: 1,
      issued: false,
      rate: parseFloat(req.body.part_cost),
      base: parseFloat(base.toFixed(2)),
      amount: parseFloat(amount),
      tax_amount: _.sumBy(part_tax, (x) => x.amount),
      amount_is_tax: "inclusive",
      customer_dep: 100,
      insurance_dep: 0,
      discount: 0,
      tax: tax_info.tax,
      tax_rate: tax_info.rate,
      tax_info: tax_detail,
    });
  }

  if (parseFloat(req.body.labour_cost) > 0) {
    var amount = parseFloat(req.body.labour_cost);
    var base = amount;
    var labour_tax = [];

    var x = (100 + tax_info.rate) / 100;
    var tax_on_amount = amount / x;

    if (tax_rate.length > 0) {
      for (var r = 0; r < tax_rate.length; r++) {
        if (tax_rate[r].rate != tax_info.rate) {
          var t = tax_on_amount * (tax_rate[r].rate / 100);
          base = base - t;
          labour_tax.push({
            tax: tax_rate[r].tax,
            rate: parseFloat(tax_rate[r].rate.toFixed(2)),
            amount: parseFloat(t.toFixed(2)),
          });
        } else {
          base = base - t;
          labour_tax.push({
            tax: tax_info.tax,
            rate: parseFloat(tax_info.rate.toFixed(2)),
            amount: parseFloat(tax_on_amount.toFixed(2)),
          });
        }
      }
    }

    labours.push({
      item: req.body.service,
      quantity: 1,
      // hsn_sac: req.body.hsn_sac,
      rate: parseFloat(req.body.labour_cost),
      base: parseFloat(base.toFixed(2)),
      amount: parseFloat(amount),
      discount: 0,
      amount_is_tax: "inclusive",
      customer_dep: 100,
      insurance_dep: 0,
      tax_amount: _.sumBy(labour_tax, (x) => x.amount),
      tax: tax_info.tax,
      tax_rate: tax_info.rate,
      tax_info: {
        tax: tax_info.tax,
        tax_rate: tax_info.rate,
        rate: tax_info.rate,
        base: parseFloat(base.toFixed(2)),
        detail: labour_tax,
      },
    });
  }
  var margin_total = parseFloat(req.body.labour_cost) * (40 / 100);
  var mrp = parseFloat(req.body.labour_cost) + margin_total;

  Collision.create({
    business: business,
    imported: true,
    model: model,
    _model: _model,
    automaker: automaker,
    _automaker: _automaker,
    package: req.body._package,
    segment: req.body.segment,
    service: req.body.service,
    // description: req.body.description,
    parts: parts,
    part_cost: parseFloat(req.body.part_cost),
    opening_fitting: [],
    of_cost: 0,
    labour: labours,
    labour_cost: parseFloat(req.body.labour_cost),
    cost: parseFloat(req.body.part_cost) + parseFloat(req.body.labour_cost),
    mrp: parseFloat(req.body.part_cost) + Math.ceil(mrp),
    editable: true,
    labour_cost_editable: false,
    part_cost_editable: false,
    of_cost_editable: true,
    amount_is_tax: "inclusive",
    publish: true,
    approved: false,
    admin_verified: false,
    admin_status: "Custom",
    created_at: new Date(),
    updated_at: new Date(),

    // gallery: g,
    tax: "18.0% GST",
    rate: 18,
    tax_info: {
      tax: tax_info.tax,
      tax_rate: tax_info.rate,
      rate: tax_info.rate,
      base: parseFloat(base.toFixed(2)),
      detail: labour_tax,
    },
  });

  res.status(200).json({
    responseCode: 200,
    responseMessage: "New Custom Service Addded Successfully",
    responseData: {},
  });
  // event.ServiceApproval("Collision", business, sg, pg, req.body.service, pc, lb, req.headers['tz'])
});

router.put("/services/edit", async function (req, res, next) {
  // // console.log("API Called")
  var token = req.headers["x-access-token"];
  var secret = config.secret;
  var decoded = jwt.verify(token, secret);
  var user = decoded.user;
  var business = req.headers["business"];
  var lb = req.body.labour_cost;
  var pc = req.body.part_cost;
  var pg = req.body.package;
  var sg = req.body.segment;
  var service_name = req.body.service;
  var category = req.body.category;
  // console.log("Labour= " + lb + "Part= " + pc + "Business Id " + business)
  var not_inserted = [];

  var automaker = null;
  var _automaker = "";
  var model = null;
  var _model = "";
  // return res.json({
  //     data: req.body._id
  // })
  if (req.body._model) {
    var model = await Model.findOne({ value: req.body._model }).exec();
    if (model) {
      var automaker = await Automaker.findById(model.automaker).exec();

      model = model._id;
      _model = model.value;
      automaker = automaker._id;
      _automaker = automaker.maker;
    }
  }

  var tax_info = {};
  var tax_info = await Tax.findOne({
    rate: parseFloat(18),
    type: "GST",
  }).exec();
  var tax_rate = tax_info.detail;

  var parts = [];
  var labours = [];
  var opening_fitting = [];

  if (parseFloat(req.body.part_cost) > 0) {
    parts_visible = false;
    var service = req.body.service;
    var amount = Math.ceil(req.body.part_cost);
    var base = amount;
    var part_tax = [];

    var x = (100 + tax_info.rate) / 100;
    var tax_on_amount = amount / x;
    if (tax_rate.length > 0) {
      for (var r = 0; r < tax_rate.length; r++) {
        if (tax_rate[r].rate != tax_info.rate) {
          var t = tax_on_amount * (tax_rate[r].rate / 100);
          base = base - t;
          part_tax.push({
            tax: tax_rate[r].tax,
            rate: tax_rate[r].rate,
            amount: parseFloat(t.toFixed(2)),
          });
        } else {
          base = base - t;
          part_tax.push({
            tax: tax_info.tax,
            tax_rate: tax_info.rate,
            rate: tax_info.rate,
            amount: parseFloat(tax_on_amount.toFixed(2)),
          });
        }
      }
    }

    tax_detail = {
      tax: tax_info.tax,
      tax_rate: tax_info.rate,
      rate: tax_info.rate,
      base: parseFloat(base.toFixed(2)),
      detail: part_tax,
    };

    parts.push({
      source: null,
      item: req.body.service,
      // hsn_sac: req.body.hsn_sac,
      part_no: "",
      quantity: 1,
      issued: false,
      rate: parseFloat(req.body.part_cost),
      base: parseFloat(base.toFixed(2)),
      amount: parseFloat(amount),
      tax_amount: _.sumBy(part_tax, (x) => x.amount),
      amount_is_tax: "inclusive",
      customer_dep: 100,
      insurance_dep: 0,
      discount: 0,
      tax: tax_info.tax,
      tax_rate: tax_info.rate,
      tax_info: tax_detail,
    });
  }

  if (parseFloat(req.body.labour_cost) > 0) {
    var amount = parseFloat(req.body.labour_cost);
    var base = amount;
    var labour_tax = [];

    var x = (100 + tax_info.rate) / 100;
    var tax_on_amount = amount / x;

    if (tax_rate.length > 0) {
      for (var r = 0; r < tax_rate.length; r++) {
        if (tax_rate[r].rate != tax_info.rate) {
          var t = tax_on_amount * (tax_rate[r].rate / 100);
          base = base - t;
          labour_tax.push({
            tax: tax_rate[r].tax,
            rate: parseFloat(tax_rate[r].rate.toFixed(2)),
            amount: parseFloat(t.toFixed(2)),
          });
        } else {
          base = base - t;
          labour_tax.push({
            tax: tax_info.tax,
            rate: parseFloat(tax_info.rate.toFixed(2)),
            amount: parseFloat(tax_on_amount.toFixed(2)),
          });
        }
      }
    }
    labours.push({
      item: req.body.service,
      quantity: 1,
      // hsn_sac: req.body.hsn_sac,
      rate: parseFloat(req.body.labour_cost),
      base: parseFloat(base.toFixed(2)),
      amount: parseFloat(amount),
      discount: 0,
      amount_is_tax: "inclusive",
      customer_dep: 100,
      insurance_dep: 0,
      tax_amount: _.sumBy(labour_tax, (x) => x.amount),
      tax: tax_info.tax,
      tax_rate: tax_info.rate,
      tax_info: {
        tax: tax_info.tax,
        tax_rate: tax_info.rate,
        rate: tax_info.rate,
        base: parseFloat(base.toFixed(2)),
        detail: labour_tax,
      },
    });
  }
  var margin_total = parseFloat(req.body.labour_cost) * (40 / 100);
  var mrp = parseFloat(req.body.labour_cost) + margin_total;

  var data = {
    business: business,
    imported: true,
    model: model,
    _model: _model,
    // package: req.body.package,
    // segment: req.body.segment,
    service: req.body.service,
    parts: parts,
    part_cost: parseFloat(req.body.part_cost),
    labour: labours,
    labour_cost: parseFloat(req.body.labour_cost),
    cost: parseFloat(req.body.part_cost) + parseFloat(req.body.labour_cost),
    mrp: parseFloat(req.body.part_cost) + Math.ceil(mrp),
    amount_is_tax: "inclusive",
    publish: true,
    admin_status: "Standard",
    created_at: new Date(),
    updated_at: new Date(),
    custom: false,
    tax: "18.0% GST",
    rate: 18,
    tax_info: {
      tax: tax_info.tax,
      tax_rate: tax_info.rate,
      rate: tax_info.rate,
      base: parseFloat(base.toFixed(2)),
      detail: labour_tax,
    },
  };

  if (category == "services") {
    Service.findOneAndUpdate(
      { _id: req.body.id },
      { $set: data },
      { new: true },
      async function (err, doc) {
        res.status(200).json({
          responseCode: 200,
          responseMessage: "Successfully Updated",
          responseData: doc,
        });
      }
    );
  } else if (category == "customization") {
    Customization.findOneAndUpdate(
      { _id: req.body.id },
      { $set: data },
      { new: true },
      async function (err, doc) {
        res.status(200).json({
          responseCode: 200,
          responseMessage: "Successfully Updated",
          responseData: doc,
        });
      }
    );
  } else if (category == "detailing") {
    Detailing.findOneAndUpdate(
      { _id: req.body.id },
      { $set: data },
      { new: true },
      async function (err, doc) {
        res.status(200).json({
          responseCode: 200,
          responseMessage: "Successfully Updated",
          responseData: doc,
        });
      }
    );
  } else if (category == "collision") {
    Collision.findOneAndUpdate(
      { _id: req.body.id },
      { $set: data },
      { new: true },
      async function (err, doc) {
        res.status(200).json({
          responseCode: 200,
          responseMessage: "Successfully Updated",
          responseData: doc,
        });
      }
    );
  } else {
    res.status(400).json({
      responseCode: 400,
      responseMessage: "Service Category not found",
      responseData: {},
    });
  }
});
router.get("/user/get", async function (req, res, next) {
  var rules = {
    query: "required",
  };

  var validation = new Validator(req.query, rules);

  if (validation.fails()) {
    res.status(422).json({
      responseCode: 422,
      responseMessage: "Error",
      responseData: {
        res: validation.errors.all(),
      },
    });
  } else {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var data = [];
    // , business: business
    await User.find({ contact_no: req.query.query })
      .cursor()
      .eachAsync(async (user) => {
        var bookings = [];
        await Booking.find({
          status: {
            $in: [
              "Approved",
              "Confirmed",
              "Pending",
              "Approval",
              "Failure",
              "Failed",
              "EstimateRequested",
            ],
          },
          is_services: true,
          user: user._id,
        })
          .populate({
            path: "user",
            populate: {
              path: "user",
              select: "_id id name contact_no email address",
            },
          })
          .populate({
            path: "manager",
            populate: { path: "user", select: "_id id name contact_no" },
          })
          .populate({
            path: "car",
            select: "_id id title registration_no ic rc",
            populate: { path: "thumbnails" },
          })
          .cursor()
          .eachAsync(async (booking) => {
            var address = await Address.findOne({
              _id: booking.address,
            }).exec();
            if (booking.car) {
              if (booking.car.thumbnails[0]) {
                var thumbnail = [booking.car.thumbnails[0]];
              } else {
                var thumbnail = [];
              }

              var car = {
                title: booking.car.title,
                _id: booking.car._id,
                id: booking.car.id,
                rc_address: booking.car.rc_address,
                ic_address: booking.car.ic_address,
                ic: booking.car.ic,
                rc: booking.car.rc,
                registration_no: booking.car.registration_no,
              };
            } else {
              var car = null;
            }

            var manager = null;
            if (booking.manager) {
              manager = {
                name: booking.manager.name,
                _id: booking.manager._id,
                id: booking.manager.id,
                contact_no: booking.manager.contact_no,
                email: booking.manager.email,
              };
            }

            bookings.push({
              _id: booking._id,
              id: booking._id,
              car: car,
              user: {
                name: booking.user.name,
                _id: booking.user._id,
                id: booking.user.id,
                contact_no: booking.user.contact_no,
              },
              manager: manager,
              services: booking.services,
              convenience: booking.convenience,
              date: moment(booking.date).tz(req.headers["tz"]).format("ll"),
              time_slot: booking.time_slot,
              status: _.startCase(booking.status),
              booking_no: booking.booking_no,
              address: address,
              payment: booking.payment,
              customer_requirements: booking.customer_requirements,
              estimation_requested: booking.estimation_requested,
              txnid: booking.txnid,
              __v: booking.__v,
              created_at: booking.created_at,
              updated_at: booking.updated_at,
            });
          });

        data.push({
          _id: user._id,
          id: user.id,
          name: user.name,
          username: user.username,
          email: user.email,
          contact_no: user.contact_no,
          avatar_address: user.avatar_address,
          avatar: user.avatar,
          address: user.address,
          account_info: user.account_info,
          bookings: bookings,
        });
      });

    if (data.length > 0) {
      res.status(200).json({
        responseCode: 200,
        responseMessage: "success",
        responseData: data,
      });
    } else {
      res.status(200).json({
        responseCode: 200,
        responseMessage: data.length,
        responseData: [],
      });
    }
  }
});

router.get(
  "/user/cars/get",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers["business"];
    var car = [];
    var currentDate = new Date();

    await Car.find({ user: req.query.user, status: true })
      .populate("bookmark")
      .populate("thumbnails")
      .populate({
        path: "user",
        select: "name username avatar avatar_address address",
      })
      .populate({ path: "variant", populate: { path: "model" } })
      .sort({ created_at: -1 })
      .cursor()
      .eachAsync(async (doc) => {
        car.push({
          __v: 0,
          _id: doc._id,
          id: doc.id,
          title: doc.title,
          variant: doc.variant._id,
          model: doc.model,
          modelName: doc.variant.model.model,
          price: doc.price,
          numericPrice: doc.price,
          accidental: doc.accidental,
          body_style: doc.body_style,
          description: doc.description,
          driven: doc.driven,
          carId: doc.carId,
          fuel_type: doc.fuel_type,
          insurance: doc.insurance,
          location: doc.location,
          manufacture_year: doc.manufacture_year,
          mileage: doc.mileage,
          owner: doc.owner,
          registration_no: doc.registration_no,
          transmission: doc.transmission,
          vehicle_color: doc.vehicle_color,
          vehicle_status: doc.vehicle_status,
          geometry: doc.geometry,
          fuel_level: doc.fuel_level,
          engine_no: doc.engine_no,
          vin: doc.vin,
          ic: doc.ic,
          rc: doc.rc,
          ic_address: doc.ic_address,
          rc_address: doc.rc_address,
          publish: doc.publish,
          status: doc.status,
          premium: doc.premium,
          is_bookmarked: doc.is_bookmarked,
          thumbnails: doc.thumbnails,
          user: doc.user,
          insurance_info: doc.insurance_info,
          created_at: doc.created_at,
          updated_at: doc.updated_at,
        });
      });

    res.status(200).json({
      responseCode: 200,
      responseMessage: "success",
      responseData: car,
    });
  }
);

router.get("/makers/get", async function (req, res, next) {
  var rules = {
    query: "required",
  };

  var validation = new Validator(req.query, rules);

  if (validation.fails()) {
    res.status(422).json({
      responseCode: 422,
      responseMessage: "Invalid Request",
      responseData: {
        res: validation.errors.all(),
      },
    });
  } else {
    if (req.query.query) {
      req.query.query = req.query.query.replace(
        /([.?*+^$[\]\\(){}|-])/g,
        "\\$1"
      );
      var variant = [];

      await Variant.find({ variant: new RegExp(req.query.query, "i") })
        .select("-service_schedule")
        .cursor()
        .eachAsync(async (v) => {
          variant.push({
            _id: v._id,
            id: v.id,
            variant: v.variant + " (" + v.specification.fuel_type + ")",
            value: v.value,
          });
        });

      res.status(200).json({
        responseCode: 200,
        responseMessage: "success",
        responseData: variant,
      });
    }
  }
});

router.post(
  "/lead/booking/confirmed/add/",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers["business"];
    var loggedInDetails = await User.findById(decoded.user).exec();
    var role = await Management.findOne({
      user: decoded.user,
      business: business,
    }).exec();

    var advisor = await q.all(
      businessFunctions.getAdvisor(loggedInDetails._id, business)
    );

    var estimation_requested = false;
    if (req.body.estimation_requested == "Yes") {
      estimation_requested = true;
    }

    var date = null;
    if (req.body.date) {
      date = new Date(req.body.date).toISOString();
    }

    var time_slot = "";
    if (req.body.time_slot) {
      time_slot = req.body.time_slot;
    }

    var convenience = "";
    if (req.body.convenience) {
      convenience = req.body.convenience;
    }

    var address = null;
    if (req.body.address) {
      address = req.body.address;
    }

    var role = await Management.findOne({
      user: user,
      business: business,
    }).exec();

    // console.log("18495 req.body.lead = " + req.body.lead)
    if (role.role == "CRE") {
      var lead = await Lead.findOne({
        assignee: user,
        _id: req.body.lead,
      }).exec();
    } else {
      var lead = await Lead.findOne({
        business: business,
        _id: req.body.lead,
      }).exec();
    }

    if (lead) {
      var leadUser = {
        name: lead.name,
        contact_no: lead.contact_no,
        email: lead.email,
        user: lead.user,
      };
      // console.log("18511 leadUser.contact_no = " + leadUser.contact_no)
      // var user = await q.all(businessFunctions.getUser(leadUser))
      var user = await User.findOne({ _id: req.body.user }).exec();
      if (user) {
        var rg = req.body.registration_no;
        req.body.registration_no = rg.replace(/ /g, "");

        var leadCar = {
          user: user,
          car: req.body.car,
          variant: req.body.variant,
          registration_no: req.body.registration_no,
        };
        var car = await q.all(businessFunctions.getCar(leadCar));
        if (car) {
          var booking = await Booking.findOne({
            car: car._id,
            user: user,
            status: {
              $nin: [
                "Completed",
                "CompleteWork",
                "QC",
                "Closed",
                "Ready",
                "Rejected",
                "Cancelled",
                "Inactive",
              ],
            },
            is_services: true,
          }).exec();
          if (booking) {
            return res.status(422).json({
              responseCode: 422,
              responseMessage:
                "Booking already exists for the same registration no. [" +
                booking.status +
                "]",
              responseData: {},
            });
          } else {
            var bookingService = [];
            var customer_requirements = [];

            if (req.body.requirement) {
              customer_requirements.push({
                requirement: req.body.requirement,
              });
            }

            var payment = {
              payment_mode: "",
              payment_status: "Pending",
              discount_type: "",
              coupon: "",
              coupon_type: "",
              discount: 0,
              discount_total: 0,
              part_cost: 0,
              labour_cost: 0,
              paid_total: 0,
              total: 0,
              discount_applied: false,
              transaction_id: "",
              transaction_date: "",
              transaction_status: "",
              transaction_response: "",
            };

            var bookingData = {
              package: null,
              car: car,
              advisor: advisor,
              manager: lead.assignee,
              business: business,
              user: user,
              services: bookingService,
              customer_requirements: customer_requirements,
              booking_no: Math.round(+new Date() / 1000),
              date: date,
              time_slot: time_slot,
              estimation_requested: estimation_requested,
              convenience: convenience,
              status: "Inactive",
              payment: payment,
              address: address,
              lead: lead._id,
              is_services: true,
              converted: true,
              created_at: new Date(),
              updated_at: new Date(),
            };

            await Booking.create(bookingData).then(async function (b) {
              var activity = {
                user: loggedInDetails._id,
                name: loggedInDetails.name,
                stage: "Inactive",
                activity: "Booking",
              };

              // fun.bookingLog(b._id, activity);

              if (role.role == "CRE") {
                if (estimation_requested) {
                  //False
                  var notify = {
                    receiver: [b.advisor],
                    sender: loggedInDetails._id,
                    activity: "booking",
                    source: b._id,
                    tag: "EstimateRequested",
                    points: 0,
                  };

                  // fun.newNotification(notify);
                } else {
                  var notify = {
                    source: b._id,
                    receiver: [b.advisor],
                    sender: loggedInDetails._id,
                    activity: "booking",
                    tag: "leadBooking",
                    points: 0,
                  };
                  // fun.newNotification(notify);
                }
              } else {
                if (estimation_requested) {
                  //false
                  var notify = {
                    receiver: [b.manager],
                    sender: loggedInDetails._id,
                    activity: "booking",
                    source: b._id,
                    tag: "Inactive",
                    points: 0,
                  };

                  // fun.newNotification(notify);
                } else {
                  var notify = {
                    source: b._id,
                    receiver: [b.manager],
                    sender: loggedInDetails._id,
                    activity: "booking",
                    tag: "Inactive",
                    points: 0,
                  };
                  // fun.newNotification(notify);
                }
              }
              var contact_no = lead.contact_no;
              var alternate_no = "";
              if (lead.optional_info) {
                alternate_no = lead.optional_info.alternate_no;
              }

              if (user.contact_no != lead.contact_no) {
                contact_no: user.contact_no;
                alternate_no = lead.contact_no;
              }
              // var activity = "Booking";
              // fun.webNotification(activity, b);

              var data = {
                user: user,
                contact_no: contact_no,
                "optional_info.alternate_no": alternate_no,
                follow_up: {},
                converted: true,
                remark: {
                  lead: lead._id,
                  status: "Inactive",
                  color_code: lead.remark.color_code,
                  assignee: user,
                  customer_remark: "Inactive",
                  assignee_remark: "Inactive",
                  created_at: new Date(),
                  updated_at: new Date(),
                },
                // created_at: new Date(),
                updated_at: new Date(),
              };
              // var activity = "Booking";
              // fun.webNotification(activity, booking);

              await Lead.findOneAndUpdate(
                { _id: lead._id },
                { $set: data },
                { new: true },
                async function (err, doc) {
                  if (err) {
                    return res.status(422).json({
                      responseCode: 422,
                      responseMessage: "Server Error",
                      responseData: err,
                    });
                  } else {
                    LeadRemark.create(data.remark).then(function (newRemark) {
                      Lead.findOneAndUpdate(
                        { _id: lead._id },
                        { $push: { remarks: newRemark._id } },
                        { new: true },
                        async function (err, doc) {}
                      );
                    });
                  }
                }
              );

              var bookings = [];
              var booking = await Booking.findById(b._id)
                .populate({
                  path: "user",
                  populate: {
                    path: "user",
                    select: "_id id name contact_no email business_info",
                  },
                })
                .populate({
                  path: "manager",
                  populate: {
                    path: "user",
                    select: "_id id name contact_no email",
                  },
                })
                .populate({
                  path: "car",
                  select: "_id id title registration_no ic rc",
                  populate: { path: "thumbnails" },
                })
                .exec();

              if (booking.address) {
                var address = await Address.findOne({
                  _id: booking.address,
                }).exec();
              } else {
                var address = {};
              }
              if (booking.car) {
                var car = {
                  title: booking.car.title,
                  _id: booking.car._id,
                  id: booking.car.id,
                  rc_address: booking.car.rc_address,
                  ic_address: booking.car.ic_address,
                  ic: booking.car.ic,
                  rc: booking.car.rc,
                  registration_no: booking.car.registration_no,
                };
              }

              var manager = null;
              if (booking.manager) {
                manager = {
                  name: booking.manager.name,
                  _id: booking.manager._id,
                  id: booking.manager.id,
                  contact_no: booking.manager.contact_no,
                  email: booking.manager.email,
                };
              }
              if (booking.user) {
                user = {
                  name: booking.user.name,
                  _id: booking.user._id,
                  id: booking.user.id,
                  contact_no: booking.user.contact_no,
                  email: booking.user.email,
                  business_info: booking.user.business_info,
                };
              }
              bookings.push({
                _id: booking._id,
                id: booking._id,
                car: car,
                user: user,
                manager: manager,
                services: booking.services,
                convenience: booking.convenience,
                date: moment(booking.date).tz(req.headers["tz"]).format("ll"),
                time_slot: booking.time_slot,
                status: booking.status,
                booking_no: booking.booking_no,
                job_no: booking.job_no,
                estimation_requested: booking.estimation_requested,
                address: address,
                remarks: booking.remarks,
                customer_requirements: booking.customer_requirements,
                payment: booking.payment,
                txnid: booking.txnid,
                __v: booking.__v,
                created_at: moment(booking.created_at)
                  .tz(req.headers["tz"])
                  .format("lll"),
                updated_at: moment(booking.updated_at)
                  .tz(req.headers["tz"])
                  .format("lll"),
              });
              //await whatsAppEvent.bookingWhatsApp(b._id,business)
              // Lead.findOneAndUpdate({ _id: lead._id }, { $set: { user: user, converted: true } }, { new: false }, async function (err, doc) {
              //     if (err) {
              //         res.status(422).json({
              //             responseCode: 422,
              //             responseMessage: "Server Error",
              //             responseData: err
              //         });
              //     }
              //     else {
              //         event.zohoLead(b._id);

              //         res.status(200).json({
              //             responseCode: 200,
              //             responseMessage: "Booking",
              //             responseData: bookings
              //         });
              //     }
              // });
              res.status(200).json({
                responseCode: 200,
                responseMessage: "Booking",
                responseData: bookings[0],
              });
            });
          }
        } else {
          res.status(422).json({
            responseCode: 400,
            responseMessage: "Car required",
            responseData: {},
          });
        }
      } else {
        res.status(422).json({
          responseCode: 400,
          responseMessage: "Name & Contact_no is required",
          responseData: {},
        });
      }
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Lead not found",
        responseData: {},
      });
    }
  }
);

//   console.log("body..", JSON.stringify(req.body))
//   var rules = {
//     booking: "required",
//     services: "required",
//   };
//   var validation = new Validator(req.body, rules);

//   if (validation.fails()) {
//     res.status(422).json({
//       responseCode: 422,
//       responseMessage: "Error",
//       responseData: {
//         res: validation.errors.all(),
//       },
//     });
//   } else {
//     if (req.body.package == "") {
//       req.body.package = null;
//     }

//     var token = req.headers["x-access-token"];
//     var secret = config.secret;
//     var decoded = jwt.verify(token, secret);
//     var user = decoded.user;
//     var total = 0;
//     var labourCost = 0;

//     var part_cost = 0;
//     var is_services = true;
//     var doorstep = true;
//     var bookingService = [];
//     var checkBooking = await Booking.findOne({
//       _id: req.body.booking,
//       status: {
//         $in: [
//           "Confirmed",
//           "Pending",
//           "Approval",
//           "Inactive",
//           "Approved",
//           "Failed",
//           "JobInitiated",
//         ],
//       },
//       is_services: true,
//     }).exec();
//     var services = req.body.services;
//     if (checkBooking) {
//       for (var i = 0; i < services.length; i++) {
//         if (services[i].type == "package") {
//           await Package.find({ _id: services[i].id })
//             .cursor()
//             .eachAsync(async (service) => {
//               if (service) {
//                 var tax_info = await Tax.findOne({ tax: "18.0% GST" }).exec();
//                 var tax_rate = tax_info.detail;
//                 var amount = service.cost;
//                 var base = amount;
//                 var labour_tax = [];
//                 var labours = [];

//                 var x = (100 + tax_info.rate) / 100;
//                 var tax_on_amount = amount / x;
//                 if (tax_rate.length > 0) {
//                   for (var r = 0; r < tax_rate.length; r++) {
//                     if (tax_rate[r].rate != tax_info.rate) {
//                       var t = tax_on_amount * (tax_rate[r].rate / 100);
//                       base = base - t;
//                       labour_tax.push({
//                         tax: tax_rate[r].tax,
//                         rate: parseFloat(tax_rate[r].rate.toFixed(2)),
//                         amount: parseFloat(t.toFixed(2)),
//                       });
//                     } else {
//                       base = base - t;
//                       labour_tax.push({
//                         tax: tax_info.tax,
//                         tax_rate: tax_info.rate,
//                         rate: parseFloat(tax_info.rate.toFixed(2)),
//                         amount: parseFloat(tax_on_amount.toFixed(2)),
//                       });
//                     }
//                   }
//                 }

//                 labours.push({
//                   item: service.name,
//                   quantity: 1,
//                   rate: parseFloat(service.cost),
//                   base: parseFloat(base.toFixed(2)),
//                   amount: parseFloat(amount),
//                   discount: 0,
//                   customer_dep: 100,
//                   insurance_dep: 0,
//                   amount_is_tax: "inclusive",
//                   tax_amount: _.sumBy(labour_tax, (x) => x.amount),
//                   tax: tax_info.tax,
//                   tax_rate: tax_info.rate,
//                   tax_info: {
//                     tax: tax_info.tax,
//                     tax_rate: tax_info.rate,
//                     rate: tax_info.rate,
//                     base: parseFloat(base.toFixed(2)),
//                     detail: labour_tax,
//                   },
//                 });

//                 is_services = false;

//                 bookingService.push({
//                   source: services[i].id,
//                   service: service.name,
//                   description: service.description,
//                   cost: Math.ceil(service.cost),
//                   labour_cost: Math.ceil(service.cost),
//                   part_cost: 0,
//                   of_cost: 0,
//                   discount: 0,
//                   parts: [],
//                   labour: labours,
//                   opening_fitting: [],
//                   type: "package",
//                   customer_approval: true,
//                   surveyor_approval: false,
//                 });

//                 // console.log(bookingService)
//               } else {
//                 res.status(400).json({
//                   responseCode: 400,
//                   responseMessage: "Service Not Found",
//                   responseData: {},
//                 });
//               }
//             });
//         } else if (services[i].type == "addOn") {
//           await Package.find({ _id: services[i].id })
//             .cursor()
//             .eachAsync(async (service) => {
//               if (service) {
//                 var tax_info = await Tax.findOne({ tax: "18.0% GST" }).exec();
//                 var tax_rate = tax_info.detail;
//                 var amount = service.cost;
//                 var base = amount;
//                 var labour_tax = [];
//                 var labours = [];

//                 var x = (100 + tax_info.rate) / 100;
//                 var tax_on_amount = amount / x;
//                 if (tax_rate.length > 0) {
//                   for (var r = 0; r < tax_rate.length; r++) {
//                     if (tax_rate[r].rate != tax_info.rate) {
//                       var t = tax_on_amount * (tax_rate[r].rate / 100);
//                       base = base - t;
//                       labour_tax.push({
//                         tax: tax_rate[r].tax,
//                         rate: parseFloat(tax_rate[r].rate.toFixed(2)),
//                         amount: parseFloat(t.toFixed(2)),
//                       });
//                     } else {
//                       base = base - t;
//                       labour_tax.push({
//                         tax: tax_info.tax,
//                         tax_rate: tax_info.rate,
//                         rate: parseFloat(tax_info.rate.toFixed(2)),
//                         amount: parseFloat(tax_on_amount.toFixed(2)),
//                       });
//                     }
//                   }
//                 }

//                 labours.push({
//                   item: service.name,
//                   quantity: 1,
//                   rate: parseFloat(service.cost),
//                   base: parseFloat(base.toFixed(2)),
//                   amount: parseFloat(amount),
//                   discount: 0,
//                   customer_dep: 100,
//                   insurance_dep: 0,
//                   amount_is_tax: "inclusive",
//                   tax_amount: _.sumBy(labour_tax, (x) => x.amount),
//                   tax: tax_info.tax,
//                   tax_rate: tax_info.rate,
//                   tax_info: {
//                     tax: tax_info.tax,
//                     tax_rate: tax_info.rate,
//                     rate: tax_info.rate,
//                     base: parseFloat(base.toFixed(2)),
//                     detail: labour_tax,
//                   },
//                 });

//                 is_services = true;

//                 bookingService.push({
//                   source: service._id,
//                   service: service.name,
//                   description: service.description,
//                   cost: Math.ceil(service.cost),
//                   labour_cost: Math.ceil(service.cost),
//                   part_cost: 0,
//                   of_cost: 0,
//                   discount: 0,
//                   parts: [],
//                   labour: labours,
//                   opening_fitting: [],
//                   type: "addOn",
//                   customer_approval: true,
//                   surveyor_approval: false,
//                 });
//               } else {
//                 res.status(400).json({
//                   responseCode: 400,
//                   responseMessage: "Service Not Found",
//                   responseData: {},
//                 });
//               }
//             });
//         } else if (services[i].type == "services") {
//           is_services = true;
//           await Service.find({ _id: services[i].id, publish: true })
//             .cursor()
//             .eachAsync(async (service) => {
//               var getDiscount = {
//                 package: "",
//                 car: req.body.car,
//                 category: service.type,
//                 service: service.service,
//                 tz: req.headers["tz"],
//                 claim: false,
//               };

//               if (
//                 typeof services[i].quantity != "number" ||
//                 parseInt(services[i].quantity) <= 0
//               ) {
//                 var quantity = 1;
//               } else {
//                 var quantity = parseInt(services[i].quantity);
//               }

//               var quantity = 1;
//               var package = await q.all(
//                 businessFunctions.getPackageDiscount(getDiscount)
//               );
//               var labour_list = service.labour;
//               var labours = [];

//               var discount_eligible_labour_cost = _.sumBy(
//                 labour_list,
//                 (x) => x.amount * quantity
//               );
//               if (labour_list.length > 0) {
//                 for (var l = 0; l < labour_list.length; l++) {
//                   var discount_total = 0;
//                   var total = 0;
//                   var tax_info = await Tax.findOne({
//                     tax: labour_list[l].tax,
//                   }).exec();

//                   var tax = [];
//                   var rate = labour_list[l].rate;
//                   var amount = parseFloat(labour_list[l].amount) * quantity;
//                   var tax_rate = tax_info.detail;
//                   var base = amount;

//                   if (Object.keys(package).length > 0) {
//                     if (package.discount_type == "percent") {
//                       discount = parseFloat(package.discount);
//                       if (!isNaN(discount) && discount > 0) {
//                         var discount_total = amount * (discount / 100);
//                         amount = amount - parseFloat(discount_total.toFixed(2));
//                         if (amount < 0) {
//                           amount = 0;
//                         }
//                       }
//                     } else if (package.discount_type == "fixed") {
//                       discount = parseFloat(package.discount);
//                       if (!isNaN(discount) && discount > 0) {
//                         var discount_total =
//                           (amount / discount_eligible_labour_cost) * discount;
//                         amount = parseFloat(discount_total.toFixed(2));
//                         discount = amount - discount_total;
//                         if (amount < 0) {
//                           amount = 0;
//                         }
//                       }
//                     } else {
//                       discount = parseFloat(package.discount);
//                       if (!isNaN(discount) && discount > 0) {
//                         var discount_total =
//                           (amount / discount_eligible_labour_cost) * discount;
//                         amount = amount - parseFloat(discount_total.toFixed(2));
//                         if (amount < 0) {
//                           amount = 0;
//                         }
//                       }
//                     }
//                   }

//                   if (labour_list[l].amount_is_tax == "inclusive") {
//                     var x = (100 + tax_info.rate) / 100;
//                     var tax_on_amount = amount / x;
//                     if (tax_rate.length > 0) {
//                       for (var r = 0; r < tax_rate.length; r++) {
//                         if (tax_rate[r].rate != tax_info.rate) {
//                           var t = tax_on_amount * (tax_rate[r].rate / 100);
//                           base = base - t;
//                           tax.push({
//                             tax: tax_rate[r].tax,
//                             rate: tax_rate[r].rate,
//                             amount: parseFloat(t.toFixed(2)),
//                           });
//                         } else {
//                           var t = amount - tax_on_amount;
//                           base = base - t;
//                           tax.push({
//                             tax: tax_info.tax,
//                             tax_rate: tax_info.rate,
//                             rate: tax_info.rate,
//                             amount: parseFloat(t.toFixed(2)),
//                           });
//                         }
//                       }

//                       base = base - discount_total;
//                     }
//                     total = total + amount;
//                   }

//                   var tax_details = {
//                     tax: tax_info.tax,
//                     rate: tax_info.rate,
//                     amount: total,
//                     detail: tax,
//                   };

//                   labours.push({
//                     item: labour_list[l].item,
//                     source: labour_list[l].source,
//                     rate: parseFloat(labour_list[l].rate),
//                     quantity: quantity,
//                     base: parseFloat(total.toFixed(2)),
//                     discount: parseFloat(discount_total.toFixed(2)),
//                     amount: total,
//                     customer_dep: parseFloat(labour_list[l].customer_dep),
//                     insurance_dep: parseFloat(labour_list[l].insurance_dep),
//                     tax_amount: parseFloat(
//                       _.sumBy(tax, (x) => x.amount).toFixed(2)
//                     ),
//                     amount_is_tax: labour_list[l].amount_is_tax,
//                     tax: tax_info.tax,
//                     tax_rate: tax_info.rate,
//                     tax_info: tax_details,
//                   });
//                 }
//               }

//               bookingService.push({
//                 service: service.service,
//                 labour: labours,
//                 labour_cost: _.sumBy(labours, (x) => x.amount),
//                 discount: _.sumBy(labours, (x) => x.discount),
//                 parts: service.parts,
//                 part_cost: Math.ceil(service.part_cost),
//                 opening_fitting: service.opening_fitting,
//                 of_cost: Math.ceil(service.of_cost),
//                 exceeded_cost: 0,
//                 mrp: Math.ceil(service.mrp),
//                 cost:
//                   service.part_cost +
//                   _.sumBy(labours, (x) => x.amount) +
//                   service.of_cost,
//                 doorstep: service.doorstep,
//                 unit: service.unit,
//                 quantity: quantity,
//                 part_cost_editable: service.part_cost_editable,
//                 labour_cost_editable: service.labour_cost_editable,
//                 of_cost_editable: service.of_cost_editable,
//                 type: service.type,
//                 source: service.id,
//                 description: service.description,
//                 claim: false,
//                 customer_approval: true,
//                 surveyor_approval: false,
//               });
//             });
//         } else if (services[i].type == "collision") {
//           is_services = true;
//           await Collision.find({ _id: services[i].id, publish: true })
//             .cursor()
//             .eachAsync(async (service) => {
//               var getDiscount = {
//                 package: "",
//                 car: req.body.car,
//                 category: service.type,
//                 service: service.service,
//                 tz: req.headers["tz"],
//                 claim: false,
//               };

//               if (
//                 typeof services[i].quantity != "number" ||
//                 parseInt(services[i].quantity) <= 0
//               ) {
//                 var quantity = 1;
//               } else {
//                 var quantity = parseInt(services[i].quantity);
//               }

//               var package = await q.all(
//                 businessFunctions.getPackageDiscount(getDiscount)
//               );
//               var labour_list = service.labour;
//               var labours = [];

//               var discount_eligible_labour_cost = _.sumBy(
//                 labour_list,
//                 (x) => x.amount * quantity
//               );
//               if (labour_list.length > 0) {
//                 for (var l = 0; l < labour_list.length; l++) {
//                   var discount_total = 0;
//                   var total = 0;
//                   var tax_info = await Tax.findOne({
//                     tax: labour_list[l].tax,
//                   }).exec();

//                   var tax = [];
//                   var rate = labour_list[l].rate;
//                   var amount = parseFloat(labour_list[l].amount) * quantity;
//                   var tax_rate = tax_info.detail;
//                   var base = amount;

//                   if (Object.keys(package).length > 0) {
//                     if (package.discount_type == "percent") {
//                       discount = parseFloat(package.discount);
//                       if (!isNaN(discount) && discount > 0) {
//                         var discount_total = amount * (discount / 100);
//                         amount = amount - parseFloat(discount_total.toFixed(2));
//                         if (amount < 0) {
//                           amount = 0;
//                         }
//                       }
//                     } else if (package.discount_type == "fixed") {
//                       discount = parseFloat(package.discount);
//                       if (!isNaN(discount) && discount > 0) {
//                         var discount_total =
//                           (amount / discount_eligible_labour_cost) * discount;
//                         amount = parseFloat(discount_total.toFixed(2));
//                         discount = amount - discount_total;
//                         if (amount < 0) {
//                           amount = 0;
//                         }
//                       }
//                     } else {
//                       discount = parseFloat(package.discount);
//                       if (!isNaN(discount) && discount > 0) {
//                         var discount_total =
//                           (amount / discount_eligible_labour_cost) * discount;
//                         amount = amount - parseFloat(discount_total.toFixed(2));
//                         if (amount < 0) {
//                           amount = 0;
//                         }
//                       }
//                     }
//                   }

//                   if (labour_list[l].amount_is_tax == "inclusive") {
//                     var x = (100 + tax_info.rate) / 100;
//                     var tax_on_amount = amount / x;
//                     if (tax_rate.length > 0) {
//                       for (var r = 0; r < tax_rate.length; r++) {
//                         if (tax_rate[r].rate != tax_info.rate) {
//                           var t = tax_on_amount * (tax_rate[r].rate / 100);
//                           base = base - t;
//                           tax.push({
//                             tax: tax_rate[r].tax,
//                             rate: tax_rate[r].rate,
//                             amount: parseFloat(t.toFixed(2)),
//                           });
//                         } else {
//                           var t = amount - tax_on_amount;
//                           base = base - t;
//                           tax.push({
//                             tax: tax_info.tax,
//                             tax_rate: tax_info.rate,
//                             rate: tax_info.rate,
//                             amount: parseFloat(t.toFixed(2)),
//                           });
//                         }
//                       }

//                       base = base - discount_total;
//                     }
//                     total = total + amount;
//                   }

//                   var tax_details = {
//                     tax: tax_info.tax,
//                     rate: tax_info.rate,
//                     amount: total,
//                     detail: tax,
//                   };

//                   labours.push({
//                     item: labour_list[l].item,
//                     source: labour_list[l].source,
//                     rate: parseFloat(labour_list[l].rate),
//                     quantity: quantity,
//                     base: parseFloat(total.toFixed(2)),
//                     discount: parseFloat(discount_total.toFixed(2)),
//                     amount: total,
//                     customer_dep: parseFloat(labour_list[l].customer_dep),
//                     insurance_dep: parseFloat(labour_list[l].insurance_dep),
//                     tax_amount: parseFloat(
//                       _.sumBy(tax, (x) => x.amount).toFixed(2)
//                     ),
//                     amount_is_tax: labour_list[l].amount_is_tax,
//                     tax: tax_info.tax,
//                     tax_rate: tax_info.rate,
//                     tax_info: tax_details,
//                   });
//                 }
//               }

//               bookingService.push({
//                 service: service.service,
//                 labour: labours,
//                 labour_cost: _.sumBy(labours, (x) => x.amount),
//                 discount: _.sumBy(labours, (x) => x.discount),
//                 parts: service.parts,
//                 part_cost: Math.ceil(service.part_cost),
//                 opening_fitting: service.opening_fitting,
//                 of_cost: Math.ceil(service.of_cost),
//                 exceeded_cost: 0,
//                 mrp: Math.ceil(service.mrp),
//                 cost:
//                   service.part_cost +
//                   _.sumBy(labours, (x) => x.amount) +
//                   service.of_cost,
//                 doorstep: service.doorstep,
//                 unit: service.unit,
//                 quantity: quantity,
//                 part_cost_editable: service.part_cost_editable,
//                 labour_cost_editable: service.labour_cost_editable,
//                 of_cost_editable: service.of_cost_editable,
//                 type: service.type,
//                 source: service.id,
//                 description: service.description,
//                 claim: false,
//                 customer_approval: true,
//                 surveyor_approval: false,
//               });
//             });
//         } else if (services[i].type == "detailing") {
//           is_services = true;
//           await Detailing.find({ _id: services[i].id, publish: true })
//             .cursor()
//             .eachAsync(async (service) => {
//               var getDiscount = {
//                 package: "",
//                 car: req.body.car,
//                 category: service.type,
//                 service: service.service,
//                 tz: req.headers["tz"],
//                 claim: false,
//               };

//               if (
//                 typeof services[i].quantity != "number" ||
//                 parseInt(services[i].quantity) <= 0
//               ) {
//                 var quantity = 1;
//               } else {
//                 var quantity = parseInt(services[i].quantity);
//               }

//               var package = await q.all(
//                 businessFunctions.getPackageDiscount(getDiscount)
//               );
//               var labour_list = service.labour;
//               var labours = [];

//               var discount_eligible_labour_cost = _.sumBy(
//                 labour_list,
//                 (x) => x.amount * quantity
//               );
//               if (labour_list.length > 0) {
//                 for (var l = 0; l < labour_list.length; l++) {
//                   var discount_total = 0;
//                   var total = 0;
//                   var tax_info = await Tax.findOne({
//                     tax: labour_list[l].tax,
//                   }).exec();

//                   var tax = [];
//                   var rate = labour_list[l].rate;
//                   var amount = parseFloat(labour_list[l].amount) * quantity;
//                   var tax_rate = tax_info.detail;
//                   var base = amount;

//                   if (Object.keys(package).length > 0) {
//                     if (package.discount_type == "percent") {
//                       discount = parseFloat(package.discount);
//                       if (!isNaN(discount) && discount > 0) {
//                         var discount_total = amount * (discount / 100);
//                         amount = amount - parseFloat(discount_total.toFixed(2));
//                         if (amount < 0) {
//                           amount = 0;
//                         }
//                       }
//                     } else if (package.discount_type == "fixed") {
//                       discount = parseFloat(package.discount);
//                       if (!isNaN(discount) && discount > 0) {
//                         var discount_total =
//                           (amount / discount_eligible_labour_cost) * discount;
//                         amount = parseFloat(discount_total.toFixed(2));
//                         discount = amount - discount_total;
//                         if (amount < 0) {
//                           amount = 0;
//                         }
//                       }
//                     } else {
//                       discount = parseFloat(package.discount);
//                       if (!isNaN(discount) && discount > 0) {
//                         var discount_total =
//                           (amount / discount_eligible_labour_cost) * discount;
//                         amount = amount - parseFloat(discount_total.toFixed(2));
//                         if (amount < 0) {
//                           amount = 0;
//                         }
//                       }
//                     }
//                   }

//                   if (labour_list[l].amount_is_tax == "inclusive") {
//                     var x = (100 + tax_info.rate) / 100;
//                     var tax_on_amount = amount / x;
//                     if (tax_rate.length > 0) {
//                       for (var r = 0; r < tax_rate.length; r++) {
//                         if (tax_rate[r].rate != tax_info.rate) {
//                           var t = tax_on_amount * (tax_rate[r].rate / 100);
//                           base = base - t;
//                           tax.push({
//                             tax: tax_rate[r].tax,
//                             rate: tax_rate[r].rate,
//                             amount: parseFloat(t.toFixed(2)),
//                           });
//                         } else {
//                           var t = amount - tax_on_amount;
//                           base = base - t;
//                           tax.push({
//                             tax: tax_info.tax,
//                             tax_rate: tax_info.rate,
//                             rate: tax_info.rate,
//                             amount: parseFloat(t.toFixed(2)),
//                           });
//                         }
//                       }

//                       base = base - discount_total;
//                     }
//                     total = total + amount;
//                   }

//                   var tax_details = {
//                     tax: tax_info.tax,
//                     rate: tax_info.rate,
//                     amount: total,
//                     detail: tax,
//                   };

//                   labours.push({
//                     item: labour_list[l].item,
//                     source: labour_list[l].source,
//                     rate: parseFloat(labour_list[l].rate),
//                     quantity: quantity,
//                     base: parseFloat(total.toFixed(2)),
//                     discount: parseFloat(discount_total.toFixed(2)),
//                     amount: total,
//                     customer_dep: parseFloat(labour_list[l].customer_dep),
//                     insurance_dep: parseFloat(labour_list[l].insurance_dep),
//                     tax_amount: parseFloat(
//                       _.sumBy(tax, (x) => x.amount).toFixed(2)
//                     ),
//                     amount_is_tax: labour_list[l].amount_is_tax,
//                     tax: tax_info.tax,
//                     tax_rate: tax_info.rate,
//                     tax_info: tax_details,
//                   });
//                 }
//               }

//               bookingService.push({
//                 service: service.service,
//                 labour: labours,
//                 labour_cost: _.sumBy(labours, (x) => x.amount),
//                 discount: _.sumBy(labours, (x) => x.discount),
//                 parts: service.parts,
//                 part_cost: Math.ceil(service.part_cost),
//                 opening_fitting: service.opening_fitting,
//                 of_cost: Math.ceil(service.of_cost),
//                 exceeded_cost: 0,
//                 mrp: Math.ceil(service.mrp),
//                 cost:
//                   service.part_cost +
//                   _.sumBy(labours, (x) => x.amount) +
//                   service.of_cost,
//                 doorstep: service.doorstep,
//                 unit: service.unit,
//                 quantity: quantity,
//                 part_cost_editable: service.part_cost_editable,
//                 labour_cost_editable: service.labour_cost_editable,
//                 of_cost_editable: service.of_cost_editable,
//                 type: service.type,
//                 source: service.id,
//                 description: service.description,
//                 claim: false,
//                 customer_approval: true,
//                 surveyor_approval: false,
//               });
//             });
//         } else if (services[i].type == "customization") {
//           is_services = true;
//           await Customization.find({ _id: services[i].id, publish: true })
//             .cursor()
//             .eachAsync(async (service) => {
//               var getDiscount = {
//                 package: "",
//                 car: req.body.car,
//                 category: service.type,
//                 service: service.service,
//                 tz: req.headers["tz"],
//                 claim: false,
//               };

//               if (
//                 typeof services[i].quantity != "number" ||
//                 parseInt(services[i].quantity) <= 0
//               ) {
//                 var quantity = 1;
//               } else {
//                 var quantity = parseInt(services[i].quantity);
//               }

//               var package = await q.all(
//                 businessFunctions.getPackageDiscount(getDiscount)
//               );
//               var labour_list = service.labour;
//               var labours = [];

//               var discount_eligible_labour_cost = _.sumBy(
//                 labour_list,
//                 (x) => x.amount * quantity
//               );
//               if (labour_list.length > 0) {
//                 for (var l = 0; l < labour_list.length; l++) {
//                   var discount_total = 0;
//                   var total = 0;
//                   var tax_info = await Tax.findOne({
//                     tax: labour_list[l].tax,
//                   }).exec();

//                   var tax = [];
//                   var rate = labour_list[l].rate;
//                   var amount = parseFloat(labour_list[l].amount) * quantity;
//                   var tax_rate = tax_info.detail;
//                   var base = amount;

//                   if (Object.keys(package).length > 0) {
//                     if (package.discount_type == "percent") {
//                       discount = parseFloat(package.discount);
//                       if (!isNaN(discount) && discount > 0) {
//                         var discount_total = amount * (discount / 100);
//                         amount = amount - parseFloat(discount_total.toFixed(2));
//                         if (amount < 0) {
//                           amount = 0;
//                         }
//                       }
//                     } else if (package.discount_type == "fixed") {
//                       discount = parseFloat(package.discount);
//                       if (!isNaN(discount) && discount > 0) {
//                         var discount_total =
//                           (amount / discount_eligible_labour_cost) * discount;
//                         amount = parseFloat(discount_total.toFixed(2));
//                         discount = amount - discount_total;
//                         if (amount < 0) {
//                           amount = 0;
//                         }
//                       }
//                     } else {
//                       discount = parseFloat(package.discount);
//                       if (!isNaN(discount) && discount > 0) {
//                         var discount_total =
//                           (amount / discount_eligible_labour_cost) * discount;
//                         amount = amount - parseFloat(discount_total.toFixed(2));
//                         if (amount < 0) {
//                           amount = 0;
//                         }
//                       }
//                     }
//                   }

//                   if (labour_list[l].amount_is_tax == "inclusive") {
//                     var x = (100 + tax_info.rate) / 100;
//                     var tax_on_amount = amount / x;
//                     if (tax_rate.length > 0) {
//                       for (var r = 0; r < tax_rate.length; r++) {
//                         if (tax_rate[r].rate != tax_info.rate) {
//                           var t = tax_on_amount * (tax_rate[r].rate / 100);
//                           base = base - t;
//                           tax.push({
//                             tax: tax_rate[r].tax,
//                             rate: tax_rate[r].rate,
//                             amount: parseFloat(t.toFixed(2)),
//                           });
//                         } else {
//                           var t = amount - tax_on_amount;
//                           base = base - t;
//                           tax.push({
//                             tax: tax_info.tax,
//                             tax_rate: tax_info.rate,
//                             rate: tax_info.rate,
//                             amount: parseFloat(t.toFixed(2)),
//                           });
//                         }
//                       }

//                       base = base - discount_total;
//                     }
//                     total = total + amount;
//                   }

//                   var tax_details = {
//                     tax: tax_info.tax,
//                     rate: tax_info.rate,
//                     amount: total,
//                     detail: tax,
//                   };

//                   labours.push({
//                     item: labour_list[l].item,
//                     source: labour_list[l].source,
//                     rate: parseFloat(labour_list[l].rate),
//                     quantity: quantity,
//                     base: parseFloat(total.toFixed(2)),
//                     discount: parseFloat(discount_total.toFixed(2)),
//                     amount: total,
//                     customer_dep: parseFloat(labour_list[l].customer_dep),
//                     insurance_dep: parseFloat(labour_list[l].insurance_dep),
//                     tax_amount: parseFloat(
//                       _.sumBy(tax, (x) => x.amount).toFixed(2)
//                     ),
//                     amount_is_tax: labour_list[l].amount_is_tax,
//                     tax: tax_info.tax,
//                     tax_rate: tax_info.rate,
//                     tax_info: tax_details,
//                   });
//                 }
//               }

//               bookingService.push({
//                 service: service.service,
//                 labour: labours,
//                 labour_cost: _.sumBy(labours, (x) => x.amount),
//                 discount: _.sumBy(labours, (x) => x.discount),
//                 parts: service.parts,
//                 part_cost: Math.ceil(service.part_cost),
//                 opening_fitting: service.opening_fitting,
//                 of_cost: Math.ceil(service.of_cost),
//                 exceeded_cost: 0,
//                 mrp: Math.ceil(service.mrp),
//                 cost:
//                   service.part_cost +
//                   _.sumBy(labours, (x) => x.amount) +
//                   service.of_cost,
//                 doorstep: service.doorstep,
//                 unit: service.unit,
//                 quantity: quantity,
//                 part_cost_editable: service.part_cost_editable,
//                 labour_cost_editable: service.labour_cost_editable,
//                 of_cost_editable: service.of_cost_editable,
//                 type: service.type,
//                 source: service.id,
//                 description: service.description,
//                 claim: false,
//                 customer_approval: true,
//                 surveyor_approval: false,
//               });
//             });
//         }
//       }

//       var labour_cost = _.sumBy(bookingService, (x) => x.labour_cost);
//       var part_cost = _.sumBy(bookingService, (x) => x.part_cost);
//       var of_cost = _.sumBy(bookingService, (x) => x.of_cost);
//       var discount_total = _.sumBy(bookingService, (x) => x.discount);
//       var additionalDiscount = 0;
//       var estimate_cost = servicesCost;
//       var servicesCost = labour_cost + part_cost + of_cost;
//       var pick_up_charges = 0;
//       var careager_cash = 0;
//       // var paid_total = part_cost + labour_cost + of_cost + pick_up_charges - careager_cash;
//       var paid_total = 0;
//       var total =
//         part_cost +
//         labour_cost +
//         of_cost +
//         discount_total +
//         pick_up_charges +
//         additionalDiscount;

//       var payment = {
//         servicesCost: servicesCost,
//         estimate_cost: servicesCost,
//         careager_cash: careager_cash,
//         additionalDiscount: additionalDiscount,
//         payment_mode: "",
//         payment_status: "Pending",
//         discount_type: "",
//         coupon: "",
//         coupon_type: "",
//         discount: discount_total.toFixed(2),
//         discount_total: discount_total.toFixed(2),
//         // terms: checkVendor.business_info.terms,
//         // pick_up_limit: checkVendor.business_info.pick_up_limit,
//         pick_up_charges: pick_up_charges,
//         part_cost: parseFloat(part_cost.toFixed(2)),
//         labour_cost: parseFloat(labour_cost.toFixed(2)),
//         of_cost: parseFloat(of_cost.toFixed(2)),
//         paid_total: 0,
//         total: parseFloat(total.toFixed(2)),
//         discount_applied: false,
//         transaction_id: "",
//         transaction_date: "",
//         transaction_status: "",
//         transaction_response: "",
//         policy_clause: 0,
//         salvage: 0,
//       };

//       var data = {
//         services: bookingService,
//         payment: payment,
//         "due.due": Math.ceil(paid_total.toFixed(2)),
//         status: "Inactive",
//         created_at: new Date(),
//         updated_at: new Date(),
//         date: new Date(),
//       };

//       await Booking.findOneAndUpdate(
//         { _id: req.body.booking },
//         { $set: data },
//         { new: false },
//         async function (err, doc) {
//           if (!err) {
//           }
//         }
//       );
//       // fun.getCarEagerCash(req.body.booking)
//         var bookingData = await Booking.findOne({ _id: req.body.booking }).exec();
//         var date=bookingData.date
//       res.status(200).json({
//         responseCode: 200,
//         responseMessage: "Requested Services has been added",
//           responseData: {
//               bookingData
//           },
//       });
//     } else {
//       res.status(400).json({
//         responseCode: 400,
//         responseMessage: "Booking Not Found",
//         responseData: {},
//       });
//     }
//   }
// });

router.post('/lead/booking/services/add', async function (req, res) {
    // console.log("Logs body..............................", req.body.status)
    var rules = {
        booking: 'required',
        services: 'required'
    };
    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Error",
            responseData: {
                res: validation.errors.all()
            }
        });
    }
    else {
        if (req.body.package == "") {
            req.body.package = null;
        }

        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        // var user = decoded.user;
        var total = 0;
        // var labourCost = 0;

        var part_cost = 0;
        var is_services = true;
        var doorstep = true;
        var bookingService = [];
        var checkBooking = await Booking.findOne({ _id: req.body.booking, status: { $in: ["Confirmed", "Pending", "Approval", "Inactive", "Approved", "Failed", "JobInitiated"] }, is_services: true }).exec();
        var services = req.body.services
        // var servicesList = req.body.services
        // var services = []
        // for (var s = 0; s < servicesList.length; s++) {
        //     if (servicesList[s].type == "services") {

        //         services.push(await Booking.findOne({ _id: servicesList[s].id }).exec())
        //     } else if (services[s].type == "collision") {
        //         services.push(await Booking.findOne({ _id: servicesList[s].id }).exec())
        //     } else if (services[s].type == "detailing") {
        //         services.push(await Booking.findOne({ _id: servicesList[s].id }).exec())
        //     } else if (services[s].type == "customization") {
        //         services.push(await Booking.findOne({ _id: servicesList[s].id }).exec())
        //     }
        // }



        if (checkBooking) {
            for (var i = 0; i < services.length; i++) {
                var quantity = 1
                if (services[i].type == "package") {
                    await Package.find({ _id: services[i].id }).cursor().eachAsync(async (service) => {
                        if (service) {
                            var tax_info = await Tax.findOne({ tax: "18.0% GST" }).exec();
                            var tax_rate = tax_info.detail;
                            var amount = service.cost;
                            var base = amount;
                            var labour_tax = [];
                            var labours = [];

                            var x = (100 + tax_info.rate) / 100;
                            var tax_on_amount = amount / x;
                            if (tax_rate.length > 0) {
                                for (var r = 0; r < tax_rate.length; r++) {
                                    if (tax_rate[r].rate != tax_info.rate) {
                                        var t = tax_on_amount * (tax_rate[r].rate / 100);
                                        base = base - t
                                        labour_tax.push({
                                            tax: tax_rate[r].tax,
                                            rate: parseFloat(tax_rate[r].rate.toFixed(2)),
                                            amount: parseFloat(t.toFixed(2))
                                        })
                                    }
                                    else {
                                        base = base - t
                                        labour_tax.push({
                                            tax: tax_info.tax, tax_rate: tax_info.rate,
                                            rate: parseFloat(tax_info.rate.toFixed(2)),
                                            amount: parseFloat(tax_on_amount.toFixed(2))
                                        })
                                    }
                                }
                            }

                            labours.push({
                                item: service.name,
                                quantity: 1,
                                rate: parseFloat(service.cost),
                                base: parseFloat(base.toFixed(2)),
                                amount: parseFloat(amount),
                                discount: 0,
                                customer_dep: 100,
                                insurance_dep: 0,
                                amount_is_tax: "inclusive",
                                tax_amount: _.sumBy(labour_tax, x => x.amount),
                                tax: tax_info.tax, tax_rate: tax_info.rate,
                                tax_info: {
                                    tax: tax_info.tax, tax_rate: tax_info.rate,
                                    rate: tax_info.rate,
                                    base: parseFloat(base.toFixed(2)),
                                    detail: labour_tax
                                }
                            })

                            is_services = false;

                            bookingService.push({
                                source: services[i].id,
                                service: service.name,
                                description: service.description,
                                cost: Math.ceil(service.cost),
                                labour_cost: Math.ceil(service.cost),
                                part_cost: 0,
                                of_cost: 0,
                                discount: 0,
                                parts: [],
                                labour: labours,
                                opening_fitting: [],
                                type: "package",
                                customer_approval: true, surveyor_approval: false,
                            });

                            // console.log(bookingService)

                        }
                        else {
                            res.status(400).json({
                                responseCode: 400,
                                responseMessage: "Service Not Found",
                                responseData: {},
                            });
                        }
                    });
                }
                else if (services[i].type == "addOn") {
                    await Package.find({ _id: services[i].id }).cursor().eachAsync(async (service) => {
                        if (service) {
                            var tax_info = await Tax.findOne({ tax: "18.0% GST" }).exec();
                            var tax_rate = tax_info.detail;
                            var amount = service.cost;
                            var base = amount;
                            var labour_tax = [];
                            var labours = [];

                            var x = (100 + tax_info.rate) / 100;
                            var tax_on_amount = amount / x;
                            if (tax_rate.length > 0) {
                                for (var r = 0; r < tax_rate.length; r++) {
                                    if (tax_rate[r].rate != tax_info.rate) {
                                        var t = tax_on_amount * (tax_rate[r].rate / 100);
                                        base = base - t
                                        labour_tax.push({
                                            tax: tax_rate[r].tax,
                                            rate: parseFloat(tax_rate[r].rate.toFixed(2)),
                                            amount: parseFloat(t.toFixed(2))
                                        })
                                    }
                                    else {
                                        base = base - t
                                        labour_tax.push({
                                            tax: tax_info.tax, tax_rate: tax_info.rate,
                                            rate: parseFloat(tax_info.rate.toFixed(2)),
                                            amount: parseFloat(tax_on_amount.toFixed(2))
                                        })
                                    }
                                }
                            }

                            labours.push({
                                item: service.name,
                                quantity: 1,
                                rate: parseFloat(service.cost),
                                base: parseFloat(base.toFixed(2)),
                                amount: parseFloat(amount),
                                discount: 0,
                                customer_dep: 100,
                                insurance_dep: 0,
                                amount_is_tax: "inclusive",
                                tax_amount: _.sumBy(labour_tax, x => x.amount),
                                tax: tax_info.tax, tax_rate: tax_info.rate,
                                tax_info: {
                                    tax: tax_info.tax, tax_rate: tax_info.rate,
                                    rate: tax_info.rate,
                                    base: parseFloat(base.toFixed(2)),
                                    detail: labour_tax
                                }
                            })

                            is_services = true;

                            bookingService.push({
                                source: service._id,
                                service: service.name,
                                description: service.description,
                                cost: Math.ceil(service.cost),
                                labour_cost: Math.ceil(service.cost),
                                part_cost: 0,
                                of_cost: 0,
                                discount: 0,
                                parts: [],
                                labour: labours,
                                opening_fitting: [],
                                type: "addOn",
                                customer_approval: true, surveyor_approval: false,
                            });

                        }
                        else {
                            res.status(400).json({
                                responseCode: 400,
                                responseMessage: "Service Not Found",
                                responseData: {},
                            });
                        }
                    });
                }
                else if (services[i].type == "services") {
                    is_services = true;
                    await Service.find({ _id: services[i].id, publish: true, })
                        .cursor().eachAsync(async (service) => {
                            var getDiscount = {
                                package: '',
                                car: req.body.car,
                                category: service.type,
                                service: service.service,
                                tz: req.headers['tz'],
                                claim: false,
                            };

                            if (typeof services[i].quantity != "number" || parseInt(services[i].quantity) <= 0) {
                                var quantity = 1
                            }
                            else {
                                var quantity = parseInt(services[i].quantity)
                            }

                            var package = await q.all(businessFunctions.getPackageDiscount(getDiscount));
                            var labour_list = service.labour;
                            var labours = [];

                            var discount_eligible_labour_cost = _.sumBy(labour_list, x => x.amount * quantity);
                            if (labour_list.length > 0) {
                                for (var l = 0; l < labour_list.length; l++) {
                                    var discount_total = 0;
                                    var total = 0;
                                    var tax_info = await Tax.findOne({ tax: labour_list[l].tax }).exec();

                                    var tax = [];
                                    var rate = labour_list[l].rate;
                                    var amount = parseFloat(labour_list[l].amount) * quantity;
                                    var tax_rate = tax_info.detail;
                                    var base = amount;

                                    if (Object.keys(package).length > 0) {
                                        if (package.discount_type == "percent") {
                                            discount = parseFloat(package.discount);
                                            if (!isNaN(discount) && discount > 0) {
                                                var discount_total = amount * (discount / 100);
                                                amount = amount - parseFloat(discount_total.toFixed(2))
                                                if (amount < 0) {
                                                    amount = 0
                                                }
                                            }
                                        }
                                        else if (package.discount_type == "fixed") {
                                            discount = parseFloat(package.discount);
                                            if (!isNaN(discount) && discount > 0) {
                                                var discount_total = (amount / discount_eligible_labour_cost) * discount;
                                                amount = parseFloat(discount_total.toFixed(2))
                                                discount = amount - discount_total;
                                                if (amount < 0) {
                                                    amount = 0
                                                }
                                            }
                                        }
                                        else {
                                            discount = parseFloat(package.discount);
                                            if (!isNaN(discount) && discount > 0) {
                                                var discount_total = (amount / discount_eligible_labour_cost) * discount;
                                                amount = amount - parseFloat(discount_total.toFixed(2))
                                                if (amount < 0) {
                                                    amount = 0
                                                }
                                            }
                                        }
                                    }

                                    if (labour_list[l].amount_is_tax == "inclusive") {
                                        var x = (100 + tax_info.rate) / 100;
                                        var tax_on_amount = amount / x;
                                        if (tax_rate.length > 0) {
                                            for (var r = 0; r < tax_rate.length; r++) {
                                                if (tax_rate[r].rate != tax_info.rate) {
                                                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                                                    base = base - t;
                                                    tax.push({
                                                        tax: tax_rate[r].tax,
                                                        rate: tax_rate[r].rate,
                                                        amount: parseFloat(t.toFixed(2))
                                                    });
                                                }
                                                else {
                                                    var t = amount - tax_on_amount;
                                                    base = base - t;
                                                    tax.push({
                                                        tax: tax_info.tax, tax_rate: tax_info.rate,
                                                        rate: tax_info.rate,
                                                        amount: parseFloat(t.toFixed(2))
                                                    });
                                                }
                                            }

                                            base = base - discount_total;
                                        }
                                        total = total + amount;
                                    }

                                    var tax_details = {
                                        tax: tax_info.tax,
                                        rate: tax_info.rate,
                                        amount: total,
                                        detail: tax
                                    }


                                    labours.push({
                                        item: labour_list[l].item,
                                        source: labour_list[l].source,
                                        rate: parseFloat(labour_list[l].rate),
                                        quantity: quantity,
                                        base: parseFloat(total.toFixed(2)),
                                        discount: parseFloat(discount_total.toFixed(2)),
                                        amount: total,
                                        customer_dep: parseFloat(labour_list[l].customer_dep),
                                        insurance_dep: parseFloat(labour_list[l].insurance_dep),
                                        tax_amount: parseFloat(_.sumBy(tax, x => x.amount).toFixed(2)),
                                        amount_is_tax: labour_list[l].amount_is_tax,
                                        tax: tax_info.tax, tax_rate: tax_info.rate,
                                        tax_info: tax_details
                                    });
                                }
                            }

                            bookingService.push({
                                service: service.service,
                                labour: labours,
                                labour_cost: _.sumBy(labours, x => x.amount),
                                discount: _.sumBy(labours, x => x.discount),
                                parts: service.parts,
                                part_cost: Math.ceil(service.part_cost),
                                opening_fitting: service.opening_fitting,
                                of_cost: Math.ceil(service.of_cost),
                                exceeded_cost: 0,
                                mrp: Math.ceil(service.mrp),
                                cost: service.part_cost + _.sumBy(labours, x => x.amount) + service.of_cost,
                                doorstep: service.doorstep,
                                unit: service.unit,
                                quantity: quantity,
                                part_cost_editable: service.part_cost_editable,
                                labour_cost_editable: service.labour_cost_editable,
                                of_cost_editable: service.of_cost_editable,
                                type: service.type,
                                source: service.id,
                                description: service.description,
                                claim: false,
                                customer_approval: true, surveyor_approval: false,
                            });
                        });
                }
                else if (services[i].type == "collision") {
                    is_services = true;
                    await Collision.find({ _id: services[i].id, publish: true, })
                        .cursor().eachAsync(async (service) => {
                            var getDiscount = {
                                package: "",
                                car: req.body.car,
                                category: service.type,
                                service: service.service,
                                tz: req.headers['tz'],
                                claim: false,
                            };

                            if (typeof services[i].quantity != "number" || parseInt(services[i].quantity) <= 0) {
                                var quantity = 1
                            }
                            else {
                                var quantity = parseInt(services[i].quantity)
                            }

                            var package = await q.all(businessFunctions.getPackageDiscount(getDiscount));
                            var labour_list = service.labour;
                            var labours = [];

                            var discount_eligible_labour_cost = _.sumBy(labour_list, x => x.amount * quantity);
                            if (labour_list.length > 0) {
                                for (var l = 0; l < labour_list.length; l++) {
                                    var discount_total = 0;
                                    var total = 0;
                                    var tax_info = await Tax.findOne({ tax: labour_list[l].tax }).exec();

                                    var tax = [];
                                    var rate = labour_list[l].rate;
                                    var amount = parseFloat(labour_list[l].amount) * quantity;
                                    var tax_rate = tax_info.detail;
                                    var base = amount;

                                    if (Object.keys(package).length > 0) {
                                        if (package.discount_type == "percent") {
                                            discount = parseFloat(package.discount);
                                            if (!isNaN(discount) && discount > 0) {
                                                var discount_total = amount * (discount / 100);
                                                amount = amount - parseFloat(discount_total.toFixed(2))
                                                if (amount < 0) {
                                                    amount = 0
                                                }
                                            }
                                        }
                                        else if (package.discount_type == "fixed") {
                                            discount = parseFloat(package.discount);
                                            if (!isNaN(discount) && discount > 0) {
                                                var discount_total = (amount / discount_eligible_labour_cost) * discount;
                                                amount = parseFloat(discount_total.toFixed(2))
                                                discount = amount - discount_total;
                                                if (amount < 0) {
                                                    amount = 0
                                                }
                                            }
                                        }
                                        else {
                                            discount = parseFloat(package.discount);
                                            if (!isNaN(discount) && discount > 0) {
                                                var discount_total = (amount / discount_eligible_labour_cost) * discount;
                                                amount = amount - parseFloat(discount_total.toFixed(2))
                                                if (amount < 0) {
                                                    amount = 0
                                                }
                                            }
                                        }
                                    }

                                    if (labour_list[l].amount_is_tax == "inclusive") {
                                        var x = (100 + tax_info.rate) / 100;
                                        var tax_on_amount = amount / x;
                                        if (tax_rate.length > 0) {
                                            for (var r = 0; r < tax_rate.length; r++) {
                                                if (tax_rate[r].rate != tax_info.rate) {
                                                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                                                    base = base - t;
                                                    tax.push({
                                                        tax: tax_rate[r].tax,
                                                        rate: tax_rate[r].rate,
                                                        amount: parseFloat(t.toFixed(2))
                                                    });
                                                }
                                                else {
                                                    var t = amount - tax_on_amount;
                                                    base = base - t;
                                                    tax.push({
                                                        tax: tax_info.tax, tax_rate: tax_info.rate,
                                                        rate: tax_info.rate,
                                                        amount: parseFloat(t.toFixed(2))
                                                    });
                                                }
                                            }

                                            base = base - discount_total;
                                        }
                                        total = total + amount;
                                    }

                                    var tax_details = {
                                        tax: tax_info.tax,
                                        rate: tax_info.rate,
                                        amount: total,
                                        detail: tax
                                    }


                                    labours.push({
                                        item: labour_list[l].item,
                                        source: labour_list[l].source,
                                        rate: parseFloat(labour_list[l].rate),
                                        quantity: quantity,
                                        base: parseFloat(total.toFixed(2)),
                                        discount: parseFloat(discount_total.toFixed(2)),
                                        amount: total,
                                        customer_dep: parseFloat(labour_list[l].customer_dep),
                                        insurance_dep: parseFloat(labour_list[l].insurance_dep),
                                        tax_amount: parseFloat(_.sumBy(tax, x => x.amount).toFixed(2)),
                                        amount_is_tax: labour_list[l].amount_is_tax,
                                        tax: tax_info.tax, tax_rate: tax_info.rate,
                                        tax_info: tax_details
                                    });
                                }
                            }

                            bookingService.push({
                                service: service.service,
                                labour: labours,
                                labour_cost: _.sumBy(labours, x => x.amount),
                                discount: _.sumBy(labours, x => x.discount),
                                parts: service.parts,
                                part_cost: Math.ceil(service.part_cost),
                                opening_fitting: service.opening_fitting,
                                of_cost: Math.ceil(service.of_cost),
                                exceeded_cost: 0,
                                mrp: Math.ceil(service.mrp),
                                cost: service.part_cost + _.sumBy(labours, x => x.amount) + service.of_cost,
                                doorstep: service.doorstep,
                                unit: service.unit,
                                quantity: quantity,
                                part_cost_editable: service.part_cost_editable,
                                labour_cost_editable: service.labour_cost_editable,
                                of_cost_editable: service.of_cost_editable,
                                type: service.type,
                                source: service.id,
                                description: service.description,
                                claim: false,
                                customer_approval: true, surveyor_approval: false,
                            });
                        });
                }
                else if (services[i].type == "detailing") {
                    is_services = true;
                    await Detailing.find({ _id: services[i].id, publish: true, })
                        .cursor().eachAsync(async (service) => {
                            var getDiscount = {
                                package: "",
                                car: req.body.car,
                                category: service.type,
                                service: service.service,
                                tz: req.headers['tz'],
                                claim: false,
                            };

                            if (typeof services[i].quantity != "number" || parseInt(services[i].quantity) <= 0) {
                                var quantity = 1
                            }
                            else {
                                var quantity = parseInt(services[i].quantity)
                            }

                            var package = await q.all(businessFunctions.getPackageDiscount(getDiscount));
                            var labour_list = service.labour;
                            var labours = [];

                            var discount_eligible_labour_cost = _.sumBy(labour_list, x => x.amount * quantity);
                            if (labour_list.length > 0) {
                                for (var l = 0; l < labour_list.length; l++) {
                                    var discount_total = 0;
                                    var total = 0;
                                    var tax_info = await Tax.findOne({ tax: labour_list[l].tax }).exec();

                                    var tax = [];
                                    var rate = labour_list[l].rate;
                                    var amount = parseFloat(labour_list[l].amount) * quantity;
                                    var tax_rate = tax_info.detail;
                                    var base = amount;

                                    if (Object.keys(package).length > 0) {
                                        if (package.discount_type == "percent") {
                                            discount = parseFloat(package.discount);
                                            if (!isNaN(discount) && discount > 0) {
                                                var discount_total = amount * (discount / 100);
                                                amount = amount - parseFloat(discount_total.toFixed(2))
                                                if (amount < 0) {
                                                    amount = 0
                                                }
                                            }
                                        }
                                        else if (package.discount_type == "fixed") {
                                            discount = parseFloat(package.discount);
                                            if (!isNaN(discount) && discount > 0) {
                                                var discount_total = (amount / discount_eligible_labour_cost) * discount;
                                                amount = parseFloat(discount_total.toFixed(2))
                                                discount = amount - discount_total;
                                                if (amount < 0) {
                                                    amount = 0
                                                }
                                            }
                                        }
                                        else {
                                            discount = parseFloat(package.discount);
                                            if (!isNaN(discount) && discount > 0) {
                                                var discount_total = (amount / discount_eligible_labour_cost) * discount;
                                                amount = amount - parseFloat(discount_total.toFixed(2))
                                                if (amount < 0) {
                                                    amount = 0
                                                }
                                            }
                                        }
                                    }

                                    if (labour_list[l].amount_is_tax == "inclusive") {
                                        var x = (100 + tax_info.rate) / 100;
                                        var tax_on_amount = amount / x;
                                        if (tax_rate.length > 0) {
                                            for (var r = 0; r < tax_rate.length; r++) {
                                                if (tax_rate[r].rate != tax_info.rate) {
                                                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                                                    base = base - t;
                                                    tax.push({
                                                        tax: tax_rate[r].tax,
                                                        rate: tax_rate[r].rate,
                                                        amount: parseFloat(t.toFixed(2))
                                                    });
                                                }
                                                else {
                                                    var t = amount - tax_on_amount;
                                                    base = base - t;
                                                    tax.push({
                                                        tax: tax_info.tax, tax_rate: tax_info.rate,
                                                        rate: tax_info.rate,
                                                        amount: parseFloat(t.toFixed(2))
                                                    });
                                                }
                                            }

                                            base = base - discount_total;
                                        }
                                        total = total + amount;
                                    }

                                    var tax_details = {
                                        tax: tax_info.tax,
                                        rate: tax_info.rate,
                                        amount: total,
                                        detail: tax
                                    }


                                    labours.push({
                                        item: labour_list[l].item,
                                        source: labour_list[l].source,
                                        rate: parseFloat(labour_list[l].rate),
                                        quantity: quantity,
                                        base: parseFloat(total.toFixed(2)),
                                        discount: parseFloat(discount_total.toFixed(2)),
                                        amount: total,
                                        customer_dep: parseFloat(labour_list[l].customer_dep),
                                        insurance_dep: parseFloat(labour_list[l].insurance_dep),
                                        tax_amount: parseFloat(_.sumBy(tax, x => x.amount).toFixed(2)),
                                        amount_is_tax: labour_list[l].amount_is_tax,
                                        tax: tax_info.tax, tax_rate: tax_info.rate,
                                        tax_info: tax_details
                                    });
                                }
                            }

                            bookingService.push({
                                service: service.service,
                                labour: labours,
                                labour_cost: _.sumBy(labours, x => x.amount),
                                discount: _.sumBy(labours, x => x.discount),
                                parts: service.parts,
                                part_cost: Math.ceil(service.part_cost),
                                opening_fitting: service.opening_fitting,
                                of_cost: Math.ceil(service.of_cost),
                                exceeded_cost: 0,
                                mrp: Math.ceil(service.mrp),
                                cost: service.part_cost + _.sumBy(labours, x => x.amount) + service.of_cost,
                                doorstep: service.doorstep,
                                unit: service.unit,
                                quantity: quantity,
                                part_cost_editable: service.part_cost_editable,
                                labour_cost_editable: service.labour_cost_editable,
                                of_cost_editable: service.of_cost_editable,
                                type: service.type,
                                source: service.id,
                                description: service.description,
                                claim: false,
                                customer_approval: true, surveyor_approval: false,
                            });
                        });
                }
                else if (services[i].type == "customization") {
                    is_services = true;
                    await Customization.find({ _id: services[i].id, publish: true, })
                        .cursor().eachAsync(async (service) => {
                            var getDiscount = {
                                package: "",
                                car: req.body.car,
                                category: service.type,
                                service: service.service,
                                tz: req.headers['tz'],
                                claim: false,
                            };

                            if (typeof services[i].quantity != "number" || parseInt(services[i].quantity) <= 0) {
                                var quantity = 1
                            }
                            else {
                                var quantity = parseInt(services[i].quantity)
                            }

                            var package = await q.all(businessFunctions.getPackageDiscount(getDiscount));
                            var labour_list = service.labour;
                            var labours = [];

                            var discount_eligible_labour_cost = _.sumBy(labour_list, x => x.amount * quantity);
                            if (labour_list.length > 0) {
                                for (var l = 0; l < labour_list.length; l++) {
                                    var discount_total = 0;
                                    var total = 0;
                                    var tax_info = await Tax.findOne({ tax: labour_list[l].tax }).exec();

                                    var tax = [];
                                    var rate = labour_list[l].rate;
                                    var amount = parseFloat(labour_list[l].amount) * quantity;
                                    var tax_rate = tax_info.detail;
                                    var base = amount;

                                    if (Object.keys(package).length > 0) {
                                        if (package.discount_type == "percent") {
                                            discount = parseFloat(package.discount);
                                            if (!isNaN(discount) && discount > 0) {
                                                var discount_total = amount * (discount / 100);
                                                amount = amount - parseFloat(discount_total.toFixed(2))
                                                if (amount < 0) {
                                                    amount = 0
                                                }
                                            }
                                        }
                                        else if (package.discount_type == "fixed") {
                                            discount = parseFloat(package.discount);
                                            if (!isNaN(discount) && discount > 0) {
                                                var discount_total = (amount / discount_eligible_labour_cost) * discount;
                                                amount = parseFloat(discount_total.toFixed(2))
                                                discount = amount - discount_total;
                                                if (amount < 0) {
                                                    amount = 0
                                                }
                                            }
                                        }
                                        else {
                                            discount = parseFloat(package.discount);
                                            if (!isNaN(discount) && discount > 0) {
                                                var discount_total = (amount / discount_eligible_labour_cost) * discount;
                                                amount = amount - parseFloat(discount_total.toFixed(2))
                                                if (amount < 0) {
                                                    amount = 0
                                                }
                                            }
                                        }
                                    }

                                    if (labour_list[l].amount_is_tax == "inclusive") {
                                        var x = (100 + tax_info.rate) / 100;
                                        var tax_on_amount = amount / x;
                                        if (tax_rate.length > 0) {
                                            for (var r = 0; r < tax_rate.length; r++) {
                                                if (tax_rate[r].rate != tax_info.rate) {
                                                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                                                    base = base - t;
                                                    tax.push({
                                                        tax: tax_rate[r].tax,
                                                        rate: tax_rate[r].rate,
                                                        amount: parseFloat(t.toFixed(2))
                                                    });
                                                }
                                                else {
                                                    var t = amount - tax_on_amount;
                                                    base = base - t;
                                                    tax.push({
                                                        tax: tax_info.tax, tax_rate: tax_info.rate,
                                                        rate: tax_info.rate,
                                                        amount: parseFloat(t.toFixed(2))
                                                    });
                                                }
                                            }

                                            base = base - discount_total;
                                        }
                                        total = total + amount;
                                    }

                                    var tax_details = {
                                        tax: tax_info.tax,
                                        rate: tax_info.rate,
                                        amount: total,
                                        detail: tax
                                    }


                                    labours.push({
                                        item: labour_list[l].item,
                                        source: labour_list[l].source,
                                        rate: parseFloat(labour_list[l].rate),
                                        quantity: quantity,
                                        base: parseFloat(total.toFixed(2)),
                                        discount: parseFloat(discount_total.toFixed(2)),
                                        amount: total,
                                        customer_dep: parseFloat(labour_list[l].customer_dep),
                                        insurance_dep: parseFloat(labour_list[l].insurance_dep),
                                        tax_amount: parseFloat(_.sumBy(tax, x => x.amount).toFixed(2)),
                                        amount_is_tax: labour_list[l].amount_is_tax,
                                        tax: tax_info.tax, tax_rate: tax_info.rate,
                                        tax_info: tax_details
                                    });
                                }
                            }

                            bookingService.push({
                                service: service.service,
                                labour: labours,
                                labour_cost: _.sumBy(labours, x => x.amount),
                                discount: _.sumBy(labours, x => x.discount),
                                parts: service.parts,
                                part_cost: Math.ceil(service.part_cost),
                                opening_fitting: service.opening_fitting,
                                of_cost: Math.ceil(service.of_cost),
                                exceeded_cost: 0,
                                mrp: Math.ceil(service.mrp),
                                cost: service.part_cost + _.sumBy(labours, x => x.amount) + service.of_cost,
                                doorstep: service.doorstep,
                                unit: service.unit,
                                quantity: quantity,
                                part_cost_editable: service.part_cost_editable,
                                labour_cost_editable: service.labour_cost_editable,
                                of_cost_editable: service.of_cost_editable,
                                type: service.type,
                                source: service.id,
                                description: service.description,
                                claim: false,
                                customer_approval: true, surveyor_approval: false,
                            });
                        });
                }
            }

            var labour_cost = _.sumBy(bookingService, x => x.labour_cost);
            var part_cost = _.sumBy(bookingService, x => x.part_cost);
            var of_cost = _.sumBy(bookingService, x => x.of_cost);
            var discount_total = _.sumBy(bookingService, x => x.discount);
            var additionalDiscount = 0;
            var estimate_cost = servicesCost
            var servicesCost = labour_cost + part_cost + of_cost;
            var pick_up_charges = 0;
            var careager_cash = 0;
            // var paid_total = part_cost + labour_cost + of_cost + pick_up_charges - careager_cash;
            var paid_total = 0;
            var total = part_cost + labour_cost + of_cost + discount_total + pick_up_charges + additionalDiscount;

            var payment = {
                servicesCost: servicesCost,
                estimate_cost: servicesCost,
                careager_cash: careager_cash,
                additionalDiscount: additionalDiscount,
                payment_mode: "",
                payment_status: "Pending",
                discount_type: "",
                coupon: "",
                coupon_type: "",
                discount: discount_total.toFixed(2),
                discount_total: discount_total.toFixed(2),
                // terms: checkVendor.business_info.terms,
                // pick_up_limit: checkVendor.business_info.pick_up_limit,
                pick_up_charges: pick_up_charges,
                part_cost: parseFloat(part_cost.toFixed(2)),
                labour_cost: parseFloat(labour_cost.toFixed(2)),
                of_cost: parseFloat(of_cost.toFixed(2)),
                paid_total: 0,
                total: parseFloat(total.toFixed(2)),
                discount_applied: false,
                transaction_id: "",
                transaction_date: "",
                transaction_status: "",
                transaction_response: "",
                policy_clause: 0,
                salvage: 0,
            };



            var data = {
                services: bookingService,
                payment: payment,
                "due.due": Math.ceil(paid_total.toFixed(2)),
                status: "Inactive",
                created_at: new Date(),
                updated_at: new Date(),
                date: new Date(),
            };

            await Booking.findOneAndUpdate({ _id: req.body.booking }, { $set: data }, { new: false }, async function (err, doc) {
                if (!err) {
                }
            });
            // fun.getCarEagerCash(req.body.booking)
            var bookingData = await Booking.findOne({ _id: req.body.booking }).exec();
            res.status(200).json({
                responseCode: 200,
                responseMessage: "Requested Services has been added",
                responseData: bookingData
            });
        } else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Booking Not Found",
                responseData: {}
            });
        }
    }
});

router.get("/booking/coupon/list", async function (req, res, next) {
  var token = req.headers["x-access-token"];
  var secret = config.secret;
  var decoded = jwt.verify(token, secret);
  var user = decoded.user;
  var data = [];
  var business = req.headers["business"];
  if (req.body.booking) {
    var booking = await Booking.findById(req.body.booking).exec();
    user = booking.user;
  }
  await Coupon.find({ is_product: false, business: business, publish: true })
    .cursor()
    .eachAsync(async (coupon) => {
      if (coupon) {
        var used = await CouponUsed.find({ code: coupon.code, user: user })
          .count()
          .exec();
        if (used < coupon.usage_limit) {
          var serverTime = moment.tz(new Date(), req.headers["tz"]);
          var bar = moment.tz(coupon.expired_at, req.headers["tz"]);
          var baz = bar.diff(serverTime);
          // console.log(baz);
          if (baz > 0) {
            var limit = await CouponUsed.find({ code: coupon.code })
              .count()
              .exec();
            if (limit < coupon.limit) {
              data.push({
                _id: coupon._id,
                id: coupon.id,
                code: coupon.code,
                limit: coupon.limit,
                description: coupon.description,
              });
            }
          }
        }
      }
    });
  res.status(200).json({
    responseCode: 200,
    responseMessage: "Coupons",
    responseData: data,
  });
});

router.get("/booking/time-slot/get", xAccessToken.token, async function (req, res, next) {
    var rules = {
      booking: "required",
    //   date: "required",
    };

    var validation = new Validator(req.query, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Service not mention",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var user = decoded.user;
      var business = req.headers["business"];
      var slots = [];
        var booking = await Booking.findById(req.query.booking).exec();
        var date=booking.date
      if (booking) {
        var business = booking.business;
        var date = new Date(new Date(date).setHours(0, 0, 0, 0));
        var next = new Date(new Date(date).setHours(0, 0, 0, 0));
        next.setDate(date.getDate() + 1);

        var check = await BookingTiming.find({ business: business })
          .count()
          .exec();

        var body = booking.services;
        if (body.length <= 0) {
          body.push({
            type: "services",
          });
        }

        body = _.uniqBy(body, "type");

        var slots = [];

        for (var i = 0; i < body.length; i++) {
          if (body[i].type == "addOn") {
            body[i].type = "services";
          }

          if (check > 0) {
            await BookingTiming.find({
              business: business,
              category: body[i].type,
            })
              .sort({ sort: 1 })
              .cursor()
              .eachAsync(async (timing) => {
                if (timing) {
                  var slot = await Booking.find({
                    time_slot: timing.slot,
                    is_services: true,
                    business: business,
                    date: { $gte: date, $lt: next },
                    services: { $elemMatch: { type: body[i].type } },
                    status: {
                      $nin: [
                        "Inactive",
                        "Rejected",
                        "Cancelled",
                        "Completed",
                        "Closed",
                      ],
                    },
                  })
                    .count()
                    .exec();

                  if (slot < timing.booking_per_slot) {
                    slot = timing.booking_per_slot - slot;
                    slots.push({
                      slot: timing.slot,
                      count: slot,
                      sort: timing.sort,
                      type: timing.category,
                      status: true,
                    });
                  } else {
                    slots.push({
                      slot: timing.slot,
                      count: slot,
                      sort: timing.sort,
                      type: timing.category,
                      status: false,
                    });
                  }
                } else {
                  slots.push({
                    slot: timing.slot,
                    count: slot,
                    sort: timing.sort,
                    type: timing.category,
                    status: false,
                  });
                }
              });
          } else {
            var a = await BookingTiming.find({
              business: null,
              category: body[i].type,
            }).exec();

            await BookingTiming.find({ business: null, category: body[i].type })
              .sort({ sort: 1 })
              .cursor()
              .eachAsync(async (timing) => {
                var slot = await Booking.find({
                  time_slot: timing.slot,
                  is_services: true,
                  business: business,
                  date: { $gte: date, $lt: next },
                  services: { $elemMatch: { type: body[i].type } },
                  status: {
                    $nin: [
                      "Inactive",
                      "Rejected",
                      "Cancelled",
                      "Completed",
                      "Closed",
                    ],
                  },
                })
                  .count()
                  .exec();

                if (slot < timing.booking_per_slot) {
                  slot = timing.booking_per_slot - slot;
                  slots.push({
                    slot: timing.slot,
                    count: slot,
                    sort: timing.sort,
                    type: timing.category,
                    status: true,
                  });
                } else {
                  slots.push({
                    slot: timing.slot,
                    count: slot,
                    sort: timing.sort,
                    type: timing.category,
                    status: false,
                  });
                }
              });
          }
        }

        slots = _.orderBy(slots, "count", "desc");
        slots = _.uniqBy(slots, "slot");
        slots = _.orderBy(slots, "sort", "asc");

        res.status(200).json({
          responseCode: 200,
          responseMessage: "",
          responseData: slots,
        });
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Booking not found",
          responseData: {},
        });
      }
    }
  }
);

// router.post("/lead/booking/checkout/edit",xAccessToken.token, async  (req, res)=> {
//     var rules = {
//       booking: "required",
//     };

//     var validation = new Validator(req.body, rules);

//     if (validation.fails()) {
//       res.status(422).json({
//         responseCode: 422,
//         responseMessage: "Validation Error",
//         responseData: {
//           res: validation.errors.all(),
//         },
//       });
//     } else {
//       var token = req.headers["x-access-token"];
//       var secret = config.secret;
//       var decoded = jwt.verify(token, secret);
//       var user = decoded.user;
//       var business = req.headers["business"];
//       var labour_cost = 0;
//       var part_cost = 0;
//       var of_cost = 0;
//       var due_amount = 0;
//       var totalResult = 0;
//       var bookingService = [];
//       var services_added = "";
//       var logged_remark = "";
//       var lst = "";
//       var labour_log = "";
//       var parts_log = "";
//       var others_log = "";
//       var total_labour_cost = 0;
//       var total_part_cost = 0;

//       var others_log = "";

//       var loggedInDetails = await User.findById(decoded.user).exec();
//       var booking = await Booking.findById(req.body.booking)
//         .populate({ path: "user", select: "name contact_no address _id" })
//         .populate({
//           path: "manager",
//           populate: { path: "user", select: "_id id name contact_no email" },
//         })
//         .populate({ path: "car", select: "registration_no title" })
//         .exec();
//       // var booking = await Booking.findOne({ car: car._id, user: user, status: { $nin: ["Completed", "CompleteWork", "QC", "Closed", "Ready", "Rejected", "Cancelled", "Inactive"] }, is_services: true }).exec();
//       if (booking) {
//         var manager = null;
//         if (booking.manager) {
//           // console.log('in manager 28392');

//           manager = {
//             name: booking.manager.name,
//             _id: booking.manager._id,
//             id: booking.manager.id,
//             contact_no: booking.manager.contact_no,
//             email: booking.manager.email,
//           };
//         }
//         // console.log(" Man" + manager);
//         labour_cost = booking.payment.labour_cost;
//         part_cost = booking.payment.part_cost;
//         if (booking.payment.of_cost) {
//           var of_cost = booking.payment.of_cost;
//         }
//         var services = booking.services;
//         var Index = req.body.index;
//         // console.log("services Length before", services.length)
//         if (req.body.activity == "Remove") {
//           booking.services.splice(Index, 1);
//           // console.log("services Length After", services.length)
//         }

//         for (var i = 0; i < services.length; i++) {
//           var total_labour_cost = 0;
//           var total_part_cost = 0;
//           others_log =
//             "Service Name : " +
//             services[i].service +
//             "( Rate * Quantity = Amount )";
//           var parts_visible = true;
//           var part_tax = [];
//           var labour_tax = [];
//           var fitting_tax = [];
//           var tax_detail = {};
//           if (
//             typeof services[i].quantity != "number" ||
//             parseInt(services[i].quantity) <= 0
//           ) {
//             var quantity = 1;
//           } else {
//             var quantity = parseInt(services[i].quantity);
//           }
//           var quantity = 1;
//           var parts = services[i].parts;
//           var part = [];

//           if (parts.length > 0) {
//             parts_log =
//               parts_log +
//               " \n Service Name : " +
//               services[i].service +
//               "( Rate * Quantity = Amount )";
//             part = parts;
//             for (j = 0; j < part.length; j++) {
//               total_part_cost += part[j].amount;
//               parts_log = parts_log +"\n" + "Part Name :" + part[j].item + " ( " +part[j].rate +" * " +part[j].quantity + " = " +part[j].amount +" )";
//               // console.log("Labour cost Inside" + labour_log)
//             }
//           } else {
//             if (services[i].part_cost > 0) {
//               parts_visible = false;
//               var tax_info = await Tax.findOne({ tax: "0% GST" }).exec();

//               var tax_rate = tax_info.detail;
//               var service = services[i].service;
//               var amount = parseFloat(services[i].part_cost) * quantity;
//               var base = amount;
//               var part_tax = [];

//               var x = (100 + tax_info.rate) / 100;
//               var tax_on_amount = amount / x;

//               if (tax_rate.length > 0) {
//                 for (var r = 0; r < tax_rate.length; r++) {
//                   if (tax_rate[r].rate != tax_info.rate) {
//                     var t = tax_on_amount * (tax_rate[r].rate / 100);
//                     //////////console.log(t)
//                     if (t > 0) {
//                       base = base - t;
//                     } else {
//                       base = base;
//                     }

//                     part_tax.push({
//                       tax: tax_rate[r].tax,
//                       rate: tax_rate[r].rate,
//                       amount: parseFloat(t.toFixed(2)),
//                     });
//                   } else {
//                     /*if(tax_info.rate>0)
//                                     {
//                                         tax_on_amount = parseFloat(tax_on_amount.toFixed(2))
//                                     }
//                                     else
//                                     {
//                                         tax_on_amount = 0;
//                                     }
//                                     part_tax.push({
//                                         tax: tax_info.tax,tax_rate: tax_info.rate,
//                                         rate: tax_info.rate,
//                                         amount: 
//                                     });*/

//                     var t = amount - tax_on_amount;
//                     base = base - t;
//                     part_tax.push({
//                       tax: tax_info.tax,
//                       tax_rate: tax_info.rate,
//                       rate: tax_info.rate,
//                       amount: parseFloat(t.toFixed(2)),
//                     });
//                   }
//                 }
//               }

//               tax_detail = {
//                 tax: tax_info.tax,
//                 tax_rate: tax_info.rate,
//                 rate: tax_info.rate,
//                 base: parseFloat(base.toFixed(2)),
//                 detail: part_tax,
//               };

//               part.push({
//                 item: services[i].service,
//                 source: null,
//                 quantity: quantity,
//                 hsn_sac: "",
//                 part_no: "",
//                 rate: parseFloat(services[i].part_cost),
//                 base: parseFloat(base.toFixed(2)),
//                 amount: parseFloat(amount),
//                 customer_dep: 100,
//                 insurance_dep: 0,
//                 tax_amount: _.sumBy(part_tax, (x) => x.amount),
//                 amount_is_tax: "inclusive",
//                 discount: 0,
//                 issued: false,
//                 tax: tax_info.tax,
//                 tax_rate: tax_info.rate,
//                 tax_info: tax_detail,
//               });
//             } else {
//               part = [];
//             }
//           }

//           var labour = services[i].labour;
//           var labours = [];

//           if (labour.length > 0) {
//             labour_log =
//               labour_log +
//               " \n Service Name : " +
//               services[i].service +
//               "( Rate * Quantity = Amount )";
//             labours = labour;
//             //ABHINAV

//             for (j = 0; j < labours.length; j++) {
//               total_labour_cost += labours[j].amount;
//               labour_log =labour_log +"\n" +"Labour Name :" +labours[j].item +" ( " +labours[j].rate +" * " + labours[j].quantity +" = " +labours[j].amount +" )";
//               // console.log("Labour cost Inside" + labour_log)
//             }
//             // lst = labours.slice(-1).pop();
//             // console.log("Labour cost Outside" + labour_log)
//           } else {
//             if (services[i].labour_cost > 0) {
//               var tax_info = await Tax.findOne({ tax: "18.0% GST" }).exec();
//               var tax_rate = tax_info.detail;
//               var service = services[i].service;
//               var amount = parseFloat(services[i].labour_cost) * quantity;
//               var base = amount;
//               var labour_tax = [];

//               var x = (100 + tax_info.rate) / 100;
//               var tax_on_amount = amount / x;
//               if (tax_rate.length > 0) {
//                 for (var r = 0; r < tax_rate.length; r++) {
//                   if (tax_rate[r].rate != tax_info.rate) {
//                     var t = tax_on_amount * (tax_rate[r].rate / 100);
//                     base = base - t;
//                     labour_tax.push({
//                       tax: tax_rate[r].tax,
//                       rate: parseFloat(tax_rate[r].rate.toFixed(2)),
//                       amount: parseFloat(t.toFixed(2)),
//                     });
//                   } else {
//                     base = base - t;
//                     labour_tax.push({
//                       tax: tax_info.tax,
//                       tax_rate: tax_info.rate,
//                       rate: parseFloat(tax_info.rate.toFixed(2)),
//                       amount: parseFloat(tax_on_amount.toFixed(2)),
//                     });
//                   }
//                 }
//               }

//               labours.push({
//                 item: services[i].service,
//                 quantity: quantity,
//                 rate: parseFloat(services[i].labour_cost),
//                 base: parseFloat(base.toFixed(2)),
//                 amount: parseFloat(amount),
//                 customer_dep: 100,
//                 insurance_dep: 0,
//                 discount: 0,
//                 amount_is_tax: "inclusive",
//                 tax_amount: _.sumBy(labour_tax, (x) => x.amount),
//                 tax: tax_info.tax,
//                 tax_rate: tax_info.rate,
//                 tax_info: {
//                   tax: tax_info.tax,
//                   tax_rate: tax_info.rate,
//                   rate: tax_info.rate,
//                   base: parseFloat(base.toFixed(2)),
//                   detail: labour_tax,
//                 },
//               });
//             }
//           }

//           var opening_fittings = services[i].opening_fitting;
//           var opening_fitting = [];

//           if (opening_fittings.length > 0) {
//             opening_fitting = opening_fittings;
//           } else {
//             if (services[i].of_cost != 0) {
//               var tax_info = await Tax.findOne({ tax: "18.0% GST" }).exec();
//               var tax_rate = tax_info.detail;
//               var service = services[i].service;
//               var amount = parseFloat(services[i].of_cost) * quantity;
//               var base = amount;
//               var fitting_tax = [];

//               var x = (100 + tax_info.rate) / 100;
//               var tax_on_amount = amount / x;
//               if (tax_rate.length > 0) {
//                 for (var r = 0; r < tax_rate.length; r++) {
//                   if (tax_rate[r].rate != tax_info.rate) {
//                     var t = tax_on_amount * (tax_rate[r].rate / 100);
//                     base = base - t;
//                     fitting_tax.push({
//                       tax: tax_rate[r].tax,
//                       rate: tax_rate[r].rate,
//                       amount: parseFloat(t.toFixed(2)),
//                     });
//                   } else {
//                     base = base - t;
//                     fitting_tax.push({
//                       tax: tax_info.tax,
//                       tax_rate: tax_info.rate,
//                       rate: tax_info.rate,
//                       amount: parseFloat(tax_on_amount.toFixed(2)),
//                     });
//                   }
//                 }
//               }

//               opening_fitting.push({
//                 item: services[i].service,
//                 quantity: quantity,
//                 rate: parseFloat(services[i].of_cost),
//                 base: parseFloat(base.toFixed(2)),
//                 discount: 0,
//                 amount: parseFloat(amount),
//                 customer_dep: 100,
//                 insurance_dep: 0,
//                 amount_is_tax: "inclusive",
//                 tax_amount: _.sumBy(fitting_tax, (x) => x.amount),
//                 tax: tax_info.tax,
//                 tax_rate: tax_info.rate,
//                 tax_info: {
//                   tax: tax_info.tax,
//                   tax_rate: tax_info.rate,
//                   rate: tax_info.rate,
//                   base: parseFloat(base.toFixed(2)),
//                   detail: fitting_tax,
//                 },
//               });
//             }
//           }
//           // console.log("Openning Fitting = " + _.sumBy(opening_fitting, x => x.amount))
//           var cost =
//             _.sumBy(part, (x) => x.amount) +
//             _.sumBy(labour, (x) => x.amount) +
//             _.sumBy(opening_fitting, (x) => x.amount);
//           if (services[i].customer_approval == true) {
//             logged_remark =
//               logged_remark +
//               " |--> " +
//               services[i].service +
//               " Rs/-" +
//               cost +
//               " \n ";
//           }

//           services_added =
//             services_added +
//             " |--> " +
//             services[i].service +
//             " Rs/- " +
//             cost +
//             " \n |----> Labour Charges" +
//             total_labour_cost +
//             " \n |----> Parts Charges" +
//             total_part_cost +
//             ") \n |----> Other Charges" +
//             _.sumBy(opening_fitting, (x) => x.amount) +
//             " \n ";

//           bookingService.push({
//             source: services[i].source,
//             service: services[i].service,
//             mileage: services[i].mileage,
//             parts: part,
//             labour: labours,
//             opening_fitting: opening_fitting,
//             hours: services[i].hours,
//             parts_visible: parts_visible,
//             quantity: quantity,
//             discount:
//               _.sumBy(labours, (x) => x.discount) +
//               _.sumBy(part, (x) => x.discount) +
//               _.sumBy(opening_fitting, (x) => x.discount),
//             description: services[i].description,
//             cost:
//               _.sumBy(part, (x) => x.amount) +
//               _.sumBy(labours, (x) => x.amount) +
//               services[i].of_cost,
//             labour_cost: parseFloat(services[i].labour_cost),
//             of_cost: parseFloat(services[i].of_cost),
//             part_cost: parseFloat(services[i].part_cost),
//             exceeded_cost: parseFloat(services[i].exceeded_cost),
//             part_cost_editable: services[i].part_cost_editable,
//             labour_cost_editable: services[i].labour_cost_editable,
//             of_cost_editable: services[i].of_cost_editable,
//             type: services[i].type,
//             sub_category: services[i].sub_category,
//             customer_approval: true,
//             surveyor_approval: true,
//             claim: services[i].claim,
//             custom: services[i].custom,
//           });
//           // console.log("Sub Category inside Array  = " + services[i].sub_category)
//         }

//         // serviceAdd(bookingService, booking._id);
//         var policy_clause = booking.payment.policy_clause;
//         if (req.body.policy_clause >= 0 && req.body.policy_clause != null) {
//           policy_clause = req.body.policy_clause;
//         }

//         var salvage = booking.payment.salvage;
//         if (req.body.salvage >= 0 && req.body.salvage != null) {
//           salvage = req.body.salvage;
//         }

//         var pick_up_charges = booking.payment.pick_up_charges;
//         if (req.body.pick_up_charge >= 0) {
//           pick_up_charges = req.body.pick_up_charge;
//         }
//         var convenience = booking.convenience;
//         if (req.body.convenience) {
//           convenience = req.body.convenience;
//         }
//         var status = booking.status;
//         if (req.body.booking_date) {
//           // status = "Confirmed";
//           date = new Date(req.body.booking_date).toISOString();
//         }
//         if (req.body.status) {
//           status = req.body.status;
//         }
//         var additionalDiscount = 0;
//         if (req.body.additionalDiscount) {
//           additionalDiscount = parseFloat(req.body.additionalDiscount);
//         }
//         var time_slot = booking.time_slot;
//         if (req.body.time_slot) {
//           time_slot = req.body.time_slot;
//         }
//         var address = null;
//         if (req.body.address) {
//           address = req.body.address;
//         }

//         var approved = _.filter(bookingService,(customer_approval) => customer_approval.customer_approval == true);

//         var paid_total = booking.payment.paid_total;
//         var labour_cost = _.sumBy(bookingService, (x) => x.labour_cost);
//         var part_cost = _.sumBy(bookingService, (x) => x.part_cost);
//         var of_cost = _.sumBy(bookingService, (x) => x.of_cost);
//         var discount_total = _.sumBy(bookingService, (x) => x.discount);

//         // var careager_cash =fun ;deductCarEagerCash

//         var careager_cash = booking.payment.careager_cash;
//         if (req.body.careager_cash && status == "Confirmed") {
//           var deducted = await q.all(
//             fun.deductCarEagerCashManual(
//               parseFloat(req.body.careager_cash),
//               booking._id
//             )
//           );
//           // console.log("deducted = " + deducted)
//           if (deducted) {
//             careager_cash = parseFloat(req.body.careager_cash);
//           } else {
//             // console.log("Already deducted max")
//             careager_cash = booking.payment.careager_cash;
//           }
//         }
//         // + discount_total;
//         var servicesCost = labour_cost + part_cost + of_cost;
//         // console.log("28471 = servicesCost = " + servicesCost)
//         // console.log("28472 = discount_total = " + discount_total)
//         // console.log("28473 = pick_up_charges = " + pick_up_charges)
//         // console.log("28471 = additionalDiscount = " + additionalDiscount)
//         // console.log("28471 = careager_cash = " + careager_cash)
//         var payment_total =
//           labour_cost +
//           part_cost +
//           of_cost +
//           discount_total +
//           policy_clause +
//           salvage +
//           pick_up_charges +
//           additionalDiscount;

//         var estimate_cost =
//           labour_cost +
//           part_cost +
//           of_cost +
//           policy_clause +
//           salvage +
//           pick_up_charges -
//           (careager_cash + additionalDiscount);

//         var due_amount =
//           _.sumBy(approved, (x) => x.labour_cost) +
//           _.sumBy(approved, (x) => x.part_cost) +
//           _.sumBy(approved, (x) => x.of_cost) +
//           policy_clause +
//           salvage +
//           pick_up_charges -
//           (paid_total + careager_cash + additionalDiscount);

//         var due = {
//           due: Math.ceil(due_amount.toFixed(2)),
//         };

//         var payment = {
//           total: parseFloat(payment_total.toFixed(2)),
//           estimate_cost: parseFloat(estimate_cost.toFixed(2)),
//           careager_cash: careager_cash,
//           of_cost: of_cost,
//           labour_cost: labour_cost,
//           part_cost: part_cost,
//           payment_mode: booking.payment.payment_mode,
//           payment_status: booking.payment.payment_status,
//           discount_type: booking.payment.discount_type,
//           coupon: booking.payment.coupon,
//           coupon_type: booking.payment.coupon_type,
//           discount_by: booking.payment.discount_by,
//           discount: booking.payment.discount,
//           discount_total: discount_total,
//           additionalDiscount: additionalDiscount,
//           policy_clause: policy_clause,
//           salvage: salvage,
//           servicesCost: servicesCost,
//           terms: booking.payment.terms,
//           due: Math.ceil(due_amount.toFixed(2)),
//           pick_up_limit: booking.payment.pick_up_limit,
//           pick_up_charges: pick_up_charges,
//           paid_total: parseFloat(booking.payment.paid_total),
//           discount_applied: booking.payment.discount_applied,
//           transaction_id: booking.payment.transaction_id,
//           transaction_date: booking.payment.transaction_date,
//           transaction_status: booking.payment.transaction_status,
//           transaction_response: booking.payment.transaction_response,
//         };

//         var date = new Date(req.body.booking_date);
//         // serviceAdd(bookingService, booking._id);
//         //
//         // console.log("Status = " + status)
//         await Booking.findOneAndUpdate(
//           { _id: booking._id },
//           {
//             $set: {
//               status: status,
//               time_slot: time_slot,
//               date: date,
//               services: bookingService,
//               convenience: req.body.convenience,
//               payment: payment,
//               due: due,
//               advance: req.body.advance,
//               address: address,
//               updated_at: new Date(),
//             },
//           },
//           { new: false },
//           async function (err, doc) {
//             if (err) {
//               //////////console.log(err)
//             } else {
//               // serviceAdd(bookingService, booking._id);
//               var activity = {
//                 user: loggedInDetails._id,
//                 name: loggedInDetails.name,
//                 stage: status,
//                 activity: services_added,
//               };

//               fun.bookingLog(booking._id, activity);

//               var activity = {
//                 user: loggedInDetails._id,
//                 name: loggedInDetails.name,
//                 stage: status,
//                 activity: labour_log,
//               };
//               fun.bookingLog(booking._id, activity);
//               var activity = {
//                 user: loggedInDetails._id,
//                 name: loggedInDetails.name,
//                 stage: status,
//                 activity: parts_log,
//               };

//               fun.bookingLog(booking._id, activity);

//               if (logged_remark) {
//                 var activity = {
//                   user: loggedInDetails._id,
//                   name: loggedInDetails.name,
//                   stage: status,
//                   activity: logged_remark,
//                 };

//                 fun.bookingLog(booking._id, activity);
//               }

//               // event.zohoLead(booking._id);

//               var updated = await Booking.findById(booking.id)
//                 .populate({
//                   path: "business",
//                   select:
//                     "name avatar avatar_address contact_no isCarEager uuid business_info whatsAppChannelId",
//                 })
//                 .populate({
//                   path: "user",
//                   select: "name contact_no address _id",
//                 })
//                 .populate({ path: "car", select: "registration_no title" })
//                 .exec();

//               if (status == "Confirmed") {
//                 console.log("Sumit Booking vfdgd");
//                 await whatsAppEvent.bookingWhatsApp(updated._id);
//                 var activity = "Booking";
//                 fun.webNotification(activity, updated);

//                 await whatsAppEvent.newBookingAdvisor(booking._id);
//                 event.bookingStatusMail(booking.user, booking._id, business);
//               }
//               res.status(200).json({
//                 responseCode: 200,
//                 responseMessage: "Booking Saved...",
//                 responseData: updated,
//               });
//             }
//           }
//         );
//       } else {
//         res.status(400).json({
//           responseCode: 400,
//           responseMessage: "Booking not found",
//           responseData: {},
//         });
//       }
//     }
//   }
// );

router.post("/lead/booking/checkout/edit", xAccessToken.token,async function (req, res) {
  console.log("Body= ",JSON.stringify(req.body))
    var rules = {
      booking: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Validation Error",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var user = decoded.user;
      var business = req.headers["business"];
      var labour_cost = 0;
      var part_cost = 0;
      var of_cost = 0;
      var due_amount = 0;
      var totalResult = 0;
      var bookingService = [];
      var services_added = "";
      var logged_remark = "";
      var lst = "";
      var labour_log = "";
      var parts_log = "";
      var others_log = "";
      var total_labour_cost = 0;
      var total_part_cost = 0;

      var others_log = "";

      var loggedInDetails = await User.findById(decoded.user).exec();
      var booking = await Booking.findById(req.body.booking)
        .populate({ path: "user", select: "name contact_no address _id" })
        .populate({
          path: "manager",
          populate: { path: "user", select: "_id id name contact_no email" },
        })
        .populate({ path: "car", select: "registration_no title" })
        .exec();
      // var booking = await Booking.findOne({ car: car._id, user: user, status: { $nin: ["Completed", "CompleteWork", "QC", "Closed", "Ready", "Rejected", "Cancelled", "Inactive"] }, is_services: true }).exec();
      if (booking) {
        var manager = null;
        if (booking.manager) {
          // console.log('in manager 28392');

          manager = {
            name: booking.manager.name,
            _id: booking.manager._id,
            id: booking.manager.id,
            contact_no: booking.manager.contact_no,
            email: booking.manager.email,
          };
        }
        // console.log(" Man" + manager);
        labour_cost = booking.payment.labour_cost;
        part_cost = booking.payment.part_cost;
        if (booking.payment.of_cost) {
          var of_cost = booking.payment.of_cost;
        }
        var services = booking.services;

        for (var i = 0; i < services.length; i++) {
          var total_labour_cost = 0;
          var total_part_cost = 0;
          others_log =
            "Service Name : " +
            services[i].service +
            "( Rate * Quantity = Amount )";
          var parts_visible = true;
          var part_tax = [];
          var labour_tax = [];
          var fitting_tax = [];
          var tax_detail = {};
          if (
            typeof services[i].quantity != "number" ||
            parseInt(services[i].quantity) <= 0
          ) {
            var quantity = 1;
          } else {
            var quantity = parseInt(services[i].quantity);
          }
          var parts = services[i].parts;
          var part = [];

          if (parts.length > 0) {
            parts_log =
              parts_log +
              " \n Service Name : " +
              services[i].service +
              "( Rate * Quantity = Amount )";
            part = parts;
            for (j = 0; j < part.length; j++) {
              total_part_cost += part[j].amount;
              parts_log =
                parts_log +
                "\n" +
                "Part Name :" +
                part[j].item +
                " ( " +
                part[j].rate +
                " * " +
                part[j].quantity +
                " = " +
                part[j].amount +
                " )";
              // console.log("Labour cost Inside" + labour_log)
            }
          } else {
            if (services[i].part_cost > 0) {
              parts_visible = false;
              var tax_info = await Tax.findOne({ tax: "0% GST" }).exec();

              var tax_rate = tax_info.detail;
              var service = services[i].service;
              var amount = parseFloat(services[i].part_cost) * quantity;
              var base = amount;
              var part_tax = [];

              var x = (100 + tax_info.rate) / 100;
              var tax_on_amount = amount / x;

              if (tax_rate.length > 0) {
                for (var r = 0; r < tax_rate.length; r++) {
                  if (tax_rate[r].rate != tax_info.rate) {
                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                    // console.log(t)
                    if (t > 0) {
                      base = base - t;
                    } else {
                      base = base;
                    }

                    part_tax.push({
                      tax: tax_rate[r].tax,
                      rate: tax_rate[r].rate,
                      amount: parseFloat(t.toFixed(2)),
                    });
                  } else {
                    /*if(tax_info.rate>0)
                                    {
                                        tax_on_amount = parseFloat(tax_on_amount.toFixed(2))
                                    }
                                    else
                                    {
                                        tax_on_amount = 0;
                                    }
                                    part_tax.push({
                                        tax: tax_info.tax,tax_rate: tax_info.rate,
                                        rate: tax_info.rate,
                                        amount: 
                                    });*/

                    var t = amount - tax_on_amount;
                    base = base - t;
                    part_tax.push({
                      tax: tax_info.tax,
                      tax_rate: tax_info.rate,
                      rate: tax_info.rate,
                      amount: parseFloat(t.toFixed(2)),
                    });
                  }
                }
              }

              tax_detail = {
                tax: tax_info.tax,
                tax_rate: tax_info.rate,
                rate: tax_info.rate,
                base: parseFloat(base.toFixed(2)),
                detail: part_tax,
              };

              part.push({
                item: services[i].service,
                source: null,
                quantity: quantity,
                hsn_sac: "",
                part_no: "",
                rate: parseFloat(services[i].part_cost),
                base: parseFloat(base.toFixed(2)),
                amount: parseFloat(amount),
                customer_dep: 100,
                insurance_dep: 0,
                tax_amount: _.sumBy(part_tax, (x) => x.amount),
                amount_is_tax: "inclusive",
                discount: 0,
                issued: false,
                tax: tax_info.tax,
                tax_rate: tax_info.rate,
                tax_info: tax_detail,
              });
            } else {
              part = [];
            }
          }

          var labour = services[i].labour;
          var labours = [];

          if (labour.length > 0) {
            labour_log =
              labour_log +
              " \n Service Name : " +
              services[i].service +
              "( Rate * Quantity = Amount )";
            labours = labour;
            //ABHINAV

            for (j = 0; j < labours.length; j++) {
              total_labour_cost += labours[j].amount;
              labour_log =
                labour_log +
                "\n" +
                "Labour Name :" +
                labours[j].item +
                " ( " +
                labours[j].rate +
                " * " +
                labours[j].quantity +
                " = " +
                labours[j].amount +
                " )";
              // console.log("Labour cost Inside" + labour_log)
            }
            // lst = labours.slice(-1).pop();
            // console.log("Labour cost Outside" + labour_log)
          } else {
            if (services[i].labour_cost > 0) {
              var tax_info = await Tax.findOne({ tax: "18.0% GST" }).exec();
              var tax_rate = tax_info.detail;
              var service = services[i].service;
              var amount = parseFloat(services[i].labour_cost) * quantity;
              var base = amount;
              var labour_tax = [];

              var x = (100 + tax_info.rate) / 100;
              var tax_on_amount = amount / x;
              if (tax_rate.length > 0) {
                for (var r = 0; r < tax_rate.length; r++) {
                  if (tax_rate[r].rate != tax_info.rate) {
                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                    base = base - t;
                    labour_tax.push({
                      tax: tax_rate[r].tax,
                      rate: parseFloat(tax_rate[r].rate.toFixed(2)),
                      amount: parseFloat(t.toFixed(2)),
                    });
                  } else {
                    base = base - t;
                    labour_tax.push({
                      tax: tax_info.tax,
                      tax_rate: tax_info.rate,
                      rate: parseFloat(tax_info.rate.toFixed(2)),
                      amount: parseFloat(tax_on_amount.toFixed(2)),
                    });
                  }
                }
              }

              labours.push({
                item: services[i].service,
                quantity: quantity,
                rate: parseFloat(services[i].labour_cost),
                base: parseFloat(base.toFixed(2)),
                amount: parseFloat(amount),
                customer_dep: 100,
                insurance_dep: 0,
                discount: 0,
                amount_is_tax: "inclusive",
                tax_amount: _.sumBy(labour_tax, (x) => x.amount),
                tax: tax_info.tax,
                tax_rate: tax_info.rate,
                tax_info: {
                  tax: tax_info.tax,
                  tax_rate: tax_info.rate,
                  rate: tax_info.rate,
                  base: parseFloat(base.toFixed(2)),
                  detail: labour_tax,
                },
              });
            }
          }

          var opening_fittings = services[i].opening_fitting;
          var opening_fitting = [];

          if (opening_fittings.length > 0) {
            opening_fitting = opening_fittings;
          } else {
            if (services[i].of_cost != 0) {
              var tax_info = await Tax.findOne({ tax: "18.0% GST" }).exec();
              var tax_rate = tax_info.detail;
              var service = services[i].service;
              var amount = parseFloat(services[i].of_cost) * quantity;
              var base = amount;
              var fitting_tax = [];

              var x = (100 + tax_info.rate) / 100;
              var tax_on_amount = amount / x;
              if (tax_rate.length > 0) {
                for (var r = 0; r < tax_rate.length; r++) {
                  if (tax_rate[r].rate != tax_info.rate) {
                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                    base = base - t;
                    fitting_tax.push({
                      tax: tax_rate[r].tax,
                      rate: tax_rate[r].rate,
                      amount: parseFloat(t.toFixed(2)),
                    });
                  } else {
                    base = base - t;
                    fitting_tax.push({
                      tax: tax_info.tax,
                      tax_rate: tax_info.rate,
                      rate: tax_info.rate,
                      amount: parseFloat(tax_on_amount.toFixed(2)),
                    });
                  }
                }
              }

              opening_fitting.push({
                item: services[i].service,
                quantity: quantity,
                rate: parseFloat(services[i].of_cost),
                base: parseFloat(base.toFixed(2)),
                discount: 0,
                amount: parseFloat(amount),
                customer_dep: 100,
                insurance_dep: 0,
                amount_is_tax: "inclusive",
                tax_amount: _.sumBy(fitting_tax, (x) => x.amount),
                tax: tax_info.tax,
                tax_rate: tax_info.rate,
                tax_info: {
                  tax: tax_info.tax,
                  tax_rate: tax_info.rate,
                  rate: tax_info.rate,
                  base: parseFloat(base.toFixed(2)),
                  detail: fitting_tax,
                },
              });
            }
          }
          // console.log("Openning Fitting = " + _.sumBy(opening_fitting, x => x.amount))
          var cost =
            _.sumBy(part, (x) => x.amount) +
            _.sumBy(labour, (x) => x.amount) +
            _.sumBy(opening_fitting, (x) => x.amount);
          if (services[i].customer_approval == true) {
            logged_remark =
              logged_remark +
              " |--> " +
              services[i].service +
              " Rs/-" +
              cost +
              " \n ";
          }

          services_added =
            services_added +
            " |--> " +
            services[i].service +
            " Rs/- " +
            cost +
            " \n |----> Labour Charges" +
            total_labour_cost +
            " \n |----> Parts Charges" +
            total_part_cost +
            ") \n |----> Other Charges" +
            _.sumBy(opening_fitting, (x) => x.amount) +
            " \n ";

          bookingService.push({
            source: services[i].source,
            service: services[i].service,
            mileage: services[i].mileage,
            parts: part,
            labour: labours,
            opening_fitting: opening_fitting,
            hours: services[i].hours,
            parts_visible: parts_visible,
            quantity: quantity,
            discount:
              _.sumBy(labours, (x) => x.discount) +
              _.sumBy(part, (x) => x.discount) +
              _.sumBy(opening_fitting, (x) => x.discount),
            description: services[i].description,
            cost:
              _.sumBy(part, (x) => x.amount) +
              _.sumBy(labours, (x) => x.amount) +
              services[i].of_cost,
            labour_cost: parseFloat(services[i].labour_cost),
            of_cost: parseFloat(services[i].of_cost),
            part_cost: parseFloat(services[i].part_cost),
            exceeded_cost: parseFloat(services[i].exceeded_cost),
            part_cost_editable: services[i].part_cost_editable,
            labour_cost_editable: services[i].labour_cost_editable,
            of_cost_editable: services[i].of_cost_editable,
            type: services[i].type,
            sub_category: services[i].sub_category,
            customer_approval: true,
            surveyor_approval: true,
            claim: services[i].claim,
            custom: services[i].custom,
          });
          // console.log("Sub Category inside Array  = " + services[i].sub_category)
        }

        // serviceAdd(bookingService, booking._id);
        var policy_clause = booking.payment.policy_clause;
        if (req.body.policy_clause >= 0 && req.body.policy_clause != null) {
          policy_clause = req.body.policy_clause;
        }

        var salvage = booking.payment.salvage;
        if (req.body.salvage >= 0 && req.body.salvage != null) {
          salvage = req.body.salvage;
        }

        var pick_up_charges = booking.payment.pick_up_charges;
        if (req.body.pick_up_charge >= 0) {
          pick_up_charges = req.body.pick_up_charge;
        }
        var convenience = booking.convenience;
        if (req.body.convenience) {
          convenience = req.body.convenience;
        }
        var status = booking.status;
        if (req.body.booking_date) {
          // status = "Confirmed";
          date = new Date(req.body.booking_date).toISOString();
        }
        if (req.body.status) {
          status = req.body.status;
        }
        var additionalDiscount = 0;
        if (req.body.additionalDiscount) {
          additionalDiscount = parseFloat(req.body.additionalDiscount);
        }
        var time_slot = booking.time_slot;
        if (req.body.time_slot) {
          time_slot = req.body.time_slot;
        }
        var address = null;
        if (req.body.address) {
          address = req.body.address;
        }

        var approved = _.filter(
          bookingService,
          (customer_approval) => customer_approval.customer_approval == true
        );

        var paid_total = booking.payment.paid_total;
        var labour_cost = _.sumBy(bookingService, (x) => x.labour_cost);
        var part_cost = _.sumBy(bookingService, (x) => x.part_cost);
        var of_cost = _.sumBy(bookingService, (x) => x.of_cost);
        var discount_total = _.sumBy(bookingService, (x) => x.discount);

        // var careager_cash =fun ;deductCarEagerCash

        var careager_cash = booking.payment.careager_cash;
        if (req.body.careager_cash && status == "Confirmed") {
          var deducted = await q.all(
            fun.deductCarEagerCashManual(
              parseFloat(req.body.careager_cash),
              booking._id
            )
          );
          // console.log("deducted = " + deducted)
          if (deducted) {
            careager_cash = parseFloat(req.body.careager_cash);
          } else {
            // console.log("Already deducted max")
            careager_cash = booking.payment.careager_cash;
          }
        }
        // + discount_total;
        var servicesCost = labour_cost + part_cost + of_cost;
        // console.log("28471 = servicesCost = " + servicesCost)
        // console.log("28472 = discount_total = " + discount_total)
        // console.log("28473 = pick_up_charges = " + pick_up_charges)
        // console.log("28471 = additionalDiscount = " + additionalDiscount)
        // console.log("28471 = careager_cash = " + careager_cash)
        var payment_total =
          labour_cost +
          part_cost +
          of_cost +
          discount_total +
          policy_clause +
          salvage +
          pick_up_charges +
          additionalDiscount;

        var estimate_cost =
          labour_cost +
          part_cost +
          of_cost +
          policy_clause +
          salvage +
          pick_up_charges -
          (careager_cash + additionalDiscount);

        var due_amount =
          _.sumBy(approved, (x) => x.labour_cost) +
          _.sumBy(approved, (x) => x.part_cost) +
          _.sumBy(approved, (x) => x.of_cost) +
          policy_clause +
          salvage +
          pick_up_charges -
          (paid_total + careager_cash + additionalDiscount);

        var due = {
          due: Math.ceil(due_amount.toFixed(2)),
        };

        var payment = {
          total: parseFloat(payment_total.toFixed(2)),
          estimate_cost: parseFloat(estimate_cost.toFixed(2)),
          careager_cash: careager_cash,
          of_cost: of_cost,
          labour_cost: labour_cost,
          part_cost: part_cost,
          payment_mode: booking.payment.payment_mode,
          payment_status: booking.payment.payment_status,
          discount_type: booking.payment.discount_type,
          coupon: booking.payment.coupon,
          coupon_type: booking.payment.coupon_type,
          discount_by: booking.payment.discount_by,
          discount: booking.payment.discount,
          discount_total: discount_total,
          additionalDiscount: additionalDiscount,
          policy_clause: policy_clause,
          salvage: salvage,
          servicesCost: servicesCost,
          terms: booking.payment.terms,
          due: Math.ceil(due_amount.toFixed(2)),
          pick_up_limit: booking.payment.pick_up_limit,
          pick_up_charges: pick_up_charges,
          paid_total: parseFloat(booking.payment.paid_total),
          discount_applied: booking.payment.discount_applied,
          transaction_id: booking.payment.transaction_id,
          transaction_date: booking.payment.transaction_date,
          transaction_status: booking.payment.transaction_status,
          transaction_response: booking.payment.transaction_response,
        };

        var date = new Date(req.body.booking_date);
        console.log("Date = " + date);
        console.log("time_slot = " + time_slot);
        date.setUTCHours(15);
        if (req.body.time_slot == "10:30 AM - 12:30 PM") {
          date.setUTCHours(06, 30, 00); //12:30
          date.setUTCHours(07); //12:30
          // date.setUTCMinutes(30)
        } else if (req.body.time_slot == "12:30 PM - 2:30 PM") {
          // date.setUTCHours(08, 30, 00)
          date.setUTCHours(09);
          // date.setUTCMinutes(30)
        } else if (req.body.time_slot == "2:30 PM - 4:30 PM") {
          // date.setUTCHours(10, 30, 00)
          date.setUTCHours(11);
          // date.setUTCMinutes(30)
        } else if (req.body.time_slot == "4:30 PM - 6:30 PM") {
          // date.setUTCHours(12, 30, 00)
          date.setUTCHours(13);
          // date.setUTCMinutes(30)
        }
        console.log("Date = " + date);

        await Booking.findOneAndUpdate(
          { _id: booking._id },
          {
            $set: {
              status: status,
              time_slot: time_slot,
              date: date,
              services: bookingService,
              convenience: req.body.convenience,
              payment: payment,
              due: due,
              advance: req.body.advance,
              address: address,
              updated_at: new Date(),
            },
          },
          { new: false },
          async function (err, doc) {
            if (err) {
              // console.log(err)
            } else {
              event.zohoLead(booking._id);
              // serviceAdd(bookingService, booking._id);
              var activity = {
                user: loggedInDetails._id,
                name: loggedInDetails.name,
                stage: status,
                activity: services_added,
              };

              fun.bookingLog(booking._id, activity);

              var activity = {
                user: loggedInDetails._id,
                name: loggedInDetails.name,
                stage: status,
                activity: labour_log,
              };
              fun.bookingLog(booking._id, activity);
              var activity = {
                user: loggedInDetails._id,
                name: loggedInDetails.name,
                stage: status,
                activity: parts_log,
              };

              fun.bookingLog(booking._id, activity);

              if (logged_remark) {
                var activity = {
                  user: loggedInDetails._id,
                  name: loggedInDetails.name,
                  stage: status,
                  activity: logged_remark,
                };

                fun.bookingLog(booking._id, activity);
              }

              // event.zohoLead(booking._id);

              var updated = await Booking.findById(booking.id)
                .populate({
                  path: "business",
                  select:
                    "name avatar avatar_address contact_no isCarEager uuid business_info whatsAppChannelId",
                })
                .populate({
                  path: "user",
                  select: "name contact_no address _id",
                })
                .populate({ path: "car", select: "registration_no title" })
                .exec();

              if (status == "Confirmed") {
                // console.log("Sumit Booking vfdgd");
                await whatsAppEvent.bookingWhatsApp(updated._id);
                var activity = "Booking";
                fun.webNotification(activity, updated);

                await whatsAppEvent.newBookingAdvisor(booking._id);
                event.bookingStatusMail(booking.user, booking._id, business);
              }
              res.status(200).json({
                responseCode: 200,
                responseMessage: "Booking Saved...",
                responseData: updated,
              });
            }
          }
        );
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Booking not found",
          responseData: {},
        });
      }
    }
  }
);

router.get(
  "/bookings/get",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers["business"];
    var bookings = [];
    var filters = [];
    var totalResult = 0;

    var role = await Management.findOne({
      user: user,
      business: business,
    }).exec();

    // console.log('role of the user...', role.role)

    var date = new Date();
    var to = moment(date, "YYYY-MM-DD").subtract(1, "days");

    var thumbnail = [];

    var specification = {};
    specification["$lookup"] = {
      from: "User",
      localField: "user",
      foreignField: "_id",
      as: "user",
    };
    filters.push(specification);

    var specification = {};
    specification["$unwind"] = {
      path: "$user",
      preserveNullAndEmptyArrays: false,
    };
    filters.push(specification);

    var specification = {};
    specification["$lookup"] = {
      from: "Car",
      localField: "car",
      foreignField: "_id",
      as: "car",
    };
    filters.push(specification);

    var specification = {};
    specification["$lookup"] = {
      from: "User",
      localField: "advisor",
      foreignField: "_id",
      as: "advisor",
    };
    filters.push(specification);

    var specification = {};
    specification["$unwind"] = {
      path: "$advisor",
      preserveNullAndEmptyArrays: false,
    };
    filters.push(specification);

    var page = 0;

    if (req.query.page == undefined) {
      page = 0;
    } else {
      page = req.query.page;
    }

    var page = Math.max(0, parseInt(page));

    // if (role.role == "Service Advisor") {
    //     var specification = {};
    //     // specification['advisor._id'] = mongoose.Types.ObjectId(role.user);
    //     specification['$match'] = {
    //         "advisor": mongoose.Types.ObjectId(role.user),

    //     }
    //     filters.push(specification);
    // }

    var queries = new Object();
    var sortBy = new Object();

    if (req.query.query) {
      var filters = [];
      var specification = {};
      specification["$lookup"] = {
        from: "User",
        localField: "user",
        foreignField: "_id",
        as: "user",
      };
      filters.push(specification);

      var specification = {};
      specification["$unwind"] = {
        path: "$user",
        preserveNullAndEmptyArrays: false,
      };
      filters.push(specification);

      var specification = {};
      specification["$lookup"] = {
        from: "Car",
        localField: "car",
        foreignField: "_id",
        as: "car",
      };
      filters.push(specification);

      var specification = {};
      specification["$lookup"] = {
        from: "User",
        localField: "advisor",
        foreignField: "_id",
        as: "advisor",
      };
      filters.push(specification);

      var specification = {};
      specification["$unwind"] = {
        path: "$advisor",
        preserveNullAndEmptyArrays: false,
      };
      filters.push(specification);

      var page = 0;

      if (req.query.page == undefined) {
        page = 0;
      } else {
        page = req.query.page;
      }

      var page = Math.max(0, parseInt(page));

      if (role.role == "Service Advisor") {
        var specification = {};
        specification["$match"] = {
          "advisor._id": mongoose.Types.ObjectId(role.user),
        };
        filters.push(specification);
      }
      //Abhinav New Role
      else if (role.role == "cr_assignee") {
        var specification = {};
        specification["$match"] = {
          "cr_assignee._id": mongoose.Types.ObjectId(role.user),
        };
        filters.push(specification);
      }
      //END
      req.query.query = req.query.query.replace(
        /([.?*+^$[\]\\(){}|-])/g,
        "\\$1"
      );
      var specification = {};
      specification["$match"] = {
        business: mongoose.Types.ObjectId(business),
        $or: [
          { status: { $regex: req.query.query, $options: "i" } },
          { booking_no: { $eq: req.query.query } },
          { "user.name": { $regex: req.query.query, $options: "i" } },
          { "user.contact_no": { $regex: req.query.query, $options: "i" } },
          { "car.title": { $regex: req.query.query, $options: "i" } },
          { "car.registration_no": { $regex: req.query.query, $options: "i" } },
          { "advisor.name": { $regex: req.query.query, $options: "i" } },
          { "advisor.contact_no": { $regex: req.query.query, $options: "i" } },
          {
            "insurance_info.insurance_company": {
              $regex: req.query.query,
              $options: "i",
            },
          },
          {
            logs: {
              $elemMatch: {
                status: { $regex: req.query.query, $options: "i" },
              },
            },
          },
          {
            services: {
              $elemMatch: {
                service: { $regex: req.query.query, $options: "i" },
              },
            },
          },
          {
            services: {
              $elemMatch: {
                parts: {
                  $elemMatch: {
                    item: { $regex: req.query.query, $options: "i" },
                  },
                },
              },
            },
          },
          {
            services: {
              $elemMatch: {
                parts: {
                  $elemMatch: {
                    part_no: { $regex: req.query.query, $options: "i" },
                  },
                },
              },
            },
          },
        ],
      };
      filters.push(specification);

      var specification = {};
      specification["$sort"] = {
        updated_at: -1,
      };
      filters.push(specification);

      totalResult = await Booking.aggregate(filters);

      var specification = {};
      specification["$skip"] = config.perPage * page;
      filters.push(specification);

      var specification = {};
      specification["$limit"] = config.perPage;
      filters.push(specification);

      await Booking.aggregate(filters)
        .allowDiskUse(true)
        .cursor({ batchSize: 10 })
        .exec()
        .eachAsync(async function (booking) {
          if (booking.car.length > 0) {
            var car = {
              title: booking.car[0]._automaker + " " + booking.car[0]._model,
              _id: booking.car[0]._id,
              id: booking.car[0].id,
              rc_address: booking.car[0].rc_address,
              ic_address: booking.car[0].ic_address,
              ic: booking.car[0].ic,
              rc: booking.car[0].rc,
              registration_no: booking.car[0].registration_no,
            };
          } else {
            var car = {
              title: "",
              _id: null,
              id: null,
              rc_address: "",
              ic_address: "",
              ic: "",
              rc: "",
              registration_no: "",
            };
          }

          var serverTime = moment.tz(new Date(), req.headers["tz"]);

          var startDate = moment(serverTime, "DD.MM.YYYY");
          var endDate = moment(booking.delivery_date, "DD.MM.YYYY");

          var days_left = endDate.diff(startDate, "days");

          bookings.push({
            _id: booking._id,
            id: booking._id,
            car: car,
            user: {
              name: booking.user.name,
              _id: booking.user._id,
              id: booking.user.id,
              contact_no: booking.user.contact_no,
              email: booking.user.email,
            },
            manager: null,
            time_left: moment(booking.delivery_date)
              .tz(req.headers["tz"])
              .endOf("day")
              .fromNow(),
            days_left: days_left,
            delivery_date: moment(booking.delivery_date)
              .tz(req.headers["tz"])
              .format("ll"),
            delivery_time: booking.delivery_time,
            status: _.startCase(booking.status),
            _status: booking.status,
            sub_status: booking.sub_status,
            job_no: booking.job_no,
            booking_no: booking.booking_no,
            created_at: moment(booking.created_at)
              .tz(req.headers["tz"])
              .format("lll"),
            updated_at: moment(booking.updated_at)
              .tz(req.headers["tz"])
              .format("lll"),
          });
        });

      res.status(200).json({
        responseCode: 200,
        responseMessage: to,
        responseInfo: {
          //role: role.role,
          //filters: filters,
          totalResult: totalResult.length,
        },
        responseData: bookings,
      });
    } else if (req.query.by == "filter") {
      filters = [];
      if (role.role == "Service Advisor") {
        var specification = {};
        specification["advisor"] = mongoose.Types.ObjectId(role.user);
        // specification['$match'] = {
        //     "advisor._id": mongoose.Types.ObjectId(role.user),

        // }
        filters.push(specification);
      }
      if (req.query.status != "#") {
        if (req.query.status == "All") {
          var date = new Date();
          if (req.query.date) {
            date = new Date(req.query.date);
          }
          var specification = {};
          specification["business"] = mongoose.Types.ObjectId(business);
          specification["status"] = {
            $in: ["JobInitiated", "JobOpen", "Cancelled"],
          };
          // specification['status'] = "Confirmed";
          specification["is_services"] = true;
          specification["created_at"] = { $lte: to };
          // specification['created_at'] = { $lte: date };
          filters.push(specification);
        } else if (req.query.status == "Missed") {
          var specification = {};
          specification["business"] = mongoose.Types.ObjectId(business);

          specification["status"] = { $in: ["JobInitiated", "JobOpen"] };
          specification["status"] = "Confirmed";
          specification["is_services"] = true;
          specification["date"] = { $lte: to };
          //     business: mongoose.Types.ObjectId(business),
          //     status: { $in: ["Approval", "EstimateRequested", "Approved", "Rework", "Pending"] },
          //     updated_at: { "$gt": date, "$lte": to }

          // };
          if (req.query.date && req.query.end_date) {
            date = new Date(req.query.date);
            to = new Date(req.query.end_date);
            // console.log("Date .... ", date, to)
            specification["updated_at"] = { $gt: date, $lte: to };
          }

          filters.push(specification);

          // var specification = {};
          // specification['$match'] = {
          //     business: mongoose.Types.ObjectId(business),
          //     status: { $in: ["JobInitiated", "JobOpen"] },
          //     status: "Confirmed",
          //     is_services: true,
          //     date: { "$lte": to },
          //     // updated_at: { "$gt": date, "$lte": end }

          // };
          // filters.push(specification);
        } else if (req.query.status == "Approval") {
          // if (req.query.date && req.query.end_date) {
          //     date = new Date(req.query.date)
          //     to = new Date(req.query.end_date)
          // console.log("Date .... ", date, to)
          // }

          // var specification = {};
          // specification['$match'] = {
          //     business: mongoose.Types.ObjectId(business)
          //     status: { $in: ["Approval", "EstimateRequested", "Approved", "Rework", "Pending"] },
          //     updated_at: { "$gt": date, "$lte": to }

          // };
          var specification = {};
          specification["business"] = mongoose.Types.ObjectId(business);
          specification["status"] = {
            $in: [
              "Approval",
              "EstimateRequested",
              "Approved",
              "Rework",
              "Pending",
            ],
          };
          //     business: mongoose.Types.ObjectId(business),
          //     status: { $in: ["Approval", "EstimateRequested", "Approved", "Rework", "Pending"] },
          //     updated_at: { "$gt": date, "$lte": to }

          // };
          if (req.query.date && req.query.end_date) {
            date = new Date(req.query.date);
            to = new Date(req.query.end_date);
            // console.log("Date .... ", date, to)
            specification["updated_at"] = { $gt: date, $lte: to };
          }

          filters.push(specification);
          // console.log("Query By Filters", filters)
        } else if (req.query.status == "Cancelled") {
          var specification = {};
          specification["business"] = mongoose.Types.ObjectId(business);
          specification["status"] = { $in: ["Cancelled"] };
          //     business: mongoose.Types.ObjectId(business),
          //     status: { $in: ["Approval", "EstimateRequested", "Approved", "Rework", "Pending"] },
          //     updated_at: { "$gt": date, "$lte": to }

          // };
          if (req.query.date && req.query.end_date) {
            date = new Date(req.query.date);
            to = new Date(req.query.end_date);
            // console.log("Date .... ", date, to)
            specification["created_at"] = { $gt: date, $lte: to };
          }

          filters.push(specification);
          // var specification = {};
          // specification['$match'] = {
          //     business: mongoose.Types.ObjectId(business),
          //     status: { $in: ["Cancelled"] },
          //     // updated_at: { "$gt": date, "$lte": end }

          // };
          // filters.push(specification);
        } else {
          var specification = {};
          specification["business"] = mongoose.Types.ObjectId(business);
          specification["status"] = { $in: ["Confirmed"] };
          //     business: mongoose.Types.ObjectId(business),
          //     status: { $in: ["Approval", "EstimateRequested", "Approved", "Rework", "Pending"] },
          //     updated_at: { "$gt": date, "$lte": to }

          // };
          if (req.query.date && req.query.end_date) {
            date = new Date(req.query.date);
            to = new Date(req.query.end_date);
            // console.log("Date .... ", date, to)
            specification["updated_at"] = { $gt: date, $lte: to };
          }

          filters.push(specification);
          // var specification = {};
          // specification['$match'] = {

          //     business: mongoose.Types.ObjectId(business),
          //     status: { $in: ["Confirmed"] },
          //     // updated_at: { "$gt": date, "$lte": end }
          // };
          // filters.push(specification);
        }

        // var specification = {};
        // specification['$sort'] = {
        //     date: -1,
        //     // updated_at: -1,
        // };
        // filters.push(specification);
      }
      var query = {
        $match: {
          $and: filters,
        },
      };

      // return res.json(query)

      totalResult = await Booking.aggregate([query]);
      // console.log("Totallllll Result  ", totalResult.length)

      // var specification = {};
      // specification['$skip'] = config.perPage * page;
      // filters.push(specification);

      // var specification = {};
      // specification['$limit'] = config.perPage;
      // filters.push(specification);
      var sortQuery = { $sort: { created_at: -1 } };
      await Booking.aggregate([
        query,
        sortQuery,
        { $skip: 10 * page },
        { $limit: 10 },
      ])
        .allowDiskUse(true)
        .cursor({ batchSize: 10 })

        .exec()
        .eachAsync(async function (booking) {
          // console.log(booking.car)
          // var car1 = await Car.findById(booking.car).exec();
          // var user = await User.findById(booking.user).exec();

          // console.log(car1.title)

          // console.log(user.name )
          // if (user) {
          //     var user1 = {
          //         name: user.name,
          //         _id: user._id,
          //         id: user.id,
          //         contact_no: user.contact_no,
          //         email: user.email,
          //     }

          // } else {
          //     var user1 = {
          //         name: "",
          //         _id: "",
          //         id: "",
          //         contact_no: "",
          //         email: "",
          //     }
          // }
          // var advisor = await User.findById(booking.advisor).exec();
          // if (advisor) {
          //     var advisor1 = {
          //         name: advisor.name,
          //         _id: advisor._id,
          //         id: advisor.id,
          //         contact_no: advisor.contact_no,
          //         email: advisor.email,
          //     }

          // } else {
          //     var advisor1 = {
          //         name: "",
          //         _id: "",
          //         id: "",
          //         contact_no: "",
          //         email: "",
          //     }
          // }
          // return// console.log("Crraaaaaaa ", booking.user.name)
          // console.log(booking._id)
          // console.log("cars length ...", car1)

          // if (car1) {
          //     var car = {
          //         title: car1._automaker + " " + car1._model,
          //         _id: car1._id,
          //         id: car1.id,
          //         rc_address: car1.rc_address,
          //         ic_address: car1.ic_address,
          //         ic: car1.ic,
          //         rc: car1.rc,
          //         registration_no: car1.registration_no,
          //     }
          // console.log("Car,,,,,,,,,,,,,,,,,,,,,,,,,", car)
          // }
          // else {
          //     var car = {
          //         title: "",
          //         _id: null,
          //         id: null,
          //         rc_address: "",
          //         ic_address: "",
          //         ic: "",
          //         rc: "",
          //         registration_no: "",
          //     }
          // }

          var car = null;
          var user = null;
          var manager = null;
          var advisor = null;
          var driver = null;
          var technician = null;
          var surveyor = null;

          ///////////////////////
          var AllBookings = await Booking.findById(booking._id)
            .populate({
              path: "manager",
              populate: {
                path: "user",
                select: "_id id name contact_no email",
              },
            })
            .populate({
              path: "advisor",
              populate: {
                path: "user",
                select: "_id id name contact_no email",
              },
            })
            .populate({
              path: "user",
              populate: {
                path: "user",
                select:
                  "_id id name contact_no email account_info business_info",
              },
            })
            .populate({
              path: "business",
              populate: {
                path: "user",
                select:
                  "_id id name contact_no email business_info address bank_details",
              },
            })
            .populate({
              path: "driver",
              populate: {
                path: "user",
                select: "_id id name contact_no email",
              },
            })
            .populate({
              path: "technician",
              populate: {
                path: "user",
                select: "_id id name contact_no email",
              },
            })
            .populate({
              path: "surveyor",
              populate: {
                path: "user",
                select: "_id id name contact_no email",
              },
            })
            .populate({
              path: "car",
              select:
                "_id id title variant registration_no ic rc vin engine_no insurance_info manufacture_year purchased_year",
            })
            .exec();
          if (AllBookings) {
            if (AllBookings.car) {
              car = {
                title: AllBookings.car.title,
                _id: AllBookings.car._id,
                id: AllBookings.car.id,
                vin: AllBookings.car.vin,
                engine_no: AllBookings.car.engine_no,
                registration_no: AllBookings.car.registration_no,
                ic_address: AllBookings.car.ic_address,
                rc_address: AllBookings.car.rc_address,
                variant: AllBookings.car.variant,
                manufacture_year: AllBookings.car.manufacture_year,
                purchased_year: AllBookings.car.purchased_year,
              };
            }

            if (AllBookings.manager) {
              var email = "";
              if (AllBookings.manager.email) {
                email = AllBookings.manager.email;
              }

              manager = {
                name: AllBookings.manager.name,
                _id: AllBookings.manager._id,
                id: AllBookings.manager.id,
                contact_no: AllBookings.manager.contact_no,
                email: email,
              };
            }
            if (AllBookings.user) {
              var email = "";
              if (AllBookings.user.email) {
                email = AllBookings.user.email;
              }

              user = {
                name: AllBookings.user.name,
                _id: AllBookings.user._id,
                id: AllBookings.user.id,
                contact_no: AllBookings.user.contact_no,
                email: email,
              };
            }

            if (AllBookings.advisor) {
              var email = "";
              if (AllBookings.advisor.email) {
                email = AllBookings.advisor.email;
              }
              advisor = {
                name: AllBookings.advisor.name,
                _id: AllBookings.advisor._id,
                id: AllBookings.advisor.id,
                contact_no: AllBookings.advisor.contact_no,
                email: email,
              };
            }

            if (AllBookings.driver) {
              var email = "";
              if (AllBookings.driver.email) {
                email = AllBookings.driver.email;
              }
              driver = {
                name: AllBookings.driver.name,
                _id: AllBookings.driver._id,
                id: AllBookings.driver.id,
                contact_no: AllBookings.driver.contact_no,
                email: email,
              };
            }

            if (AllBookings.technician) {
              var email = "";
              if (AllBookings.technician.email) {
                email = AllBookings.technician.email;
              }

              technician = {
                name: AllBookings.technician.name,
                _id: AllBookings.technician._id,
                id: AllBookings.technician.id,
                contact_no: AllBookings.technician.contact_no,
                email: email,
              };
            }

            if (AllBookings.surveyor) {
              var email = "";
              if (AllBookings.surveyor.email) {
                email = AllBookings.surveyor.email;
              }

              surveyor = {
                name: AllBookings.surveyor.name,
                _id: AllBookings.surveyor._id,
                id: AllBookings.surveyor.id,
                contact_no: AllBookings.surveyor.contact_no,
                email: email,
              };
            }
          }
          ///////////////////////
          var serverTime = moment.tz(new Date(), req.headers["tz"]);

          var startDate = moment(serverTime, "DD.MM.YYYY");
          var endDate = moment(booking.delivery_date, "DD.MM.YYYY");

          var days_left = endDate.diff(startDate, "days");

          bookings.push({
            _id: booking._id,
            id: booking._id,
            car: car,
            // user: user1,
            // advisor: advisor1,
            advisor: advisor,
            manager: manager,
            manager: manager,
            driver: driver,
            technician: technician,
            surveyor: surveyor,
            manager: null,
            time_left: moment(booking.delivery_date)
              .tz(req.headers["tz"])
              .endOf("day")
              .fromNow(),
            days_left: days_left,
            delivery_date: moment(booking.delivery_date)
              .tz(req.headers["tz"])
              .format("ll"),
            delivery_time: booking.delivery_time,
            status: _.startCase(booking.status),
            _status: booking.status,
            sub_status: booking.sub_status,
            job_no: booking.job_no,
            booking_no: booking.booking_no,
            created_at: moment(booking.created_at)
              .tz(req.headers["tz"])
              .format("lll"),
            updated_at: moment(booking.updated_at)
              .tz(req.headers["tz"])
              .format("lll"),
          });
        });

      res.status(200).json({
        responseCode: 200,
        responseMessage: to,
        responseInfo: {
          //role: role.role,
          //filters: filters,
          totalResult: totalResult.length,
        },
        responseData: bookings,
      });
    } else {
      filters = [];
      if (role.role == "Service Advisor") {
        var specification = {};
        specification["advisor"] = mongoose.Types.ObjectId(role.user);
        // specification['$match'] = {
        //     "advisor._id": mongoose.Types.ObjectId(role.user),

        // }
        filters.push(specification);
      }
      if (req.query.status != "#") {
        if (req.query.status == "Missed") {
          var specification = {};
          specification["business"] = mongoose.Types.ObjectId(business);

          specification["status"] = { $in: ["Confirmed"] };
          // specification['status'] = "Confirmed";
          specification["is_services"] = true;
          // specification['date'] = { $lte: to }
          // console.log("  TO Date Mixed  =  " + to)
          var date_missed = new Date();
          var todayTo = new Date(
            date_missed.getFullYear(),
            date.getMonth(),
            date.getDate() + 1
          );
          var todayfrom = new Date(
            date_missed.getFullYear(),
            date.getMonth(),
            date.getDate() - 1
          );
          // { $lt: todayTo, $gt: todayfrom }
          // console.log("Missed date is less than to " + to)
          // console.log("todayTo = = " + todayTo)
          // console.log("todayfrom = = " + todayfrom)

          to = new Date();
          // console.log("tO NEW date = " + to)
          // specification['date'] = { $lt: todayTo, $gt: todayfrom }
          specification["date"] = { $lt: date_missed };
          // specification['date'] = { $lt: to }
          // console.log
          //     business: mongoose.Types.ObjectId(business),
          //     status: { $in: ["Approval", "EstimateRequested", "Approved", "Rework", "Pending"] },
          //     updated_at: { "$gt": date, "$lte": to }

          // };
          if (req.query.date && req.query.end_date) {
            date = new Date(req.query.date);
            to = new Date(req.query.end_date);
            // console.log("Date .... ", date, to)
            specification["updated_at"] = { $gt: date, $lte: to };
          }

          filters.push(specification);

          // var specification = {};
          // specification['$match'] = {
          //     business: mongoose.Types.ObjectId(business),
          //     status: { $in: ["JobInitiated", "JobOpen"] },
          //     status: "Confirmed",
          //     is_services: true,
          //     date: { "$lte": to },
          //     // updated_at: { "$gt": date, "$lte": end }

          // };
          // filters.push(specification);
        } else if (req.query.status == "Approval") {
          // console.log("Approval")

          var specification = {};
          specification["business"] = mongoose.Types.ObjectId(business);
          specification["status"] = { $in: ["Approval", "Approved", "Rework"] };

          if (req.query.date && req.query.end_date) {
            date = new Date(req.query.date);
            to = new Date(req.query.end_date);
            // console.log("Date .... ", date, to)
            specification["updated_at"] = { $gt: date, $lte: to };
          }

          filters.push(specification);
          // console.log("Query By Filters", filters)
        } else if (req.query.status == "Estimated") {
          // console.log("Approval")
          var specification = {};
          specification["business"] = mongoose.Types.ObjectId(business);
          specification["status"] = { $in: ["EstimateRequested"] };
          if (req.query.date && req.query.end_date) {
            date = new Date(req.query.date);
            to = new Date(req.query.end_date);
            // console.log("Date .... ", date, to)
            specification["updated_at"] = { $gt: date, $lte: to };
          }

          filters.push(specification);
          // console.log("Query By Filters", filters)
        } else if (req.query.status == "Pending") {
          // console.log("Pending ")
          var specification = {};
          specification["business"] = mongoose.Types.ObjectId(business);
          specification["status"] = { $in: ["Pending"] };
          if (req.query.date && req.query.end_date) {
            date = new Date(req.query.date);
            to = new Date(req.query.end_date);
            // console.log("Date .... ", date, to)
            specification["updated_at"] = { $gt: date, $lte: to };
          }

          filters.push(specification);
          // console.log("Query By Filters", filters)
        } else if (req.query.status == "Confirmed") {
          // console.log("Confirmed ")
          var specification = {};
          specification["business"] = mongoose.Types.ObjectId(business);
          specification["status"] = { $in: ["Confirmed"] };
          var newDate = new Date();
          var todayfrom = new Date(
            newDate.getFullYear(),
            date.getMonth(),
            date.getDate() - 1
          );
          var todayTo = new Date(
            newDate.getFullYear(),
            date.getMonth(),
            date.getDate() + 1
          );
          specification["date"] = { $gt: todayfrom };

          // new Date(date_missed.getFullYear(), date.getMonth(), date.getDate() + 1);
          if (req.query.date && req.query.end_date) {
            date = new Date(req.query.date);
            to = new Date(req.query.end_date);
            // console.log("Date .... ", date, to)
            specification["updated_at"] = { $gt: date, $lte: to };
          }
          filters.push(specification);
          // console.log("Query By Filters", filters)
        } else if (req.query.status == "Upcoming") {
          // console.log("upcoming ")
          var specification = {};
          specification["business"] = mongoose.Types.ObjectId(business);
          specification["status"] = { $in: ["Confirmed"] };
          specification["date"] = { $gt: new Date() };
          if (req.query.date && req.query.end_date) {
            date = new Date(req.query.date);
            to = new Date(req.query.end_date);
            // console.log("Date .... ", date, to)
            specification["updated_at"] = { $gt: date, $lte: to };
          }

          filters.push(specification);
          // console.log("Query By Filters", filters)
        } else if (req.query.status == "Cancelled") {
          // console.log("Cancelled")
          var specification = {};
          specification["business"] = mongoose.Types.ObjectId(business);
          specification["status"] = { $in: ["Cancelled"] };

          if (req.query.date && req.query.end_date) {
            date = new Date(req.query.date);
            to = new Date(req.query.end_date);
            // console.log("Date .... ", date, to)
            specification["created_at"] = { $gt: date, $lte: to };
          }

          filters.push(specification);
        } else if (req.query.status == "Converted") {
          // console.log("Converted ")

          var jobsStatus = [
            "JobOpen",
            "In-Process",
            "CompleteWork",
            "QC",
            "StoreApproval",
            "Ready",
            "Completed",
            "Closed",
          ];
          var specification = {};
          specification["business"] = mongoose.Types.ObjectId(business);
          specification["status"] = { $in: jobsStatus };
          // specification['status'] = { $nin: ["Rejected", "Cancelled", "Inactive", "EstimateRequested", "Lost"] }
          // specification['status'] = { $nin: ["Rejected", "Cancelled", "Inactive"] }
          specification["converted"] = true;
          // specification['date'] = { "$gt": new Date() }
          if (req.query.date && req.query.end_date) {
            date = new Date(req.query.date);
            to = new Date(req.query.end_date);
            // console.log(date + "   = Date .... ", date, to)
            // specification['updated_at'] = { "$gt": date, "$lte": to };
            specification["date"] = { $gt: date, $lte: to };
          }

          filters.push(specification);
          // var query = {
          //     "$match": {
          //         "$and": filters
          //     }
          // }

          // // return res.json(query)
          // var count = 0
          // var Totalcount = 0

          // totalResult = await Booking.aggregate([query]);
          // console.log("Total Converted = " + totalResult.length)
          // var sortQuery = { $sort: { 'created_at': -1 } };
          // await Booking.aggregate([
          //     query,
          //     sortQuery,
          //     { $skip: 2000 * page },
          //     { $limit: 2000 }
          // ])
          //     .allowDiskUse(true)
          //     .cursor({ batchSize: 2000 })
          //     .exec()
          //     .eachAsync(async function (booking) {
          //         Totalcount = Totalcount + 1
          // console.log(Totalcount + "  ,Booking Id = " + booking._id)
          //         var car = null;
          //         var user = null;
          //         var manager = null;
          //         var advisor = null;
          //         var driver = null;
          //         var technician = null;
          //         var surveyor = null;
          //         var lead = null;

          //         var AllBookings = await Booking.findById(booking._id)
          //             .populate({ path: 'manager', populate: { path: 'user', select: "_id id name contact_no email" } })
          //             .populate({ path: 'advisor', populate: { path: 'user', select: "_id id name contact_no email" } })
          //             .populate({ path: 'user', populate: { path: 'user', select: "_id id name contact_no email account_info business_info" } })
          //             .populate({ path: 'business', populate: { path: 'user', select: "_id id name contact_no email business_info address bank_details" } })
          //             .populate({ path: 'driver', populate: { path: 'user', select: "_id id name contact_no email" } })
          //             .populate({ path: 'technician', populate: { path: 'user', select: "_id id name contact_no email" } })
          //             .populate({ path: 'surveyor', populate: { path: 'user', select: "_id id name contact_no email" } })
          //             .populate({ path: 'lead', select: "_id id name contact_no email source category" })
          //             .populate({ path: 'car', select: '_id id title variant registration_no ic rc vin engine_no insurance_info manufacture_year purchased_year' })
          //             .exec();

          //         if (AllBookings) {
          //             // if(AllBookings.lead.source){
          //             // if (AllBookings.lead.source != 'Booking') { }
          //             if (AllBookings.car) {
          //                 car = {
          //                     title: AllBookings.car.title,
          //                     _id: AllBookings.car._id,
          //                     id: AllBookings.car.id,
          //                     vin: AllBookings.car.vin,
          //                     engine_no: AllBookings.car.engine_no,
          //                     registration_no: AllBookings.car.registration_no,
          //                     ic_address: AllBookings.car.ic_address,
          //                     rc_address: AllBookings.car.rc_address,
          //                     variant: AllBookings.car.variant,
          //                     manufacture_year: AllBookings.car.manufacture_year,
          //                     purchased_year: AllBookings.car.purchased_year,
          //                 }
          //             }

          //             if (AllBookings.manager) {
          //                 var email = "";
          //                 if (AllBookings.manager.email) {
          //                     email = AllBookings.manager.email;
          //                 }

          //                 manager = {
          //                     name: AllBookings.manager.name,
          //                     _id: AllBookings.manager._id,
          //                     id: AllBookings.manager.id,
          //                     contact_no: AllBookings.manager.contact_no,
          //                     email: email
          //                 }
          //             }
          //             if (AllBookings.user) {
          //                 var email = "";
          //                 if (AllBookings.user.email) {
          //                     email = AllBookings.user.email;
          //                 }

          //                 user = {
          //                     name: AllBookings.user.name,
          //                     _id: AllBookings.user._id,
          //                     id: AllBookings.user.id,
          //                     contact_no: AllBookings.user.contact_no,
          //                     email: email
          //                 }
          //             }
          //             if (AllBookings.advisor) {
          //                 var email = "";
          //                 if (AllBookings.advisor.email) {
          //                     email = AllBookings.advisor.email;
          //                 }
          //                 advisor = {
          //                     name: AllBookings.advisor.name,
          //                     _id: AllBookings.advisor._id,
          //                     id: AllBookings.advisor.id,
          //                     contact_no: AllBookings.advisor.contact_no,
          //                     email: email
          //                 }
          //             }
          //             if (booking.lead) {
          //                 lead = {
          //                     name: booking.lead.name,
          //                     _id: booking.lead._id,
          //                     id: booking.lead.id,
          //                     contact_no: booking.lead.contact_no,
          //                     source: booking.lead.source,
          //                 }
          //             }
          //             if (AllBookings.driver) {
          //                 var email = "";
          //                 if (AllBookings.driver.email) {
          //                     email = AllBookings.driver.email;
          //                 }
          //                 driver = {
          //                     name: AllBookings.driver.name,
          //                     _id: AllBookings.driver._id,
          //                     id: AllBookings.driver.id,
          //                     contact_no: AllBookings.driver.contact_no,
          //                     email: email
          //                 }
          //             }
          //             if (AllBookings.technician) {
          //                 var email = "";
          //                 if (AllBookings.technician.email) {
          //                     email = AllBookings.technician.email;
          //                 }
          //                 technician = {
          //                     name: AllBookings.technician.name,
          //                     _id: AllBookings.technician._id,
          //                     id: AllBookings.technician.id,
          //                     contact_no: AllBookings.technician.contact_no,
          //                     email: email
          //                 }
          //             }
          //             if (AllBookings.surveyor) {
          //                 var email = "";
          //                 if (AllBookings.surveyor.email) {
          //                     email = AllBookings.surveyor.email;
          //                 }
          //                 surveyor = {
          //                     name: AllBookings.surveyor.name,
          //                     _id: AllBookings.surveyor._id,
          //                     id: AllBookings.surveyor.id,
          //                     contact_no: AllBookings.surveyor.contact_no,
          //                     email: email
          //                 }
          //             }

          //         }
          //         var serverTime = moment.tz(new Date(), req.headers['tz']);

          //         var startDate = moment(serverTime, "DD.MM.YYYY");
          //         var endDate = moment(booking.delivery_date, "DD.MM.YYYY");

          //         var days_left = endDate.diff(startDate, 'days');
          // console.log("Contact NO :" + user.contact_no)
          //         if (user) {
          // console.log("Contact NO :" + user.contact_no)
          //             var firstLead = await Lead.findOne({ business: business, contact_no: user.contact_no }).sort({ created_at: 1 }).exec();
          //             // return res.json({ abhi: firstLead })
          //             // var leads = firstLead.pop();
          //             // return res.json({ abhi: leads })
          //             if (firstLead) {
          //                 lead = {
          //                     name: firstLead.name,
          //                     // _id: firstLead._id,
          //                     // id: firstLead.id,
          //                     contact_no: firstLead.contact_no,
          //                     source: firstLead.source,
          //                 }
          //             }
          //         } else {
          // console.log("NOt Found   } ")
          //         }
          //         if (AllBookings.lead) {

          //             if (AllBookings.lead.source != 'Booking' && AllBookings.lead.source != '' && AllBookings.lead.source != 'PSF') {
          //                 // totalResult=
          // console.log(" Lead spource =" + AllBookings.lead.source)
          //                 count = count + 1
          // console.log(count)
          //                 bookings.push({
          //                     _id: booking._id,
          //                     id: booking._id,
          //                     car: car,
          //                     user: user,
          //                     advisor: advisor,
          //                     lead: lead,
          //                     manager: manager,
          //                     manager: manager,
          //                     driver: driver,
          //                     technician: technician,
          //                     surveyor: surveyor,
          //                     time_left: moment(booking.delivery_date).tz(req.headers['tz']).endOf('day').fromNow(),
          //                     days_left: days_left,
          //                     delivery_date: moment(booking.delivery_date).tz(req.headers['tz']).format('ll'),
          //                     delivery_time: booking.delivery_time,
          //                     status: _.startCase(booking.status),
          //                     _status: booking.status,
          //                     sub_status: booking.sub_status,
          //                     job_no: booking.job_no,
          //                     booking_no: booking.booking_no,
          //                     created_at: moment(booking.created_at).tz(req.headers['tz']).format('lll'),
          //                     updated_at: moment(booking.updated_at).tz(req.headers['tz']).format('lll'),
          //                 });
          // console.log("End One")
          //             } else {
          // console.log("Data Walk-in" + AllBookings.lead.contact_no)
          //             }

          //         }
          //     });

          // return res.status(200).json({
          //     responseCode: 200,
          //     responseMessage: to,
          //     category: req.query.status,
          //     responseInfo: {
          //         //role: role.role,
          //         //filters: filters,
          //         query: query,
          //         // totalResult: totalResult.length
          //         totalResult: count
          //     },
          //     responseData: bookings,
          // });
          // console.log("Query By Filters", filters)
        } else {
          // console.log("NO Condition matched")
          var specification = {};
          specification["business"] = mongoose.Types.ObjectId(business);
          specification["status"] = { $in: ["Confirmed"] };
          if (req.query.date && req.query.end_date) {
            date = new Date(req.query.date);
            to = new Date(req.query.end_date);
            // console.log("Date .... ", date, to)
            specification["updated_at"] = { $gt: date, $lte: to };
          }
          filters.push(specification);
        }
      }
      var query = {
        $match: {
          $and: filters,
        },
      };

      totalResult = await Booking.aggregate([query]);
      // console.log("Totallllll Result  ", totalResult.length)

      // var specification = {};
      // specification['$skip'] = config.perPage * page;
      // filters.push(specification);

      // var specification = {};
      // specification['$limit'] = config.perPage;
      // filters.push(specification);
      var sortQuery = { $sort: { created_at: -1 } };
      await Booking.aggregate([
        query,
        sortQuery,
        { $skip: 10 * page },
        { $limit: 10 },
      ])
        .allowDiskUse(true)
        .cursor({ batchSize: 10 })
        .exec()
        .eachAsync(async function (booking) {
          var car = null;
          var user = null;
          var manager = null;
          var advisor = null;
          var driver = null;
          var technician = null;
          var surveyor = null;
          var lead = null;
          // console.log("Booking Id = " + booking._id)
          // if (booking.lead) {
          var AllBookings = await Booking.findById(booking._id)
            .populate({
              path: "manager",
              populate: {
                path: "user",
                select: "_id id name contact_no email",
              },
            })
            .populate({
              path: "advisor",
              populate: {
                path: "user",
                select: "_id id name contact_no email",
              },
            })
            .populate({
              path: "user",
              populate: {
                path: "user",
                select:
                  "_id id name contact_no email account_info business_info",
              },
            })
            .populate({
              path: "business",
              populate: {
                path: "user",
                select:
                  "_id id name contact_no email business_info address bank_details",
              },
            })
            .populate({
              path: "driver",
              populate: {
                path: "user",
                select: "_id id name contact_no email",
              },
            })
            .populate({
              path: "technician",
              populate: {
                path: "user",
                select: "_id id name contact_no email",
              },
            })
            .populate({
              path: "surveyor",
              populate: {
                path: "user",
                select: "_id id name contact_no email",
              },
            })
            .populate({
              path: "car",
              select:
                "_id id title variant registration_no ic rc vin engine_no insurance_info manufacture_year purchased_year",
            })
            .exec();
          // console.log("Booking End At end " + booking._id)
          // }
          if (AllBookings) {
            if (AllBookings.car) {
              car = {
                title: AllBookings.car.title,
                _id: AllBookings.car._id,
                id: AllBookings.car.id,
                vin: AllBookings.car.vin,
                engine_no: AllBookings.car.engine_no,
                registration_no: AllBookings.car.registration_no,
                ic_address: AllBookings.car.ic_address,
                rc_address: AllBookings.car.rc_address,
                variant: AllBookings.car.variant,
                manufacture_year: AllBookings.car.manufacture_year,
                purchased_year: AllBookings.car.purchased_year,
              };
            }

            if (AllBookings.manager) {
              var email = "";
              if (AllBookings.manager.email) {
                email = AllBookings.manager.email;
              }

              manager = {
                name: AllBookings.manager.name,
                _id: AllBookings.manager._id,
                id: AllBookings.manager.id,
                contact_no: AllBookings.manager.contact_no,
                email: email,
              };
            }
            if (AllBookings.user) {
              var email = "";
              if (AllBookings.user.email) {
                email = AllBookings.user.email;
              }

              user = {
                name: AllBookings.user.name,
                _id: AllBookings.user._id,
                id: AllBookings.user.id,
                contact_no: AllBookings.user.contact_no,
                email: email,
              };
            }

            if (AllBookings.advisor) {
              var email = "";
              if (AllBookings.advisor.email) {
                email = AllBookings.advisor.email;
              }
              advisor = {
                name: AllBookings.advisor.name,
                _id: AllBookings.advisor._id,
                id: AllBookings.advisor.id,
                contact_no: AllBookings.advisor.contact_no,
                email: email,
              };
            }
            // var lead = await Lead.findById(booking.lead).exec();
            // if (booking.lead) {
            //     lead = {
            //         name: lead.name,
            //         _id: lead._id,
            //         id: lead.id,
            //         contact_no: lead.contact_no,
            //         source: lead.source,
            //     }
            // }
            // if (booking.lead) {
            //     lead = {
            //         name: booking.lead.name,
            //         _id: booking.lead._id,
            //         id: booking.lead.id,
            //         contact_no: booking.lead.contact_no,
            //         source: booking.lead.source,
            //     }
            // }
            if (AllBookings.driver) {
              var email = "";
              if (AllBookings.driver.email) {
                email = AllBookings.driver.email;
              }
              driver = {
                name: AllBookings.driver.name,
                _id: AllBookings.driver._id,
                id: AllBookings.driver.id,
                contact_no: AllBookings.driver.contact_no,
                email: email,
              };
            }
            if (AllBookings.technician) {
              var email = "";
              if (AllBookings.technician.email) {
                email = AllBookings.technician.email;
              }
              technician = {
                name: AllBookings.technician.name,
                _id: AllBookings.technician._id,
                id: AllBookings.technician.id,
                contact_no: AllBookings.technician.contact_no,
                email: email,
              };
            }
            if (AllBookings.surveyor) {
              var email = "";
              if (AllBookings.surveyor.email) {
                email = AllBookings.surveyor.email;
              }
              surveyor = {
                name: AllBookings.surveyor.name,
                _id: AllBookings.surveyor._id,
                id: AllBookings.surveyor.id,
                contact_no: AllBookings.surveyor.contact_no,
                email: email,
              };
            }
          }
          var serverTime = moment.tz(new Date(), req.headers["tz"]);

          var startDate = moment(serverTime, "DD.MM.YYYY");
          var endDate = moment(booking.delivery_date, "DD.MM.YYYY");

          var days_left = endDate.diff(startDate, "days");
          // console.log("Contact NO :" + user.contact_no)
          if (user) {
            // console.log("Contact NO :" + user.contact_no)
            var firstLead = await Lead.findOne({
              business: business,
              contact_no: user.contact_no,
            })
              .sort({ created_at: 1 })
              .exec();
            // return res.json({ abhi: firstLead })
            // var leads = firstLead.pop();
            // return res.json({ abhi: leads })
            if (firstLead) {
              lead = {
                name: firstLead.name,
                _id: firstLead._id,
                id: firstLead.id,
                contact_no: firstLead.contact_no,
                source: firstLead.source,
              };
            }
          } else {
            // console.log("NOt Found   } ")
          }

          // if ()
          bookings.push({
            _id: booking._id,
            id: booking._id,
            car: car,
            user: user,
            advisor: advisor,
            lead: lead,
            manager: manager,
            manager: manager,
            driver: driver,
            technician: technician,
            surveyor: surveyor,
            time_left: moment(booking.delivery_date)
              .tz(req.headers["tz"])
              .endOf("day")
              .fromNow(),
            date: moment(booking.date).tz(req.headers["tz"]).format("ll"),
            days_left: days_left,
            delivery_date: moment(booking.delivery_date)
              .tz(req.headers["tz"])
              .format("ll"),
            delivery_time: booking.delivery_time,
            status: _.startCase(booking.status),
            _status: booking.status,
            sub_status: booking.sub_status,
            job_no: booking.job_no,
            booking_no: booking.booking_no,
            created_at: moment(booking.created_at)
              .tz(req.headers["tz"])
              .format("lll"),
            updated_at: moment(booking.updated_at)
              .tz(req.headers["tz"])
              .format("lll"),
          });
        });

      res.status(200).json({
        responseCode: 200,
        responseMessage: to,
        category: req.query.status,
        responseInfo: {
          //role: role.role,
          //filters: filters,
          query: query,
          totalResult: totalResult.length,
        },
        responseData: bookings,
      });
    }
  }
);

router.post("/owner/add", async function (req, res, next) {
  if (req.body.user) {
    var user = await User.findOne({ _id: req.body.user }).exec();
    if (user) {
      res.status(200).json({
        responseCode: 200,
        responseMessage: "success",
        responseData: {
          _id: user._id,
          id: user._id,
          name: user.name,
          email: user.email,
          user: user._id,
          contact_no: user.contact_no,
        },
      });
    }
  } else {
    var rules = {
      contact_no: "required",
      name: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Mobile No. and name is required",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var checkPhone = await User.find({
        contact_no: req.body.contact_no,
        "account_info.type": "user",
      })
        .count()
        .exec();
      if (checkPhone == 0) {
        var otp = Math.floor(Math.random() * 90000) + 10000;
        req.body.username = shortid.generate();
        req.body.socialite = {};
        req.body.business_info = {};
        req.body.optional_info = {};

        var country = await Country.findOne({
          timezone: { $in: req.headers["tz"] },
        }).exec();
        req.body.address = {
          country: country.countryName,
          timezone: req.headers["tz"],
          location: req.body.location,
        };

        req.body.account_info = {
          type: "user",
          status: "Complete",
          phone_verified: false,
          verified_account: false,
          approved_by_admin: false,
        };

        req.body.geometry = [0, 0];

        req.body.device = [];
        req.body.otp = otp;
        req.body.uuid = uuidv1();
        req.body.business_info = {};

        var firstPart = (Math.random() * 46656) | 0;
        var secondPart = (Math.random() * 46656) | 0;
        firstPart = ("000" + firstPart.toString(36)).slice(-3);
        secondPart = ("000" + secondPart.toString(36)).slice(-3);
        req.body.referral_code =
          firstPart.toUpperCase() + secondPart.toUpperCase();

        User.create(req.body).then(async function (user) {
          // event.signupSMS(user);
          //event.otpSms(user);

          res.status(200).json({
            responseCode: 200,
            responseMessage: "success",
            responseData: {
              _id: user._id,
              id: user._id,
              name: user.name,
              email: user.email,
              user: user._id,
              contact_no: user.contact_no,
            },
          });
        });
      } else {
        res.status(422).json({
          responseCode: 422,
          responseMessage: "Contact no already exist",
          responseData: {},
        });
      }
    }
  }
});

router.post(
  "/booking/discount/add",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      booking: "required",
      type: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Booking is required",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var user = decoded.user;
      var data = new Object();
      var discount = 0;
      var code = "";
      var discount_type = "";
      var discount_by = "";

      var booking = await Booking.findOne({ _id: req.body.booking }).exec();

      if (booking) {
        // console.log("Payment Toatl " + booking.payment.total)
        if (booking.payment.total != 0 && booking.package == null) {
          var bookingService = [];
          var services = booking.services;
          var type = req.body.type;

          if (type == "special") {
            discount_by = req.body.discount_type;
            discount_type = "special";

            var discount_eligible = _.filter(
              booking.services,
              (claim) => claim.claim == false
            );

            var discount_eligible_labour = _.map(discount_eligible, "labour");
            var discount_eligible_labour_cost = 0;

            for (var k = 0; k < discount_eligible_labour.length; k++) {
              discount_eligible_labour_cost =
                _.sumBy(
                  discount_eligible_labour[k],
                  (x) => x.rate * x.quantity
                ) + discount_eligible_labour_cost;
            }

            for (var i = 0; i < services.length; i++) {
              if (services[i].claim == true) {
                bookingService.push(services[i]);
              } else {
                var labour_list = services[i].labour;

                var labours = [];

                if (labour_list) {
                  for (var l = 0; l < labour_list.length; l++) {
                    var discount = req.body.discount;

                    var total = 0;
                    var tax_info = await Tax.findOne({
                      tax: labour_list[l].tax,
                    }).exec();

                    var tax = [];
                    var rate = labour_list[l].rate;
                    var amount =
                      parseFloat(labour_list[l].rate) *
                      parseFloat(labour_list[l].quantity);
                    var tax_rate = tax_info.detail;
                    var base = amount;

                    if (req.body.discount_type == "percent") {
                      discount = parseFloat(discount);
                      if (!isNaN(discount) && discount > 0) {
                        var discount_total = amount * (discount / 100);
                        amount = amount - parseFloat(discount_total.toFixed(2));
                        if (amount < 0) {
                          amount = 0;
                        }
                      }
                    } else {
                      discount = parseFloat(discount);
                      if (!isNaN(discount) && discount > 0) {
                        var discount_total =
                          (amount / discount_eligible_labour_cost) * discount;
                        amount = amount - parseFloat(discount_total.toFixed(2));
                        if (amount < 0) {
                          amount = 0;
                        }
                      }
                    }

                    if (labour_list[l].amount_is_tax == "exclusive") {
                      var tax_on_amount = amount;
                      if (tax_rate.length > 0) {
                        for (var r = 0; r < tax_rate.length; r++) {
                          if (tax_rate[r].rate != tax_info.rate) {
                            var t = tax_on_amount * (tax_rate[r].rate / 100);
                            amount = amount + t;
                            tax.push({
                              tax: tax_rate[r].tax,
                              rate: tax_rate[r].rate,
                              amount: parseFloat(t.toFixed(2)),
                            });
                          } else {
                            var t = tax_on_amount * (tax_rate[r].rate / 100);
                            amount = amount + t;
                            tax.push({
                              tax: tax_info.tax,
                              tax_rate: tax_info.rate,
                              rate: tax_info.rate,
                              amount: parseFloat(t.toFixed(2)),
                            });
                          }
                        }
                      }
                      total = total + amount;
                    }

                    if (labour_list[l].amount_is_tax == "inclusive") {
                      var x = (100 + tax_info.rate) / 100;
                      var tax_on_amount = amount / x;
                      if (tax_rate.length > 0) {
                        for (var r = 0; r < tax_rate.length; r++) {
                          if (tax_rate[r].rate != tax_info.rate) {
                            var t = tax_on_amount * (tax_rate[r].rate / 100);
                            base = base - t;
                            tax.push({
                              tax: tax_rate[r].tax,
                              rate: tax_rate[r].rate,
                              amount: parseFloat(t.toFixed(2)),
                            });
                          } else {
                            var t = amount - tax_on_amount;
                            base = base - t;
                            tax.push({
                              tax: tax_info.tax,
                              tax_rate: tax_info.rate,
                              rate: tax_info.rate,
                              amount: parseFloat(t.toFixed(2)),
                            });
                          }
                        }

                        //base = base - discount_total;
                      }
                      total = total + amount;
                    }

                    var tax_details = {
                      tax: tax_info.tax,
                      rate: tax_info.rate,
                      amount: total,
                      detail: tax,
                    };

                    labours.push({
                      item: labour_list[l].item,
                      source: labour_list[l].source,
                      rate: parseFloat(labour_list[l].rate),
                      quantity: parseFloat(labour_list[l].quantity),
                      base: parseFloat(base.toFixed(2)),
                      discount: parseFloat(discount_total.toFixed(2)),
                      amount: total,
                      customer_dep: parseFloat(labour_list[l].customer_dep),
                      insurance_dep: parseFloat(labour_list[l].insurance_dep),
                      tax_amount: parseFloat(
                        _.sumBy(tax, (x) => x.amount).toFixed(2)
                      ),
                      amount_is_tax: labour_list[l].amount_is_tax,
                      tax: tax_info.tax,
                      tax_rate: tax_info.rate,
                      tax_info: tax_details,
                    });

                    //////////console.log(labours)
                  }

                  bookingService.push({
                    part_cost: services[i].part_cost,
                    labour_cost: _.sumBy(labours, (x) => x.amount),
                    of_cost: services[i].of_cost,
                    exceeded_cost: services[i].exceeded_cost,
                    part_rate: services[i].part_rate,
                    labour_rate: services[i].labour_rate,
                    quantity: services[i].quantity,
                    of_rate: services[i].of_rate,
                    parts: services[i].parts,
                    labour: labours,
                    cost:
                      services[i].part_cost +
                      _.sumBy(labours, (x) => x.amount) +
                      services[i].of_cost,
                    discount:
                      _.sumBy(labours, (x) => x.discount) +
                      _.sumBy(services[i].parts, (x) => x.discount) +
                      _.sumBy(services[i].opening_fitting, (x) => x.discount),
                    opening_fitting: services[i].opening_fitting,
                    part_cost_editable: services[i].part_cost_editable,
                    labour_cost_editable: services[i].part_cost_editable,
                    of_cost_editable: services[i].part_cost_editable,
                    description: services[i].description,
                    service: services[i].service,
                    type: services[i].type,
                    claim: services[i].claim,
                    custom: services[i].custom,
                    customer_approval: services[i].customer_approval,
                    surveyor_approval: services[i].surveyor_approval,
                    source: services[i].source,
                  });
                }
              }
            }
          }

          if (type == "coupon") {
            discount_type = "coupon";
            var discount_eligible = [];
            var coupon_code = req.body.coupon;
            var coupon = await Coupon.findOne({
              code: coupon_code.toUpperCase(),
              is_product: false,
            }).exec();
            var used = await CouponUsed.findOne({
              code: coupon_code.toUpperCase(),
              user: booking.user,
            })
              .count()
              .exec();
            // return res.json({ Coup: coupon, used: used })
            if (coupon) {
              if (used < coupon.usage_limit) {
                var serverTime = moment.tz(new Date(), req.headers["tz"]);
                var bar = moment.tz(coupon.expired_at, req.headers["tz"]);
                var baz = bar.diff(serverTime);
                if (baz > 0) {
                  var limit = await CouponUsed.findOne({
                    code: coupon_code.toUpperCase(),
                  })
                    .count()
                    .exec();
                  if (limit <= coupon.limit) {
                    // console.log("Coupon is Avail " + limit)
                    code = coupon_code.toUpperCase();
                    discount_by = "coupon";
                    // console.log(" 9932 coupon.coupon_on  " + coupon.coupon_on)

                    if (coupon.coupon_on == "total") {
                      if (coupon.for == "category") {
                        var filter = _.filter(
                          booking.services,
                          (claim) => claim.claim == false
                        );
                        discount_eligible = _.filter(
                          filter,
                          (type) => type.type == coupon.label
                        );
                        var discount_eligible_labour = _.map(
                          discount_eligible,
                          "labour"
                        );
                        var discount_eligible_labour_cost = 0;
                        for (
                          var k = 0;
                          k < discount_eligible_labour.length;
                          k++
                        ) {
                          discount_eligible_labour_cost =
                            _.sumBy(
                              discount_eligible_labour[k],
                              (x) => x.rate * x.quantity
                            ) + discount_eligible_labour_cost;
                        }
                      } else if (coupon.for == "specific") {
                        var filter = _.filter(
                          booking.services,
                          (claim) => claim.claim == false
                        );
                        discount_eligible = _.filter(
                          filter,
                          (service) => service.service == coupon.label
                        );
                        var discount_eligible_labour = _.map(
                          discount_eligible,
                          "labour"
                        );
                        var discount_eligible_labour_cost = 0;
                        for (
                          var k = 0;
                          k < discount_eligible_labour.length;
                          k++
                        ) {
                          discount_eligible_labour_cost =
                            _.sumBy(
                              discount_eligible_labour[k],
                              (x) => x.rate * x.quantity
                            ) + discount_eligible_labour_cost;
                        }
                      }
                    } else {
                      // console.log(" 9955 ELSE   " + coupon.for)

                      if (coupon.for == "general") {
                        discount_eligible = _.filter(
                          booking.services,
                          (claim) => claim.claim == false
                        );
                        var discount_eligible_labour = _.map(
                          discount_eligible,
                          "labour"
                        );
                        var discount_eligible_labour_cost = 0;
                        for (
                          var k = 0;
                          k < discount_eligible_labour.length;
                          k++
                        ) {
                          discount_eligible_labour_cost =
                            _.sumBy(
                              discount_eligible_labour[k],
                              (x) => x.rate * x.quantity
                            ) + discount_eligible_labour_cost;
                        }
                      } else if (coupon.for == "category") {
                        var filter = _.filter(
                          booking.services,
                          (claim) => claim.claim == false
                        );
                        discount_eligible = _.filter(
                          filter,
                          (type) => type.type == coupon.label
                        );
                        var discount_eligible_labour = _.map(
                          discount_eligible,
                          "labour"
                        );
                        var discount_eligible_labour_cost = 0;
                        for (
                          var k = 0;
                          k < discount_eligible_labour.length;
                          k++
                        ) {
                          discount_eligible_labour_cost =
                            _.sumBy(
                              discount_eligible_labour[k],
                              (x) => x.rate * x.quantity
                            ) + discount_eligible_labour_cost;
                        }
                      } else if (coupon.for == "specific") {
                        var filter = _.filter(
                          booking.services,
                          (claim) => claim.claim == false
                        );
                        discount_eligible = _.filter(
                          filter,
                          (service) => service.service == coupon.label
                        );
                        var discount_eligible_labour = _.map(
                          discount_eligible,
                          "labour"
                        );
                        var discount_eligible_labour_cost = 0;
                        for (
                          var k = 0;
                          k < discount_eligible_labour.length;
                          k++
                        ) {
                          discount_eligible_labour_cost =
                            _.sumBy(
                              discount_eligible_labour[k],
                              (x) => x.rate * x.quantity
                            ) + discount_eligible_labour_cost;
                        }
                      }
                    }
                  } else {
                    return res.status(400).json({
                      responseCode: 400,
                      responseMessage: "Coupon has been expired",
                      responseData: {},
                    });
                  }
                } else {
                  return res.status(400).json({
                    responseCode: 400,
                    responseMessage: "Coupon has been expired",
                    responseData: {},
                  });
                }
              } else {
                return res.status(400).json({
                  responseCode: 400,
                  responseMessage: "Coupon has been used",
                  responseData: {},
                });
              }
            } else {
              return res.status(400).json({
                responseCode: 400,
                responseMessage: "Coupon Not Exist",
                responseData: {},
              });
            }

            for (var i = 0; i < services.length; i++) {
              if (services[i].claim == true) {
                bookingService.push(services[i]);
              } else {
                var labour_list = services[i].labour;

                var labours = [];

                if (labour_list) {
                  for (var l = 0; l < labour_list.length; l++) {
                    var discount_total = 0;
                    var total = 0;
                    var tax_info = await Tax.findOne({
                      tax: labour_list[l].tax,
                    }).exec();

                    var tax = [];
                    var rate = labour_list[l].rate;
                    var amount =
                      parseFloat(labour_list[l].rate) *
                      parseFloat(labour_list[l].quantity);
                    var tax_rate = tax_info.detail;
                    var base = amount;

                    if (coupon.coupon_on == "total") {
                      if (coupon.for == "category") {
                        if (services[i].type == coupon.label) {
                          if (coupon.type == "percent") {
                            discount_by = "percent";
                            discount = parseFloat(coupon.discount);
                            if (!isNaN(discount) && discount > 0) {
                              discount_total = amount * (discount / 100);
                              amount =
                                amount - parseFloat(discount_total.toFixed(2));
                              if (amount < 0) {
                                amount = 0;
                              }
                            }
                          }
                        } else {
                          var discount_total = labour_list[l].discount;
                          amount =
                            amount - parseFloat(discount_total.toFixed(2));
                        }
                      } else if (coupon.for == "specific") {
                        if (services[i].service == coupon.label) {
                          if (coupon.type == "percent") {
                            discount_by = "percent";
                            discount = parseFloat(coupon.discount);
                            if (!isNaN(discount) && discount > 0) {
                              discount_total = amount * (discount / 100);
                              amount =
                                amount - parseFloat(discount_total.toFixed(2));
                              if (amount < 0) {
                                amount = 0;
                              }
                            }
                          }
                        } else {
                          //console.log("no coupon discount")
                          var discount_total = labour_list[l].discount;
                          amount =
                            amount - parseFloat(discount_total.toFixed(2));
                        }
                      } else {
                        //console.log("no coupon discount")
                        var discount_total = labour_list[l].discount;
                        amount = amount - parseFloat(discount_total.toFixed(2));
                      }
                    } else {
                      if (coupon.for == "general") {
                        if (coupon.type == "percent") {
                          discount_by = "percent";
                          discount = parseFloat(coupon.discount);
                          if (!isNaN(discount) && discount > 0) {
                            discount_total = amount * (discount / 100);
                            amount =
                              amount - parseFloat(discount_total.toFixed(2));
                            if (amount < 0) {
                              amount = 0;
                            }
                          }
                        } else if (coupon.type == "price") {
                          discount_by = "percent";
                          discount = parseFloat(coupon.discount);
                          if (!isNaN(discount) && discount > 0) {
                            discount_total =
                              (amount / discount_eligible_labour_cost) *
                              discount;
                            amount =
                              amount - parseFloat(discount_total.toFixed(2));
                            if (amount < 0) {
                              amount = 0;
                            }
                          }
                        } else {
                          var discount_total = labour_list[l].discount;
                          amount =
                            amount - parseFloat(discount_total.toFixed(2));
                        }
                      } else if (coupon.for == "category") {
                        if (services[i].type == coupon.label) {
                          if (coupon.type == "percent") {
                            discount_by = "percent";
                            discount = parseFloat(coupon.discount);
                            if (!isNaN(discount) && discount > 0) {
                              discount_total = amount * (discount / 100);
                              amount =
                                amount - parseFloat(discount_total.toFixed(2));
                              if (amount < 0) {
                                amount = 0;
                              }
                            }
                          }
                        } else {
                          var discount_total = labour_list[l].discount;
                          amount =
                            amount - parseFloat(discount_total.toFixed(2));
                        }
                      } else if (coupon.for == "specific") {
                        if (services[i].service == coupon.label) {
                          if (coupon.type == "percent") {
                            discount_by = "percent";
                            discount = parseFloat(coupon.discount);
                            if (!isNaN(discount) && discount > 0) {
                              discount_total = amount * (discount / 100);
                              amount =
                                amount - parseFloat(discount_total.toFixed(2));
                              if (amount < 0) {
                                amount = 0;
                              }
                            }
                          }
                          if (coupon.type == "fixed") {
                            labour_list[l].amount_is_tax = "inclusive";
                            discount_by = "value";
                            discount = parseFloat(coupon.discount);
                            discount_total =
                              (amount / discount_eligible_labour_cost) *
                              discount;
                            discount = amount - discount_total;
                            amount = parseFloat(discount_total.toFixed(2));
                            discount_total = discount;
                            if (amount < 0) {
                              amount = 0;
                            }
                          } else if (coupon.type == "price") {
                            discount_by = "value";
                            discount = parseFloat(coupon.discount);
                            if (!isNaN(discount) && discount > 0) {
                              discount_total =
                                (amount / discount_eligible_labour_cost) *
                                discount;
                              amount =
                                amount - parseFloat(discount_total.toFixed(2));
                              if (amount < 0) {
                                amount = 0;
                              }
                            }
                          }
                        } else {
                          //console.log("no coupon discount")
                          var discount_total = labour_list[l].discount;
                          amount =
                            amount - parseFloat(discount_total.toFixed(2));
                        }
                      } else {
                        //console.log("no coupon discount")
                        var discount_total = labour_list[l].discount;
                        amount = amount - parseFloat(discount_total.toFixed(2));
                      }
                    }

                    if (labour_list[l].amount_is_tax == "exclusive") {
                      var tax_on_amount = amount;
                      if (tax_rate.length > 0) {
                        for (var r = 0; r < tax_rate.length; r++) {
                          if (tax_rate[r].rate != tax_info.rate) {
                            var t = tax_on_amount * (tax_rate[r].rate / 100);
                            amount = amount + t;
                            tax.push({
                              tax: tax_rate[r].tax,
                              rate: tax_rate[r].rate,
                              amount: parseFloat(t.toFixed(2)),
                            });
                          } else {
                            var t = tax_on_amount * (tax_rate[r].rate / 100);
                            amount = amount + t;
                            tax.push({
                              tax: tax_info.tax,
                              tax_rate: tax_info.rate,
                              rate: tax_info.rate,
                              amount: parseFloat(t.toFixed(2)),
                            });
                          }
                        }
                      }
                      total = total + amount;
                    }

                    if (labour_list[l].amount_is_tax == "inclusive") {
                      var x = (100 + tax_info.rate) / 100;
                      var tax_on_amount = amount / x;
                      if (tax_rate.length > 0) {
                        for (var r = 0; r < tax_rate.length; r++) {
                          if (tax_rate[r].rate != tax_info.rate) {
                            var t = tax_on_amount * (tax_rate[r].rate / 100);
                            base = base - t;
                            tax.push({
                              tax: tax_rate[r].tax,
                              rate: tax_rate[r].rate,
                              amount: parseFloat(t.toFixed(2)),
                            });
                          } else {
                            var t = amount - tax_on_amount;
                            base = base - t;
                            tax.push({
                              tax: tax_info.tax,
                              tax_rate: tax_info.rate,
                              rate: tax_info.rate,
                              amount: parseFloat(t.toFixed(2)),
                            });
                          }
                        }

                        //base = base - discount_total;
                      }
                      total = total + amount;
                    }

                    var tax_details = {
                      tax: tax_info.tax,
                      rate: tax_info.rate,
                      amount: total,
                      detail: tax,
                    };

                    labours.push({
                      item: labour_list[l].item,
                      source: labour_list[l].source,
                      rate: parseFloat(labour_list[l].rate),
                      quantity: parseFloat(labour_list[l].quantity),
                      base: parseFloat(base.toFixed(2)),
                      discount: parseFloat(discount_total.toFixed(2)),
                      amount: total,
                      customer_dep: parseFloat(labour_list[l].customer_dep),
                      insurance_dep: parseFloat(labour_list[l].insurance_dep),
                      tax_amount: parseFloat(
                        _.sumBy(tax, (x) => x.amount).toFixed(2)
                      ),
                      amount_is_tax: labour_list[l].amount_is_tax,
                      tax: tax_info.tax,
                      tax_rate: tax_info.rate,
                      tax_info: tax_details,
                    });
                  }

                  bookingService.push({
                    quantity: services[i].quantity,
                    part_cost: services[i].part_cost,
                    labour_cost: _.sumBy(labours, (x) => x.amount),
                    of_cost: services[i].of_cost,
                    exceeded_cost: services[i].exceeded_cost,
                    part_rate: services[i].part_rate,
                    labour_rate: services[i].labour_rate,
                    of_rate: services[i].of_rate,
                    parts: services[i].parts,
                    labour: labours,
                    cost:
                      services[i].part_cost +
                      _.sumBy(labours, (x) => x.amount) +
                      services[i].of_cost,
                    opening_fitting: services[i].opening_fitting,
                    part_cost_editable: services[i].part_cost_editable,
                    labour_cost_editable: services[i].part_cost_editable,
                    of_cost_editable: services[i].part_cost_editable,
                    description: services[i].description,
                    service: services[i].service,
                    type: services[i].type,
                    claim: services[i].claim,
                    custom: services[i].custom,
                    discount:
                      _.sumBy(labours, (x) => x.discount) +
                      _.sumBy(services[i].parts, (x) => x.discount) +
                      _.sumBy(services[i].opening_fitting, (x) => x.discount),
                    customer_approval: services[i].customer_approval,
                    surveyor_approval: services[i].surveyor_approval,
                    source: services[i].source,
                  });
                }
              }
            }
          }
          var additionalDiscount = 0;
          if (type == "additional") {
            additionalDiscount = parseFloat(req.body.discount);
            console.log("Additional discount " + additionalDiscount);
            bookingService = services;
          } else {
            if (booking.payment.additionalDiscount) {
              additionalDiscount = booking.payment.additionalDiscount;
            }
          }

          if (type == "careager_cash") {
            careager_cash = parseFloat(req.body.careager_cash);
            bookingService = services;
          } else {
            var careager_cash = booking.payment.careager_cash;
          }
          var policy_clause = 0;
          if (booking.payment.policy_clause) {
            policy_clause = booking.payment.policy_clause;
          }
          var salvage = 0;
          if (booking.payment.salvage) {
            salvage = booking.payment.salvage;
          }

          var approved = _.filter(
            bookingService,
            (customer_approval) => customer_approval.customer_approval == true
          );

          var labour_cost = _.sumBy(bookingService, (x) => x.labour_cost);
          var part_cost = _.sumBy(bookingService, (x) => x.part_cost);
          var of_cost = _.sumBy(bookingService, (x) => x.of_cost);

          var servicesCost = labour_cost + part_cost + of_cost;
          var discount_total = _.sumBy(bookingService, (x) => x.discount);
          var pick_up_charges = booking.payment.pick_up_charges;

          var paid_total = booking.payment.paid_total;

          console.log("Addition dis COP = " + additionalDiscount);
          console.log("Addition dis COP = " + labour_cost);
          console.log("part_cost = " + part_cost);
          console.log("salvage  = " + salvage);
          console.log("discount_total  = " + discount_total);
          console.log("pick_up_charges  = " + pick_up_charges);
          console.log("pick_up_charges  = " + pick_up_charges);
          // + additionalDiscount
          var payment_total =
            labour_cost +
            part_cost +
            of_cost +
            discount_total +
            policy_clause +
            salvage +
            pick_up_charges;

          var estimate_cost =
            labour_cost +
            part_cost +
            of_cost +
            policy_clause +
            salvage +
            pick_up_charges -
            (careager_cash + additionalDiscount);
          console.log("Estimate  = " + estimate_cost);
          var due_amount =
            _.sumBy(approved, (x) => x.labour_cost) +
            _.sumBy(approved, (x) => x.part_cost) +
            _.sumBy(approved, (x) => x.of_cost) +
            policy_clause +
            salvage +
            pick_up_charges -
            (paid_total + additionalDiscount + careager_cash);

          var due = {
            due: Math.ceil(due_amount.toFixed(2)),
          };

          var payment = {
            total: payment_total,
            estimate_cost: estimate_cost,
            of_cost: of_cost,
            labour_cost: labour_cost,
            part_cost: part_cost,
            careager_cash: careager_cash,
            payment_mode: booking.payment.payment_mode,
            payment_status: booking.payment.payment_status,
            coupon: coupon_code,
            coupon_type: "",
            discount_by: discount_by,
            discount_type: discount_type,
            discount: discount,
            servicesCost: servicesCost,
            additionalDiscount: additionalDiscount,
            discount_total: discount_total,
            policy_clause: booking.payment.policy_clause,
            salvage: booking.payment.salvage,
            terms: booking.payment.terms,
            pick_up_limit: booking.payment.pick_up_limit,
            pick_up_charges: booking.payment.pick_up_charges,
            paid_total: parseFloat(booking.payment.paid_total),
            discount_applied: booking.payment.discount_applied,
            transaction_id: booking.payment.transaction_id,
            transaction_date: booking.payment.transaction_date,
            transaction_status: booking.payment.transaction_status,
            transaction_response: booking.payment.transaction_response,
          };

          await Booking.findOneAndUpdate(
            { _id: booking._id },
            {
              $set: {
                services: bookingService,
                payment: payment,
                due: due,
                updated_at: new Date(),
              },
            },
            { new: false },
            async function (err, doc) {
              if (err) {
                res.status(400).json({
                  responseCode: 400,
                  responseMessage: "Error",
                  responseData: err,
                });
              } else {
                var update = await Booking.findById(booking.id).exec();
                res.status(200).json({
                  responseCode: 200,
                  responseMessage: "Discount has been applied",
                  responseData: update,
                });
              }
            }
          );
        } else {
          res.status(200).json({
            responseCode: 200,
            responseMessage: "Not eligible for discount",
            responseData: {},
          });
        }
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Unauthorized",
          responseData: {},
        });
      }
    }
  }
);

router.post(
  "/booking/discount/remove",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      booking: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Booking is required",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var user = decoded.user;
      var data = new Object();
      var discount = 0;
      var discount_total = 0;
      var code = "";
      var discount_type = "";
      var discount_by = "";

      var booking = await Booking.findOne({ _id: req.body.booking }).exec();

      if (booking) {
        var bookingService = [];

        if (booking.payment.discount_type == "special") {
          var discount_services = booking.services;
        } else if (booking.payment.discount_type == "coupon") {
          var coupon = await Coupon.findOne({
            code: booking.payment.coupon,
          }).exec();
          if (coupon) {
            if (coupon.for == "category") {
              var discount_services = _.filter(
                booking.services,
                (type) => type.type == coupon.label
              );
              var bookingService = _.filter(
                booking.services,
                (type) => type.type != coupon.label
              );
            } else if (coupon.for == "specific") {
              var discount_services = _.filter(
                booking.services,
                (service) => service.service == coupon.label
              );
              var bookingService = _.filter(
                booking.services,
                (service) => service.service != coupon.label
              );
            } else if (coupon.for == "general") {
              var discount_services = booking.services;
            }
          } else {
            var discount_services = [];
          }
        } else {
          var discount_services = [];
        }

        if (discount_services.length > 0) {
          for (var i = 0; i < discount_services.length; i++) {
            if (discount_services[i].claim == true) {
              bookingService.push(discount_services[i]);
            } else {
              var labour_list = discount_services[i].labour;

              var labours = [];

              if (labour_list) {
                for (var l = 0; l < labour_list.length; l++) {
                  var total = 0;
                  var tax_info = await Tax.findOne({
                    tax: labour_list[l].tax,
                  }).exec();

                  var tax = [];
                  var rate = labour_list[l].rate;
                  var amount =
                    parseFloat(labour_list[l].rate) *
                    parseFloat(labour_list[l].quantity);
                  var tax_rate = tax_info.detail;
                  var base = amount;

                  if (labour_list[l].amount_is_tax == "exclusive") {
                    var tax_on_amount = amount;
                    if (tax_rate.length > 0) {
                      for (var r = 0; r < tax_rate.length; r++) {
                        if (tax_rate[r].rate != tax_info.rate) {
                          var t = tax_on_amount * (tax_rate[r].rate / 100);
                          amount = amount + t;
                          tax.push({
                            tax: tax_rate[r].tax,
                            rate: tax_rate[r].rate,
                            amount: parseFloat(t.toFixed(2)),
                          });
                        } else {
                          var t = tax_on_amount * (tax_rate[r].rate / 100);
                          amount = amount + t;
                          tax.push({
                            tax: tax_info.tax,
                            tax_rate: tax_info.rate,
                            rate: tax_info.rate,
                            amount: parseFloat(t.toFixed(2)),
                          });
                        }
                      }
                    }
                    total = total + amount;
                  }

                  if (labour_list[l].amount_is_tax == "inclusive") {
                    var x = (100 + tax_info.rate) / 100;
                    var tax_on_amount = amount / x;
                    if (tax_rate.length > 0) {
                      for (var r = 0; r < tax_rate.length; r++) {
                        if (tax_rate[r].rate != tax_info.rate) {
                          var t = tax_on_amount * (tax_rate[r].rate / 100);
                          base = base - t;
                          tax.push({
                            tax: tax_rate[r].tax,
                            rate: tax_rate[r].rate,
                            amount: parseFloat(t.toFixed(2)),
                          });
                        } else {
                          var t = amount - tax_on_amount;
                          base = base - t;
                          tax.push({
                            tax: tax_info.tax,
                            tax_rate: tax_info.rate,
                            rate: tax_info.rate,
                            amount: parseFloat(t.toFixed(2)),
                          });
                        }
                      }

                      //base = base - discount_total;
                    }
                    total = total + amount;
                  }

                  var tax_amount = total - parseFloat(base.toFixed(2));

                  var tax_details = {
                    tax: tax_info.tax,
                    rate: tax_info.rate,
                    amount: total,
                    detail: tax,
                  };

                  labours.push({
                    item: labour_list[l].item,
                    source: labour_list[l].source,
                    rate: parseFloat(labour_list[l].rate),
                    quantity: parseFloat(labour_list[l].quantity),
                    base: parseFloat(base.toFixed(2)),
                    discount: parseFloat(discount_total.toFixed(2)),
                    amount: total,
                    customer_dep: parseFloat(labour_list[l].customer_dep),
                    insurance_dep: parseFloat(labour_list[l].insurance_dep),
                    tax_amount: parseFloat(
                      _.sumBy(tax, (x) => x.amount).toFixed(2)
                    ),
                    amount_is_tax: labour_list[l].amount_is_tax,
                    tax: tax_info.tax,
                    tax_rate: tax_info.rate,
                    tax_info: tax_details,
                  });
                }

                bookingService.push({
                  quantity: discount_services[i].quantity,
                  part_cost: discount_services[i].part_cost,
                  labour_cost: _.sumBy(labours, (x) => x.amount),
                  of_cost: discount_services[i].of_cost,
                  exceeded_cost: discount_services[i].exceeded_cost,
                  part_rate: discount_services[i].part_rate,
                  labour_rate: discount_services[i].labour_rate,
                  of_rate: discount_services[i].of_rate,
                  parts: discount_services[i].parts,
                  labour: labours,
                  cost:
                    discount_services[i].part_cost +
                    _.sumBy(labours, (x) => x.amount) +
                    discount_services[i].of_cost,
                  opening_fitting: discount_services[i].opening_fitting,
                  part_cost_editable: discount_services[i].part_cost_editable,
                  labour_cost_editable: discount_services[i].part_cost_editable,
                  of_cost_editable: discount_services[i].part_cost_editable,
                  description: discount_services[i].description,
                  service: discount_services[i].service,
                  type: discount_services[i].type,
                  claim: discount_services[i].claim,
                  custom: discount_services[i].custom,
                  customer_approval: discount_services[i].customer_approval,
                  surveyor_approval: discount_services[i].surveyor_approval,
                  discount:
                    _.sumBy(labours, (x) => x.discount) +
                    _.sumBy(discount_services[i].parts, (x) => x.discount) +
                    _.sumBy(
                      discount_services[i].opening_fitting,
                      (x) => x.discount
                    ),
                  source: discount_services[i].source,
                });
              }
            }
          }

          var policy_clause = 0;
          if (booking.payment.policy_clause) {
            policy_clause = booking.payment.policy_clause;
          }

          var salvage = 0;
          if (booking.payment.salvage) {
            salvage = booking.payment.salvage;
          }

          var careager_cash = await q.all(
            fun.getBookingCarEagerCash(booking._id)
          );

          var approved = _.filter(
            bookingService,
            (customer_approval) => customer_approval.customer_approval == true
          );

          var paid_total = booking.payment.paid_total;
          var labour_cost = _.sumBy(bookingService, (x) => x.labour_cost);
          var part_cost = _.sumBy(bookingService, (x) => x.part_cost);
          var of_cost = _.sumBy(bookingService, (x) => x.of_cost);
          var discount_total = _.sumBy(bookingService, (x) => x.discount);
          var pick_up_charges = booking.payment.pick_up_charges;

          var servicesCost = labour_cost + part_cost + of_cost;
          // console.log("28471 = servicesCost = " + servicesCost)
          // console.log("28472 = discount_total = " + discount_total)
          // console.log("28473 = pick_up_charges = " + pick_up_charges)
          // console.log("28471 = additionalDiscount = " + booking.payment.additionalDiscount)
          // console.log("28471 = careager_cash = " + careager_cash)
          var additionalDiscount = 0;
          if (booking.payment.additionalDiscount) {
            additionalDiscount = booking.payment.additionalDiscount;
          }
          var payment_total =
            labour_cost +
            part_cost +
            of_cost +
            discount_total +
            policy_clause +
            salvage +
            pick_up_charges +
            additionalDiscount;

          var estimate_cost =
            labour_cost +
            part_cost +
            of_cost +
            policy_clause +
            salvage +
            pick_up_charges -
            (careager_cash + additionalDiscount);

          var due_amount =
            _.sumBy(approved, (x) => x.labour_cost) +
            _.sumBy(approved, (x) => x.part_cost) +
            _.sumBy(approved, (x) => x.of_cost) +
            policy_clause +
            salvage +
            pick_up_charges -
            (paid_total + careager_cash + additionalDiscount);

          var due = {
            due: Math.ceil(due_amount.toFixed(2)),
          };

          var payment = {
            total: payment_total,
            estimate_cost: estimate_cost,
            of_cost: of_cost,
            servicesCost: servicesCost,
            careager_cash: careager_cash,
            labour_cost: labour_cost,
            part_cost: part_cost,
            payment_mode: booking.payment.payment_mode,
            payment_status: booking.payment.payment_status,
            coupon: "",
            additionalDiscount: additionalDiscount,
            due: Math.ceil(due_amount.toFixed(2)),
            coupon_type: "",
            discount_by: "",
            discount_type: "",
            discount: 0,
            discount_total: 0,
            policy_clause: booking.payment.policy_clause,
            salvage: booking.payment.salvage,
            terms: booking.payment.terms,
            pick_up_limit: booking.payment.pick_up_limit,
            pick_up_charges: booking.payment.pick_up_charges,
            paid_total: parseFloat(booking.payment.paid_total),
            discount_applied: false,
            transaction_id: booking.payment.transaction_id,
            transaction_date: booking.payment.transaction_date,
            transaction_status: booking.payment.transaction_status,
            transaction_response: booking.payment.transaction_response,
          };

          await Booking.findOneAndUpdate(
            { _id: booking._id },
            {
              $set: {
                services: bookingService,
                payment: payment,
                due: due,
                updated_at: new Date(),
              },
            },
            { new: false },
            async function (err, doc) {
              if (err) {
                res.status(400).json({
                  responseCode: 400,
                  responseMessage: "Error",
                  responseData: err,
                });
              } else {
                await CouponUsed.remove({ booking: booking._id }).exec();
                var update = await Booking.findById(booking.id).exec();

                res.status(200).json({
                  responseCode: 200,
                  responseMessage: "Discount has been removed",
                  responseData: update,
                });
              }
            }
          );
        } else {
          res.status(400).json({
            responseCode: 400,
            responseMessage: "Coupon not found",
            responseData: {},
          });
        }
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Booking not found",
          responseData: {},
        });
      }
    }
  }
);

router.get(
  "/products/get",
  xAccessToken.token,
  async function (req, res, next) {
    let date = new Date(req.query.date);
    // console.log("Date Filter query......", date, req.query.date)
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    var business = req.headers["business"];
    if (req.query.query) {
      req.query.query = req.query.query.replace(
        /([.?*+^$[\]\\(){}|-])/g,
        "\\$1"
      );
    }
    // console.log("QUERY = " + req.query.query)
    // query
    //paginate
    if (req.query.page == undefined) {
      var page = 0;
    } else {
      var page = req.query.page;
    }

    var page = Math.max(0, parseInt(page));

    if (req.query.limit == undefined) {
      var limit = 50;
    } else {
      var limit = parseInt(req.query.limit);
    }

    //paginate

    var product = [];

    if (req.query.page == undefined) {
      var page = 0;
    } else {
      var page = req.query.page;
    }
    // var isAvailable = { $gte: 0 }
    var isAvailable = { $ne: "NaN" };
    // console.log("req.query.isAvailable " + req.query.isAvailable)
    if (req.query.isAvailable == "true") {
      isAvailable = { $gte: 1 };
    } else {
      // isAvailable = { $gte: 0 };
      isAvailable = { $ne: "NaN" };
    }
    // console.log("isAvailable " + isAvailable.$gte)
    var page = Math.max(0, parseInt(page));

    var product = [];
    var array = [];

    if (req.query.by == "category") {
      var query = {
        $match: {
          category: mongoose.Types.ObjectId(req.query.query),
          business: mongoose.Types.ObjectId(business),
        },
      };
    } else if (req.query.by == "subcategory") {
      var query = {
        $match: { subcategory: mongoose.Types.ObjectId(req.query.query) },
        "stock.available": isAvailable,
        business: mongoose.Types.ObjectId(business),
      };
    } else if (req.query.by == "brand") {
      var query = {
        $match: {
          product_brand: mongoose.Types.ObjectId(req.query.query),
          "stock.available": isAvailable,
          business: mongoose.Types.ObjectId(business),
        },
      };
    } else if (req.query.by == "model") {
      var query = {
        $match: {
          product_model: mongoose.Types.ObjectId(req.query.query),
          "stock.available": isAvailable,
          business: mongoose.Types.ObjectId(business),
        },
      };
    } else if (req.query.by == "id") {
      var query = {
        $match: {
          product: mongoose.Types.ObjectId(req.query.query),
          "stock.available": isAvailable,
          business: mongoose.Types.ObjectId(business),
        },
      };
    } else if (req.query.by == "filter") {
      var specification = {};
      var subcategory = req.query.subcategory;
      specification["business"] = business;
      specification["stock.available"] = isAvailable;
      array.push(specification);

      if (req.query.subcategory) {
        var specification = {};
        var subcategory = req.query.subcategory;
        specification["_subcategory"] = { $in: subcategory.split(",") };
        array.push(specification);
      }

      if (req.query.brand) {
        var specification = {};
        var brand = req.query.brand;
        specification["_product_brand"] = { $in: brand.split(",") };
        array.push(specification);
      }

      if (req.query.type) {
        var specification = {};
        var type = req.query.type;
        specification["type"] = { $in: type.split(",") };
        array.push(specification);
      }

      if (req.query.size) {
        var specification = {};
        var size = req.query.size;
        specification["specification.size"] = { $in: size.split(",") };
        array.push(specification);
      }

      if (req.query.material) {
        var specification = {};
        var material = req.query.material;
        specification["specification.specification"] = {
          $in: material.split(","),
        };
        array.push(specification);
      }

      if (req.query.variants) {
        var specification = {};
        var variants = req.query.variants;
        specification["specification.type"] = { $in: variants.split(",") };
        array.push(specification);
      }

      if (req.query.price) {
        var specification = {};
        var price = req.query.price;
        var min = price.split(",")[0];
        var max = price.split(",")[1];
        specification["price.sell_price"] = {
          $gte: parseInt(min),
          $lte: parseInt(max),
        };
        array.push(specification);
      }

      if (req.query.car) {
        var specification = {};
        var models = req.query.car;
        specification["models"] = { $in: models.split(",") };
        array.push(specification);
      }

      var specification = {};
      var list_type = req.query.list_type;
      specification["list_type"] = { $in: list_type.split(",") };
      array.push(specification);

      var query = {
        $match: {
          $and: array,
        },
      };
    } else {
      // console.log("Business Product ")
      var list_type = req.query.list_type;
      let startDate = undefined;
      let endDate = undefined;
      if (req.query.date) {
        startDate = new Date(req.query.date);
        // console.log("Query contains date...", startDate, req.query.endDate);

        if (req.query.endDate) {
          endDate = new Date(req.query.endDate);
        }
        var query = {
          $match: {
            business: mongoose.Types.ObjectId(business),
            "stock.available": isAvailable,
            list_type: { $in: list_type.split(",") },
            created_at: { $gte: new Date(startDate), $lt: new Date(endDate) },
            $or: [
              { type: { $regex: req.query.query, $options: "i" } },
              { models: { $regex: req.query.query, $options: "i" } },
              { title: { $regex: req.query.query, $options: "i" } },
              { part_no: { $regex: req.query.query, $options: "i" } },
              { keywords: { $regex: req.query.query, $options: "i" } },
              {
                sku: {
                  $elemMatch: {
                    sku: { $regex: req.query.query, $options: "i" },
                  },
                },
              },
            ],
          },
        };
      } else {
        //vinay
        var query = {
          $match: {
            business: mongoose.Types.ObjectId(business),
            "stock.available": isAvailable,
            list_type: { $in: list_type.split(",") },
            $or: [
              { type: { $regex: req.query.query, $options: "i" } },
              { models: { $regex: req.query.query, $options: "i" } },
              { title: { $regex: req.query.query, $options: "i" } },
              { part_no: { $regex: req.query.query, $options: "i" } },
              { keywords: { $regex: req.query.query, $options: "i" } },
              {
                sku: {
                  $elemMatch: {
                    sku: { $regex: req.query.query, $options: "i" },
                  },
                },
              },
            ],
          },
        };
      }
    }
    // console.log("Query filter....", query)
    await BusinessProduct.aggregate([
      query,
      { $sort: { updated_at: -1 } },
      // { $sort: { "price.sell_price": -1 } },
      //{$group: {_id: '$_id', data: {$push:'$$ROOT'}}},
      { $skip: limit * page },
      { $limit: limit },
    ])
      .allowDiskUse(true)
      .cursor({ batchSize: limit })
      .exec()

      .eachAsync(async function (p) {
        var title = p.title;
        if (_.includes(title, ",")) {
          title = title.replace(/,/g, ", ");
        }

        var offers = [];
        await ProductOffer.find({
          $or: [{ source: null }, { source: p.category }],
        })
          .cursor()
          .eachAsync(async (o) => {
            var ofrs = o.offers;
            ofrs.forEach(function (ofr) {
              if (ofr.offer) {
                offers.push({
                  offer: ofr.offer,
                });
              }
            });
          });

        var gallery = await Gallery.find({ source: p._id }).exec();
        var tax_type = "GST";
        // console.log("p",JSON.stringify(p))
        // if (p) {
        //     tax_type = p.tax.split('% ').pop()
        // }

        product.push({
          product: p.product,
          _id: p._id,
          id: p._id,
          product_brand: await ProductBrand.findById(p.product_brand).exec(),
          product_model: await ProductCategory.findById(p.product_model).exec(),
          category: await ProductCategory.findById(p.category).exec(),
          subcategory: await ProductCategory.findById(p.subcategory).exec(),
          business: p.business,
          title: _.startCase(_.toLower(title)),
          price: p.price,
          stock: p.stock,
          part_no: p.part_no,
          hsn_sac: p.hsn_sac,
          oes: p.oes,
          oem: p.oem,
          tax: p.tax,
          tax_type: tax_type,
          sku: p.sku,
          specification: p.specification,
          product_id: p.product_id,
          short_description: p.short_description,
          long_description: p.long_description,
          thumbnail: p.preview,
          models: p.models,
          services: p.services,
          amount_is_tax: p.amount_is_tax,
          offers: offers,
          unit: p.unit,
          warranty: p.warranty,
          quantity: p.quantity,
          logs: p.logs,
        });
      });

    const totalProductCount = await BusinessProduct.aggregate([
      query,
      { $sort: { "price.sell_price": -1 } },
    ]).exec();

    const publishedProductCount = await BusinessProduct.count({
      business: business,
      publish: true,
      list_type: { $in: ["Offline"] },
    }).exec();

    res.status(200).json({
      responseCode: 200,
      //responseQuery: query,
      responseMessage: "success",
      responseData: {
        total: totalProductCount.length,
        published: publishedProductCount,
        products: product,
        // query: query
      },
    });
  }
);

router.get("/taxes/get", async function (req, res, next) {
  var tz = req.headers["tz"];
  if (tz) {
    var country = await Country.findOne({ timezone: { $in: tz } }).exec();
    if (country) {
      var taxes = await Tax.find({ country: country._id, type: "GST" })
        .sort({ count: -1 })
        .exec();
      result = await q.all(
        businessFunctions.removeDublicateDoumnets(taxes, "tax")
      );
      res.status(200).json({
        responseCode: 200,
        responseMessage: "Tax Slabs",
        // responseInfo: {
        //     taxes: _.map(taxes, 'rate')
        // },
        responseData: result,
      });
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Tax Slabs",
        responseData: {},
      });
    }
  } else {
    res.status(400).json({
      responseCode: 400,
      responseMessage: "Tax Slabs",
      responseData: {},
    });
  }
});
router.get("/taxes/get/new", async function (req, res, next) {
  var tz = req.headers["tz"];
  if (tz) {
    var country = await Country.findOne({ timezone: { $in: tz } }).exec();
    if (country) {
      var taxes = await Tax.find({ country: country._id, type: "GST" })
        .sort({ count: -1 })
        .exec();
      result = await q.all(
        businessFunctions.removeDublicateDoumnets(taxes, "tax")
      );
      console.log(result.length);
      var taxes = [];
      for (var i = 0; i < result.length; i++) {
        taxes.push({
          tax: result[i].tax,
          type: result[i].type,
          _id: result[i]._id,
        });
      }
      res.status(200).json({
        responseCode: 200,
        responseMessage: "Tax Slabs",
        // responseInfo: {
        //     taxes: _.map(taxes, 'rate')
        // },
        responseData: taxes,
      });
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Tax Slabs",
        responseData: {},
      });
    }
  } else {
    res.status(400).json({
      responseCode: 400,
      responseMessage: "Tax Slabs",
      responseData: {},
    });
  }
});

router.put(
  "/taxes/update",
  xAccessToken.token,
  async function (req, res, next) {
    var count = 1;
    await Tax.find({})
      .cursor()
      .eachAsync(async (v) => {
        await Tax.findOneAndUpdate(
          { _id: v._id },
          { $set: { count: count } },
          { new: true },
          async function (err, doc) {
            if (err) {
              res.status(422).json({
                responseCode: 422,
                responseMessage: "Error Occurred",
                responseData: err,
              });
            } else {
              res.status(200).json({
                responseCode: 200,
                responseMessage: "Successfully Updated",
                responseData: {},
              });
            }
          }
        );
        count = count + 1;
      })
      .exec();
  }
);

router.get(
  "/products/brand/get",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var business = req.headers["business"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    if (req.query.page == undefined) {
      var page = 0;
    } else {
      var page = req.query.page;
    }

    var page = Math.max(0, parseInt(page));
    var result = [];
    let regex = req.query.query;
    // let regex = req.query.query.replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1");
    await ProductBrand.find({
      value: new RegExp(regex, "i"),
    })
      .populate("category")
      .cursor()
      .eachAsync(async (p) => {
        result.push({
          _id: p._id,
          id: p._id,
          value: p.value,
          category: p.category,
        });
      });
    // await ProductModel.find({
    //     model: new RegExp(regex, "i")
    // })
    //     .populate('brand')
    //     .cursor().eachAsync(async (p) => {
    //         result.push({
    //             _id: p._id,
    //             id: p._id,
    //             value: p.value,
    //             model: p.model,
    //             product_brand: p.brand
    //         })
    //     });
    res.status(200).json({
      responseCode: 200,
      responseMessage: "success",
      responseData: result,
    });
  }
);
router.get("/models/list/get", async function (req, res, next) {
  var models = [];
  if (req.query.query) {
    await Model.find({ model: new RegExp(req.query.query, "i") })
      .cursor()
      .eachAsync(async (v) => {
        models.push({
          _id: v._id,
          id: v.id,
          model: v.model,
          value: v.value,
        });
      });
  } else {
    await Model.find({})
      .cursor()
      .eachAsync(async (v) => {
        models.push({
          _id: v._id,
          id: v.id,
          model: v.model,
          value: v.value,
          segment: v.segment,
        });
      });
  }

  res.status(200).json({
    responseCode: 200,
    responseMessage: "success",
    responseData: models,
  });
});

router.get(
  "/products/brand/category/get",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var business = req.headers["business"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    if (req.query.page == undefined) {
      var page = 0;
    } else {
      var page = req.query.page;
    }

    var page = Math.max(0, parseInt(page));
    var result = [];
    let regex = req.query.query;
    // let regex = req.query.query.replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1");
    await ProductCategory.find({
      category: new RegExp(regex, "i"),
    })
      .cursor()
      .eachAsync(async (c) => {
        result.push({
          _id: c._id,
          id: c._id,
          // value: p.value,
          category: c.category,
        });
      });
    res.status(200).json({
      responseCode: 200,
      responseMessage: "success",
      responseData: result,
    });
  }
);

router.put(
  "/stock/item/edit",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      unit: "required",
      itemId: "required",
      part_no: "required",
    };
    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Some fileds are missing",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var user = decoded.user;
      var business = req.headers["business"];
      // var part_no = req.body.part_no;
      var unit = req.body.unit;
      var loggedInDetails = await User.findById(user).exec();
      var part_no = req.body.part_no;
      part_no = part_no.replace(/,/g, ", ");
      part_no = part_no.toUpperCase();
      var unit = req.body.unit;
      var loggedInDetails = await User.findById(user).exec();
      var businessProduct = await BusinessProduct.findOne({
        _id: req.body.itemId,
        business: business,
      }).exec();
      if (businessProduct) {
        var tax_slab = req.body.tax;
        var tax_details = req.body.tax_details;
        var remark = req.body.remark;
        var sale_price = parseFloat(req.body.sale_price); //Sale Price
        var margin = parseFloat(req.body.margin); //Margin
        var base_price = parseFloat(req.body.base_price);
        var purchase_price = parseFloat(req.body.purchase_price).toFixed(2); //Purchase Price
        var mrp = parseFloat(req.body.mrp); //mrp
        var category = req.body.category; //OEM or OES   partNo_category
        var item_name = req.body.item_name; //Item name
        var hsn_sac = req.body.hsn_sac;
        var models = req.body.models;
        margin_total = parseFloat(margin);
        var discount = req.body.discount;
        var discount_type = req.body.discount_type;
        var isDiscount = req.body.isDiscount;
        // console.log(" 2164 New Business Product Entry")
        // tax_type
        var tax_info = await Tax.findOne({ tax: tax_slab }).exec(); //products[p].tax = "28.0% GST"
        var rate = parseFloat(purchase_price); //sale price
        var amount = parseFloat(purchase_price);
        var tax_rate = tax_info.detail;
        // var base = amount;
        // console.log("Amount = " + amount)

        var amount_is_tax = "exclusive";

        var taxes = {
          tax: tax_info.tax,
          rate: tax_info.rate,
          amount: amount,
          detail: tax_details,
        };
        var sku = {
          sku: req.body.store_location,
        };
        var price = {
          base: base_price, //base price with GST
          tax_amount: _.sumBy(tax_details, (x) => x.amount), //Tax Amount
          purchase_price: purchase_price, //base + GST on base
          rate: parseFloat(base_price) + parseFloat(margin),
          amount:
            parseFloat(base_price) +
            parseFloat(margin) +
            _.sumBy(tax_details, (x) => x.amount),
          mrp: mrp,
          discount: discount,
          discount_type: discount_type,
          isDiscount: isDiscount,
          margin: margin,
          sell_price: sale_price,
          // amount: amount,
          // sell_price: amount + parseFloat(margin),
          // margin_total: margin_total,
          // unit_price: purchase_price
        };

        var list_type = [];
        list_type.push("Offline");
        // purchases.push(purchase);
        // console.log("1772 Amount = " + amount)
        var product_brand = null;
        var brand_category = null;

        // var product_brand = req.body.product_brand; //ObjectId
        // var brand_category = req.body.brand_category; //ObjectId
        if (req.body.product_brand) {
          product_brand = req.body.product_brand;
        }
        if (req.body.brand_category) {
          brand_category = req.body.brand_category;
        }

        var data = {
          part_no: part_no,
          product_brand: product_brand,
          subcategory: brand_category,
          title: item_name,
          hsn_sac: hsn_sac,
          unit: unit,
          models: models,
          sku: sku,
          price: price,
          amount_is_tax: amount_is_tax,
          tax: tax_info.tax,
          tax_rate: tax_info.rate,
          tax_type: tax_info.tax.split("% ").pop(),
          part_category: category,
          tax_info: taxes,
          updated_at: new Date(),
        };
        await BusinessProduct.findOneAndUpdate(
          { _id: businessProduct._id },
          { $set: data },
          { new: false },
          async function (err, doc) {
            // console.log("2216")
            var activity = {
              vendor_name: "Updated",
              quantity: 0,
              unit_price: purchase_price,
              price: 0,
              received_by: loggedInDetails.name,
              purchase: null,
              remark: remark,
              business: business,
              activity: "Updated",
              created_at: new Date(),
            };
            // console.log("2216")
            await fun.productLog(businessProduct._id, activity);
          }
        );
        var p = await BusinessProduct.findOne({
          _id: businessProduct._id,
        }).exec();
        var updatedData = {
          _id: p._id,
          id: p._id,
          product: p.title,
          part_no: p.part_no,
          hsn_sac: p.hsn_sac,
          specification: p.specification,
          //long_description: p.long_description,
          base: p.price.base,
          price: p.price.purchase_price,
          // price: p.price.unit_price,
          unit: p.unit,
          item_details: p,
        };
        res.status(200).json({
          responseCode: 200,
          responseMessage: "Successfully Updated",
          responseData: updatedData,
        });
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Item Not Updated",
          responseData: {},
        });
      }
    }
  }
);

router.post(
  "/stock/item/get",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var business = req.headers["business"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    // console.log("Part NO " + req.body.part_no)
    // console.log("purchase_price  " + req.body.purchase_price)
    var query = {};
    var rules = {};
    if (req.body.item_id) {
      rule = {
        item_id: "required",
      };
      // console.log("If STOCK GET")
      query = {
        _id: req.body.item_id,
        business: business,
      };
    } else if (req.body.part_no && req.body.purchase_price) {
      rule = {
        part_no: "required",
        unit: "required",
        purchase_price: "required",
      };
      var floor = Math.floor(req.body.purchase_price);
      var ceil = Math.ceil(req.body.purchase_price);
      // console.log("Floor " + floor)
      // console.log("ceil " + ceil)
      // console.log("purchase_price " + req.body.purchase_price)
      // 'price.purchase_price': { $gte: floor, $lte: ceil },
      query = {
        part_no: req.body.part_no,
        unit: req.body.unit,
        // 'price.purchase_price':  req.body.purchase_price,
        "price.purchase_price": { $gte: floor, $lte: ceil },
        business: business,
      };
    } else {
      req.body.part_no = "";
      rule = {
        part_no: "required",
        unit: "required",
        purchase_price: "required",
      };
    }
    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Error",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var result = await BusinessProduct.findOne(query)
        .populate("subcategory")
        .populate("product_brand")
        .exec();
      if (result) {
        var models = [];
        var value = "";
        if (result.models) {
          models = result.models;
        }
        if (result.product_brand) {
          value = result.product_brand.value;
        }

        console.log(
          "result.product_brand==",
          JSON.stringify(result.product_brand)
        );
        var data = {
          id: result._id,
          _id: result._id,
          price: result.price,
          models: models,
          product: result.product,
          purchase: result.purchase,
          purchases: result.purchases,
          amount_is_tax: result.amount_is_tax,
          tax_type: result.tax_type,
          _product_brand: value,
          _product_model: result._product_model,
          _category: result._category,
          _subcategory: result._subcategory,
          reference_no: result.reference_no,
          part_no: result.part_no,
          keywords: result.keywords,
          short_description: result.short_description,
          long_description: result.long_description,
          list_type: result.list_type,
          thumbnail: result.thumbnail,
          type: result.type,
          procurement_sla: result.procurement_sla,
          convenience_charges: result.convenience_charges,
          unit: result.unit,
          publish: result.publish,
          variants: result.variants,
          _id: result._id,
          business: result.business,
          product_id: result.product_id,
          product_brand: result.product_brand,
          product_model: result.product_model,
          category: result.category,
          subcategory: result.subcategory,
          title: result.title,
          hsn_sac: result.hsn_sac,
          quantity: result.quantity,
          stock: result.stock,
          sku: result.sku,
          tax: result.tax,
          tax_rate: result.tax_rate,
          part_category: result.part_category,
          tax_info: result.tax_info,
          created_at: result.created_at,
          updated_at: result.updated_at,
          services: result.services,
          logs: result.logs,
          __v: result.__v,
          bookmark: result.bookmark,
          is_bookmarked: result.is_bookmarked,
          preview: result.preview,
          id: result.id,
        };
        res.status(200).json({
          responseCode: 200,
          responseMessage: "success",
          responseData: data,
        });
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Item Not found",
          responseData: result,
        });
      }
    }
  }
);

router.post(
  "/tax_info/get",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var business = req.headers["business"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    let regex = req.body.tax_slab;
    // console.log("Tax Rate = " + regex)
    // let regex = req.query.query.replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1");
    var tax_info = await Tax.findOne({
      tax: regex,
    }).exec();
    if (tax_info) {
      // var unique = [...new Set(tax_info)]
      // console.log("unique", unique)
      res.status(200).json({
        responseCode: 200,
        responseMessage: "Tax Details",
        responseData: tax_info,
      });
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Tax Details not found",
        responseData: {},
      });
    }
  }
);

router.put(
  "/stock/item/delete",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers["business"];
    // var part_no = req.body.part_no;
    var loggedInDetails = await User.findById(user).exec();
    // var part_no = req.body.part_no;
    // part_no = part_no.replace(/,/g, ", ");
    // part_no = part_no.toUpperCase();
    var loggedInDetails = await User.findById(user).exec();
    var businessProduct = await BusinessProduct.findOne({
      _id: req.body.item_id,
      business: business,
    }).exec();
    if (businessProduct) {
      // console.log("Avaia =  " + businessProduct.stock.available)
      if (!businessProduct.stock.available) {
        await BusinessProduct.findOneAndDelete(
          { _id: businessProduct._id },
          { new: false },
          async function (err, doc) {
            // var activity = {
            //     vendor_name: "",
            //     quantity: 0,
            //     unit_price: purchase_price,
            //     price: 0,
            //     received_by: loggedInDetails.name,
            //     purchase: null,
            //     remark: remark,
            //     business: business,
            //     activity: "Item Deleted",
            //     created_at: new Date()
            // };
            // await fun.productLog(businessProduct._id, activity);
          }
        );

        res.status(200).json({
          responseCode: 200,
          responseMessage: "Successfully Deleted",
          responseData: {},
        });
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Some Items are available in stock",
          responseData: {},
        });
      }
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Item not found",
        responseData: {},
      });
    }
  }
);

// router.get('/leads/count/get', async function (req, res, next) {
//     var token = req.headers['x-access-token'];
//     var secret = config.secret;
//     var decoded = jwt.verify(token, secret);
//     var user = decoded.user;
//     var data = [];
//     var business = req.headers['business'];

//     var role = await Management.findOne({ user: user, business: business }).exec();

//     if (role.role == 'CRE') {
//         assignee = mongoose.Types.ObjectId(role.user)
//         var query = { manager: user, converted: true, status: { $nin: ["Rejected", "Cancelled", "Inactive"] } }
//     }

//     else {
//         assignee = { $ne: null }
//         var query = { business: business, converted: true, status: { $nin: ["Rejected", "Cancelled", "Inactive", "EstimateRequested"] } }
//     }

//     var open = await Lead.find({ "remark.status": "Open", business: business, assignee: assignee }).count().exec()
//     var closedLost = await Lead.find({ "remark.status": { $in: ["Lost", "Closed"] }, business: business, assignee: assignee }).count().exec()
//     var lost = await Lead.find({ "remark.status": { $in: ["Lost"] }, business: business, assignee: assignee }).count().exec()
//     var followUp = await Lead.find({ "remark.status": { $in: ["Follow-Up"] }, "follow_up.date": { $lt: new Date() }, business: business, assignee: assignee }).count().exec()
//     // var followUp = await OutBoundLead.find({ status: { $in: ["Follow-Up"] }, "follow_up.date": { $lt: new Date() }, business: business, category: req.query.category, assignee: assignee }).count().exec()
//     var converted = await Booking.find(query).count().exec()
//     var estimateRequested = await Lead.find({ "remark.status": { $in: ["EstimateRequested"] }, business: business, assignee: assignee }).count().exec()
//     var approval = await Lead.find({ "remark.status": { $in: ["Approval"] }, business: business, assignee: assignee }).count().exec()
//     var rework = await Lead.find({ "remark.status": { $in: ["Rework"] }, business: business, assignee: assignee }).count().exec()
//     var dissatisfied = await Lead.find({ "remark.reason": { $in: ["Dissatisfied"] }, business: business, assignee: assignee }).count().exec()
//     var satisfied = await Lead.find({ "remark.reason": { $in: ["Satisfied"] }, business: business, assignee: assignee }).count().exec()

//     // 'car.insurance_info.expire': { $lt: new Date() },
//     // var reminderOpen = await OutBoundLead.find({ business: business, category: 'ServiceReminder', assignee: assignee, status: "Open" }).count().exec()
//     // var reminderFollowUp = await OutBoundLead.find({ business: business, category: 'ServiceReminder', assignee: assignee, status: "Follow-Up", "follow_up.date": { $lt: new Date() } }).count().exec()

//     res.status(200).json({
//         responseCode: 200,
//         responseMessage: "Stats Counts",
//         responseData: {
//             open: open,
//             followUp: followUp,
//             closedLost: closedLost,
//             converted: converted,
//             lost: lost,
//             estimateRequested: estimateRequested,
//             approval: approval,
//             rework: rework,
//             dissatisfied: dissatisfied,
//             satisfied: satisfied
//             // insurance_open: insurance_open.length,
//             // insurance_followUp: insurance_followUp.length,
//             // insurance_expired: insurance_expired.length,

//             // reminderOpen: reminderOpen,
//             // reminderFollowUp: reminderFollowUp
//         }
//     });
// });
router.get("/leads/count/get", async function (req, res, next) {
  var token = req.headers["x-access-token"];
  var secret = config.secret;
  var decoded = jwt.verify(token, secret);
  var user = decoded.user;
  var data = [];
  var business = req.headers["business"];
  var role = await Management.findOne({
    user: user,
    business: business,
  }).exec();
  assignee = null;
  // if (role.role == 'CRE') {
  //     assignee = mongoose.Types.ObjectId(role.user)
  // } else
  if (role.role == "Admin" || role.role == "Manager") {
    assignee = { $ne: null };
  } else {
    assignee = mongoose.Types.ObjectId(role.user);
  }

  var open = await Lead.find({
    "remark.status": "Open",
    business: business,
    assignee: assignee,
  })
    .count()
    .exec();
  var followUp = await Lead.find({
    "remark.status": { $in: ["Follow-Up"] },
    "follow_up.date": { $lt: new Date() },
    business: business,
    assignee: assignee,
  })
    .count()
    .exec();

  var estimateRequested = await Lead.find({
    "remark.status": { $in: ["EstimateRequested"] },
    business: business,
    assignee: assignee,
  })
    .count()
    .exec();
  var outbound = await Booking.find({
    isOutbound: true,
    status: "EstimateRequested",
    business: business,
  })
    .count()
    .exec();
  estimateRequested = estimateRequested - outbound;
  var approval = await Lead.find({
    "remark.status": { $in: ["Approval"] },
    business: business,
    assignee: assignee,
  })
    .count()
    .exec();
  var confirmed = await Lead.find({
    "remark.status": { $in: ["Confirmed"] },
    business: business,
    assignee: assignee,
  })
    .count()
    .exec();

  // var outbound = await Booking.find({ isOutbound: true, status: "Confirmed", business: business }).count().exec();
  // if (role.role == 'CRE') {
  //     assignee = mongoose.Types.ObjectId(role.user)
  //     var query = { isOutbound: false, manager: assignee, converted: true, status: { $nin: ["Rejected", "Cancelled", "Inactive", "EstimateRequested", 'Confirmed'] } }
  // } else
  if (role.role == "Admin" || role.role == "Manager") {
    assignee = { $ne: null };
    var query = {
      isOutbound: false,
      business: business,
      converted: true,
      status: {
        $nin: [
          "Rejected",
          "Cancelled",
          "Inactive",
          "EstimateRequested",
          "Confirmed",
        ],
      },
    };
  } else {
    assignee = mongoose.Types.ObjectId(role.user);
    var query = {
      isOutbound: false,
      manager: assignee,
      converted: true,
      status: {
        $nin: [
          "Rejected",
          "Cancelled",
          "Inactive",
          "EstimateRequested",
          "Confirmed",
        ],
      },
    };
  }
  var converted = await Booking.find(query).count().exec();

  var confirmedQuery = null;
  // if (role.role == "CRE") {
  //     confirmedQuery = { isOutbound: false, manager: user, date: { $gte: new Date() }, status: { $in: ["Confirmed"] } }
  // }
  // else
  if (role.role == "Admin" || role.role == "Manager") {
    confirmedQuery = {
      isOutbound: false,
      business: business,
      date: { $gte: new Date() },
      status: { $in: ["Confirmed"] },
    };
  } else {
    confirmedQuery = {
      isOutbound: false,
      manager: user,
      date: { $gte: new Date() },
      status: { $in: ["Confirmed"] },
    };
  }
  var confirmed = await Booking.find(confirmedQuery).count().exec();

  var missedQuery = null;
  // if (role.role == "CRE") {
  //     missedQuery = { isOutbound: false, manager: user, date: { $lt: new Date() }, status: { $in: ["Confirmed"] } }
  // }
  // else
  if (role.role == "Admin" || role.role == "Manager") {
    missedQuery = {
      isOutbound: false,
      business: business,
      date: { $lt: new Date() },
      status: { $in: ["Confirmed"] },
    };
  } else {
    missedQuery = {
      isOutbound: false,
      manager: user,
      date: { $lt: new Date() },
      status: { $in: ["Confirmed"] },
    };
  }
  var missed = await Booking.find(missedQuery).count().exec();

  res.status(200).json({
    responseCode: 200,
    responseMessage: "Stats Counts",
    responseData: {
      open: open,
      followUp: followUp,
      // closedLost: closedLost,
      converted: converted,
      // lost: lost,
      estimateRequested: estimateRequested,
      approval: approval,
      confirmed: confirmed,
      missed: missed,
      // rework: rework,
      // dissatisfied: dissatisfied,
      // satisfied: satisfied
    },
  });
});

router.get(
  "/outbound/lead/stats",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers["business"];
    var role = await Management.findOne({
      user: user,
      business: business,
    }).exec();
    if (role) {
      var assignee = null;
      if (role.role == "CRE") {
        assignee = mongoose.Types.ObjectId(role.user);
      } else {
        assignee = { $ne: null };
      }
      var insurance_open = [];
      var insurance_followUp = [];
      var insurance_expired = [];
      if (req.query.category == "Insurance") {
        var filters = [];
        var date = new Date();
        // var from = new Date(date.getFullYear(), date.getMonth() - 1, date.getDate());
        var from = new Date(date.getFullYear(), date.getMonth(), 1);
        var to = new Date(
          date.getFullYear(),
          date.getMonth(),
          date.getDate() + 1
        );
        // { $gte: [{ $month: "$follow_up.date" }, { $month: new Date(from) }] },
        // { $lte: [{ $month: "$follow_up.date" }, { $month: new Date(to) }] },
        // { $lte: [{ $dayOfMonth: "$follow_up.date" }, { $dayOfMonth: new Date() }] }
        var specification = {};
        specification["$match"] = {
          business: mongoose.Types.ObjectId(business),
          status: { $in: ["Follow-Up"] },
          category: "Insurance",
          assignee: assignee,
          $expr: {
            $and: [
              // { $eq: [{ $month: "$follow_up.date" }, { $month: new Date() }] },
              // { $eq: [{ $dayOfMonth: "$follow_up.date" }, { $dayOfMonth: new Date() }] }

              // { $gte: [{ $month: "$follow_up.date" }, { $month: new Date(from) }] },
              // { $lte: [{ $month: "$follow_up.date" }, { $month: new Date(to) }] },
              // { $lte: [{ $dayOfMonth: "$follow_up.date" }, { $dayOfMonth: new Date() }] },
              // { $eq: [{ $year: "$follow_up.date" }, { $year: new Date() }] }

              { $lte: [{ $month: "$follow_up.date" }, { $month: new Date() }] },
              {
                $lte: [
                  { $dayOfMonth: "$follow_up.date" },
                  { $dayOfMonth: new Date() },
                ],
              },
              { $eq: [{ $year: "$follow_up.date" }, { $year: new Date() }] },
            ],
          },
        };
        filters.push(specification);
        var insurance_followUp = await OutBoundLead.aggregate(filters);

        //Insurance Open Counts
        var filters = [];
        console.log("Insurance Open");
        var specification = {};
        specification["$match"] = {
          business: mongoose.Types.ObjectId(business),
          status: { $in: ["Open", "Follow-Up", "Lost", "Converted"] },
          category: "Insurance",
          assignee: assignee,
        };
        filters.push(specification);

        var bar = new Date();
        bar.setDate(bar.getDate() + 30);
        var specification = {};
        specification["$match"] = {
          insurance_rem: { $gte: new Date(), $lt: bar },
          $expr: {
            $and: [
              { $ne: [{ $month: "$follow_up.date" }, { $month: new Date() }] }, //Used Before Working
              {
                $ne: [
                  { $dayOfMonth: "$follow_up.date" },
                  { $dayOfMonth: new Date() },
                ],
              }, //Date Wise
            ],
          },
        };
        filters.push(specification);
        var insurance_open = await OutBoundLead.aggregate(filters);
        console.log("Insurance Open Count = " + insurance_open.length);
        //Expired

        var filters = [];
        var specification = {};
        specification["$lookup"] = {
          from: "Car",
          localField: "car",
          foreignField: "_id",
          as: "car",
        };
        filters.push(specification);

        console.log("Insurance Open");
        var specification = {};
        specification["$match"] = {
          business: mongoose.Types.ObjectId(business),
          status: { $in: ["Open", "Follow-Up"] },
          category: "Insurance",
          assignee: assignee,
        };
        filters.push(specification);

        var bar = new Date();
        bar.setDate(bar.getDate() + 30);
        var specification = {};
        specification["$match"] = {
          "car.insurance_info.expire": { $lt: new Date() },
        };
        filters.push(specification);
        var insurance_expired = await OutBoundLead.aggregate(filters);
        console.log("Insurab=nce Expired  = " + insurance_expired.length);
      }
      var open = await OutBoundLead.find({
        status: "Open",
        business: business,
        category: req.query.category,
        assignee: assignee,
      })
        .count()
        .exec();
      var closedLost = await OutBoundLead.find({
        status: { $in: ["Lost", "Closed"] },
        business: business,
        category: req.query.category,
        assignee: assignee,
      })
        .count()
        .exec();
      var lost = await OutBoundLead.find({
        status: { $in: ["Lost"] },
        business: business,
        category: req.query.category,
        assignee: assignee,
      })
        .count()
        .exec();
      var followUp = await OutBoundLead.find({
        status: { $in: ["Follow-Up"] },
        "follow_up.date": { $lt: new Date() },
        business: business,
        category: req.query.category,
        assignee: assignee,
      })
        .count()
        .exec();
      var converted = await OutBoundLead.find({
        status: { $in: ["Converted"] },
        business: business,
        category: req.query.category,
        assignee: assignee,
      })
        .count()
        .exec();

      res.status(200).json({
        responseCode: 200,
        responseMessage: "Stats Counts",
        responseData: {
          open: open,
          followUp: followUp,
          closedLost: closedLost,
          converted: converted,
          lost: lost,
          insurance_open: insurance_open.length,
          insurance_followUp: insurance_followUp.length,
          insurance_expired: insurance_expired.length,
        },
      });
    }
  }
);
router.get(
  "/review-points",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      booking: "required",
    };

    var validation = new Validator(req.query, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Booking required",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      if (req.query.booking != "null") {
        var booking = await Booking.findById(req.query.booking).exec();
        if (booking) {
          var reviewPoint = await ReviewPoint.find({
            business: booking.business,
          })
            .sort({ rating: 1 })
            .exec();

          res.status(200).json({
            responseCode: 200,
            responseMessage: "companies",
            responseData: reviewPoint,
          });
        } else {
          res.status(400).json({
            responseCode: 400,
            responseMessage: "Booking not found",
            responseData: {},
          });
        }
      } else {
        res.status(422).json({
          responseCode: 422,
          responseMessage: "Booking required",
          responseData: {},
        });
      }
    }
  }
);

router.get(
  "/outbound/leads/get",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers["business"];
    var filters = [];
    var totalResult = 0;

    var role = await Management.findOne({
      user: user,
      business: business,
    }).exec();

    var date = new Date();
    var to = new Date();
    to.setDate(date.getDate() - 1);
    to.setHours(23, 59, 58);
    var specification = {};
    specification["$lookup"] = {
      from: "User",
      localField: "user",
      foreignField: "_id",
      as: "user",
    };
    filters.push(specification);

    var specification = {};
    specification["$unwind"] = {
      path: "$user",
      preserveNullAndEmptyArrays: false,
    };
    filters.push(specification);

    var specification = {};
    specification["$lookup"] = {
      from: "Car",
      localField: "car",
      foreignField: "_id",
      as: "car",
    };
    filters.push(specification);

    /*var specification = {};
    specification['$unwind']= {
        path: "$car",
        preserveNullAndEmptyArrays : false
    };
    filters.push(specification);*/

    var specification = {};
    specification["$lookup"] = {
      from: "User",
      localField: "assignee",
      foreignField: "_id",
      as: "assignee",
    };
    filters.push(specification);

    var specification = {};
    specification["$unwind"] = {
      path: "$assignee",
      preserveNullAndEmptyArrays: false,
    };
    filters.push(specification);
    //
    var specification = {};
    specification["$lookup"] = {
      from: "Booking",
      localField: "booking",
      foreignField: "_id",
      as: "booking",
    };
    filters.push(specification);

    var specification = {};
    specification["$unwind"] = {
      path: "$booking",
      preserveNullAndEmptyArrays: false,
    };
    filters.push(specification);
    //
    var page = 0;

    if (req.query.page == undefined) {
      page = 0;
    } else {
      page = req.query.page;
    }

    var page = Math.max(0, parseInt(page));

    if (role.role == "CRE") {
      var specification = {};
      specification["$match"] = {
        "assigne._id": mongoose.Types.ObjectId(role.user),
      };
      filters.push(specification);
    }
    if (req.query.category) {
      var specification = {};
      specification["$match"] = {
        category: req.query.category,
      };
      filters.push(specification);
    }

    if (req.query.query) {
      req.query.query = req.query.query.replace(
        /([.?*+^$[\]\\(){}|-])/g,
        "\\$1"
      );
      // category: { $in: [req.query.category] },
      var specification = {};
      specification["$match"] = {
        business: mongoose.Types.ObjectId(business),
        status: { $in: ["Open", "Follow-Up"] },
        $or: [
          { status: { $regex: req.query.query, $options: "i" } },
          { "user.name": { $regex: req.query.query, $options: "i" } },
          { "user.contact_no": { $regex: req.query.query, $options: "i" } },
          { "car.title": { $regex: req.query.query, $options: "i" } },
          { "car.registration_no": { $regex: req.query.query, $options: "i" } },
          {
            "car.insurance_info.insurance_company": {
              $regex: req.query.query,
              $options: "i",
            },
          },
          // { 'car.insurance_info.insurance_company': { $regex: req.query.query, $options: 'i' } },
          // { 'car.insurance_info.insurance_company': { $regex: req.query.query, $options: 'i' } },
        ],
      };
      filters.push(specification);

      var specification = {};
      specification["$sort"] = {
        updated_at: -1,
      };
      filters.push(specification);
    } else {
      console.log("Status = " + req.query.status);
      var date = new Date();
      var from = new Date(date.getFullYear(), date.getMonth(), 1);
      var to = new Date(
        date.getFullYear(),
        date.getMonth(),
        date.getDate() + 1
      );
      if (req.query.status == "Follow-Up") {
        var specification = {};
        specification["$match"] = {
          business: mongoose.Types.ObjectId(business),
          status: { $in: ["Follow-Up"] },
        };
        filters.push(specification);
        if (req.query.category == "Insurance") {
          console.log("Year before " + new Date().getFullYear());

          console.log("Follow Insurence");
          var specification = {};
          var from = new Date(date.getFullYear(), date.getMonth(), 1);
          var to = new Date(
            date.getFullYear(),
            date.getMonth(),
            date.getDate() + 1
          );

          specification["$match"] = {
            $expr: {
              $and: [
                // { $gte: [{ $month: "$follow_up.date" }, { $month: new Date() }] },  //Used Before Working
                // { $lte: [{ $dayOfMonth: "$follow_up.date" }, { $dayOfMonth: new Date() }] }  //Date Wise

                // { $gte: [{ $month: "$follow_up.date" }, { $month: new Date(from) }] },
                // { $lte: [{ $month: "$follow_up.date" }, { $month: new Date(to) }] },
                // { $lte: [{ $dayOfMonth: "$follow_up.date" }, { $dayOfMonth: new Date() }] },
                // { $lte: [{ $year: "$insurance_rem" }, { $year: new Date() }] }

                //to get Follow Ups
                {
                  $lte: [{ $month: "$follow_up.date" }, { $month: new Date() }],
                },
                {
                  $lte: [
                    { $dayOfMonth: "$follow_up.date" },
                    { $dayOfMonth: new Date() },
                  ],
                },
                { $eq: [{ $year: "$follow_up.date" }, { $year: new Date() }] },
              ],
            },
            //Abhinav Current MOnth Data END
          };
          filters.push(specification);
        } else {
          console.log("Follow Others");
          var specification = {};
          specification["$match"] = {
            "follow_up.date": { $lt: new Date() },
          };
          filters.push(specification);
        }

        var specification = {};
        specification["$sort"] = {
          "follow_up.date": -1,
        };
        filters.push(specification);
      } else if (req.query.status == "Open") {
        if (req.query.category == "Insurance") {
          console.log("Insurance Open");
          var specification = {};
          specification["$match"] = {
            business: mongoose.Types.ObjectId(business),
            status: { $in: ["Open", "Follow-Up", "Lost", "Converted"] },
          };
          filters.push(specification);

          var bar = new Date();
          bar.setDate(bar.getDate() + 30);
          var specification = {};
          specification["$match"] = {
            insurance_rem: { $gte: new Date(), $lt: bar },
            $expr: {
              $and: [
                {
                  $ne: [{ $month: "$follow_up.date" }, { $month: new Date() }],
                }, //Used Before Working
                {
                  $ne: [
                    { $dayOfMonth: "$follow_up.date" },
                    { $dayOfMonth: new Date() },
                  ],
                }, //Date Wise
              ],
            },
          };

          filters.push(specification);
          var specification = {};
          specification["$sort"] = {
            insurance_rem: 1,
          };
          filters.push(specification);
        } else {
          var specification = {};
          specification["$match"] = {
            business: mongoose.Types.ObjectId(business),
            status: { $in: ["Open"] },
          };
          filters.push(specification);
          var specification = {};
          specification["$sort"] = {
            updated_at: -1,
          };
          filters.push(specification);
        }
      } else if (req.query.status == "Lost_Closed") {
        // || req.query.status == "Closed"
        var specification = {};
        specification["$match"] = {
          business: mongoose.Types.ObjectId(business),
          status: { $in: ["Lost", "Closed"] },
        };
        filters.push(specification);
        var specification = {};
        specification["$sort"] = {
          updated_at: -1,
        };
        filters.push(specification);
      } else if (req.query.status == "Lost") {
        // || req.query.status == "Closed"
        var specification = {};
        specification["$match"] = {
          business: mongoose.Types.ObjectId(business),
          status: { $in: ["Lost"] },
        };
        filters.push(specification);
        var specification = {};
        specification["$sort"] = {
          updated_at: -1,
        };
        filters.push(specification);
      } else if (req.query.status == "Converted") {
        // || req.query.status == "Closed"
        var specification = {};
        specification["$match"] = {
          business: mongoose.Types.ObjectId(business),
          status: { $in: ["Converted"] },
        };
        filters.push(specification);
        var specification = {};
        specification["$sort"] = {
          updated_at: -1,
        };
        filters.push(specification);
      } else if (req.query.status == "Expired") {
        if (req.query.category == "Insurance") {
          console.log("Insurance Expired");
          var specification = {};
          specification["$match"] = {
            business: mongoose.Types.ObjectId(business),
            status: { $in: ["Open", "Follow-Up"] },
          };
          filters.push(specification);
          var specification = {};
          specification["$match"] = {
            "car.insurance_info.expire": { $lt: new Date() },
            // $expr: {
            //     $and: [
            //         { $ne: [{ $month: "$follow_up.date" }, { $month: new Date() }] },  //Used Before Working
            //         { $ne: [{ $dayOfMonth: "$follow_up.date" }, { $dayOfMonth: new Date() }] }  //Date Wise
            //     ]
            // }
          };

          filters.push(specification);
          var specification = {};
          specification["$sort"] = {
            "car.insurance_info.expire": -1,
          };
          filters.push(specification);
        } else {
          var specification = {};
          specification["$match"] = {
            business: mongoose.Types.ObjectId(business),
            status: { $in: ["Open"] },
          };
          filters.push(specification);
          var specification = {};
          specification["$sort"] = {
            updated_at: -1,
          };
          filters.push(specification);
        }
      }
    }
    totalResult = await OutBoundLead.aggregate(filters);

    console.log("Total Result - - - = " + totalResult.length);
    var specification = {};
    specification["$skip"] = config.perPage * page;
    filters.push(specification);

    var specification = {};
    specification["$limit"] = config.perPage;
    filters.push(specification);
    var leads = [];
    await OutBoundLead.aggregate(filters)
      .allowDiskUse(true)
      .cursor({ batchSize: 10 })
      .exec()
      .eachAsync(async function (lead) {
        var booking = await Booking.findById(lead.booking._id).exec();
        leads.push({
          _id: lead._id,
          id: lead._id,
          name: lead.name,
          contact_no: lead.contact_no,
          last_service: lead.booking.updated_at,
          status: lead.status,
          follow_up: lead.follow_up,
          insurance_rem: lead.insurance_rem,
          priority: lead.priority,
          booking: {
            booking_no: booking.booking_no,
            created_at: booking.created_at,
            updated_at: booking.updated_at,
            date: booking.date,
          },
          manager: {
            name: lead.assignee.name,
            contact_no: lead.assignee.contact_no,
            email: lead.assignee.email,
          },
          car: lead.car[0],
        });
      });

    res.status(200).json({
      responseCode: 200,
      responseMessage: "to",
      responseInfo: {
        // filters: filters,
        totalResult: totalResult.length,
      },
      responseData: leads,
    });
  }
);

router.put(
  "/taxes/update",
  xAccessToken.token,
  async function (req, res, next) {
    var count = 1;
    await Tax.find({})
      .cursor()
      .eachAsync(async (v) => {
        await Tax.findOneAndUpdate(
          { _id: v._id },
          { $set: { count: count } },
          { new: true },
          async function (err, doc) {
            if (err) {
              res.status(422).json({
                responseCode: 422,
                responseMessage: "Error Occurred",
                responseData: err,
              });
            } else {
              res.status(200).json({
                responseCode: 200,
                responseMessage: "Successfully Updated",
                responseData: {},
              });
            }
          }
        );
        count = count + 1;
      })
      .exec();
  }
);

router.get("/postal/get", async function (req, res, next) {
  var rules = {
    zip: "required",
  };

  var validation = new Validator(req.query, rules);

  if (validation.fails()) {
    res.status(422).json({
      responseCode: 422,
      responseMessage: "Error",
      responseData: {
        res: validation.errors.all(),
      },
    });
  } else {
    // var token = req.headers['x-access-token'];
    //var secret = config.secret;
    //  var decoded = jwt.verify(token, secret);
    //   var user = decoded.user;
    var data = {};

    request.get(
      { url: "http://postalpincode.in/api/pincode/" + req.query.zip },
      function (err, httpResponse, body) {
        if (!err) {
          var resBody = JSON.parse(body);

          if (resBody) {
            var po = resBody.PostOffice;
            if (po != null) {
              data = {
                city: resBody.PostOffice[0].Division,
                state: resBody.PostOffice[0].State,
              };
            }
          }

          res.status(200).json({
            responseCode: 200,
            responseMessage: "",
            responseData: data,
          });
        }
      }
    );
  }
});
router.post(
  "/stock/item/create",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers["business"];
    var product = new Object();
    var result = [];
    var tax = [];
    var total = 0;
    var margin_total = 0;
    var part_no = req.body.part_no;
    part_no = part_no.replace(/,/g, ", ");
    part_no = part_no.toUpperCase();
    var unit = req.body.unit;
    var loggedInDetails = await User.findById(user).exec();
    var floor = Math.floor(parseFloat(req.body.purchase_price).toFixed(2));
    var ceil = Math.ceil(parseFloat(req.body.purchase_price).toFixed(2));
    // console.log("Floor " + floor)
    // console.log("ceil " + ceil)
    // console.log("purchase_price " + req.body.purchase_price)
    // 'price.purchase_price': { $gte: floor, $lte: ceil },
    var businessProduct = await BusinessProduct.find({
      part_no: part_no,
      "price.purchase_price": { $gte: floor, $lte: ceil },
      unit: unit,
      business: business,
    }).exec();
    if (businessProduct.length == 0) {
      var tax_slab = req.body.tax;
      // var tax_details = req.body.tax_details
      var remark = req.body.remark;
      var sale_price = parseFloat(req.body.sale_price); //Sale Price
      var margin = req.body.margin; //Margin
      var base_price = parseFloat(req.body.base_price);
      var purchase_price = parseFloat(req.body.purchase_price).toFixed(2); //Purchase Price
      var mrp = parseFloat(req.body.mrp); //mrp
      var product_brand = null;
      if (
        req.body.product_brand &&
        req.body.product_brand != "NaN" &&
        req.body.product_brand != ""
      ) {
        product_brand = req.body.product_brand; //ObjectId
      }
      var brand_category = null;
      if (
        req.body.brand_category &&
        req.body.brand_category != "" &&
        req.body.brand_category != "NaN"
      ) {
        var brand_category = req.body.brand_category; //ObjectId
      }

      var category = req.body.category; //OEM or OES   partNo_category
      var item_name = req.body.item_name; //Item name
      var hsn_sac = req.body.hsn_sac;
      var models = [];
      if (req.body.models) {
        models = req.body.models;
      }
      // margin_total = parseFloat(margin);
      var discount = req.body.discount;
      var discount_type = req.body.discount_type;
      var isDiscount = req.body.isDiscount;
      // console.log("New Business Product Entry")
      // tax_type
      var tax_info = await Tax.findOne({ tax: tax_slab }).exec(); //products[p].tax = "28.0% GST"
      var rate = parseFloat(purchase_price); //sale price
      var amount = parseFloat(purchase_price);
      var tax_rate = tax_info.detail;
      if (mrp == "NaN") {
        mrp = 0;
      }
      var total_amount = 0;
      if (margin) {
        margin = margin.toString();
        if (margin.indexOf("%") >= 0) {
          margin = parseFloat(margin);
          if (!isNaN(margin) && margin > 0) {
            margin_total = base_price * (margin / 100);
          }
        } else {
          margin_total = parseFloat(margin);
        }
      }
      // if (req.body.isDiscount) {
      // console.log("Discount prints here...", discount)
      //     if (discount.indexOf("%") >= 0) {
      // console.log("602 - Discount If Condition = " + discount)
      //         discount = parseFloat(discount);
      //         if (!isNaN(discount) && discount > 0) {
      //             var discount_total = amount * (discount / 100);
      //             amount = amount - parseFloat(discount_total.toFixed(2))
      //         }
      //     }
      //     else {
      // console.log("610 - Discount ELSE Condition= " + discount)

      //         discount = parseFloat(discount);
      //         if (!isNaN(discount) && discount > 0) {
      //             amount = amount - parseFloat(discount.toFixed(2))
      //         }
      //     }
      // }
      var amount_is_tax = "exclusive";
      // if (req.body.amount_is_tax) {
      //     amount_is_tax = req.body.amount_is_tax
      // }
      // console.log("Ta Type = " + amount_is_tax)
      var tax_details = [];
      if (amount_is_tax == "exclusive") {
        var amount = base_price;
        var tax_on_amount = amount;
        if (tax_rate.length > 0) {
          for (var r = 0; r < tax_rate.length; r++) {
            if (tax_rate[r].rate != tax_info.rate) {
              var t = tax_on_amount * (tax_rate[r].rate / 100);
              amount = amount + t;
              tax_details.push({
                tax: tax_rate[r].tax,
                rate: tax_rate[r].rate,
                amount: parseFloat(t.toFixed(2)),
              });
            } else {
              var t = tax_on_amount * (tax_info.rate / 100);
              amount = amount + t;
              tax_details.push({
                tax: tax_info.tax,
                tax_rate: tax_info.rate,
                rate: tax_info.rate,
                amount: parseFloat(t.toFixed(2)),
              });
            }
          }
        }
      }
      /* 
      if (amount_is_tax == "inclusive") {
             var x = (100 + tax_info.rate) / 100;
             var tax_on_amount = amount / x;
             if (tax_rate.length > 0) {
                 for (var r = 0; r < tax_rate.length; r++) {
                     if (tax_rate[r].rate != tax_info.rate) {
                         var t = tax_on_amount * (tax_rate[r].rate / 100);
                         base = base - t;
                         tax.push({
                             tax: tax_rate[r].tax,
                             rate: tax_rate[r].rate,
                             amount: parseFloat(t.toFixed(2))
                         });
                     }
                     else {
                         var t = amount - tax_on_amount;
                         base = base - t;
                         tax.push({
                             tax: tax_info.tax,
                             rate: tax_info.rate,
                             amount: parseFloat(t.toFixed(2))
                         });
                     }
                 }
             }
         }*/

      var taxes = {
        tax: tax_info.tax,
        rate: tax_info.rate,
        amount: amount,
        detail: tax_details,
      };
      var sku = {
        sku: req.body.store_location,
        total: 0,
        available: 0,
        created_at: new Date(),
      };
      var stock = {
        total: 0,
        consumed: 0,
        available: 0,
        opening_stock: req.body.opening_stock,
        minimum_stock: req.body.minimum_stock,
      };
      var total_amount = parseFloat(base_price) + parseFloat(margin_total);
      // console.log("Total Amountn = " + total_amount)
      var tax_on_amount = total_amount;
      if (tax_rate.length > 0) {
        for (var r = 0; r < tax_rate.length; r++) {
          if (tax_rate[r].rate != tax_info.rate) {
            var t = tax_on_amount * (tax_rate[r].rate / 100);
            total_amount = total_amount + t;
          } else {
            var t = tax_on_amount * (tax_info.rate / 100);
            total_amount = total_amount + t;
          }
        }
      }

      var price = {
        base: base_price, //base price with GST
        tax_amount: _.sumBy(tax_details, (x) => x.amount), //Tax Amount
        purchase_price: purchase_price, //base + GST on base
        rate: parseFloat(base_price) + parseFloat(margin_total),
        // amount: parseFloat(base_price) + parseFloat(margin) + _.sumBy(tax_details, x => x.amount),
        amount: total_amount,
        mrp: mrp,
        discount: discount,
        discount_type: discount_type,
        isDiscount: isDiscount,
        margin: margin,
        sell_price: sale_price,
        margin_total: margin_total,
      };

      var list_type = [];
      list_type.push("Offline");
      var purchases = [];
      // console.log("1772 Amount = " + amount)
      var data = {
        purchase: null,
        purchases: purchases,
        business: business,
        product: null,
        product_id:
          Math.round(+new Date() / 1000) + Math.round(Math.random() * 9999 + 1),
        part_no: part_no, //mend
        product_brand: product_brand, //
        product_model: null,
        model: null,
        category: null,
        // _subcategory: brand_category,
        subcategory: brand_category,
        title: item_name,
        short_description: "",
        long_description: "",
        thumbnail: "",
        specification: "",
        hsn_sac: hsn_sac,
        quantity: 0,
        unit: unit,
        models: models,
        stock: stock,
        sku: sku,
        list_type: list_type,
        price: price,
        amount_is_tax: amount_is_tax,
        tax: tax_info.tax,
        tax_rate: tax_info.rate,
        tax_type: tax_info.tax.split("% ").pop(),
        // tax_type: "GST",
        part_category: category,
        tax_info: taxes,
        list_type: list_type,

        created_at: new Date(),
        updated_at: new Date(),
      };
      var updatedData = {};
      await BusinessProduct.create(data).then(async function (bp) {
        ////// console.log(bp._id)
        var activity = {
          vendor_name: "Created",
          quantity: 0,
          unit_price: purchase_price,
          price: 0,
          received_by: loggedInDetails.name,
          purchase: null,
          remark: remark,
          business: business,
          activity: "Created",
          created_at: new Date(),
        };
        // console.log("Activity")
        fun.productLog(bp._id, activity);
        var p = await BusinessProduct.findOne({ _id: bp._id }).exec();
        updatedData = {
          _id: p._id,
          id: p._id,
          product: p.title,
          part_no: p.part_no,
          hsn_sac: p.hsn_sac,
          specification: p.specification,
          base: p.price.base,
          price: p.price.purchase_price,
          unit: p.unit,
          item_details: p,
        };
      });

      res.status(200).json({
        responseCode: 200,
        responseMessage: "Item Created Successfully",
        responseData: updatedData,
      });
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Item Already Exist",
        responseData: {},
      });
    }
  }
);

router.get(
  "/all/business/get",
  xAccessToken.token,
  async function (req, res, next) {
    businessFunctions.logs(
      "INFO: /all/business/get Api Called from 3.0.js," +
        " " +
        "Request Headers:" +
        JSON.stringify(req.headers) +
        ", " +
        "Request Query:" +
        JSON.stringify(req.query)
    );

    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers["business"];
    var loggedInDetails = await User.findById(decoded.user).exec();
    var product = new Object();
    var result = [];
    //console.log("Main ")
    // //console.log("Business Id = " + business)
    if (req.query.page == undefined) {
      var page = 0;
    } else {
      var page = req.query.page;
    }
    var page = Math.max(0, parseInt(page));

    if (req.query.limit == undefined) {
      var limit = 10;
    } else {
      var limit = parseInt(req.query.limit);
    }

    var list = [];
    var data = [];
    let startDate = req.query.from;
    let endDate = req.query.to;
    let brand = req.query.brand;
    // console.log(startDate, req.query.end_date)
    if (req.query.query) {
      req.query.query = req.query.query.replace(
        /([.?*+^$[\]\\(){}|-])/g,
        "\\$1"
      );
    }

    if (req.query.type == "business") {
      if (req.query.query) {
        //console.log("Query=  " + req.query.query)
        var query = {
          $and: [
            {
              "account_info.type": "business",
              visibility: true,
              _id: { $ne: mongoose.Types.ObjectId(business) },
              $or: [
                {
                  name: { $regex: req.query.query, $options: "i" },
                },
                {
                  contact_no: { $regex: req.query.query, $options: "i" },
                },
                // {
                //     "business_info.gstin": { $regex: req.query.query, $options: 'i' }
                // },
                {
                  "address.location": {
                    $regex: req.query.query,
                    $options: "i",
                  },
                },
                {
                  "address.address": { $regex: req.query.query, $options: "i" },
                },
              ],
            },
          ],
        };
        //console.log(query + " Query")
      } else if (req.query.brand) {
        //console.log("active 1200= " + req.query.active)
        var query = {
          "account_info.type": "business",
          visibility: true,
          _id: { $ne: mongoose.Types.ObjectId(business) },
          "business_info.brand": req.query.brand,
        };
      } else if (req.query.location) {
        req.query.location = req.query.location.replace(
          /([.?*+^$[\]\\(){}|-])/g,
          "\\$1"
        );

        //console.log("Location  = " + req.query.location)
        var query = {
          $and: [
            {
              "account_info.type": "business",
              visibility: true,
              _id: { $ne: mongoose.Types.ObjectId(business) },
              $or: [
                {
                  "address.city": { $regex: req.query.location, $options: "i" },
                },
                {
                  "address.zip": { $regex: req.query.location, $options: "i" },
                },
                {
                  "address.address": {
                    $regex: req.query.location,
                    $options: "i",
                  },
                },
                // {
                //     "address.state": new RegExp(req.query.location, "i"),
                // },
                // {
                //     $text: { $search: req.query.query }
                //     // "address.address": new RegExp(req.query.query, "i")
                // },
                // {
                //     $elemMatch: { "address.address": req.query.query }
                // },
              ],
            },
          ],
        };
        //console.log(query + " Query")
      } else if (req.query.active) {
        //console.log("active 1200= " + req.query.active)
        var query = {
          "account_info.type": "business",
          visibility: true,
          _id: { $ne: mongoose.Types.ObjectId(business) },
          "account_info.status": req.query.active,
        };
      }
      //APS OR AWS
      else if (req.query.category) {
        //console.log("Category")
        result = [];
        // var busi = await BusinessPlan.find({ category: req.query.category }).populate('user').sort({ created_at: -1 }).exec();
        // return res.status(200).json(busi)
        totalResult = 0;
        if (req.query.category != "others") {
          //console.log("APS AWS")
          if (
            Log_Level == 4 ||
            Log_Level == 6 ||
            Log_Level == 8 ||
            Log_Level == 10 ||
            Log_Level == 0
          ) {
            businessFunctions.logs(
              "DEBUG: Fatching Business and their Business Plan Details, Category:" +
                req.query.category +
                ", " +
                "User:" +
                loggedInDetails.name
            );
          }
          await BusinessPlan.find({
            category: req.query.category,
            business: { $ne: mongoose.Types.ObjectId(business) },
          })
            .populate("business")
            .sort({ created_at: -1 })
            .skip(limit * page)
            .limit(limit)
            .cursor()
            .eachAsync(async (business) => {
              // return res.status(200).json(business)
              totalResult = totalResult + 1;
              //console.log(" Error doucument= " + business._id)
              result.push({
                _id: business.business._id,
                id: business.business._id,
                name: business.business.name,
                // owner_name: business.business.owner_name,
                // email: business.business.email,
                // referral_code: business.business.referral_code,
                contact_no: business.business.contact_no,
                // address: business.business.address,
                address: {
                  country: business.business.address.country,
                  state: business.business.address.state,
                  country_code: business.business.address.country_code,
                  zip: business.business.address.zip,
                  area: business.business.address.area,
                  city: business.business.address.city,
                  address: business.business.address.address,
                  location: business.business.address.city,
                  _id: business.business.address._id,
                  timezone: business.business.address.timezone,
                },
                // bank_details: business.business.bank_details,
                business_info: {
                  company_logo: business.business.business_info.company_logo,
                  category: business.business.business_info.category,
                },
                account_info: {
                  status: business.business.account_info.status,
                },
                // agent: business.business.agent,
                // partner: business.business.partner,
                // plans_details: [business],
                created_at: moment(business.business.created_at)
                  .tz(req.headers["tz"])
                  .format("ll"),
                updated_at: moment(business.business.created_at)
                  .tz(req.headers["tz"])
                  .format("ll"),
              });
            });
          result = await q.all(
            businessFunctions.removeDublicateDoumnets(result, "contact_no")
          );
          if (
            Log_Level == 4 ||
            Log_Level == 6 ||
            Log_Level == 8 ||
            Log_Level == 10 ||
            Log_Level == 0
          ) {
            businessFunctions.logs(
              "DEBUG: Sending Business and their Business Plan Details in Response, Category:" +
                req.query.category +
                ", " +
                "User:" +
                loggedInDetails.name
            );
          }
          return res.status(200).json({
            responseCode: 200,
            responseInfo: {
              totalResult: totalResult,
            },
            // responseQuery: query,
            responseMessage: "success",
            responseData: result,
          });
        } else if (req.query.category == "others") {
          //console.log(" Others doucument= ")
          // var totalResult = await User.find(query).count();
          if (
            Log_Level == 4 ||
            Log_Level == 6 ||
            Log_Level == 8 ||
            Log_Level == 10 ||
            Log_Level == 0
          ) {
            businessFunctions.logs(
              "DEBUG: Fatching Business and their Business Plan Details, Category:" +
                req.query.category +
                ", " +
                "User:" +
                loggedInDetails.name
            );
          }
          await User.find({
            "account_info.type": "business",
            visibility: true,
            _id: { $ne: mongoose.Types.ObjectId(business) },
          })
            // .skip(limit * page).limit(limit)
            .sort({ created_at: -1 })
            .skip(limit * page)
            .limit(limit)
            .cursor()
            .eachAsync(async (p) => {
              var busi = {};
              var busi = await BusinessPlan.find({ business: p._id })
                .count()
                .exec();
              //console.log("isPlan = " + busi)
              if (busi == 0) {
                totalResult = totalResult + 1;
                //console.log("Inside If isPlan = ")
                result.push({
                  _id: p._id,
                  id: p._id,
                  name: p.name,
                  // owner_name: p.owner_name,
                  // email: p.email,
                  // referral_code: p.referral_code,
                  contact_no: p.contact_no,
                  // address: p.address,
                  address: {
                    // country: p.address.country,
                    // state: p.address.state,
                    // country_code: p.address.country_code,
                    // zip: p.address.zip,
                    // area: p.address.area,
                    city: p.address.city,
                    // address: p.address.address,
                    location: p.address.city,
                    // _id: p.address._id,
                    // timezone: p.address.timezone
                  },
                  // bank_details: p.bank_details,
                  business_info: {
                    company_logo: p.business_info.company_logo,
                    category: p.business_info.category,
                  },
                  account_info: {
                    status: p.account_info.status,
                  },
                  // agent: p.agent,
                  // partner: p.partner,
                  // plans_details: [],
                  created_at: moment(p.created_at)
                    .tz(req.headers["tz"])
                    .format("ll"),
                  updated_at: moment(p.created_at)
                    .tz(req.headers["tz"])
                    .format("ll"),
                });
              }
            });
          result = await q.all(
            businessFunctions.removeDublicateDoumnets(result, "contact_no")
          );
          if (
            Log_Level == 4 ||
            Log_Level == 6 ||
            Log_Level == 8 ||
            Log_Level == 10 ||
            Log_Level == 0
          ) {
            businessFunctions.logs(
              "DEBUG: Sending Business and their Business Plan Details in Response, Category:" +
                req.query.category +
                ", " +
                "User:" +
                loggedInDetails.name
            );
          }
          return res.status(200).json({
            responseCode: 200,
            responseInfo: {
              totalResult: totalResult,
            },
            // responseQuery: query,
            responseMessage: "success",
            responseData: result,
          });
        }
      }
      //
      else if (startDate && endDate) {
        //console.log(startDate + "  = Date 1207 -" + endDate)
        // filters.push({ $match: {} }
        var query = {
          "account_info.type": "business",
          visibility: true,
          _id: { $ne: mongoose.Types.ObjectId(business) },
          created_at: { $gte: new Date(startDate), $lt: new Date(endDate) },
        };
      } else if (req.query.connection1) {
        //console.log("   Connection 1207 -" + req.query.connection)
        // await BusinessVendor.find({ business: business }).cursor().eachAsync(async (p) => {
        await BusinessVendor.find({})
          .cursor()
          .eachAsync(async (p) => {
            list.push(mongoose.Types.ObjectId(p.vendor));
          });
        // filters.push({ $match: {} }
        var query = {
          // "account_info.type": "business",
          // "visibility": true,
          // _id: { $ne: mongoose.Types.ObjectId(business) },
          _id: { $in: list },
          // "created_at": { $gte: new Date(startDate), $lt: new Date(endDate) }
        };
      } else if (req.query.connection) {
        //console.log("   Connection 1207 -" + req.query.connection)
        totalResult = 0;
        await BusinessVendor.find({ business: business })
          .populate("vendor")
          .skip(limit * page)
          .limit(limit)
          .cursor()
          .eachAsync(async (p) => {
            totalResult = totalResult + 1;
            var busi = {};
            var busi = await BusinessPlan.find({
              business: p.vendor._id,
            }).exec();
            //console.log(" p.vendor.address", p.vendor.address)
            result.push({
              _id: p.vendor._id,
              id: p.vendor._id,
              name: p.vendor.name,
              // owner_name: p.vendor.owner_name,
              // email: p.vendor.email,
              // referral_code: p.vendor.referral_code,
              contact_no: p.vendor.contact_no,
              // address: p.vendor.address,
              address: {
                // country: p.vendor.address.country,
                // state: p.vendor.address.state,
                // country_code: p.vendor.address.country_code,
                // zip: p.vendor.address.zip,
                // area: p.vendor.address.area,
                city: p.vendor.address.city,
                // address: p.vendor.address.address,
                location: p.vendor.address.address,
                // _id: p.vendor.address._id,
                // timezone: p.vendor.address.timezone
              },
              // bank_details: p.vendor.bank_details,
              business_info: {
                company_logo: p.vendor.business_info.company_logo,
                category: p.vendor.business_info.category,
              },
              account_info: {
                status: p.vendor.account_info.status,
              },
              // agent: p.vendor.agent,
              // partner: p.vendor.partner,
              // plans_details: busi,
              created_at: moment(p.vendor.created_at)
                .tz(req.headers["tz"])
                .format("ll"),
              updated_at: moment(p.vendor.created_at)
                .tz(req.headers["tz"])
                .format("ll"),
            });
          });
        result = await q.all(
          businessFunctions.removeDublicateDoumnets(result, "contact_no")
        );
        return res.status(200).json({
          responseCode: 200,
          responseInfo: {
            totalResult: totalResult,
          },
          //responseQuery: query,
          responseMessage: "success",
          responseData: result,
        });

        // filters.push({ $match: {} }
      } else {
        //console.log("Else 1216 ")
        var query = {
          "account_info.type": "business",
          visibility: true,
          _id: { $ne: mongoose.Types.ObjectId(business) },
        };
      }
    } else {
      if (req.query.query) {
        //console.log("Query = " + req.query.query)
        var query = {
          $and: [
            {
              "account_info.type": "user",
              $or: [
                // {
                //     "name": { $regex: req.query.query, $options: 'i' }
                // },
                // {
                //     "contact_no": { $regex: req.query.query, $options: 'i' }
                // },
                // {
                //     "business_info.gstin": { $regex: req.query.query, $options: 'i' }
                // },
                // {
                //     $text: { $search: req.query.query }
                //     // "address.address": new RegExp(req.query.query, "i")
                // },
                // // {
                // //     $elemMatch: { "address.address": req.query.query }
                // // },
              ],
            },
          ],
        };
        //console.log(query + " Query")
      } else {
        var query = {
          "account_info.type": "user",
        };
      }
    }

    var totalResult = await User.find(query).count();
    if (
      Log_Level == 4 ||
      Log_Level == 6 ||
      Log_Level == 8 ||
      Log_Level == 10 ||
      Log_Level == 0
    ) {
      businessFunctions.logs(
        "DEBUG: Fatching Users And their Business Plan Details, User:" +
          loggedInDetails.name
      );
    }
    await User.find(query)
      .skip(limit * page)
      .limit(limit)
      .sort({ created_at: -1 })
      .cursor()
      .eachAsync(async (p) => {
        var busi = {};
        var busi = await BusinessPlan.find({ business: p._id }).exec();
        // var vendorDetails = await BusinessPlan.find({ business: p._id }).exec();
        result.push({
          _id: p._id,
          id: p._id,
          name: p.name,
          // owner_name: p.owner_name,
          // email: p.email,
          // referral_code: p.referral_code,
          contact_no: p.contact_no,
          // address: p.address,
          address: {
            // country: p.address.country,
            // state: p.address.state,
            // country_code: p.address.country_code,
            // zip: p.address.zip,
            // area: p.address.area,
            city: p.address.city,
            // address: p.address.address,
            location: p.address.city,
            // _id: p.address._id,
            // timezone: p.address.timezone
          },
          // bank_details: p.bank_details,
          business_info: {
            company_logo: p.business_info.company_logo,
            category: p.business_info.category,
          },
          account_info: {
            status: p.account_info.status,
          },
          // agent: p.agent,
          // partner: p.partner,
          // plans_details: busi,
          created_at: moment(p.created_at).tz(req.headers["tz"]).format("ll"),
          updated_at: moment(p.created_at).tz(req.headers["tz"]).format("ll"),
        });
      });
    if (
      Log_Level == 4 ||
      Log_Level == 6 ||
      Log_Level == 8 ||
      Log_Level == 10 ||
      Log_Level == 0
    ) {
      businessFunctions.logs(
        "DEBUG: Sending Users and their Business plan Details in Response, User:" +
          loggedInDetails.name
      );
    }
    result = await q.all(
      businessFunctions.removeDublicateDoumnets(result, "contact_no")
    );
    res.status(200).json({
      responseCode: 200,
      responseInfo: {
        totalResult: totalResult,
      },
      // responseQuery: query,
      responseMessage: "success",
      responseData: result,
    });
    if (
      Log_Level == 3 ||
      Log_Level == 7 ||
      Log_Level == 9 ||
      Log_Level == 10 ||
      Log_Level == 0
    ) {
      businessFunctions.logs(
        "INFO: Users and their Business plan Details send in Response Successfully, User:" +
          loggedInDetails.name
      );
    }
  }
);

router.get(
  "/bill/details/get",
  xAccessToken.token,
  async function (req, res, next) {
    businessFunctions.logs(
      "INFO: /bill/details/get Api Called from 3.0.js," +
        " " +
        "Request Headers:" +
        JSON.stringify(req.headers) +
        ", " +
        "Request Query:" +
        JSON.stringify(req.query)
    );

    var rules = {
      bill: "required",
    };

    var validation = new Validator(req.query, rules);

    if (validation.fails()) {
      if (
        Log_Level == 1 ||
        Log_Level == 5 ||
        Log_Level == 6 ||
        Log_Level == 7 ||
        Log_Level == 0
      ) {
        businessFunctions.logs(
          "ERROR: Validation failed, BillId is required to get bill details."
        );
      }
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Error",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var user = decoded.user;
      var business = req.headers["business"];
      var loggedInDetails = await User.findById(decoded.user).exec();

      if (
        Log_Level == 4 ||
        Log_Level == 6 ||
        Log_Level == 8 ||
        Log_Level == 10 ||
        Log_Level == 0
      ) {
        businessFunctions.logs(
          "DEBUG: Fatching Bill details, BillId:" +
            req.query.bill +
            ", User:" +
            loggedInDetails.name
        );
      }
      var p = await Purchase.findById({ _id: req.query.bill })
        .populate({ path: "vendor_address" })
        .populate({
          path: "vendor",
          select:
            "name username avatar avatar_address address contact_no business_info",
        })
        .populate({
          path: "business",
          select:
            "name username avatar avatar_address address contact_no business_info",
        })
        .exec();

      var total_quantity = 0;
      if (p) {
        var map_items = _.map(p.items, "quantity");

        total_quantity = parseFloat(_.sumBy(map_items));
      }

      if (p) {
        if (
          Log_Level == 4 ||
          Log_Level == 6 ||
          Log_Level == 8 ||
          Log_Level == 10 ||
          Log_Level == 0
        ) {
          businessFunctions.logs(
            "DEBUG: Sending Bill details in Response," +
              ", Vendor Name:" +
              p.vendor.name +
              ", User:" +
              loggedInDetails.name
          );
        }
        var due = "";
        var total_discount = 0;
        var paid_total = 0;
        var subTotal = 0;
        var bill_discount = 0;
        if (p.due) {
          due = p.due.toFixed(2);
        }
        if (p.total_discount) {
          total_discount = p.total_discount.toFixed(2);
        }
        if (p.paid_total) {
          paid_total = p.paid_total.toFixed(2);
        }
        if (p.subTotal) {
          subTotal = p.subTotal.toFixed(2);
        }
        if (p.bill_discount) {
          bill_discount = p.bill_discount;
        }
        var bill = {
          _id: p._id,
          id: p._id,
          bill_no: p.bill_no,
          reference_no: p.reference_no,
          date: moment(p.date).tz(req.headers["tz"]).format("YYYY-MM-DD"),
          due_date: moment(p.due_date)
            .tz(req.headers["tz"])
            .format("YYYY-MM-DD"),
          vendor: p.vendor,
          vendor_address: p.vendor_address,
          items: p.items,
          // business: p.business,
          business_name: p.business.name,
          business_contact: p.business.contact_no,
          business_id: p.business._id,
          total: p.total.toFixed(2),
          status: p.status,
          // logs: p.logs,
          file_name: p.file_name,
          bill_discount: bill_discount,
          total_discount: total_discount,
          paid_total: paid_total,
          subTotal: subTotal,
          file_name: p.file_name,
          due: due,
          bill_url: p.bill_url,
          total_quantity: total_quantity,
          vendorOrder: p.vendorOrder,
          // paid_total: p.paid_total,
          created_at: moment(p.created_at).tz(req.headers["tz"]).format("lll"),
          updated_at: moment(p.updated_at).tz(req.headers["tz"]).format("lll"),
        };
        await fun.purchaseBill(p._id);
        res.status(200).json({
          responseCode: 200,
          responseMessage: "Sucess",
          responseData: bill,
        });
        if (
          Log_Level == 3 ||
          Log_Level == 7 ||
          Log_Level == 9 ||
          Log_Level == 10 ||
          Log_Level == 0
        ) {
          businessFunctions.logs(
            "INFO: Bill Details Send in Response Successfully, BillId:" +
              req.query.bill +
              ", Vendor Name:" +
              bill.vendor.name +
              ", User:" +
              loggedInDetails.name
          );
        }
      } else {
        if (
          Log_Level == 2 ||
          Log_Level == 5 ||
          Log_Level == 8 ||
          Log_Level == 9 ||
          Log_Level == 0
        ) {
          businessFunctions.logs(
            "WARNING: Bill not found for the billId:" +
              req.body.bill +
              ", User:" +
              loggedInDetails.name
          );
        }
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Bill not found",
          responseData: {},
        });
      }
    }
  }
);

router.put(
  "/bill/to/sale/items/add",
  xAccessToken.token,
  async function (req, res, next) {
    var business = req.headers["business"];
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var date = new Date();
    var loggedInDetails = decoded.user;
    var items = [];
    var convenience_charges = 0;
    var discount = 0;
    var item_total = 0;
    // var sale = await Sales.findById(req.body.sale).exec();
    // var parts = sale.parts;
    var parts = [];
    var loggedInDetails = await User.findById(decoded.user).exec();

    var sale = await Sales.findById(req.body.sale).exec();
    var purchase = await Purchase.findById(req.body.bill).exec();
    var loggedInDetails = await User.findById(decoded.user).exec();
    if (sale && purchase) {
      // order
      // purchase.items[p].item_status != "Completed"
      // }
      // if (sale) {
      var items = purchase.items;
      console.log("Parts Length = " + items.length);
      for (var p = 0; p < items.length; p++) {
        console.log("\nParts Data = " + JSON.stringify(items[p]), null, "\t");

        if (items[p].item_status == "Completed") {
          var products = items[p];
          // var products = req.body.items;
          if (products.title != "") {
            if (products) {
              var tax_info = await Tax.findOne({ tax: products.tax }).exec();
              var floor = Math.floor(products.unit_price);
              var ceil = Math.ceil(products.unit_price);
              console.log("Floor " + floor);
              console.log("ceil " + ceil);
              console.log("ceil " + ceil);

              // Math.round(5.95)
              // console.log("purchase_price " + req.body.purchase_price)
              // 'price.purchase_price': { $gte: floor, $lte: ceil },

              // .sort({ updated_at: -1 })
              var part_no = products.part_no;
              part_no = part_no.replace(/,/g, ", ");
              part_no = part_no.toUpperCase();
              var checkProducut = await BusinessProduct.findOne({
                purchases: purchase._id,
                part_no: part_no,
                "price.purchase_price": { $gte: floor, $lte: ceil },
                business: business,
              })
                .sort({ updated_at: -1 })
                .exec();
              // if (businessProduct.price.rate == product.rate) {
              if (checkProducut) {
                console.log("checkProducut" + checkProducut.part_no);
                var tax = [];
                products.product = checkProducut._id;
                var rate = products.rate;
                var amount = products.rate * products.quantity;
                var tax_rate = tax_info.detail;
                var discount_total = 0;
                var base = amount;

                var discount = products.discount;

                // if (discount.indexOf("%") >= 0) {
                //     discount = parseFloat(discount);
                //     if (!isNaN(discount) && discount > 0) {
                //         discount_total = amount * (discount / 100);
                //         amount = amount - parseFloat(discount_total.toFixed(2))
                //     }
                // }
                // else {
                //     if (discount == "") {
                //         discount = "0"
                //     }

                //     discount_total = parseFloat(discount);

                //     if (!isNaN(discount_total) && discount_total > 0) {
                //         amount = amount - parseFloat(discount_total.toFixed(2))
                //     }
                // }
                var discount = "0";
                var discount_total = parseFloat(discount);
                if (products.amount_is_tax == "exclusive") {
                  var tax_on_amount = amount;
                  if (tax_rate.length > 0) {
                    for (var r = 0; r < tax_rate.length; r++) {
                      if (tax_rate[r].rate != tax_info.rate) {
                        var t = tax_on_amount * (tax_rate[r].rate / 100);
                        amount = amount + t;
                        tax.push({
                          tax: tax_rate[r].tax,
                          rate: tax_rate[r].rate,
                          amount: parseFloat(t.toFixed(2)),
                        });
                      } else {
                        var t = tax_on_amount * (tax_info.rate / 100);
                        amount = amount + t;
                        tax.push({
                          tax: tax_info.tax,
                          tax_rate: tax_info.rate,
                          rate: tax_info.rate,
                          amount: parseFloat(t.toFixed(2)),
                        });
                      }
                    }
                  }
                }

                if (products.amount_is_tax == "inclusive") {
                  var x = (100 + tax_info.rate) / 100;
                  var tax_on_amount = amount / x;
                  if (tax_rate.length > 0) {
                    for (var r = 0; r < tax_rate.length; r++) {
                      if (tax_rate[r].rate != tax_info.rate) {
                        var t = tax_on_amount * (tax_rate[r].rate / 100);
                        base = base - t;
                        tax.push({
                          tax: tax_rate[r].tax,
                          rate: tax_rate[r].rate,
                          amount: parseFloat(t.toFixed(2)),
                        });
                      } else {
                        var t = amount - tax_on_amount;
                        base = base - t;
                        tax.push({
                          tax: tax_info.tax,
                          rate: tax_info.rate,
                          amount: parseFloat(t.toFixed(2)),
                        });
                      }
                    }
                  }
                  //base = base - discount_total;
                }

                var tax_details = {
                  tax: tax_info.tax,
                  rate: tax_info.rate,
                  amount: total,
                  detail: tax,
                };
                // var issued = await q.all(businessFunctions.salesPartIssue(products, business, user, loggedInDetails));
                // if (issued) {

                // }
                var user = await User.findById(sale.user).exec();
                parts.push({
                  product: checkProducut._id,
                  category: checkProducut.category,
                  _category: checkProducut._category,
                  subcategory: checkProducut.subcategory,
                  _subcategory: checkProducut._subcategory,
                  product_brand: checkProducut.product_brand,
                  _brand: checkProducut.product_brand,
                  product_model: checkProducut.product_model,
                  _model: checkProducut.product_model,
                  source: checkProducut.source,
                  part_no: products.part_no,
                  hsn_sac: products.hsn_sac,
                  unit: products.unit,
                  title: products.title,
                  sku: products.sku,
                  mrp: products.mrp,
                  selling_price: products.selling_price,
                  rate: products.rate,
                  quantity: products.quantity,
                  base: parseFloat(base.toFixed(2)),
                  amount: amount,
                  discount: products.discount,
                  discount_total: parseFloat(discount_total.toFixed(2)),
                  amount_is_tax: products.amount_is_tax,
                  tax_amount: parseFloat(
                    _.sumBy(tax, (x) => x.amount).toFixed(2)
                  ),
                  amount: parseFloat(amount.toFixed(2)),
                  tax: tax_info.tax,
                  tax_rate: tax_info.rate,
                  tax_info: tax,
                  issued: await q.all(
                    businessFunctions.salesPartIssue(
                      products,
                      business,
                      user,
                      loggedInDetails
                    )
                  ),
                  added_by_customer: false,
                  created_at: new Date(),
                  updated_at: new Date(),
                });
              }
            }

            // });
          } else {
            // res.status(200).json({
            //     responseCode: 200,
            //     responseMessage: "Add New Item",
            //     responseData: {}
            // });
          }
        }
      }

      if (sale.payment.convenience_charges) {
        convenience_charges = Math.ceil(sale.payment.convenience_charges);
      }
      var discount =
        parseFloat(_.sumBy(parts, (x) => x.discount_total).toFixed(2)) +
        parseFloat(_.sumBy(sale.labours, (x) => x.discount_total).toFixed(2));
      var amount =
        parseFloat(_.sumBy(parts, (x) => x.amount).toFixed(2)) +
        parseFloat(_.sumBy(sale.labours, (x) => x.amount).toFixed(2));
      var total = amount + discount + convenience_charges;
      var transaction_log = await q.all(
        fun.getSalesTransaction(sale._id, business)
      );
      var paid_total = transaction_log.paid_total;
      var data = {
        updated_at: new Date(),
        "payment.paid_total": paid_total,
        "payment.amount": parseFloat(amount.toFixed(2)),
        "payment.discount_total": parseFloat(discount.toFixed(2)),
        "payment.total": parseFloat(total.toFixed(2)),
        "payment.order_discount": parseFloat(sale.payment.order_discount),
        due: {
          due:
            Math.ceil(amount) +
            convenience_charges -
            paid_total -
            (parseFloat(sale.payment.order_discount) +
              parseFloat(sale.payment.discount_total)),
        },
        parts: parts,
      };
      console.log("Parts Length " + parts.length);
      await Sales.findOneAndUpdate(
        { _id: sale._id, business: business },
        { $set: data },
        { new: true },
        async function (err, doc) {
          if (err) {
            res.status(422).json({
              responseCode: 422,
              responseMessage: "Server Error",
              responseData: err,
            });
          } else {
            var has_invoice = false;
            var invoices = await OrderInvoice.find({
              sale: sale._id,
              business: business,
            })
              .select("status invoice_no")
              .exec();
            if (invoices.length > 0) {
              has_invoice = true;
            }

            // var activity = {
            //     business: business,
            //     activity_by: loggedInDetails.name,
            //     activity: "'" + products.title + "'  -Added to Order",
            //     remark: "Item Added",
            //     created_at: new Date(),
            // }
            // businessFunctions.salesLogs(sale._id, activity);
            var activity = {
              business: business,
              activity_by: loggedInDetails.name,
              activity:
                "Items added from Purchase Bill ( " +
                purchase.reference_no +
                " )",
              remark: "Counter Sale",
              created_at: new Date(),
            };
            businessFunctions.salesLogs(sale._id, activity);
            res.status(200).json({
              responseCode: 200,
              responseMessage: "success",
              responseData: {},
            });
          }
        }
      );
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Sale not found",
        responseData: {},
      });
    }
  }
);

router.get(
  "/vendor/bills/get",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var business = req.headers["business"];

    var vendor = await User.findById(req.query.user).exec();
    if (vendor) {
      var bills = [];
      if (req.query.page == undefined) {
        var page = 0;
      } else {
        var page = req.query.page;
      }

      if (req.query.limit) {
        var limit = parseInt(req.query.limit);
      } else {
        var limit = 50;
      }

      await Purchase.find({
        business: business,
        vendor: vendor._id,
        status: { $ne: "Deleted" },
      })
        .sort({ bill_no: -1 })
        .skip(limit * page)
        .limit(limit)
        .cursor()
        .eachAsync(async (p) => {
          bills.push({
            _id: p._id,
            id: p._id,
            bill_no: p.bill_no,
            reference_no: p.reference_no,
            date: moment(p.date).tz(req.headers["tz"]).format("YYYY-MM-DD"),
            due_date: moment(p.due_date)
              .tz(req.headers["tz"])
              .format("YYYY-MM-DD"),
            business: p.business,
            total: p.total,
            status: p.status,
            created_at: moment(p.created_at)
              .tz(req.headers["tz"])
              .format("lll"),
            updated_at: moment(p.updated_at)
              .tz(req.headers["tz"])
              .format("lll"),
          });
        });

      res.status(200).json({
        responseCode: 200,
        responseMessage: "Sucesss",
        responseInfo: {
          totalResult: await Purchase.find({
            business: business,
            vendor: vendor._id,
            status: { $ne: "Deleted" },
          })
            .count()
            .exec(),
        },
        responseData: bills,
      });
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Vendor not found",
        responseData: {},
      });
    }
  }
);

router.post("/bill/add", xAccessToken.token, async function (req, res, next) {
  businessFunctions.logs(
    "INFO: /bill/add Api Called from 3.0.js," +
      " " +
      "Request Headers:" +
      JSON.stringify(req.headers) +
      ", " +
      "Request Body:" +
      JSON.stringify(req.body)
  );

  var token = req.headers["x-access-token"];
  var secret = config.secret;
  var decoded = jwt.verify(token, secret);
  var user = decoded.user;
  var loggedInDetails = await User.findById(decoded.user).exec();

  var business = req.headers["business"];
  var product = new Object();
  var result = [];
  var tax = [];
  var total = 0;

  if (
    Log_Level == 4 ||
    Log_Level == 6 ||
    Log_Level == 8 ||
    Log_Level == 10 ||
    Log_Level == 0
  ) {
    businessFunctions.logs(
      "DEBUG: Fatching Vendor details, VendorId:" +
        req.body.vendor +
        ", User:" +
        loggedInDetails.name
    );
  }
  var vendor = await User.findById(req.body.vendor).exec(); // Part Supllier
  var newDate = new Date();
  if (vendor) {
    // var loggedInDetails = await User.findById(decoded.user).exec();
    var log_details = {
      business: business,
      activity_by: loggedInDetails.name,
      activity: "Created",
      // time: new Date().getTime.toLocaleTimeString(),
      remark: "",
      created_at: new Date(),
    };
    var vendorOrder = null;
    if (req.body.vendorOrder) {
      vendorOrder = req.body.vendorOrder;
      var activity = {
        business: business,
        activity_by: loggedInDetails.name,
        activity: "Converted To Bill",
        // time: new Date().getTime.toLocaleTimeString(),
        remark: "Converted To Bill",
        created_at: new Date(),
      };
      console.log("Activity");
      businessFunctions.vendorOrderLogs(vendorOrder, activity);
    }
    var bill = {
      reference_no: "",
      vendorOrder: vendorOrder,
      date: null,
      due_date: null,
      vendor: vendor._id,
      vendor_address: null,
      items: [],
      business: business,
      total: 0,
      logs: log_details,
      status: "Incomplete",
      created_at: newDate,
      updated_at: newDate,
    };

    if (
      Log_Level == 4 ||
      Log_Level == 6 ||
      Log_Level == 8 ||
      Log_Level == 10 ||
      Log_Level == 0
    ) {
      businessFunctions.logs(
        "DEBUG: Add Bill for the purchase order, User:" + loggedInDetails.name
      );
    }
    await Purchase.create(bill).then(async function (purchase) {
      var count = await Purchase.find({
        _id: { $lt: purchase._id },
        business: purchase.business,
      }).count();
      var bill_no = count + 10000;

      await Purchase.findOneAndUpdate(
        { _id: purchase._id },
        { $set: { bill_no: bill_no } },
        { new: true },
        async function (err, doc) {
          // console.log("504  Vendor Order  = " + purchase.vendorOrder)
          await VendorOrders.findOneAndUpdate(
            { _id: purchase.vendorOrder },
            { $set: { purchase: purchase._id, isBill: true } },
            { new: true },
            async function (err, doc) {
              // console.log("Found Vendor Order ")
            }
          );
          res.status(200).json({
            responseCode: 200,
            responseMessage: "Bill has been added.",
            responseData: {
              bill_no: bill_no,
              id: purchase._id,
            },
          });
          if (
            Log_Level == 3 ||
            Log_Level == 7 ||
            Log_Level == 9 ||
            Log_Level == 10 ||
            Log_Level == 0
          ) {
            businessFunctions.logs(
              "INFO: Bill has been Added for the purchase, User:" +
                loggedInDetails.name
            );
          }
        }
      );
    });
  } else {
    res.status(400).json({
      responseCode: 400,
      responseMessage: "Vendor not found",
      responseData: {},
    });
  }
});

router.put(
  "/bill/details/modify",
  xAccessToken.token,
  async function (req, res, next) {
    businessFunctions.logs(
      "INFO: /bill/details/modify Api Called from inventory.js," +
        " " +
        "Request Headers:" +
        JSON.stringify(req.headers) +
        ", " +
        "Request Body:" +
        JSON.stringify(req.body)
    );

    var token = req.headers["x-access-token"];
    var business = req.headers["business"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var loggedInDetails = await User.findById(decoded.user).exec();
    let regex = req.body.tax_slab;
    // console.log("Tax Rate = " + regex)
    // let regex = req.query.query.replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1");
    var purchase = await Purchase.findById(req.body.bill)
      .populate("vendor")
      .exec();
    if (purchase) {
      var date = new Date(req.body.formattedDate).toISOString();
      var address = null;
      if (req.body.address) {
        address = req.body.address;
      }
      var log_details = {
        business: business,
        // vendor_name: "Updated",
        // activity_by: loggedInDetails.name,
        activity: "Updated",
        // time: new Date().getTime.toLocaleTimeString(),
        remark: "Bill No, Bill Date, Addresss Changed",
        created_at: new Date(),
      };
      var logs = [];
      if (purchase.logs) {
        logs = purchase.logs;
        logs.push(log_details);
      } else {
        logs.push(log_details);
      }
      var bill = {
        reference_no: req.body.reference_no,
        date: date,
        logs: logs,
        // due_date: due,
        vendor: purchase.vendor._id,
        vendor_address: req.body.address,
        // items: items,
        business: business,
        // total: total,
        updated_at: new Date(),
      };
      // Vinay working on purchase
      if (
        Log_Level == 4 ||
        Log_Level == 6 ||
        Log_Level == 8 ||
        Log_Level == 10 ||
        Log_Level == 0
      ) {
        businessFunctions.logs(
          "DEBUG: Fatching the Purchase Bill and Update the bill details, Purchaseid:" +
            purchase._id +
            ", User:" +
            loggedInDetails.name
        );
      }
      await Purchase.findOneAndUpdate(
        { _id: purchase._id },
        { $set: bill },
        { new: false },
        async function (err, doc) {
          if (err) {
            if (
              Log_Level == 1 ||
              Log_Level == 5 ||
              Log_Level == 6 ||
              Log_Level == 7 ||
              Log_Level == 0
            ) {
              businessFunctions.logs(
                "ERROR: Error Occured while updating the Purchase Bill details, PurchaseUd:" +
                  purchase._id +
                  ", User:" +
                  loggedInDetails.name
              );
            }
            res.status(422).json({
              responseCode: 422,
              responseMessage: "Server Error...",
              responseData: err,
            });
          } else {
            res.status(200).json({
              responseCode: 200,
              responseMessage: "Successfully Saved",
              responseData: await Purchase.findById(req.body.bill).exec(),
            });
            if (
              Log_Level == 3 ||
              Log_Level == 7 ||
              Log_Level == 9 ||
              Log_Level == 10 ||
              Log_Level == 0
            ) {
              businessFunctions.logs(
                "INFO: uccessfully Saved the Purchase Bill Details, Vendor_Name:" +
                  bill.vendor.name +
                  ", User:" +
                  loggedInDetails.name
              );
            }
          }
        }
      );
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Bill Details not found",
        responseData: {},
      });
    }
  }
);

router.get("/postals/get", async function (req, res, next) {
  var rules = {
    zip: "required",
  };

  var validation = new Validator(req.query, rules);

  if (validation.fails()) {
    res.status(422).json({
      responseCode: 422,
      responseMessage: "Error",
      responseData: {
        res: validation.errors.all(),
      },
    });
  } else {
    console.time("looper");
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var data = [];

    await Location.find({ zip: req.query.zip })
      .cursor()
      .eachAsync(async function (o) {
        data.push({
          _id: o._id,
          id: o._id,
          zip: o.zip,
          city: o.city,
          region: o.region,
          state: o.state,
          latitude: o.latitude,
          longitude: o.longitude,
          country: o.country,
        });
      });

    console.timeEnd("looper");

    res.status(200).json({
      responseCode: 200,
      responseMessage: "",
      responseData: data,
    }); /**/
  }
});

router.post("/vendor/add", xAccessToken.token, async function (req, res, next) {
  var rules = {
    contact_no: "required",
    name: "required",
  };

  var validation = new Validator(req.body, rules);

  if (validation.fails()) {
    res.status(422).json({
      responseCode: 422,
      responseMessage: "Validation Error",
      responseData: {
        res: validation.errors.all(),
      },
    });
  } else {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers["business"];

    var checkPhone = await User.find({
      contact_no: req.body.contact_no,
      "account_info.type": "business",
    })
      .count()
      .exec();
    if (checkPhone == 0) {
      var otp = Math.floor(Math.random() * 90000) + 10000;

      req.body.username = shortid.generate();

      req.body.socialite = {};
      req.body.optional_info = {};

      var address = req.body.address;
      //console.log("address", req.body.city)

      var country = await Country.findOne({
        timezone: { $in: req.headers["tz"] },
      }).exec();

      req.body.address = {
        country: country.countryName,
        timezone: req.headers["tz"],
        location: req.body.location,
        address: req.body.address,
        state: req.body.state,
        zip: req.body.zip,
        country_code: req.body.country_code,
      };

      req.body.bank_details = {
        ifsc: req.body.ifsc,
        account_no: req.body.account_no,
        account_holder: req.body.account_holder,
      };

      req.body.account_info = {
        type: "business",
        status: "Complete",
        added_by: business,
        phone_verified: false,
        verified_account: false,
        approved_by_admin: false,
      };

      req.body.geometry = [0, 0];

      req.body.device = [];
      req.body.otp = otp;
      req.body.uuid = uuidv1();

      req.body.business_info = {
        business_category: req.body.business_category,
        company_name: req.body.company,
        account_no: req.body.account_no,
        gst_registration_type: req.body.gst_registration_type,
        gstin: req.body.gstin,
        tax_registration_no: req.body.tax_registration_no,
        pan_no: req.body.pan_no,
        brand: req.body.carBrand,
        category: req.body.category,
      };

      var firstPart = (Math.random() * 46656) | 0;
      var secondPart = (Math.random() * 46656) | 0;
      firstPart = ("000" + firstPart.toString(36)).slice(-3);
      secondPart = ("000" + secondPart.toString(36)).slice(-3);
      req.body.referral_code =
        firstPart.toUpperCase() + secondPart.toUpperCase();

      await User.create(req.body).then(async function (user) {
        var days = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];

        for (var i = 0; i < 7; i++) {
          var timing = new BusinessTiming({
            business: user._id,
            day: days[i],
            open: "09:30 AM",
            close: "06:30 PM",
            is_closed: false,
            created_at: new Date(),
            updated_at: new Date(),
          });
          timing.save();
        }

        // Type.find({}).then(function (BT){
        //     BT.forEach(function (u) {
        //         var businessType = new BusinessType({
        //             business: user._id,
        //             business_type: u._id,
        //             is_added: false,
        //         });
        //         businessType.save();
        //     });
        // });

        Management.create({
          business: user._id,
          user: user._id,
          role: "Admin",
          created_at: new Date(),
          updated_at: new Date(),
        });

        BusinessVendor.create({
          vendor: user._id,
          business: business,
          created_at: user.created_at,
          updated_at: user.updated_at,
        });

        Address.create({
          user: user._id,
          address: address,
          area: req.body.area,
          landmark: req.body.landmark,
          zip: req.body.zip,
          city: req.body.city,
          state: req.body.state,
          created_at: new Date(),
          updated_at: new Date(),
        });

        res.status(200).json({
          responseCode: 200,
          responseMessage: "success",
          responseData: {
            user: user,
          },
        });
      });
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Phone number already in use.",
        responseData: {},
      });
    }
  }
});

router.get(
  "/lost/outbound/leads/get",
  xAccessToken.token,
  async function (req, res, next) {
    // console.log('Route is called...', req.query.query, req.query.by);
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers["business"];
    // console.log('User = ', user, business);

    var leads = [];
    var totalResult = 0;
    var role = await Management.findOne({
      user: user,
      business: business,
    }).exec();
    if (req.query.page == undefined) {
      var page = 0;
    } else {
      var page = req.query.page;
    }

    var page = Math.max(0, parseInt(page));
    var leads = [];
    var filters = [];
    var queries = {};

    if (req.query.query) {
      var specification = {};
      specification["$lookup"] = {
        from: "LeadGenRemark",
        localField: "remarks",
        foreignField: "_id",
        as: "remarks",
      };
      filters.push(specification);

      req.query.query = req.query.query.replace(
        /([.?*+^$[\]\\(){}|-])/g,
        "\\$1"
      );

      var specification = {};
      specification["$match"] = {
        business: mongoose.Types.ObjectId(business),
        $or: [
          { name: { $regex: req.query.query, $options: "i" } },
          { contact_no: { $regex: req.query.query, $options: "i" } },
          {
            remarks: {
              $elemMatch: {
                status: { $regex: req.query.query, $options: "i" },
              },
            },
          },
          {
            remarks: {
              $elemMatch: {
                customer_remark: { $regex: req.query.query, $options: "i" },
              },
            },
          },
          {
            remarks: {
              $elemMatch: {
                assignee_remark: { $regex: req.query.query, $options: "i" },
              },
            },
          },
        ],
      };

      filters.push(specification);

      await OutBoundLead.aggregate(filters)
        .allowDiskUse(true)
        .cursor({ batchSize: 20 })
        .exec()
        .eachAsync(async function (lead) {
          var assignee = await User.findById(lead.assignee).exec();
          leads.push({
            _id: lead._id,
            id: lead._id,
            name: lead.name,
            contact_no: lead.contact_no,
            status: lead.status,
            follow_up: lead.follow_up,
            priority: lead.priority,
            manager: {
              name: assignee.name,
              contact_no: assignee.contact_no,
              email: assignee.email,
            },
            additional_info: lead.additional_info,
            car: lead.car,
            isSelected: false,
          });
        });

      return res.status(200).json({
        responseCode: 200,
        responseInfo: {
          // filters: filters,
          msg: "Filter Leads",
          totalResult: leads.length,
        },
        responseMessage: "",
        totalLeads: leads.length,
        responseData: leads,
      });
    } else {
      var leads = [];
      var specification = {};
      specification["category"] = req.query.category;
      filters.push(specification);

      if (role.role == "CRE") {
        var specification = {};
        specification["assignee"] = mongoose.Types.ObjectId(role.user);
        filters.push(specification);
        var specification = {};
        specification["business"] = mongoose.Types.ObjectId(business);
        filters.push(specification);
      } else {
        var specification = {};
        specification["business"] = mongoose.Types.ObjectId(business);
        filters.push(specification);
      }
      if (req.query.status == "Follow-Up") {
        var specification = {};
        specification["status"] = req.query.status;
        specification["follow_up.date"] = { $lte: new Date() };
        if (req.query.date && req.query.endDate) {
          var date = new Date(req.query.date);
          var endDate = new Date(req.query.endDate);
          specification["follow_up.date"] = {
            $gte: new Date(date),
            $lte: new Date(endDate),
          };
        }
        // filters.push(specification);
        // var specification = {};
        // specification['$expr'] = {
        //     $and: [
        //         { $eq: [{ $month: "$follow_up.date" }, { $month: new Date() }] },
        //         // { $eq: [{ $dayOfMonth: "$follow_up.date" }, { $dayOfMonth: new Date() }] }
        //     ]
        // }
        filters.push(specification);
      } else if (req.query.status == "Open") {
        var specification = {};
        specification["status"] = req.query.status;
        if (req.query.date) {
          var date = new Date(req.query.date);
          var endDate = new Date(req.query.endDate);
          specification["updated_at"] = {
            $gte: new Date(date),
            $lte: new Date(endDate),
          };
        }
        filters.push(specification);
      } else if (req.query.status == "Converted") {
        var specification = {};
        specification["status"] = req.query.status;
        if (req.query.date) {
          var date = new Date(req.query.date);
          var endDate = new Date(req.query.endDate);
          specification["updated_at"] = {
            $gte: new Date(date),
            $lte: new Date(endDate),
          };
        }
        filters.push(specification);
      } else if (req.query.status == "Lost") {
        // console.log('Lost date filter is called....')
        var specification = {};
        var date = new Date();
        specification["status"] = req.query.status;
        if (req.query.source) {
          specification["source"] = { $eq: req.query.source };
        }
        if (req.query.date) {
          var date = new Date(req.query.date);
          //var newDate = moment(date, "DD-MM-YYYY").add(1, 'days');
          // Changes made by me
          var endDate = new Date(req.query.endDate);
          specification["remark.updated_at"] = {
            $gte: new Date(date),
            $lt: new Date(endDate),
          };
        }
        if (req.query.reason) {
          specification["additional_info.reason"] = req.query.reason;
        }
        if (req.query.source) {
          specification["source"] = req.query.source;
        }

        filters.push(specification);
      } else if (req.query.status == "Closed") {
        // console.log('Close lead is called........', req.query.status)
        var specification = {};
        specification["status"] = req.query.status;

        if (req.query.date) {
          var date = new Date(req.query.date);
          //var newDate = moment(date, "DD-MM-YYYY").add(1, 'days');
          var endDate = new Date(req.query.endDate);
          specification["created_at"] = {
            $gte: new Date(date),
            $lt: new Date(endDate),
          };
        }

        if (req.query.reason) {
          specification["reason"] = req.query.reason;
        }
        filters.push(specification);
      } else if (req.query.status == "Lost_Closed") {
        console.log("Stataus =" + req.query.status);
        // console.log('Close lead is called........', req.query.status)
        var specification = {};
        specification["status"] = { $in: ["Lost", "Closed"] };

        if (req.query.date) {
          var date = new Date(req.query.date);
          //var newDate = moment(date, "DD-MM-YYYY").add(1, 'days');
          var endDate = new Date(req.query.endDate);
          specification["created_at"] = {
            $gte: new Date(date),
            $lt: new Date(endDate),
          };
        }

        if (req.query.reason) {
          console.log("req.query.reason = " + req.query.reason);
          specification["reason"] = req.query.reason;
        }
        filters.push(specification);
      } else if (req.query.reason) {
        console.log("Reason Condition = " + req.query.reason);
        var specification = {};
        specification["additional_info.lost_reason"] = {
          $in: [req.query.reason],
        };
        filters.push(specification);
      }
      if (req.query.priority) {
        var priority = parseInt(req.query.priority);
        if (priority == 0) {
          var specification = {};
          specification["priority"] = { $in: [1, 2, 3] };
          filters.push(specification);
        } else {
          var specification = {};
          specification["priority"] = priority;
          filters.push(specification);
        }
      }

      var query = {
        $match: {
          $and: filters,
        },
      };

      var total = await OutBoundLead.aggregate([query]).exec();
      console.log("TotalCounts = " + total.length);
      var sortQuery = {};
      if (req.query.status == "Follow-Up") {
        sortQuery = { $sort: { "follow_up.date": -1 } };
      } else if (req.query.status == "Lost" || req.query.status == "Closed") {
        sortQuery = { $sort: { created_at: -1 } };
      } else if (req.query.status == "Open") {
        sortQuery = { $sort: { updated_at: -1 } };
      } else {
        sortQuery = { $sort: { created_at: -1 } };
      }

      await OutBoundLead.aggregate([
        query,
        sortQuery,
        { $skip: 10 * page },
        { $limit: 10 },
      ])
        .allowDiskUse(true)
        .cursor({ batchSize: 20 })
        .exec()
        .eachAsync(async function (lead) {
          var assignee = await User.findById(lead.assignee).exec();
          leads.push({
            _id: lead._id,
            id: lead._id,
            name: lead.name,
            contact_no: lead.contact_no,
            status: lead.status,
            follow_up: lead.follow_up,
            priority: lead.priority,
            manager: {
              name: assignee.name,
              contact_no: assignee.contact_no,
              email: assignee.email,
            },
            // additional_info: {
            //     address: result.additional_info.address,
            //     model: result.additional_info.model,
            //     location: result.additional_info.location,
            //     registration_no: result.additional_info.registration_no,
            //     brand: result.additional_info.brand,
            //     category: result.additional_info.category,
            //     variant:

            // },
            date_added: lead.date_added,
            additional_info: lead.additional_info,
            car: lead.car,
            isSelected: false,
          });
        });

      res.status(200).json({
        responseCode: 200,
        responseInfo: {
          // filters: filters,
          totalResult: total.length,
        },
        responseMessage: role.role + " Leads",
        totalLeads: leads.length,
        responseData: leads,
      });
    }
  }
);

router.get("/parties/get", xAccessToken.token, async function (req, res, next) {
  // console.l.log("Api Called")
  var token = req.headers["x-access-token"];
  var secret = config.secret;
  var decoded = jwt.verify(token, secret);
  var user = decoded.user;
  var business = req.headers["business"];
  var product = new Object();
  var result = [];
  if (req.query.page == undefined) {
    var page = 0;
  } else {
    var page = req.query.page;
  }
  var page = Math.max(0, parseInt(page));

  if (req.query.limit == undefined) {
    var limit = 20;
  } else {
    var limit = parseInt(req.query.limit);
  }

  var list = [];
  var type = req.query.type;
  // let startDate = req.query.from
  // let endDate = req.query.to
  // let brand = req.query.brand
  // console.l.l.log(startDate, req.query.end_date)

  // if (req.query.type == "business") {
  if (req.query.query) {
    req.query.query = req.query.query.replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1");
    // console.l.l.log("Query=  " + req.query.query)
    var query = {
      $and: [
        {
          // "account_info.type": "business",
          // "visibility": true,
          _id: { $ne: mongoose.Types.ObjectId(business) },
          $or: [
            {
              name: { $regex: req.query.query, $options: "i" },
            },
            {
              contact_no: { $regex: req.query.query, $options: "i" },
            },
          ],
        },
      ],
    };
    // console.l.log(query + " Query")
  } else {
    // console.l.l.log("Else 1216 ")
    var query = {
      // "account_info.type": "business",
      // "visibility": true,
      _id: { $ne: mongoose.Types.ObjectId(business) },
    };
  }
  // }
  // else {
  //     if (req.query.query) {
  // console.l.l.l.log("Query = " + req.query.query)
  //         var query = {
  //             $and: [
  //                 {
  //                     "account_info.type": "user",
  //                     $or: [
  //                         {
  //                             "name": { $regex: req.query.query, $options: 'i' }
  //                         },
  //                         {
  //                             "contact_no": { $regex: req.query.query, $options: 'i' }
  //                         },

  //                     ]
  //                 }
  //             ]
  //         }
  // console.l.l.l.log(query + " Query")
  //     }
  //     else {
  //         var query = {
  //             "account_info.type": "user"
  //         }
  //     }
  // }

  var totalResult = await User.find(query).count();
  // console.l.log("Total Result  = " + totalResult)
  await User.find(query)
    .skip(limit * page)
    .limit(limit)
    .sort({ created_at: -1 })
    .cursor()
    .eachAsync(async (user) => {
      var statementData = {};

      var details = await q.all(
        businessFunctions.getStatementDetails({
          user: user._id,
          business: business,
        })
      );
      if (details) {
        // console.log("Data = " + JSON.stringify(details));
        statementData = {
          // party: party,
          totalSale: details.totalSale - details.totalSaleCancelled,
          totalPurchase: details.totalPurchase - details.totalPurchaseCancelled,
          totalPaymentIn: details.totalPaymentIn,
          totalPaymentOut: details.totalPaymentOut,
          totalPurchaseCancelled: details.totalPurchaseCancelled,
          totalSaleCancelled: details.totalPurchaseCancelled,
          balance: details.balance.toFixed(2),
          lastTransaction: details.lastTransaction,
        };
      }
      var last_transaction = "-";
      if (statementData.lastTransaction !== null) {
        last_transaction = moment(statementData.lastTransaction)
          .tz(req.headers["tz"])
          .format("DD-MM-YYYY hh:mm A");
      }

      var party_type = user.account_info.type;
      if (party_type == "user") {
        party_type = "Individual";
      }

      result.push({
        _id: user._id,
        // id: user._id,
        name: user.name,
        email: user.email,
        business: business,
        balance: currencyFormatter.format(statementData.balance, {
          code: "INR",
        }),
        last_transaction: last_transaction,
        // statement: statementData,
        // referral_code: user.referral_code,
        contact_no: user.contact_no,
        party_type: party_type,
        // business_info: user.business_info,
        // account_info: user.account_info,
        // address: user.address,
        // bank_details: user.bank_details,

        // agent: user.agent,
        // partner: user.partner,
        // plans_details: busi,
        // created_at: moment(user.created_at).tz(req.headers['tz']).format('lll'),
        updated_at: moment(user.created_at).tz(req.headers["tz"]).format("lll"),
      });
    });

  result = await q.all(
    businessFunctions.removeDublicateDoumnets(result, "contact_no")
  );
  res.status(200).json({
    responseCode: 200,
    // responseInfo: {
    //     totalResult: totalResult
    // },
    // // responseQuery: query,
    responseMessage: "success",
    responseData: result,
  });
});

router.get(
  "/parties/get/record_payment",
  xAccessToken.token,
  async function (req, res, next) {
    // console.l.log("Api Called")
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers["business"];
    var product = new Object();
    var result = [];
    if (req.query.page == undefined) {
      var page = 0;
    } else {
      var page = req.query.page;
    }
    var page = Math.max(0, parseInt(page));

    if (req.query.limit == undefined) {
      var limit = 20;
    } else {
      var limit = parseInt(req.query.limit);
    }

    var list = [];
    var type = req.query.type;
    // let startDate = req.query.from
    // let endDate = req.query.to
    // let brand = req.query.brand
    // console.l.l.log(startDate, req.query.end_date)

    // if (req.query.type == "business") {
    if (req.query.query) {
      req.query.query = req.query.query.replace(
        /([.?*+^$[\]\\(){}|-])/g,
        "\\$1"
      );
      // console.l.l.log("Query=  " + req.query.query)
      var query = {
        $and: [
          {
            // "account_info.type": "business",
            // "visibility": true,
            _id: { $ne: mongoose.Types.ObjectId(business) },
            $or: [
              {
                name: { $regex: req.query.query, $options: "i" },
              },
              {
                contact_no: { $regex: req.query.query, $options: "i" },
              },
            ],
          },
        ],
      };
      // console.l.log(query + " Query")
    } else {
      // console.l.l.log("Else 1216 ")
      var query = {
        // "account_info.type": "business",
        // "visibility": true,
        _id: { $ne: mongoose.Types.ObjectId(business) },
      };
    }
    // }
    // else {
    //     if (req.query.query) {
    // console.l.l.l.log("Query = " + req.query.query)
    //         var query = {
    //             $and: [
    //                 {
    //                     "account_info.type": "user",
    //                     $or: [
    //                         {
    //                             "name": { $regex: req.query.query, $options: 'i' }
    //                         },
    //                         {
    //                             "contact_no": { $regex: req.query.query, $options: 'i' }
    //                         },

    //                     ]
    //                 }
    //             ]
    //         }
    // console.l.l.l.log(query + " Query")
    //     }
    //     else {
    //         var query = {
    //             "account_info.type": "user"
    //         }
    //     }
    // }

    var totalResult = await User.find(query).count();
    // console.l.log("Total Result  = " + totalResult)
    await User.find(query)
      .skip(limit * page)
      .limit(limit)
      .sort({ created_at: -1 })
      .cursor()
      .eachAsync(async (user) => {
        var statementData = {};

        var details = await q.all(
          businessFunctions.getStatementDetails({
            user: user._id,
            business: business,
          })
        );
        if (details) {
          // console.l.log("Data = " + JSON.stringify(details));
          statementData = {
            // party: party,
            totalSale: details.totalSale - details.totalSaleCancelled,
            totalPurchase:
              details.totalPurchase - details.totalPurchaseCancelled,
            totalPaymentIn: details.totalPaymentIn,
            totalPaymentOut: details.totalPaymentOut,
            totalPurchaseCancelled: details.totalPurchaseCancelled,
            totalSaleCancelled: details.totalPurchaseCancelled,
            balance: details.balance,
            lastTransaction: details.lastTransaction,
          };
        }

        result.push({
          _id: user._id,
          id: user._id,
          name: user.name,
          // email: user.email,
          // business: business,
          // statement: statementData,
          // referral_code: user.referral_code,
          contact_no: user.contact_no,
          // business_info: user.business_info,
          // account_info: user.account_info,
          // type: user.account_info.type,
          // address: user.address,
          // bank_details: user.bank_details,

          // agent: user.agent,
          // partner: user.partner,
          // plans_details: busi,
          // created_at: moment(user.created_at).tz(req.headers['tz']).format('ll'),
          // updated_at: moment(user.created_at).tz(req.headers['tz']).format('ll'),
        });
      });

    result = await q.all(
      businessFunctions.removeDublicateDoumnets(result, "contact_no")
    );
    res.status(200).json({
      responseCode: 200,
      responseInfo: {
        totalResult: totalResult,
      },
      // responseQuery: query,
      responseMessage: "success",
      responseData: result,
    });
  }
);

router.put(
  "/lead/mark/star",
  xAccessToken.token,
  async function (req, res, next) {
    console.log("body= ", JSON.stringify(req.body));
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers["business"];
    // // console.log("Lead Id= " + req.body.lead)
    var lead = await Lead.findById(req.body.lead).exec();
    if (lead) {
      await Lead.findOneAndUpdate(
        { _id: lead._id },
        { $set: { isStared: req.body.isStared } },
        { new: true },
        async function (err, doc) {
          res.status(200).json({
            responseCode: 200,
            responseMessage: "Marked Succes",
            responseData: {},
          });
        }
      );
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Lead not found",
        responseData: {},
      });
    }

    // res.status(200).json({
    //     responseCode: 200,
    //     responseMessage: "success",
    //     responseData: doc.services[req.body.service_index
    // });
  }
);

router.get("/all/reviews", xAccessToken.token, async function (req, res, next) {
  var token = req.headers["x-access-token"];
  var secret = config.secret;
  var decoded = jwt.verify(token, secret);

  var user = decoded.user;
  var businesses = [];

  if (req.query.page == undefined) {
    var page = 0;
  } else {
    var page = req.query.page;
  }

  var review = await Review.find({ business: req.query.id })
    .populate("user", "name username avatar")
    .sort({ created_at: -1 })
    .skip(config.perPage * page)
    .limit(config.perPage)
    .exec();

  var json = {
    responseCode: 200,
    responseMessage: "success",
    responseData: review,
  };

  res.status(200).json(json);
});

router.get(
  "/profile/detail",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      id: "required",
    };

    var validation = new Validator(req.query, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Error",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var rating = 0;
      var data = {};
      var userId = req.query.id;

      var user = await User.findOne({ _id: userId })
        .populate("follow")
        .populate("bookmark")
        .exec();
      if (user) {
        fun.profileView(user._id, decoded.user, req.headers["tz"]);

        if (user.account_info.type == "business") {
          var management = await Management.findOne({ user: user }).exec();
          if (management) {
            // business: management.business
            // var getBusinessConvenience = await BusinessConvenience.find({}).exec();
            // if (getBusinessConvenience.length > 0) {
            //     var booking_conveniences = getBusinessConvenience;
            // }
            // else {
            //     var booking_conveniences = [
            //         {
            //             _id: null,
            //             id: null,
            //             convenience: "Self Drop",
            //             charges: 0
            //         },
            //         {
            //             _id: null,
            //             id: null,
            //             convenience: "Pickup",
            //             charges: 0
            //         },
            //         {
            //             _id: null,
            //             id: null,
            //             convenience: "Doorstep",
            //             charges: 0
            //         },
            //         {
            //             _id: null,
            //             id: null,
            //             convenience: "Towing",
            //             charges: 0
            //         },
            //         {
            //             _id: null,
            //             id: null,
            //             convenience: "Flatbed Towing",
            //             charges: 0
            //         }
            //     ];
            // }

            var rating = await Review.find({
              business: management.business,
            }).exec();
            rating = _.meanBy(rating, (p) => p.rating);
            // console.log("Business Details")
            if (management.business.equals(userId)) {
              var user = await User.findOne({
                _id: management.business,
              }).exec();
              data = {
                // _id: user.id,
                // name: user.name,
                // username: user.username,
                // email: user.email,
                // contact_no: user.contact_no,
                // avatar: user.avatar,
                // avatar_address: user.avatar_address,
                // account_info: user.account_info,
                // address: user.address,
                // coordinates: user.geometry,
                // business_info: user.business_info,
                // joined: moment(user.created_at).tz(req.headers['tz']).format('ll'),
                // total_rating: parseFloat(rating.toFixed(1)),
                // optional_info: user.optional_info,
                // socialite: user.socialite,
                // agent: user.agent,
                // bank_details: user.bank_details,
                // is_chat_active: user.device.length > 0 ? true : false,
                // timing: await BusinessTiming.find({ business: user._id }).select('-created_at -updated_at').exec(),
                business_gallery: await BusinessGallery.find({
                  business: user._id,
                })
                  .select("-created_at -updated_at")
                  .exec(),
                // offer_gallery: await BusinessOffer.find({ business: user._id }).select('-created_at -updated_at').exec(),
                // is_bookmarked: user.is_bookmarked,
                // booking_conveniences: booking_conveniences,
                // totalViews: await ProfileView.find({ profile: user._id }).count().exec()
              };

              res.status(200).json({
                responseCode: 200,
                responseMessage: "success",
                responseData: data,
              });
            } else {
              var user = await User.findOne({ _id: userId }).exec();
              data = {
                // _id: user.id,
                // name: user.name,
                // username: user.username,
                // email: user.email,
                // contact_no: user.contact_no,
                // avatar: user.avatar,
                // avatar_address: user.avatar_address,
                // account_info: user.account_info,
                // address: user.address,
                // coordinates: user.geometry,
                // business_info: user.business_info,
                // joined: moment(user.created_at).tz(req.headers['tz']).format('ll'),
                // total_rating: rating,
                // optional_info: user.optional_info,
                // socialite: user.socialite,
                // agent: user.agent,
                // bank_details: user.bank_details,
                // is_chat_active: user.device.length > 0 ? true : false,
                // timing: await BusinessTiming.find({ business: user._id }).select('-created_at -updated_at').exec(),
                business_gallery: await BusinessGallery.find({
                  business: user._id,
                })
                  .select("-created_at -updated_at")
                  .exec(),
                // offer_gallery: await BusinessOffer.find({ business: user._id }).select('-created_at -updated_at').exec(),
                // is_bookmarked: user.is_bookmarked,
                // booking_conveniences: booking_conveniences,
                // totalViews: await ProfileView.find({ profile: user._id }).count().exec()
              };

              res.status(200).json({
                responseCode: 200,
                responseMessage: "success",
                responseData: data,
              });
            }
          } else {
            res.status(400).json({
              responseCode: 400,
              responseMessage: "User not found",
              responseData: data,
            });
          }
        } else {
          res.status(400).json({
            responseCode: 400,
            responseMessage: "Invalid Business Detail",
            responseData: data,
          });
        }

        // if (user.account_info.type == "user") {
        //     var points = 0;
        //     var level = 1;
        //     var gallerySize = 0;
        //     var media = [];

        //     var ti = 0
        //     await Post.find({ user: user._id, status: true }).populate('thumbnails').sort({ created_at: -1 }).cursor().eachAsync(async (post) => {
        //         var thumbnails = post.thumbnails;
        //         gallerySize = gallerySize + thumbnails.length;

        //         thumbnails.forEach(function (t) {
        //             if (ti < 6) {
        //                 media.push({
        //                     _id: t._id,
        //                     id: t._id,
        //                     post: t.post,
        //                     caption: t.caption,
        //                     day: t.day,
        //                     file: t.file,
        //                     type: t.type,
        //                     place: t.place,
        //                     file_address: t.file_address,
        //                     preview_address: t.preview_address,
        //                 });
        //             }

        //             ti = ti + 1;
        //         });
        //     });

        //     await Point.find({ user: user._id, type: "credit" }).cursor().eachAsync(async (u) => {
        //         points = points + u.points;
        //     });

        //     if (points >= 50 && points <= 2999) {
        //         level = 1;
        //     }
        //     else if (points >= 3000 && points <= 6999) {
        //         level = 2;
        //     }
        //     else if (points >= 7000 && points <= 11999) {
        //         level = 3;
        //     }
        //     else if (points >= 12000 && points <= 15999) {
        //         level = 4;
        //     }
        //     else if (points >= 16000) {
        //         level = 5;
        //     }

        //     data = {
        //         _id: user._id,
        //         id: user.id,
        //         name: user.name,
        //         username: user.username,
        //         email: user.email,
        //         contact_no: user.contact_no,
        //         avatar_address: user.avatar_address,
        //         account_info: user.account_info,
        //         address: user.address,
        //         optional_info: user.optional_info,
        //         joined: moment(user.created_at).tz(req.headers['tz']).format("MMM, YYYY"),
        //         socialite: user.socialite,
        //         totalViews: await ProfileView.find({ profile: user._id }).count().exec(),
        //         totalPosts: await Post.find({ user: user._id }).count().exec(),
        //         followers: await Follow.find({ follow: user._id }).count().exec(),
        //         followings: await Follow.find({ user: user._id }).count().exec(),
        //         is_following: user.is_following,
        //         is_followed: await Follow.find({ user: user._id, follow: decoded.user }).count().exec() > 0 ? true : false,
        //         is_chat_active: user.device.length > 0 ? true : false,
        //         points: {
        //             level: level,
        //             points: Math.ceil(points)
        //         },
        //         gallerySize: gallerySize - 5,
        //         gallery: media,
        //         agent: user.agent,
        //     }

        //     res.status(200).json({
        //         responseCode: 200,
        //         responseMessage: "success",
        //         responseData: data
        //     });
        // }
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage:
            "The phone number that you've entered doesn't match any account.",
          responseData: {},
        });
      }
    }
  }
);

router.put(
  "/vendor-info/update",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      user: "required",
      name: "required",
      contact_no: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "All field required",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var user = await User.findById(req.body.user).exec();
      if (user) {
        var check = await User.findOne({
          contact_no: req.body.contact_no,
          _id: { $ne: user._id },
          "account_info.type": user.account_info.type,
        }).exec();

        if (check) {
          res.status(400).json({
            responseCode: 400,
            responseMessage: "Contact no already exist",
            responseData: {},
          });
        } else {
          User.findOneAndUpdate(
            { _id: user._id },
            {
              $set: {
                name: req.body.name,
                contact_no: req.body.contact_no,
                email: req.body.email,
                "business_info.company_name": req.body.company_name,
                "business_info.gstin": req.body.gstin,
                updated_at: new Date(),
              },
            },
            { new: false },
            function (err, doc) {
              if (err) {
                res.status(422).json({
                  responseCode: 422,
                  responseMessage: "Error Occurred",
                  responseData: err,
                });
              } else {
                res.status(200).json({
                  responseCode: 200,
                  responseMessage: "User details updated...",
                  responseData: {},
                });
              }
            }
          );
        }
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "User not found",
          responseData: {},
        });
      }
    }
  }
);

router.get(
  "/payment/In-Out/list/get/old",
  xAccessToken.token,
  async function (req, res, next) {
    // console.l.log("Api Called")
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers["business"];

    if (req.query.page) {
      var page = req.query.page;
    } else {
      var page = 0;
    }
    var page = Math.max(0, parseInt(page));

    var filters = [];
    if (req.query.type == "Payment-In" || req.query.type == "Payment-Out") {
      var specification = {};
      specification["type"] = req.query.type;
      specification["business"] = mongoose.Types.ObjectId(business);
      filters.push(specification);

      // var specification = {};
      // specification['$lookup'] = {
      //     from: "User",
      //     localField: "user",
      //     foreignField: "_id",
      //     as: "user",
      // };
      // filters.push(specification);

      // var specification = {};
      // specification['$unwind'] = {
      //     path: "$user",
      //     preserveNullAndEmptyArrays: false
      // };
      // filters.push(specification);

      // var specification = {};
      if (req.query.query) {
        var specification = {};
        specification["$lookup"] = {
          from: "User",
          localField: "user",
          foreignField: "_id",
          as: "user",
        };
        req.query.query = req.query.query.replace(
          /([.?*+^$[\]\\(){}|-])/g,
          "\\$1"
        );

        var specification = {};
        specification["$match"] = {
          business: mongoose.Types.ObjectId(business),
          $or: [
            { type: { $regex: req.query.query, $options: "i" } },
            // { 'contact_no': { $regex: req.query.query, $options: 'i' } },
            {
              user: {
                $elemMatch: {
                  contact_no: { $regex: req.query.query, $options: "i" },
                },
              },
            },
          ],
        };

        filters.push(specification);
      } else if (req.query.date) {
        var date = new Date();
        //from 10-05-21to13-07-21
        if (req.query.dateType == "range") {
          var query = req.query.date;
          var ret = query.split("to");
          var from = new Date(ret[0]);
          var to = new Date(ret[1]);
        }

        // 70 Days
        else if (req.query.dateType == "period") {
          if (parseInt(req.query.date) > 1) {
            var days = parseInt(req.query.date);
            var from = new Date(
              date.getFullYear(),
              date.getMonth(),
              date.getDate() - days
            );
            var to = new Date(
              date.getFullYear(),
              date.getMonth(),
              date.getDate() + 1
            );
          } else if (parseInt(req.query.date) == 0) {
            var query = parseInt(req.query.date);
            var from = new Date(
              date.getFullYear(),
              date.getMonth(),
              date.getDate()
            );
            var to = new Date(
              date.getFullYear(),
              date.getMonth(),
              date.getDate() + 1
            );
          } else if (parseInt(req.query.date) == 1) {
            var query = parseInt(req.query.date);
            var from = new Date(
              date.getFullYear(),
              date.getMonth(),
              date.getDate() - 1
            );
            var to = new Date(
              date.getFullYear(),
              date.getMonth(),
              date.getDate()
            );
          }
        } else {
          var from = new Date(
            date.getFullYear(),
            date.getMonth(),
            date.getDate()
          );
          var to = new Date(
            date.getFullYear(),
            date.getMonth(),
            date.getDate() + 1
          );
        }
        // console.l.log("From = " + from)
        // console.l.log("To  = " + to)
        var specification = {};
        specification["transaction_date"] = { $gte: from, $lte: to };
        filters.push(specification);
      }
    }
    var query = {
      $match: {
        $and: filters,
      },
    };
    var results = [];
    var total = await Statements.aggregate([query]).exec();
    await Statements.aggregate([
      query,
      { $sort: { created_at: 1 } },
      { $skip: 10 * page },
      { $limit: 10 },
    ])
      .allowDiskUse(true)

      .cursor({ batchSize: 20 })
      .exec()
      .eachAsync(async function (transaction) {
        var statementData = {};
        var details = await q.all(
          businessFunctions.getStatementDetails({
            user: transaction.user,
            business: transaction.business,
          })
        );
        if (details) {
          // console.l.l.log("Data = " + JSON.stringify(details));

          statementData = {
            totalSale: details.totalSale - details.totalSaleCancelled,
            totalPurchase:
              details.totalPurchase - details.totalPurchaseCancelled,
            totalPaymentIn: details.totalPaymentIn,
            totalPaymentOut: details.totalPaymentOut,
            totalPurchaseCancelled: details.totalPurchaseCancelled,
            totalSaleCancelled: details.totalPurchaseCancelled,
            balance: details.balance,
            lastTransaction: details.lastTransaction,
            user: details.party,
          };
        }
        results.push({
          user: transaction.user,
          transaction_id: transaction.transaction_id,
          payment_mode: transaction.payment_mode,
          transaction_amount: transaction.transaction_amount,
          balance: transaction.balance,
          statementDetails: statementData,
          transaction_date: moment(transaction.transaction_date)
            .tz(req.headers["tz"])
            .format("lll"),
          created_at: moment(transaction.created_at)
            .tz(req.headers["tz"])
            .format("lll"),
          updated_at: moment(transaction.updated_at)
            .tz(req.headers["tz"])
            .format("lll"),
        });
      });

    res.status(200).json({
      responseCode: 200,
      responseInfo: {
        // filters: filters,
        totalResult: total.length,
      },
      responseMessage: "Total " + req.query.type,
      totalLeads: results.length,
      responseData: results,
    });
    // else {
    //     var query = {
    //         type: 'Payment-In', business: business, payment_status: { $ne: 'Failure' }
    //     }
    // }

    // var totalResult = await User.find(query).count();
    // console.l.l.log("Total Result  = " + totalResult)
    // await Statements.find(query)
    //     .skip(limit * page).limit(limit)
    //     .sort({ created_at: -1 })
    //     .populate({ path: 'user', select: 'name contact_no' })
    //     .cursor().eachAsync(async (statement) => {
    //         var statementData = {};

    //         var details = await q.all(businessFunctions.getStatementDetails({ user: statement.user._id, business: statement.business }));
    //         if (details) {
    // console.l.l.log("Data = " + JSON.stringify(details));
    //             statementData = {
    //                 // party: party,
    //                 totalSale: details.totalSale - details.totalSaleCancelled,
    //                 totalPurchase: details.totalPurchase - details.totalPurchaseCancelled,
    //                 totalPaymentIn: details.totalPaymentIn,
    //                 totalPaymentOut: details.totalPaymentOut,
    //                 totalPurchaseCancelled: details.totalPurchaseCancelled,
    //                 totalSaleCancelled: details.totalPurchaseCancelled,
    //                 balance: details.balance,
    //                 lastTransaction: details.lastTransaction
    //             }
    //         }

    //         result.push({
    //             user: statement.user,
    //             business: statement.business,
    //             statement: statementData,
    //             // referral_code: user.referral_code,
    //             contact_no: statement.user.contact_no,
    //             business_info: user.business_info,
    //             account_info: user.account_info,
    //             // type: user.account_info.type,
    //             // address: user.address,
    //             // bank_details: user.bank_details,

    //             // agent: user.agent,
    //             // partner: user.partner,
    //             // plans_details: busi,
    //             created_at: moment(user.created_at).tz(req.headers['tz']).format('ll'),
    //             updated_at: moment(user.created_at).tz(req.headers['tz']).format('ll'),
    //         })
    //     });

    // result = await q.all(businessFunctions.removeDublicateDoumnets(result, "contact_no"));
    // res.status(200).json({
    //     responseCode: 200,
    //     responseInfo: {
    //         totalResult: totalResult
    //     },
    //     responseQuery: query,
    //     responseMessage: "success",
    //     responseData: result
    // });
  }
);

router.get(
  "/payment/In-Out/list/get",
  xAccessToken.token,
  async function (req, res, next) {
    // console.l.log("Api Called")
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers["business"];

    if (req.query.page) {
      var page = req.query.page;
    } else {
      var page = 0;
    }
    var page = Math.max(0, parseInt(page));

    var filters = [];
    if (req.query.type == "Payment-In" || req.query.type == "Payment-Out") {
      if (req.query.query) {
        var filters = [];
        var specification = {};
        specification["$lookup"] = {
          from: "User",
          localField: "user",
          foreignField: "_id",
          as: "user",
        };
        filters.push(specification);

        var specification = {};
        specification["$unwind"] = {
          path: "$user",
          preserveNullAndEmptyArrays: false,
        };
        filters.push(specification);

        req.query.query = req.query.query.replace(
          /([.?*+^$[\]\\(){}|-])/g,
          "\\$1"
        );
        // console.log("Data = " + req.query.query)
        var specification = {};
        specification["$match"] = {
          type: req.query.type,
          business: mongoose.Types.ObjectId(business),
          $or: [
            // { 'type': { $regex: req.query.query, $options: 'i' } },
            { "user.name": { $regex: req.query.query, $options: "i" } },
            { "user.contact_no": { $regex: req.query.query, $options: "i" } },
            { transaction_id: { $regex: req.query.query, $options: "i" } },
          ],
        };
        filters.push(specification);

        var specification = {};
        specification["$sort"] = {
          updated_at: -1,
        };
        filters.push(specification);

        var specification = {};
        specification["$skip"] = config.perPage * page;
        filters.push(specification);

        var specification = {};
        specification["$limit"] = config.perPage;
        filters.push(specification);

        var results = [];
        var total = await Statements.aggregate(filters).exec();
        await Statements.aggregate(filters)
          .allowDiskUse(true)
          .cursor({ batchSize: 20 })
          .exec()
          .eachAsync(async function (transaction) {
            var statementData = {};
            var details = await q.all(
              businessFunctions.getStatementDetails({
                user: transaction.user,
                business: transaction.business,
              })
            );
            if (details) {
              // console.l.l.log("Data = " + JSON.stringify(details));
              statementData = {
                totalSale: details.totalSale - details.totalSaleCancelled,
                totalPurchase:
                  details.totalPurchase - details.totalPurchaseCancelled,
                totalPaymentIn: details.totalPaymentIn,
                totalPaymentOut: details.totalPaymentOut,
                totalPurchaseCancelled: details.totalPurchaseCancelled,
                totalSaleCancelled: details.totalPurchaseCancelled,
                balance: details.balance,
                lastTransaction: details.lastTransaction,
                user: details.party,
              };
            }
            results.push({
              _id: transaction._id,
              party_name: statementData.user.name,
              user: transaction.user._id,
              transaction_id: transaction.transaction_id,
              payment_mode: transaction.payment_mode,
              transaction_amount: currencyFormatter.format(
                transaction.transaction_amount,
                { code: "INR" }
              ),
              balance: currencyFormatter.format(transaction.balance, {
                code: "INR",
              }),
              // statementDetails: statementData,
              transaction_date: moment(transaction.transaction_date)
                .tz(req.headers["tz"])
                .format("lll"),
              // created_at: moment(transaction.created_at).tz(req.headers['tz']).format('lll'),
              updated_at: moment(transaction.updated_at)
                .tz(req.headers["tz"])
                .format("lll"),
            });
          });

        res.status(200).json({
          responseCode: 200,
          // responseInfo: {
          //     // filters: filters,
          //     totalResult: total.length
          // },
          responseMessage: "Total " + req.query.type,
          // totalLeads: results.length,
          responseData: results,
        });
      } else {
        var specification = {};
        specification["type"] = req.query.type;
        specification["business"] = mongoose.Types.ObjectId(business);
        filters.push(specification);
        if (req.query.date) {
          var date = new Date();
          //from 10-05-21to13-07-21
          if (req.query.dateType == "range") {
            var query = req.query.date;
            var ret = query.split("to");
            var from = new Date(ret[0]);
            var to = new Date(ret[1]);
          }

          // 70 Days
          else if (req.query.dateType == "period") {
            if (parseInt(req.query.date) > 1) {
              var days = parseInt(req.query.date);
              var from = new Date(
                date.getFullYear(),
                date.getMonth(),
                date.getDate() - days
              );
              var to = new Date(
                date.getFullYear(),
                date.getMonth(),
                date.getDate() + 1
              );
            } else if (parseInt(req.query.date) == 0) {
              var query = parseInt(req.query.date);
              var from = new Date(
                date.getFullYear(),
                date.getMonth(),
                date.getDate()
              );
              var to = new Date(
                date.getFullYear(),
                date.getMonth(),
                date.getDate() + 1
              );
            } else if (parseInt(req.query.date) == 1) {
              var query = parseInt(req.query.date);
              var from = new Date(
                date.getFullYear(),
                date.getMonth(),
                date.getDate() - 1
              );
              var to = new Date(
                date.getFullYear(),
                date.getMonth(),
                date.getDate()
              );
            }
          } else {
            var from = new Date(
              date.getFullYear(),
              date.getMonth(),
              date.getDate()
            );
            var to = new Date(
              date.getFullYear(),
              date.getMonth(),
              date.getDate() + 1
            );
          }
          var specification = {};
          specification["transaction_date"] = { $gte: from, $lte: to };
          filters.push(specification);
        }
        var query = {
          $match: {
            $and: filters,
          },
        };
        var results = [];
        var total = await Statements.aggregate([query]).exec();
        await Statements.aggregate([
          query,
          { $sort: { transaction_date: -1 } },
          { $skip: 10 * page },
          { $limit: 10 },
        ])
          .allowDiskUse(true)
          .cursor({ batchSize: 20 })
          .exec()
          .eachAsync(async function (transaction) {
            // console.log("djvfrv= ", JSON.stringify(transaction._id))
            var statementData = {};
            var details = await q.all(
              businessFunctions.getStatementDetails({
                user: transaction.user,
                business: transaction.business,
              })
            );
            if (details) {
              // console.l.l.log("Data = " + JSON.stringify(details));
              statementData = {
                totalSale: details.totalSale - details.totalSaleCancelled,
                totalPurchase:
                  details.totalPurchase - details.totalPurchaseCancelled,
                totalPaymentIn: details.totalPaymentIn,
                totalPaymentOut: details.totalPaymentOut,
                totalPurchaseCancelled: details.totalPurchaseCancelled,
                totalSaleCancelled: details.totalPurchaseCancelled,
                balance: details.balance,
                lastTransaction: details.lastTransaction,
                user: details.party,
              };
            }
            results.push({
              _id: transaction._id,
              party_name: statementData.user.name,
              user: transaction.user,
              transaction_id: transaction.transaction_id,
              payment_mode: transaction.payment_mode,
              transaction_amount: currencyFormatter.format(
                transaction.transaction_amount,
                { code: "INR" }
              ),
              balance: currencyFormatter.format(transaction.balance, {
                code: "INR",
              }),
              // statementDetails: statementData,
              transaction_date: moment(transaction.transaction_date)
                .tz(req.headers["tz"])
                .format("lll"),
              // created_at: moment(transaction.created_at).tz(req.headers['tz']).format('lll'),
              updated_at: moment(transaction.updated_at)
                .tz(req.headers["tz"])
                .format("lll"),
            });
          });

        res.status(200).json({
          responseCode: 200,
          // responseInfo: {
          //     // filters: filters,
          //     totalResult: total.length
          // },
          responseMessage: "Total " + req.query.type,
          // totalLeads: results.length,
          responseData: results,
        });
      }
    }
  }
);

router.post(
  "/record/party/payment",
  xAccessToken.token,
  async function (req, res, next) {
    businessFunctions.logs(
      "INFO: /record/party/payment Api Called from 3.0.js," +
        " " +
        "Request Headers:" +
        JSON.stringify(req.headers) +
        ", " +
        "Request Body:" +
        JSON.stringify(req.body)
    );

    var rules = {
      user: "required",
      amount: "required",
      type: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      if (
        Log_Level == 1 ||
        Log_Level == 5 ||
        Log_Level == 6 ||
        Log_Level == 7 ||
        Log_Level == 0
      ) {
        businessFunctions.logs(
          "ERROR: Validation failed, user,amount,type are required."
        );
      }
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Validation Error",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var user = decoded.user;
      var business = req.headers["business"];
      var referrals = [];
      var total = 0,
        used = 0;
      var loggedInDetails = await User.findById(user).exec();

      if (
        Log_Level == 4 ||
        Log_Level == 6 ||
        Log_Level == 8 ||
        Log_Level == 10 ||
        Log_Level == 0
      ) {
        businessFunctions.logs(
          "DEBUG: Validated Successfully and fatching user details to make payment," +
            " " +
            "UserId:" +
            req.body.user +
            ", " +
            "User:" +
            loggedInDetails.name
        );
      }
      var party = await User.findById(req.body.user).exec();
      if (party) {
        var data = {
          user: req.body.user,
          business: business,
          status: req.body.type,
          type: req.body.type,
          paid_by: req.body.paid_by,
          activity: req.body.type,
          source: req.body.user,
          bill_id: "N/A",
          bill_amount: parseFloat(req.body.amount),
          transaction_amount: parseFloat(req.body.amount),
          balance: parseFloat(req.body.amount),
          total: parseFloat(req.body.amount),
          paid_total: 0,
          due: 0,
          payment_status: "Success",
          payment_mode: req.body.payment_mode,
          received_by: loggedInDetails.name,
          transaction_id: req.body.transaction_id,
          transaction_date: new Date(req.body.transaction_date),
          transaction_status: "Success",
          transaction_response: "Success",
          transaction_type: req.body.type,
          remark: req.body.remark,
        };
        if (
          Log_Level == 4 ||
          Log_Level == 6 ||
          Log_Level == 8 ||
          Log_Level == 10 ||
          Log_Level == 0
        ) {
          businessFunctions.logs(
            "DEBUG: businessFunctions.addTransaction(data) function called to process Payment, User:" +
              loggedInDetails.name
          );
        }
        var valid = q.all(businessFunctions.addTransaction(data));

        // console.l.l.log("valid = " + JSON.stringfy(valid))
        if (
          Log_Level == 4 ||
          Log_Level == 6 ||
          Log_Level == 8 ||
          Log_Level == 10 ||
          Log_Level == 0
        ) {
          businessFunctions.logs(
            "DEBUG: Payment Processed Successfully and response send successfully, Party Name:" +
              req.body.name +
              ", " +
              "Amount:" +
              req.body.amount +
              ", " +
              "User:" +
              loggedInDetails.name
          );
        }
        res.status(200).json({
          responseCode: 200,
          responseMessage: "success",
          responseData: data,
        });
        if (
          Log_Level == 3 ||
          Log_Level == 7 ||
          Log_Level == 9 ||
          Log_Level == 10 ||
          Log_Level == 0
        ) {
          businessFunctions.logs(
            "INFO: Payment Successfull, Activity:" +
              req.body.type +
              "Party Name:" +
              req.body.name +
              ", " +
              "Amount:" +
              req.body.amount +
              ", " +
              "Received By:" +
              loggedInDetails.name
          );
        }
      } else {
        if (
          Log_Level == 2 ||
          Log_Level == 5 ||
          Log_Level == 8 ||
          Log_Level == 9 ||
          Log_Level == 0
        ) {
          businessFunctions.logs(
            "WARNING: No Party Details found with the given user, UserId:" +
              req.body.user +
              ", " +
              "User:" +
              loggedInDetails.name
          );
        }
        res.status(422).json({
          responseCode: 422,
          responseMessage: "Party not Found",
          responseData: data,
        });
      }
    }
  }
);

router.get(
  "/party/statements/get",
  xAccessToken.token,
  async function (req, res, next) {
    // console.l.log("Api Called")
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers["business"];
    var product = new Object();
    var result = [];
    var duration = {};

    // let startDate = req.query.from
    // let endDate = req.query.to
    // let brand = req.query.brand

    // console.l.log("Total Result  = " + totalResult)
    if (req.query.page == undefined) {
      var page = 0;
    } else {
      var page = req.query.page;
    }
    var page = Math.max(0, parseInt(page));

    if (req.query.limit == undefined) {
      var limit = 10;
    } else {
      var limit = parseInt(req.query.limit);
    }
    var transactions = [];
    if (req.query.date) {
      var date = new Date();
      //from 10-05-21to13-07-21
      if (req.query.dateType == "range") {
        var query = req.query.date;
        var ret = query.split("to");
        var from = new Date(ret[0]);
        var to = new Date(ret[1]);
      }

      // 70 Days
      else if (req.query.dateType == "period") {
        if (parseInt(req.query.date) > 1) {
          var days = parseInt(req.query.date);
          var from = new Date(
            date.getFullYear(),
            date.getMonth(),
            date.getDate() - days
          );
          var to = new Date(
            date.getFullYear(),
            date.getMonth(),
            date.getDate() + 1
          );
        } else if (parseInt(req.query.date) == 0) {
          var query = parseInt(req.query.date);
          var from = new Date(
            date.getFullYear(),
            date.getMonth(),
            date.getDate()
          );
          var to = new Date(
            date.getFullYear(),
            date.getMonth(),
            date.getDate() + 1
          );
        } else if (parseInt(req.query.date) == 1) {
          var query = parseInt(req.query.date);
          var from = new Date(
            date.getFullYear(),
            date.getMonth(),
            date.getDate() - 1
          );
          var to = new Date(
            date.getFullYear(),
            date.getMonth(),
            date.getDate()
          );
        }
      } else {
        var from = new Date(
          date.getFullYear(),
          date.getMonth(),
          date.getDate()
        );
        var to = new Date(
          date.getFullYear(),
          date.getMonth(),
          date.getDate() + 1
        );
      }

      // console.log("From = " + from + " TO " + to)
      var duration = {
        from: from,
        to: to,
      };

      query = {
        user: req.query.user,
        payment_status: { $ne: "Failure" },
        business: business,
        transaction_date: { $gte: from, $lte: to },
      };
      var totalResult = await Statements.find(query).count();
      await Statements.find(query)
        .populate({ path: "user", select: "name contact_no" })
        .populate({ path: "business", select: "name contact_no" })
        .skip(limit * page)
        .limit(limit)
        .sort({ Updated_at: 1 })
        .cursor()
        .eachAsync(async (statements) => {
          var transaction_date = "";
          if (
            statements.type == "Payment-Out" ||
            statements.type == "Payment-In"
          ) {
            transaction_date = moment(statements.transaction_date)
              .tz(req.headers["tz"])
              .format("ll");
          } else {
            transaction_date = moment(statements.transaction_date)
              .tz(req.headers["tz"])
              .format("lll");
          }

          transactions.push({
            user: statements.user,
            business: statements.business,
            status: statements.status,
            type: statements.type,
            paid_by: statements.paid_by,
            activity: statements.activity,
            source: statements.source,
            bill_id: statements.bill_id,
            bill_amount: statements.bill_amount,
            transaction_amount: statements.transaction_amount,
            balance: statements.balance,
            total: statements.total,
            paid_total: statements.paid_total,
            // due: parseFloat(statements.bill_amount) - parseFloat(statements.paid_total),
            payment_status: statements.payment_status,
            payment_mode: statements.payment_mode,
            received_by: statements.received_by,
            transaction_id: statements.transaction_id,
            transaction_date: transaction_date,
            transaction_status: statements.transaction_status,
            transaction_response: statements.transaction_response,
            // transaction_type: statements.transaction_type,
          });
        });
    } else {
      var list = [];
      var query = {
        user: req.query.user,
        payment_status: { $ne: "Failure" },
        business: business,
      };

      var totalResult = await Statements.find(query).count();

      await Statements.find(query)
        .populate({ path: "user", select: "name contact_no" })
        .populate({ path: "business", select: "name contact_no" })
        .skip(limit * page)
        .limit(limit)
        .sort({ Updated_at: 1 })
        .cursor()
        .eachAsync(async (statements) => {
          var transaction_date = "";
          if (
            statements.type == "Payment-Out" ||
            statements.type == "Payment-In"
          ) {
            transaction_date = moment(statements.transaction_date)
              .tz(req.headers["tz"])
              .format("ll");
          } else {
            transaction_date = moment(statements.transaction_date)
              .tz(req.headers["tz"])
              .format("lll");
          }

          transactions.push({
            user: statements.user,
            business: statements.business,
            status: statements.status,
            type: statements.type,
            paid_by: statements.paid_by,
            activity: statements.activity,
            source: statements.source,
            bill_id: statements.bill_id,
            bill_amount: statements.bill_amount,
            transaction_amount: statements.transaction_amount,
            balance: statements.balance,
            total: statements.total,
            paid_total: statements.paid_total,
            // due: parseFloat(statements.bill_amount) - parseFloat(statements.paid_total),
            payment_status: statements.payment_status,
            payment_mode: statements.payment_mode,
            received_by: statements.received_by,
            transaction_id: statements.transaction_id,
            transaction_date: transaction_date,
            transaction_status: statements.transaction_status,
            transaction_response: statements.transaction_response,
            // transaction_type: statements.transaction_type,
          });
        });

      //     var user =req.query.user;
      //    await event.partyStatement(user);
      //     console.log("sadsfdsfd---------------------"+user);
    }

    // result = await q.all(businessFunctions.removeDublicateDoumnets(result, "contact_no"));
    res.status(200).json({
      responseCode: 200,
      responseInfo: {
        totalResult: totalResult,
        // duration: duration
      },
      // responseQuery: query,
      responseMessage: "success",
      responseData: transactions,
    });
  }
);

router.get(
  "/party/statement/details",
  xAccessToken.token,
  async function (req, res, next) {
    // console.l.log("Api Called")
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers["business"];
    var product = new Object();
    var result = [];
    var party = await User.findById(req.query.user).exec();
    if (party) {
      var query = {
        user: party._id,
        business: business,
      };
      var businessDetails = await User.findById(business).exec();
      var details = await q.all(businessFunctions.getStatementDetails(query));

      if (details) {
        var data = {
          // party: party,
          party_name: party.name,
          party_contact_no: party.contact_no,
          party_address: party.address.address,
          created_at: party.created_at,
          totalSale: (details.totalSale - details.totalSaleCancelled).toFixed(
            2
          ),
          totalPurchase: details.totalPurchase - details.totalPurchaseCancelled,
          totalPaymentIn: details.totalPaymentIn.toFixed(2),
          totalPaymentOut: details.totalPaymentOut.toFixed(2),
          totalPurchaseCancelled: details.totalPurchaseCancelled,
          totalSaleCancelled: details.totalPurchaseCancelled,
          balance: currencyFormatter.format(details.balance, { code: "INR" }),
          request_balance: details.balance.toFixed(2),
          // business: businessDetails,
        };
        res.status(200).json({
          responseCode: 200,
          responseMessage: "Success",
          responseData: data,
        });
      } else {
        res.status(422).json({
          responseCode: 422,
          responseMessage: "transactions not Found",
          responseData: {},
        });
      }
    } else {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Party not Found",
        responseData: {},
      });
    }
  }
);

router.get(
  "/vendor/quotations/list/get",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var business = req.headers["business"];

    var quotations = [];
    if (req.query.page == undefined) {
      var page = 0;
    } else {
      var page = req.query.page;
    }

    if (req.query.limit) {
      var limit = parseInt(req.query.limit);
    } else {
      var limit = 20;
    }
    // , 'Confirmed'/
    var quotations = [];
    await VendorOrders.find({
      vendor: business,
      status: { $in: ["Requested", "Submitted"] },
    })
      .populate({ path: "business", select: "name contact_no" })
      .populate({ path: "quotation", select: "quotation_no updated_at" })
      .sort({ created_at: -1 })
      .skip(limit * page)
      .limit(limit)
      .cursor()
      .eachAsync(async (p) => {
        var parts = _.filter(p.parts, (part) => part.status != "Not requested");

        var car = "";
        if (p.car) {
          car = p.car.variant;
        }
        // quotations.push(p);
        quotations.push({
          id: p.id,
          _id: p._id,
          business: p.business.name,
          car: car,
          // contact_no: p.contact_no,
          totat_parts: parts.length,
          // quotation: p.quotation,
          request_date: p.request_date,
          status: p.status,
          // vendor: p.vendor,
          // created_at: p.created_at,
          updated_at: p.updated_at,
        });
      });
    // console.log("Length  = " + quotations.length)
    res.status(200).json({
      responseCode: 200,
      responseMessage: "Sucesss",
      responseInfo: {
        totalResult: await VendorOrders.find({
          vendor: business,
          status: { $in: ["Requested", "Submitted"] },
        })
          .count()
          .exec(),
      },
      // , 'Confirmed'
      responseData: {
        quotations: quotations,
      },
    });
  }
);

router.get(
  "/vendor/quotation/details",
  xAccessToken.token,
  async function (req, res, next) {
    businessFunctions.logs(
      "INFO: /vendor/quotation/details Api Called from 3.0.js," +
        " " +
        "Request Headers:" +
        JSON.stringify(req.headers) +
        ", " +
        "Request Query:" +
        JSON.stringify(req.query)
    );

    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var business = req.headers["business"];
    var user = await User.findById(decoded.user).exec();

    if (
      Log_Level == 4 ||
      Log_Level == 6 ||
      Log_Level == 8 ||
      Log_Level == 10 ||
      Log_Level == 0
    ) {
      businessFunctions.logs(
        "DEBUG: Fatching order details, OrderId:" +
          req.query.id +
          ", " +
          "User:" +
          user.name
      );
    }
    var order = await VendorOrders.findOne({
      _id: req.query.id,
      vendor: business,
      status: { $in: ["Requested", "Submitted", "Confirmed"] },
    })
      .populate({ path: "business", select: "name contact_no address" })
      .populate({ path: "quotation", select: "quotation_no buyerRemark" })
      .populate("car")
      .exec();
    if (order) {
      var total_GST = 0;
      var total_rate = 0;
      for (var i = 0; i < order.parts.length; i++) {
        total_GST = total_GST + order.parts[i].tax_amount;
        total_rate =
          total_rate + order.parts[i].unit_base_price * order.parts[i].quantity;
      }

      var orders = {
        name: order.business.name,
        contact_no: order.business.contact_no,
        total_amount: order.total_amount,
        total_GST: total_GST,
        total_rate: total_rate,
        city: order.business.address.city,
        buyersRemark: order.quotation.buyerRemark,
        parts: order.parts,
        created_at: order.created_at,
        request_date: order.request_date,
      };

      res.status(200).json({
        responseCode: 200,
        responseMessage: "Sucesss",
        responseData: {
          order: orders,
        },
      });
      if (
        Log_Level == 3 ||
        Log_Level == 7 ||
        Log_Level == 9 ||
        Log_Level == 10 ||
        Log_Level == 0
      ) {
        businessFunctions.logs(
          "INFO: Quotation Order Details send in Response Successfully, OrderId:" +
            req.query.id +
            ", " +
            "Requested By:" +
            order.business.name +
            ", " +
            "User:" +
            user.name
        );
      }
    } else {
      if (
        Log_Level == 2 ||
        Log_Level == 5 ||
        Log_Level == 8 ||
        Log_Level == 9 ||
        Log_Level == 0
      ) {
        businessFunctions.logs(
          "WARNING: No Quotation Request Order found with the given orderId:" +
            req.query.id +
            ", " +
            "User:" +
            user.name
        );
      }
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Order not found",
        responseData: {},
      });
    }
  }
);

// router.get('/taxes/get', async function (req, res, next) {
//     var tz = req.headers['tz'];
//     if (tz) {
//         var country = await Country.findOne({ timezone: { $in: tz } }).exec();
//         if (country) {
//             var taxes = await Tax.find({ country: country._id, type: 'GST' }).sort({ count: -1 }).exec()
//             result = await q.all(businessFunctions.removeDublicateDoumnets(taxes, "tax"));
//             res.status(200).json({
//                 responseCode: 200,
//                 responseMessage: "Tax Slabs",
//                 responseInfo: {
//                     taxes: _.map(result, 'rate')
//                 },
//                 responseData: result,
//             })
//         }
//         else {
//             res.status(400).json({
//                 responseCode: 400,
//                 responseMessage: "Tax Slabs",
//                 responseData: {}
//             })
//         }
//     }
//     else {
//         res.status(400).json({
//             responseCode: 400,
//             responseMessage: "Tax Slabs",
//             responseData: {}
//         })
//     }
// });

router.put("/quotation/price/update", async (req, res, next) => {
  businessFunctions.logs(
    "INFO: /quotation/price/update Api Called from 3.0.js," +
      " " +
      "Request Headers:" +
      JSON.stringify(req.headers) +
      ", " +
      "Request Body:" +
      JSON.stringify(req.body)
  );

  var token = req.headers["x-access-token"];
  var secret = config.secret;
  var decoded = jwt.verify(token, secret);
  var user = decoded.user;
  var business = req.headers["business"];
  var loggedInDetails = await User.findById(decoded.user).exec();
  var parts = req.body.parts;
  var orderId = req.body.orderId;
  var status = req.body.status;
  // console.log("parts  ", parts)

  if (
    Log_Level == 4 ||
    Log_Level == 6 ||
    Log_Level == 8 ||
    Log_Level == 10 ||
    Log_Level == 0
  ) {
    businessFunctions.logs(
      "DEBUG: Fatching Quotation Requests order details, OrderId:" +
        req.body.orderId +
        ", " +
        "User:" +
        loggedInDetails.name
    );
  }
  var order = await VendorOrders.findById(orderId).exec();
  if (order) {
    var items = [];
    var tax = [];
    var total = 0;
    // console.log("parts ", parts)
    if (parts.length > 0) {
      for (var p = 0; p < parts.length; p++) {
        var car = null;
        if (parts[p].car) {
          car = {
            mfg: parts[p].car.mfg,
            registration_no: parts[p].car.registration_no,
            title: parts[p].car.title,
            vin: parts[p].car.vin,
          };
        }
        if (parts[p].isChecked) {
          if (parts[p].quantity != null) {
            var tax_info = await Tax.findOne({ tax: parts[p].tax }).exec();
            if (tax_info) {
              // console.log("Product ")
              var tax_rate = tax_info.detail;
              var base = parseFloat(parts[p].base);
              // console.log("Base  = " + base)
              var discount = parts[p].discount;
              var amount = parseFloat(parts[p].base);
              // if(discount.indexOf("%")>=0)
              // {
              //     discount = parseFloat(discount);
              //     if(!isNaN(discount) && discount>0)
              //     {
              //         var discount_total = amount*(discount/100);
              //         amount = amount-parseFloat(discount_total.toFixed(2))
              //     }
              // }
              // else
              // {
              // discount = parseFloat(discount);
              // if (!isNaN(discount) && discount > 0) {
              //     base = base - parseFloat(discount.toFixed(2))
              // }
              // }
              parts[p].amount_is_tax = "exclusive";

              if (parts[p].amount_is_tax == "exclusive") {
                if (
                  Log_Level == 4 ||
                  Log_Level == 6 ||
                  Log_Level == 8 ||
                  Log_Level == 10 ||
                  Log_Level == 0
                ) {
                  businessFunctions.logs(
                    "DEBUG: Calculate Tax details for exclusive tax."
                  );
                }
                var tax_on_amount = amount;

                if (tax_rate.length > 0) {
                  for (var r = 0; r < tax_rate.length; r++) {
                    if (tax_rate[r].rate != tax_info.rate) {
                      var t = tax_on_amount * (tax_rate[r].rate / 100);
                      amount = amount + t;
                      // console.log("Tax AMO=" + t)
                      tax.push({
                        tax: tax_rate[r].tax,
                        rate: tax_rate[r].rate,
                        amount: parseFloat(t.toFixed(2)),
                      });
                    } else {
                      var t = tax_on_amount * (tax_info.rate / 100);
                      amount = amount + t;
                      // console.log("Tax AMO=" + t)

                      tax.push({
                        tax: tax_info.tax,
                        tax_rate: tax_info.rate,
                        rate: tax_info.rate,
                        amount: parseFloat(t.toFixed(2)),
                      });
                    }
                  }
                }
                total = total + amount;

                // console.log("Amount  = " + amount)
              }

              if (parts[p].amount_is_tax == "inclusive") {
                var x = (100 + tax_info.rate) / 100;
                var tax_on_amount = amount / x;
                if (tax_rate.length > 0) {
                  for (var r = 0; r < tax_rate.length; r++) {
                    if (tax_rate[r].rate != tax_info.rate) {
                      var t = tax_on_amount * (tax_rate[r].rate / 100);
                      base = base - t;
                      tax.push({
                        tax: tax_rate[r].tax,
                        rate: tax_rate[r].rate,
                        amount: parseFloat(t.toFixed(2)),
                      });
                    } else {
                      var t = amount - tax_on_amount;
                      base = base - t;
                      tax.push({
                        tax: tax_info.tax,
                        rate: tax_info.rate,
                        amount: parseFloat(t.toFixed(2)),
                      });
                    }
                  }
                }
                total = total + amount;
              }

              var tax_details = {
                tax: tax_info.tax,
                rate: tax_info.rate,
                amount: total,
                detail: tax,
              };

              items.push({
                part_no: parts[p].part_no,
                hsn_sac: parts[p].hsn_sac,
                item: parts[p].item,
                quantity: parts[p].quantity,
                stock: parts[p].quantity * parts[p].lot,
                sku: parts[p].sku,
                unit: parts[p].unit,
                lot: parts[p].lot,
                mrp: parts[p].unit_price,
                amount: amount,
                base: base,
                unit_base_price: base / parseFloat(parts[p].quantity),
                tax_amount: _.sumBy(tax, (x) => x.amount),
                unit_price: amount / parseFloat(parts[p].quantity),
                amount_is_tax: parts[p].amount_is_tax,
                margin: parseFloat(parts[p].margin),
                sell_price:
                  base / parseFloat(parts[p].quantity) +
                  parseFloat(parts[p].margin),
                rate:
                  base / parseFloat(parts[p].quantity) +
                  parseFloat(parts[p].margin),
                discount: parts[p].discount,
                discount_type: parts[p].discount_type,
                discount_total: parts[p].discount_total,
                tax: tax_info.tax,
                tax_rate: tax_info.rate,
                tax_info: tax,
                isChecked: parts[p].isChecked,
                remark: parts[p].remark,
                car: car,
                part_link: parts[p].part_link,
                images: parts[p].images,

                status: "Price Updated",
              });

              tax = [];
              // }
            } else {
              if (
                Log_Level == 2 ||
                Log_Level == 5 ||
                Log_Level == 8 ||
                Log_Level == 9 ||
                Log_Level == 0
              ) {
                businessFunctions.logs(
                  "WARNING: Please check tax, Tax details not found for tax_slab, Tax Slab:" +
                    parts[p].tax
                );
              }
              res.status(422).json({
                responseCode: 422,
                responseMessage: "Please check tax",
                responseData: {},
              });
            }
          } else {
            if (
              Log_Level == 1 ||
              Log_Level == 5 ||
              Log_Level == 6 ||
              Log_Level == 7 ||
              Log_Level == 0
            ) {
              businessFunctions.logs(
                "ERROR: Quantity, Tax Type and Base Amount are required to update price for the Quotation for Parts:" +
                  parts[p].item +
                  ", " +
                  "User:" +
                  loggedInDetails.name
              );
            }
            res.status(422).json({
              responseCode: 422,
              responseMessage:
                "Invalid Quantity, Tax Type , Base Amount " + parts[p].item,
              responseData: {},
            });
          }
        } else {
          items.push({
            part_no: parts[p].part_no,
            hsn_sac: parts[p].hsn_sac,
            item: parts[p].item,
            quantity: parts[p].quantity,
            stock: parts[p].quantity * parts[p].lot,
            sku: parts[p].sku,
            unit: parts[p].unit,
            lot: parts[p].lot,
            mrp: parts[p].unit_price,
            amount: 0,
            base: 0,
            unit_base_price: 0,
            tax_amount: 0,
            unit_price: 0,
            amount_is_tax: parts[p].amount_is_tax,
            margin: 0,
            sell_price: 0,
            rate: 0,
            discount: 0,
            discount_type: "",
            discount_total: 0,
            tax: "",
            tax_rate: 0,
            tax_info: [],
            isChecked: false,
            remark: "",
            car: car,
            part_link: parts[p].part_link,
            images: parts[p].images,
            status: "Not requested",
          });
          // console.log("Item Not Check Index  = " + p)
        }
      }
      // && order.order_status != 'Open'
      if (order.status == "Requested") {
        // console.log("Adede Quota")
        var quotation = await QuotationOrders.findOne({
          _id: order.quotation,
        }).exec();
        quotation.quotation_received = quotation.quotation_received + 1;
        await quotation.save();
      }

      var total_amount = _.sumBy(items, (x) => x.amount);
      // order_status: 'Open',
      await VendorOrders.findOneAndUpdate(
        { _id: orderId },
        {
          $set: {
            status: status,
            parts: items,
            total_amount: total_amount,
            updated_at: new Date(),
          },
        },
        { new: false },
        async function (err, doc) {
          if (err) {
            if (
              Log_Level == 1 ||
              Log_Level == 5 ||
              Log_Level == 6 ||
              Log_Level == 7 ||
              Log_Level == 0
            ) {
              businessFunctions.logs(
                "ERROR: Error Occured While updating the details for the order, OrderId:" +
                  orderId
              );
            }
            res.status(422).json({
              responseCode: 422,
              responseMessage: "Server Error...",
              responseData: err,
            });
          } else {
            // await QuotationOrders.findByOneAndUpdate({_id:order.quotation},{$set:{quotation_submitted:}})
          }

          // console.log(doc.vendor, doc.business);

          if (
            Log_Level == 4 ||
            Log_Level == 6 ||
            Log_Level == 8 ||
            Log_Level == 10 ||
            Log_Level == 0
          ) {
            businessFunctions.logs(
              "DEBUG: whatsAppEvent.qutationReq(doc.vendor, doc.business) function called from order.js for order, OrderId:" +
                orderId
            );
          }
          whatsAppEvent.qutationReq(doc.vendor, doc.business);
          var activity = "Quotation Update";
          fun.webNotification(activity, doc);
        }
      );

      res.status(200).json({
        responseCode: 200,
        responseMessage: "Successfully Saved",
        responseData: await VendorOrders.findById(orderId).exec(),
      });
      if (
        Log_Level == 3 ||
        Log_Level == 7 ||
        Log_Level == 9 ||
        Log_Level == 10 ||
        Log_Level == 0
      ) {
        businessFunctions.logs(
          "INFO: Details are saved successfully for the order, OrderId:" +
            orderId +
            ", " +
            "User:" +
            loggedInDetails.name
        );
      }
    }
  } else {
    if (
      Log_Level == 1 ||
      Log_Level == 5 ||
      Log_Level == 6 ||
      Log_Level == 7 ||
      Log_Level == 0
    ) {
      businessFunctions.logs(
        "ERROR: Quotation Requests Order does not exists with the given order Id, OrderId:" +
          req.body.orderId +
          ", " +
          "User:" +
          loggedInDetails.name
      );
    }
    res.status(422).json({
      responseCode: 422,
      responseMessage: "Error ",
      responseData: {},
    });
  }
});
router.put("/quotation/price/update/new", async (req, res, next) => {
  businessFunctions.logs(
    "INFO: /quotation/price/update Api Called from 3.0.js," +
      " " +
      "Request Headers:" +
      JSON.stringify(req.headers) +
      ", " +
      "Request Body:" +
      JSON.stringify(req.body)
  );

  var token = req.headers["x-access-token"];
  var secret = config.secret;
  var decoded = jwt.verify(token, secret);
  var user = decoded.user;
  var business = req.headers["business"];
  var loggedInDetails = await User.findById(decoded.user).exec();
  var parts = req.body.parts;
  var orderId = req.body.orderId;
  var status = req.body.status;
  // console.log("parts  ", JSON.stringify(parts[0], null, '\t'));

  if (
    Log_Level == 4 ||
    Log_Level == 6 ||
    Log_Level == 8 ||
    Log_Level == 10 ||
    Log_Level == 0
  ) {
    businessFunctions.logs(
      "DEBUG: Fatching Quotation Requests order details, OrderId:" +
        req.body.orderId +
        ", " +
        "User:" +
        loggedInDetails.name
    );
  }
  var order = await VendorOrders.findById(orderId).exec();
  if (order) {
    var items = [];
    var tax = [];
    var total = 0;
    //console.log("order.parts.length = ", order.parts.length)
    //console.log("parts.length = ", parts.length)
    if (parts.length > 0 && order.parts.length == parts.length) {
      for (var p = 0; p < parts.length; p++) {
        var car = {};
        if (parts[p].car) {
          car = {
            mfg: parts[p].car.mfg,
            registration_no: parts[p].car.registration_no,
            title: parts[p].car.title,
            vin: parts[p].car.vin,
          };
        }
        if (parts[p].isChecked) {
          //console.log("parts[p].quantity = ", parts[p].quantity)
          //console.log("parts[p].base = ", parts[p].base)
          //console.log("parts[p].tax = ", parts[p].tax)

          if (parts[p].quantity != null && parts[p].base && parts[p].tax) {
            var tax_info = await Tax.findOne({ tax: parts[p].tax }).exec();
            if (tax_info) {
              // console.log("Product ")
              var tax_rate = tax_info.detail;
              var base = parseFloat(parts[p].base);
              // console.log("Base  = " + base)
              var discount = parts[p].discount;
              var amount = parseFloat(parts[p].base);
              // if(discount.indexOf("%")>=0)
              // {
              //     discount = parseFloat(discount);
              //     if(!isNaN(discount) && discount>0)
              //     {
              //         var discount_total = amount*(discount/100);
              //         amount = amount-parseFloat(discount_total.toFixed(2))
              //     }
              // }
              // else
              // {
              // discount = parseFloat(discount);
              // if (!isNaN(discount) && discount > 0) {
              //     base = base - parseFloat(discount.toFixed(2))
              // }
              // }
              parts[p].amount_is_tax = "exclusive";

              if (parts[p].amount_is_tax == "exclusive") {
                if (
                  Log_Level == 4 ||
                  Log_Level == 6 ||
                  Log_Level == 8 ||
                  Log_Level == 10 ||
                  Log_Level == 0
                ) {
                  businessFunctions.logs(
                    "DEBUG: Calculate Tax details for exclusive tax."
                  );
                }
                var tax_on_amount = amount;

                if (tax_rate.length > 0) {
                  for (var r = 0; r < tax_rate.length; r++) {
                    if (tax_rate[r].rate != tax_info.rate) {
                      var t = tax_on_amount * (tax_rate[r].rate / 100);
                      amount = amount + t;
                      // console.log("Tax AMO=" + t)
                      tax.push({
                        tax: tax_rate[r].tax,
                        rate: tax_rate[r].rate,
                        amount: parseFloat(t.toFixed(2)),
                      });
                    } else {
                      var t = tax_on_amount * (tax_info.rate / 100);
                      amount = amount + t;
                      // console.log("Tax AMO=" + t)

                      tax.push({
                        tax: tax_info.tax,
                        tax_rate: tax_info.rate,
                        rate: tax_info.rate,
                        amount: parseFloat(t.toFixed(2)),
                      });
                    }
                  }
                }
                total = total + amount;

                // console.log("Amount  = " + amount)
              }

              if (parts[p].amount_is_tax == "inclusive") {
                var x = (100 + tax_info.rate) / 100;
                var tax_on_amount = amount / x;
                if (tax_rate.length > 0) {
                  for (var r = 0; r < tax_rate.length; r++) {
                    if (tax_rate[r].rate != tax_info.rate) {
                      var t = tax_on_amount * (tax_rate[r].rate / 100);
                      base = base - t;
                      tax.push({
                        tax: tax_rate[r].tax,
                        rate: tax_rate[r].rate,
                        amount: parseFloat(t.toFixed(2)),
                      });
                    } else {
                      var t = amount - tax_on_amount;
                      base = base - t;
                      tax.push({
                        tax: tax_info.tax,
                        rate: tax_info.rate,
                        amount: parseFloat(t.toFixed(2)),
                      });
                    }
                  }
                }
                total = total + amount;
              }

              var tax_details = {
                tax: tax_info.tax,
                rate: tax_info.rate,
                amount: total,
                detail: tax,
              };

              items.push({
                part_no: parts[p].part_no,
                hsn_sac: parts[p].hsn_sac,
                item: parts[p].item,
                quantity: parts[p].quantity,
                stock: parts[p].quantity * parts[p].lot,
                sku: parts[p].sku,
                unit: parts[p].unit,
                lot: parts[p].lot,
                mrp: parts[p].unit_price,
                amount: amount,
                base: base,
                unit_base_price: base / parseFloat(parts[p].quantity),
                tax_amount: _.sumBy(tax, (x) => x.amount),
                unit_price: amount / parseFloat(parts[p].quantity),
                amount_is_tax: parts[p].amount_is_tax,
                margin: parseFloat(parts[p].margin),
                sell_price:
                  base / parseFloat(parts[p].quantity) +
                  parseFloat(parts[p].margin),
                rate:
                  base / parseFloat(parts[p].quantity) +
                  parseFloat(parts[p].margin),
                discount: parts[p].discount,
                discount_type: parts[p].discount_type,
                discount_total: parts[p].discount_total,
                tax: tax_info.tax,
                tax_rate: tax_info.rate,
                tax_info: tax,
                isChecked: parts[p].isChecked,
                remark: parts[p].remark,
                car: car,
                part_link: parts[p].part_link,
                images: parts[p].images,

                status: "Price Updated",
              });

              tax = [];
              // }
            } else {
              if (
                Log_Level == 2 ||
                Log_Level == 5 ||
                Log_Level == 8 ||
                Log_Level == 9 ||
                Log_Level == 0
              ) {
                businessFunctions.logs(
                  "WARNING: Please check tax, Tax details not found for tax_slab, Tax Slab:" +
                    parts[p].tax
                );
              }

              car = {};
              if (parts[p].car) {
                var carData = {
                  mfg: parts[p].car.mfg,
                  registration_no: parts[p].car.registration_no,
                  title: parts[p].car.title,
                  vin: parts[p].car.vin,
                };
              }

              items.push({
                part_no: parts[p].part_no,
                hsn_sac: parts[p].hsn_sac,
                item: parts[p].item,
                quantity: parts[p].quantity,
                stock: parts[p].quantity * parts[p].lot,
                sku: parts[p].sku,
                unit: parts[p].unit,
                lot: parts[p].lot,
                mrp: 0,
                amount: 0,
                base: 0,
                unit_base_price: 0,
                tax_amount: 0,
                unit_price: 0,
                amount_is_tax: "exclusive",
                margin: 0,
                sell_price: 0,
                rate: 0,
                discount: 0,
                discount_type: 0,
                discount_total: 0,
                tax: "18.0% GST",
                tax_rate: 18,
                tax_info: tax,
                isChecked: parts[p].isChecked,
                remark: parts[p].remark,
                car: car,
                part_link: parts[p].part_link,
                images: parts[p].images,
                status: "requested",
              });

              tax = [];
              // res.status(422).json({
              //     responseCode: 422,
              //     responseMessage: "Please check tax",
              //     responseData: {}
              // });
            }
          } else {
            if (
              Log_Level == 1 ||
              Log_Level == 5 ||
              Log_Level == 6 ||
              Log_Level == 7 ||
              Log_Level == 0
            ) {
              businessFunctions.logs(
                "ERROR: Quantity, Tax Type and Base Amount are required to update price for the Quotation for Parts:" +
                  parts[p].item +
                  ", " +
                  "User:" +
                  loggedInDetails.name
              );
            }

            car = {};
            if (parts[p].car) {
              var car = {
                mfg: parts[p].car.mfg,
                registration_no: parts[p].car.registration_no,
                title: parts[p].car.title,
                vin: parts[p].car.vin,
              };
            }

            items.push({
              part_no: parts[p].part_no,
              hsn_sac: parts[p].hsn_sac,
              item: parts[p].item,
              quantity: parts[p].quantity,
              stock: parts[p].quantity * parts[p].lot,
              sku: parts[p].sku,
              unit: parts[p].unit,
              lot: parts[p].lot,
              mrp: 0,
              amount: 0,
              base: 0,
              unit_base_price: 0,
              tax_amount: 0,
              unit_price: 0,
              amount_is_tax: "exclusive",
              margin: 0,
              sell_price: 0,
              rate: 0,
              discount: 0,
              discount_type: 0,
              discount_total: 0,
              tax: "18.0% GST",
              tax_rate: 18,
              tax_info: tax,
              isChecked: parts[p].isChecked,
              remark: parts[p].remark,
              car: car,
              part_link: parts[p].part_link,
              images: parts[p].images,
              // status: "Price Updated"
              status: "requested",
            });

            tax = [];
            // res.status(422).json({
            //     responseCode: 422,
            //     responseMessage: "Invalid Quantity, Tax Type , Base Amount " + parts[p].item,
            //     responseData: {}
            // });
          }
        } else {
          car = {};
          if (parts[p].car) {
            var carData = {
              mfg: parts[p].car.mfg,
              registration_no: parts[p].car.registration_no,
              title: parts[p].car.title,
              vin: parts[p].car.vin,
            };
          }
          items.push({
            part_no: parts[p].part_no,
            hsn_sac: parts[p].hsn_sac,
            item: parts[p].item,
            quantity: parts[p].quantity,
            stock: parts[p].quantity * parts[p].lot,
            sku: parts[p].sku,
            unit: parts[p].unit,
            lot: parts[p].lot,
            mrp: parts[p].unit_price,
            amount: 0,
            base: 0,
            unit_base_price: 0,
            tax_amount: 0,
            unit_price: 0,
            amount_is_tax: parts[p].amount_is_tax,
            margin: 0,
            sell_price: 0,
            rate: 0,
            discount: 0,
            discount_type: "",
            discount_total: 0,
            tax: "",
            tax_rate: 0,
            tax_info: [],
            isChecked: false,
            remark: "",
            car: car,
            part_link: parts[p].part_link,
            images: parts[p].images,
            status: "Not requested",
          });
          // console.log("Item Not Check Index  = " + p)
        }
      }
      // && order.order_status != 'Open'
      if (order.status == "Requested") {
        // console.log("Adede Quota")
        var quotation = await QuotationOrders.findOne({
          _id: order.quotation,
        }).exec();
        quotation.quotation_received = quotation.quotation_received + 1;
        await quotation.save();
      }

      var total_amount = _.sumBy(items, (x) => x.amount);
      // order_status: 'Open',
      await VendorOrders.findOneAndUpdate(
        { _id: orderId },
        {
          $set: {
            status: status,
            parts: items,
            total_amount: total_amount,
            updated_at: new Date(),
          },
        },
        { new: false },
        async function (err, doc) {
          if (err) {
            if (
              Log_Level == 1 ||
              Log_Level == 5 ||
              Log_Level == 6 ||
              Log_Level == 7 ||
              Log_Level == 0
            ) {
              businessFunctions.logs(
                "ERROR: Error Occured While updating the details for the order, OrderId:" +
                  orderId
              );
            }
            res.status(422).json({
              responseCode: 422,
              responseMessage: "Server Error...",
              responseData: err,
            });
          } else {
            // await QuotationOrders.findByOneAndUpdate({_id:order.quotation},{$set:{quotation_submitted:}})
          }
          // console.log(doc.vendor, doc.business);

          if (
            Log_Level == 4 ||
            Log_Level == 6 ||
            Log_Level == 8 ||
            Log_Level == 10 ||
            Log_Level == 0
          ) {
            businessFunctions.logs(
              "DEBUG: whatsAppEvent.qutationReq(doc.vendor, doc.business) function called from order.js for order, OrderId:" +
                orderId
            );
          }
          whatsAppEvent.qutationReq(doc.vendor, doc.business);
          var activity = "Quotation Update";
          fun.webNotification(activity, doc);
        }
      );

      res.status(200).json({
        responseCode: 200,
        responseMessage: "Successfully Saved",
        responseData: await VendorOrders.findById(orderId).exec(),
      });
      if (
        Log_Level == 3 ||
        Log_Level == 7 ||
        Log_Level == 9 ||
        Log_Level == 10 ||
        Log_Level == 0
      ) {
        businessFunctions.logs(
          "INFO: Details are saved successfully for the order, OrderId:" +
            orderId +
            ", " +
            "User:" +
            loggedInDetails.name
        );
      }
    } else {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Error Occured: Please Re-Open the quoation",
        responseData: {},
      });
    }
  } else {
    if (
      Log_Level == 1 ||
      Log_Level == 5 ||
      Log_Level == 6 ||
      Log_Level == 7 ||
      Log_Level == 0
    ) {
      businessFunctions.logs(
        "ERROR: Quotation Requests Order does not exists with the given order Id, OrderId:" +
          req.body.orderId +
          ", " +
          "User:" +
          loggedInDetails.name
      );
    }
    res.status(422).json({
      responseCode: 422,
      responseMessage: "Error ",
      responseData: {},
    });
  }
});

router.get("/orders/get", xAccessToken.token, async function (req, res, next) {
  var token = req.headers["x-access-token"];
  var business = req.headers["business"];
  var secret = config.secret;
  var decoded = jwt.verify(token, secret);

  //paginate
  if (req.query.page == undefined) {
    var page = 0;
  } else {
    var page = req.query.page;
  }

  var page = Math.max(0, parseInt(page));

  var orders = [];

  var filters = [];
  var match = [];
  var queries = {};

  if (req.query.query) {
    var specification = {};
    specification["$lookup"] = {
      from: "User",
      localField: "user",
      foreignField: "_id",
      as: "user",
    };
    filters.push(specification);

    var specification = {};
    specification["$unwind"] = {
      path: "$user",
      preserveNullAndEmptyArrays: false,
    };
    filters.push(specification);
    req.query.query = req.query.query.replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1");
    var specification = {};
    specification["$match"] = {
      business: mongoose.Types.ObjectId(business),
      $or: [
        { _order: { $regex: req.query.query, $options: "i" } },
        { status: { $regex: req.query.query, $options: "i" } },
        { order_no: { $regex: req.query.query, $options: "i" } },
        { "user.name": { $regex: req.query.query, $options: "i" } },
        { "user.contact_no": { $regex: req.query.query, $options: "i" } },
      ],
    };
    filters.push(specification);

    if (req.query.status) {
      var status = req.query.status;
    }

    var specification = {};
    specification["$match"] = {
      status: status,
    };
    filters.push(specification);

    var specification = {};
    specification["$sort"] = {
      updated_at: -1,
    };
    filters.push(specification);

    var specification = {};
    specification["$skip"] = config.perPage * page;
    filters.push(specification);

    var specification = {};
    specification["$limit"] = config.perPage;
    filters.push(specification);

    if (req.query.date) {
      var date = new Date();
      //from 10-05-21to13-07-21
      if (req.query.dateType == "range") {
        var query = req.query.date;
        var ret = query.split("to");
        var from = new Date(ret[0]);
        var to = new Date(ret[1]);
      }

      // 70 Days
      else if (req.query.dateType == "period") {
        if (parseInt(req.query.date) > 1) {
          var days = parseInt(req.query.date);
          var from = new Date(
            date.getFullYear(),
            date.getMonth(),
            date.getDate() - days
          );
          var to = new Date(
            date.getFullYear(),
            date.getMonth(),
            date.getDate() + 1
          );
        } else if (parseInt(req.query.date) == 0) {
          var query = parseInt(req.query.date);
          var from = new Date(
            date.getFullYear(),
            date.getMonth(),
            date.getDate()
          );
          var to = new Date(
            date.getFullYear(),
            date.getMonth(),
            date.getDate() + 1
          );
        } else if (parseInt(req.query.date) == 1) {
          var query = parseInt(req.query.date);
          var from = new Date(
            date.getFullYear(),
            date.getMonth(),
            date.getDate() - 1
          );
          var to = new Date(
            date.getFullYear(),
            date.getMonth(),
            date.getDate()
          );
        }
      } else {
        var from = new Date(
          date.getFullYear(),
          date.getMonth(),
          date.getDate()
        );
        var to = new Date(
          date.getFullYear(),
          date.getMonth(),
          date.getDate() + 1
        );
      }
      var specification = {};
      specification["$match"] = {
        created_at: { $gte: from, $lte: to },
      };
      filters.push(specification);
    }
  } else {
    var status = "Confirmed";

    if (req.query.status) {
      var status = req.query.status;
    }

    var specification = {};
    specification["$match"] = {
      status: status,
    };
    filters.push(specification);

    var specification = {};
    specification["$match"] = {
      business: mongoose.Types.ObjectId(business),
    };
    filters.push(specification);

    var specification = {};
    specification["$match"] = {
      business: mongoose.Types.ObjectId(business),
    };
    filters.push(specification);

    var specification = {};
    specification["$sort"] = {
      updated_at: -1,
    };
    filters.push(specification);

    var specification = {};
    specification["$skip"] = config.perPage * page;
    filters.push(specification);

    var specification = {};
    specification["$limit"] = config.perPage;
    filters.push(specification);

    if (req.query.date) {
      var date = new Date();
      //from 10-05-21to13-07-21
      if (req.query.dateType == "range") {
        var query = req.query.date;
        var ret = query.split("to");
        var from = new Date(ret[0]);
        var to = new Date(ret[1]);
      }

      // 70 Days
      else if (req.query.dateType == "period") {
        if (parseInt(req.query.date) > 1) {
          var days = parseInt(req.query.date);
          var from = new Date(
            date.getFullYear(),
            date.getMonth(),
            date.getDate() - days
          );
          var to = new Date(
            date.getFullYear(),
            date.getMonth(),
            date.getDate() + 1
          );
        } else if (parseInt(req.query.date) == 0) {
          var query = parseInt(req.query.date);
          var from = new Date(
            date.getFullYear(),
            date.getMonth(),
            date.getDate()
          );
          var to = new Date(
            date.getFullYear(),
            date.getMonth(),
            date.getDate() + 1
          );
        } else if (parseInt(req.query.date) == 1) {
          var query = parseInt(req.query.date);
          var from = new Date(
            date.getFullYear(),
            date.getMonth(),
            date.getDate() - 1
          );
          var to = new Date(
            date.getFullYear(),
            date.getMonth(),
            date.getDate()
          );
        }
      } else {
        var from = new Date(
          date.getFullYear(),
          date.getMonth(),
          date.getDate()
        );
        var to = new Date(
          date.getFullYear(),
          date.getMonth(),
          date.getDate() + 1
        );
      }
      var specification = {};
      specification["$match"] = {
        created_at: { $gte: from, $lte: to },
      };
      filters.push(specification);
    }
  }

  var query = filters;

  var openOrders = 0;
  var shippedOrders = 0;
  var deliveredOrders = 0;

  if (req.query.date) {
    // var totalResult = await BusinessOrder.find({ status: status, business: business, created_at: { $gte: from, $lte: to } });
    openOrders = await BusinessOrder.find({
      status: "Confirmed",
      business: business,
      created_at: { $gte: from, $lte: to },
    }).count();
    shippedOrders = await BusinessOrder.find({
      status: "Shipped",
      business: business,
      created_at: { $gte: from, $lte: to },
    }).count();
    deliveredOrders = await BusinessOrder.find({
      status: "Delivered",
      business: business,
      created_at: { $gte: from, $lte: to },
    }).count();
  } else {
    openOrders = await BusinessOrder.find({
      status: "Confirmed",
      business: business,
    }).count();
    shippedOrders = await BusinessOrder.find({
      status: "Shipped",
      business: business,
    }).count();
    deliveredOrders = await BusinessOrder.find({
      status: "Delivered",
      business: business,
    }).count();
  }

  await BusinessOrder.aggregate(query)
    .allowDiskUse(true)
    .cursor({ batchSize: 20 })
    .exec()
    .eachAsync(async function (p) {
      var order = await Order.findById(p.order)
        .populate({
          path: "user",
          select: "name contact_no username email account_info business_info",
        })
        .populate({ path: "car", select: "variant value" })
        .populate({ path: "address" })
        .exec();

      var q = await BusinessOrder.findOne({
        order: p.order,
        business: business,
      })
        .populate({
          path: "order",
          populate: [
            {
              path: "user",
              select:
                "name contact_no username email account_info business_info",
            },
            { path: "car", select: "value variant" },
            { path: "address" },
          ],
        })
        .populate({
          path: "business",
          select:
            "name address business_info contact_no email account_info bank_details",
        })

        .exec();

      var car = "";
      if (order.car) {
        car = order.car.variant;
      }
      var name = "";
      if (order.user.name) {
        name = order.user.name;
      }
      orders.push({
        _id: order._id,
        id: order._id,
        // user: order.user,
        name: name,
        userId: order.user._id,
        contact_no: order.user.contact_no,
        car: car,
        totalParts: await OrderLine.find({ order: p.order }).count().exec(),
        // address: order.address,
        // due_date: moment(p.due_date).tz(req.headers['tz']).format('ll'),
        // delivery_date: moment(p.delivery_date).tz(req.headers['tz']).format('ll'),
        // time_slot: p.time_slot,
        // convenience: p.convenience,
        // _order: p._order,
        note: q.note,
        order_no: p.order_no,
        // address: p.address,
        // isInvoice: order.isInvoice,
        // invoice: order.invoice,
        paymentAmount: currencyFormatter.format(p.payment.total, {
          code: "INR",
        }),
        paidTotal: currencyFormatter.format(p.payment.paid_total, {
          code: "INR",
        }),
        // due: p.due,
        // log: p.log,
        // isPurchaseOrder: p.isPurchaseOrder,
        // vendorOrder: p.vendorOrder,
        status: p.status,
        created_at: moment(p.created_at).tz(req.headers["tz"]).format("lll"),
        updated_at: moment(p.updated_at).tz(req.headers["tz"]).format("lll"),
      });
    });
  res.status(200).json({
    responseCode: 200,
    responseMessage: "success",
    responseInfo: {
      // totalResult: totalResult.length,
      openOrders: openOrders,
      shippedOrders: shippedOrders,
      deliveredOrders: deliveredOrders,
    },
    responseData: orders,
  });
});

router.put(
  "/order/discount/add",
  xAccessToken.token,
  async function (req, res, next) {
    var business = req.headers["business"];
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var items = [];
    var data = [];
    var convenience_charges = 0;
    var discount = 0;
    var total = 0;
    var orderDiscount = req.body.discount;
    var discountType = req.body.discount_type;
    var order = await Order.findById(req.body.order).exec();
    var loggedInDetails = await User.findById(decoded.user).exec();
    if (order) {
      var businessOrder = await BusinessOrder.findOne({
        order: order._id,
        business: business,
      }).exec();
      var items = await OrderLine.find({
        order: order._id,
        issued: true,
        business: business,
        status: { $nin: ["Cancelled"] },
      }).exec();
      if (businessOrder.payment.convenience_charges) {
        convenience_charges = Math.ceil(
          businessOrder.payment.convenience_charges
        );
      }
      var discount = parseFloat(
        _.sumBy(items, (x) => x.discount_total).toFixed(2)
      );
      var amount = parseFloat(_.sumBy(items, (x) => x.amount).toFixed(2));
      // console.log("Discount = " + discount)
      var total = amount + discount + convenience_charges;
      var transaction_log = await q.all(
        fun.getOrderTransaction(order._id, business)
      );
      var paid_total = transaction_log.paid_total;
      var data = {
        updated_at: new Date(),
        "payment.paid_total": paid_total,
        "payment.amount": parseFloat(amount.toFixed(2)),
        "payment.order_discount": parseFloat(orderDiscount),
        "payment.discount_type": discountType,
        "payment.discount_total": parseFloat(discount.toFixed(2)),
        "payment.total": parseFloat(total.toFixed(2)),
        due: {
          due:
            Math.ceil(amount) +
            convenience_charges -
            paid_total -
            parseFloat(orderDiscount),
        },
      };
      await Order.findOneAndUpdate(
        { _id: order._id },
        { $set: data },
        { new: true },
        async function (err, doc) {
          if (err) {
            res.status(422).json({
              responseCode: 422,
              responseMessage: "Server Error",
              responseData: err,
            });
          } else {
            await BusinessOrder.findOneAndUpdate(
              { order: order._id, business: business },
              { $set: data },
              { new: true },
              async function (err, doc) {
                if (err) {
                  res.status(422).json({
                    responseCode: 422,
                    responseMessage: "Server Error",
                    responseData: err,
                  });
                } else {
                }
              }
            );
            var activity = {
              business: business,
              activity_by: loggedInDetails.name,
              activity: "Discount applied : " + parseFloat(orderDiscount),
              remark: "Discount applied",
              created_at: new Date(),
            };
            businessFunctions.salesOrderLogs(order._id, activity);
            res.status(200).json({
              responseCode: 200,
              responseMessage: "Discount Applied",
              responseData: {},
            });
          }
        }
      );
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Order not found",
        responseData: {},
      });
    }
  }
);

router.put(
  "/order/status/update",
  xAccessToken.token,
  async function (req, res, next) {
    businessFunctions.logs(
      "INFO:/order/status/update Api Called from 3.0.js," +
        " " +
        "Request Headers:" +
        JSON.stringify(req.headers) +
        ", " +
        "Request Body:" +
        JSON.stringify(req.body)
    );

    var rules = {
      order: "required",
      // quantity: 'required',
    };
    var validation = new Validator(req.body, rules);
    if (validation.fails()) {
      if (
        Log_Level == 1 ||
        Log_Level == 5 ||
        Log_Level == 6 ||
        Log_Level == 7 ||
        Log_Level == 0
      ) {
        businessFunctions.logs("ERROR: Validation failed, Order is Required.");
      }
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Order is Required",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var id = mongoose.Types.ObjectId();
      var business = req.headers["business"];
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var orderId = req.body.order;
      var status = req.body.status;
      var loggedInDetails = await User.findById(decoded.user).exec();

      if (
        Log_Level == 4 ||
        Log_Level == 6 ||
        Log_Level == 8 ||
        Log_Level == 10 ||
        Log_Level == 0
      ) {
        businessFunctions.logs(
          "DEBUG: Fatching Order Details for the order, OrderId:" +
            req.body.order
        );
      }
      var order = await Order.findOne({
        _id: orderId,
        status: { $nin: "Cancelled" },
      }).exec();
      if (order) {
        await Order.findOneAndUpdate(
          { _id: orderId },
          { $set: { status: status, updated_at: new Date() } },
          { new: false },
          async function (err, doc) {
            if (err) {
              if (
                Log_Level == 1 ||
                Log_Level == 5 ||
                Log_Level == 6 ||
                Log_Level == 7 ||
                Log_Level == 0
              ) {
                businessFunctions.logs(
                  "ERROR: Error Occured while updating order details, orderId:" +
                    req.body.order +
                    ", " +
                    "User:" +
                    loggedInDetails.name
                );
              }
              return res.status(422).json({
                responseCode: 422,
                responseMessage: "Server Error",
                responseData: err,
              });
            } else {
              // ,status: "Shipped"
              await BusinessOrder.findOneAndUpdate(
                { order: orderId, business: business },
                { $set: { status: status, updated_at: new Date() } },
                { new: false },
                async function (err, doc) {
                  if (err) {
                    if (
                      Log_Level == 1 ||
                      Log_Level == 5 ||
                      Log_Level == 6 ||
                      Log_Level == 7 ||
                      Log_Level == 0
                    ) {
                      businessFunctions.logs(
                        "ERROR: Error Occured while updating Business order details, orderId:" +
                          req.body.order +
                          ", " +
                          "User:" +
                          loggedInDetails.name
                      );
                    }
                    return res.status(422).json({
                      responseCode: 422,
                      responseMessage: "Server Error",
                      responseData: err,
                    });
                  } else {
                    var activity = {
                      business: business,
                      activity_by: loggedInDetails.name,
                      activity: "Order " + status,
                      remark: "Order " + status,
                      created_at: new Date(),
                    };
                    businessFunctions.salesOrderLogs(order._id, activity);
                  }
                  if (status == "Shipped") {
                    console.log("shipped....");
                    if (
                      Log_Level == 4 ||
                      Log_Level == 6 ||
                      Log_Level == 8 ||
                      Log_Level == 10 ||
                      Log_Level == 0
                    ) {
                      businessFunctions.logs(
                        "DEBUG: whatsAppEvent.orderShiped(doc.business, doc.order_no, doc.user) function Called from whatAppEvent.js."
                      );
                    }

                    var activity = "Order Shipped";
                    fun.webNotification(activity, doc);
                    whatsAppEvent.orderShiped(
                      doc.business,
                      doc.order_no,
                      doc.user
                    );
                  }
                }
              );
            }
          }
        );
        res.status(200).json({
          responseCode: 200,
          responseMessage: "Order Successfully " + status,
          responseData: {},
        });
        if (
          Log_Level == 3 ||
          Log_Level == 7 ||
          Log_Level == 9 ||
          Log_Level == 10 ||
          Log_Level == 0
        ) {
          businessFunctions.logs(
            "INFO: Order Successfully " +
              status +
              ", " +
              "User:" +
              loggedInDetails.name
          );
        }
      } else {
        res.status(200).json({
          responseCode: 200,
          responseMessage: "Order Not Found",
          responseData: {},
        });
      }
    }
  }
);

router.delete(
  "/address/delete",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      user: "required",
      address: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Error",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var address = await Address.findOne({
        _id: req.body.address,
        user: req.body.user,
      }).exec();
      if (address) {
        await Address.findByIdAndRemove(address._id).exec();
        res.status(200).json({
          responseCode: 200,
          responseMessage: "Address has been deleted",
          responseData: {},
        });
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Address not found",
          responseData: {},
        });
      }
    }
  }
);
router.put(
  "/address/delete",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      user: "required",
      address: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Error",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var address = await Address.findOne({
        _id: req.body.address,
        user: req.body.user,
      }).exec();
      if (address) {
        await Address.findByIdAndRemove(address._id).exec();
        res.status(200).json({
          responseCode: 200,
          responseMessage: "Address has been deleted",
          responseData: {},
        });
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Address not found",
          responseData: {},
        });
      }
    }
  }
);

router.get(
  "/sales/list/get",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var business = req.headers["business"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var sales = [];
    if (req.query.page == undefined) {
      var page = 0;
    } else {
      var page = req.query.page;
    }

    if (req.query.limit) {
      var limit = parseInt(req.query.limit);
    } else {
      var limit = 20;
    }

    var filters = [];
    var match = [];
    var queries = {};

    if (req.query.query) {
      var specification = {};
      specification["$lookup"] = {
        from: "User",
        localField: "user",
        foreignField: "_id",
        as: "user",
      };
      filters.push(specification);

      var specification = {};
      specification["$unwind"] = {
        path: "$user",
        preserveNullAndEmptyArrays: false,
      };
      filters.push(specification);

      req.query.query = req.query.query.replace(
        /([.?*+^$[\]\\(){}|-])/g,
        "\\$1"
      );
      var specification = {};
      specification["$match"] = {
        business: mongoose.Types.ObjectId(business),
        $or: [
          // { '_order': { $regex: req.query.query, $options: 'i' } },
          { status: { $regex: req.query.query, $options: "i" } },
          { sale_no: { $regex: req.query.query, $options: "i" } },
          { "user.name": { $regex: req.query.query, $options: "i" } },
          { "user.contact_no": { $regex: req.query.query, $options: "i" } },
        ],
      };
      filters.push(specification);

      var specification = {};
      specification["$match"] = {
        status: { $in: ["Confirmed", "Open"] },
      };
      filters.push(specification);

      var specification = {};
      specification["$sort"] = {
        created_at: -1,
      };
      filters.push(specification);

      var specification = {};
      specification["$skip"] = config.perPage * page;
      filters.push(specification);

      var specification = {};
      specification["$limit"] = limit;
      filters.push(specification);

      if (req.query.date) {
        var date = new Date();
        //from 10-05-21to13-07-21
        if (req.query.dateType == "range") {
          var query = req.query.date;
          var ret = query.split("to");
          var from = new Date(ret[0]);
          var to = new Date(ret[1]);
        }

        // 70 Days
        else if (req.query.dateType == "period") {
          if (parseInt(req.query.date) > 1) {
            var days = parseInt(req.query.date);
            var from = new Date(
              date.getFullYear(),
              date.getMonth(),
              date.getDate() - days
            );
            var to = new Date(
              date.getFullYear(),
              date.getMonth(),
              date.getDate() + 1
            );
          } else if (parseInt(req.query.date) == 0) {
            var query = parseInt(req.query.date);
            var from = new Date(
              date.getFullYear(),
              date.getMonth(),
              date.getDate()
            );
            var to = new Date(
              date.getFullYear(),
              date.getMonth(),
              date.getDate() + 1
            );
          } else if (parseInt(req.query.date) == 1) {
            var query = parseInt(req.query.date);
            var from = new Date(
              date.getFullYear(),
              date.getMonth(),
              date.getDate() - 1
            );
            var to = new Date(
              date.getFullYear(),
              date.getMonth(),
              date.getDate()
            );
          }
        } else {
          var from = new Date(
            date.getFullYear(),
            date.getMonth(),
            date.getDate()
          );
          var to = new Date(
            date.getFullYear(),
            date.getMonth(),
            date.getDate() + 1
          );
        }
        var specification = {};
        specification["$match"] = {
          created_at: { $gte: from, $lte: to },
        };
        filters.push(specification);
      }
    } else {
      var specification = {};
      specification["$match"] = {
        status: { $in: ["Confirmed", "Open"] },
      };
      filters.push(specification);

      var specification = {};
      specification["$match"] = {
        business: mongoose.Types.ObjectId(business),
      };
      filters.push(specification);

      var specification = {};
      specification["$sort"] = {
        created_at: -1,
      };
      filters.push(specification);

      var specification = {};
      specification["$skip"] = config.perPage * page;
      filters.push(specification);

      var specification = {};
      specification["$limit"] = limit;
      filters.push(specification);

      if (req.query.date) {
        var date = new Date();
        //from 10-05-21to13-07-21
        if (req.query.dateType == "range") {
          var query = req.query.date;
          var ret = query.split("to");
          var from = new Date(ret[0]);
          var to = new Date(ret[1]);
        }

        // 70 Days
        else if (req.query.dateType == "period") {
          if (parseInt(req.query.date) > 1) {
            var days = parseInt(req.query.date);
            var from = new Date(
              date.getFullYear(),
              date.getMonth(),
              date.getDate() - days
            );
            var to = new Date(
              date.getFullYear(),
              date.getMonth(),
              date.getDate() + 1
            );
          } else if (parseInt(req.query.date) == 0) {
            var query = parseInt(req.query.date);
            var from = new Date(
              date.getFullYear(),
              date.getMonth(),
              date.getDate()
            );
            var to = new Date(
              date.getFullYear(),
              date.getMonth(),
              date.getDate() + 1
            );
          } else if (parseInt(req.query.date) == 1) {
            var query = parseInt(req.query.date);
            var from = new Date(
              date.getFullYear(),
              date.getMonth(),
              date.getDate() - 1
            );
            var to = new Date(
              date.getFullYear(),
              date.getMonth(),
              date.getDate()
            );
          }
        } else {
          var from = new Date(
            date.getFullYear(),
            date.getMonth(),
            date.getDate()
          );
          var to = new Date(
            date.getFullYear(),
            date.getMonth(),
            date.getDate() + 1
          );
        }
        var specification = {};
        specification["$match"] = {
          created_at: { $gte: from, $lte: to },
        };
        filters.push(specification);
      }
    }
    var query = filters;

    // , 'Confirmed'/
    var count_unpaid = 0;
    var totalResultCount = 0;

    if (req.query.date) {
      var totalResult = await Sales.find({
        business: business,
        status: { $in: ["Confirmed", "Open"] },
        created_at: { $gte: from, $lte: to },
      }).exec();
      totalResultCount = await Sales.find({
        business: business,
        status: { $in: ["Confirmed", "Open"] },
        created_at: { $gte: from, $lte: to },
      }).count();
    } else {
      var totalResult = await Sales.find({
        business: business,
        status: { $in: ["Confirmed", "Open"] },
      }).exec();
      totalResultCount = await Sales.find({
        business: business,
        status: { $in: ["Confirmed", "Open"] },
      }).count();
    }
    var map_due = _.map(totalResult, "due");
    var map_payment = _.map(totalResult, "payment");

    var total_dues = parseFloat(_.sumBy(map_due, (x) => x.due).toFixed(2));
    var total_sales = parseFloat(
      _.sumBy(map_payment, (x) => x.total).toFixed(2)
    );
    for (var i = 0; i < totalResult.length; i++) {
      if (totalResult[i].due.due > 0) {
        count_unpaid = count_unpaid + 1;
      }
    }

    var total_dues_result = await businessFunctions.numberConversion(
      total_dues
    );
    var total_sales_result = await businessFunctions.numberConversion(
      total_sales
    );
    // console.log("total= ", total_dues_result)
    // console.log("total= ", total_sales_result)

    await Sales.aggregate(query)
      .cursor()
      .exec()
      .eachAsync(async (saless) => {
        var sale = await Sales.findOne({
          _id: saless._id,
          status: { $in: ["Confirmed", "Open"] },
        })
          .populate({ path: "business", select: "name contact_no" })
          .populate({ path: "invoice", select: "invoice_no" })
          .populate({ path: "user", select: "name contact_no" })
          .populate({ path: "created_by", select: "name contact_no" })
          .exec();

        if (sale) {
          sales.push({
            _id: sale._id,
            id: sale._id,
            business: sale.business,
            user: sale.user,
            created_by: sale.created_by,
            sale_no: sale.sale_no,
            // note: sale.note,
            status: sale.status,
            // items: sale.status,
            payment: sale.payment,
            due: sale.due,
            // logs: sale.logs,
            isInvoice: sale.isInvoice,
            invoice: sale.invoice,
            created_at: sale.created_at,
            updated_at: sale.updated_at,
          });
        }
      });

    res.status(200).json({
      responseCode: 200,
      responseMessage: "Sucesss",
      responseInfo: {
        totalResult: totalResultCount,
        total_sales: total_sales_result,
        total_dues: total_dues_result,
        count_unpaid: count_unpaid,
      },
      responseData: {
        sales: sales,
      },
    });
  }
);
router.get(
  "/sales/list/get/old",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var business = req.headers["business"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var sales = [];
    if (req.query.page == undefined) {
      var page = 0;
    } else {
      var page = req.query.page;
    }

    if (req.query.limit) {
      var limit = parseInt(req.query.limit);
    } else {
      var limit = 20;
    }

    var filters = [];
    var match = [];
    var queries = {};

    // if(req.query.query){

    // }
    // else{

    //     var specification = {};
    //     specification['$match'] = {
    //         status: { $in: ['Confirmed', 'Open'] }
    //     };
    //     filters.push(specification);

    //     // var specification = {};
    //     // specification['$match'] = {
    //     //     business: mongoose.Types.ObjectId(business)
    //     // };
    //     // filters.push(specification);

    //     var specification = {};
    //     specification['$match'] = {
    //         business: mongoose.Types.ObjectId(business)
    //     };
    //     filters.push(specification);

    //     var specification = {};
    //     specification['$sort'] = {
    //         created_at: -1,
    //     };
    //     filters.push(specification);

    //     var specification = {};
    //     specification['$skip'] = config.perPage * page;
    //     filters.push(specification);

    // }

    // , 'Confirmed'/
    var count_unpaid = 0;

    var totalResult = await Sales.find({
      business: business,
      status: { $in: ["Confirmed", "Open"] },
    }).exec();
    var map_due = _.map(totalResult, "due");
    var map_payment = _.map(totalResult, "payment");

    var total_dues = parseFloat(_.sumBy(map_due, (x) => x.due).toFixed(2));
    var total_sales = parseFloat(
      _.sumBy(map_payment, (x) => x.total).toFixed(2)
    );
    for (var i = 0; i < totalResult.length; i++) {
      if (totalResult[i].due.due > 0) {
        count_unpaid = count_unpaid + 1;
      }
    }

    await Sales.find({
      business: business,
      status: { $in: ["Confirmed", "Open"] },
    })
      .populate({ path: "business", select: "name contact_no" })
      .populate({ path: "invoice", select: "invoice_no" })
      .populate({ path: "user", select: "name contact_no" })
      .populate({ path: "created_by", select: "name contact_no" })
      .sort({ created_at: -1 })
      .skip(limit * page)
      .limit(limit)
      .cursor()
      .eachAsync(async (sale) => {
        sales.push({
          _id: sale._id,
          id: sale._id,
          business: sale.business,
          user: sale.user,
          created_by: sale.created_by,
          sale_no: sale.sale_no,
          // note: sale.note,
          status: sale.status,
          // items: sale.status,
          payment: sale.payment,
          due: sale.due,
          // logs: sale.logs,
          isInvoice: sale.isInvoice,
          invoice: sale.invoice,
          created_at: sale.created_at,
          updated_at: sale.updated_at,
        });
      });

    res.status(200).json({
      responseCode: 200,
      responseMessage: "Sucesss",
      responseInfo: {
        totalResult: await Sales.find({
          business: business,
          status: { $in: ["Confirmed", "Open"] },
        })
          .count()
          .exec(),
        total_sales: total_sales,
        total_dues: total_dues,
        count_unpaid: count_unpaid,
      },
      responseData: {
        sales: sales,
      },
    });
  }
);

router.get(
  "/sale/details/get/old",
  xAccessToken.token,
  async function (req, res, next) {
    console.time("looper");
    var token = req.headers["x-access-token"];
    var business = req.headers["business"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    var sale = await Sales.findOne({ _id: req.query.sale, business: business })
      .populate({
        path: "user",
        select: "name contact_no username email account_info business_info",
      })
      .populate({
        path: "business",
        select:
          "name address business_info contact_no email account_info bank_details",
      })
      .populate("address")
      .exec();
    if (sale) {
      var transactions = await q.all(
        fun.getSalesTransaction(sale._id, business)
      );
      // var transactions = await q.all(fun.getOrderTransaction(sale._id, business))

      var has_invoice = false;
      var invoices = await OrderInvoice.find({
        sale: sale._id,
        business: business,
      })
        .select("status invoice_no")
        .exec();
      var activeInvoice = await OrderInvoice.findOne({
        sale: sale._id,
        business: business,
        status: "Active",
      })
        .select("status invoice_no updated_at")
        .sort({ created_at: -1 })
        .exec();

      var isInvoiceUpToDate = false;
      if (invoices.length > 0) {
        has_invoice = true;
        // console.log("Order Date = " + new Date(p.updated_at))
        // console.log("Invoice  Date = " + new Date(activeInvoice.updated_at))
        if (activeInvoice) {
          var serverTime = moment.tz(
            new Date(sale.updated_at),
            req.headers["tz"]
          );
          var bar = moment.tz(
            new Date(activeInvoice.updated_at),
            req.headers["tz"]
          );
          var baz = serverTime.diff(bar);
          // console.log("-- " + baz);   ///Used to take diffrence between Order updated Date and Invoice Updated Date Average time is 30 to 40 When both  updated at same time.
          if (baz < 50) {
            isInvoiceUpToDate = true;
          }
        }
      }

      res.status(200).json({
        responseCode: 200,
        responseMessage: "success",
        responseData: {
          _id: sale._id,
          id: sale._id,
          parts: sale.parts,
          user: sale.user,
          car: sale.car,
          address: sale.address,
          due_date: moment(sale.due_date).tz(req.headers["tz"]).format("lll"),
          delivery_date: moment(sale.delivery_date)
            .tz(req.headers["tz"])
            .format("lll"),
          time_slot: sale.time_slot,
          convenience: sale.convenience,
          _order: sale._order,
          sale_no: sale.sale_no,
          business: sale.business,
          address: sale.address,
          payment: sale.payment,
          status: sale.status,
          due: sale.due,
          note: sale.note,
          logs: sale.logs,
          has_invoice: has_invoice,
          invoices: invoices,
          activeInvoice: activeInvoice,
          transactions: transactions.transactions,
          parchi: sale.parchi,
          created_at: moment(sale.created_at)
            .tz(req.headers["tz"])
            .format("lll"),
          updated_at: moment(sale.updated_at)
            .tz(req.headers["tz"])
            .format("lll"),
          isInvoiceUpToDate: isInvoiceUpToDate,
        },
      });
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Sale Not Found",
        responseData: {},
      });
    }
    // console.timeEnd('looper')
  }
);

router.get(
  "/sale/details/get",
  xAccessToken.token,
  async function (req, res, next) {
    businessFunctions.logs(
      "INFO: /sale/details/get Api Called from sales.js," +
        " " +
        "Request Headers:" +
        JSON.stringify(req.headers) +
        ", " +
        "Request Query:" +
        JSON.stringify(req.query)
    );

    console.time("looper");
    var token = req.headers["x-access-token"];
    var business = req.headers["business"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = await User.findById(decoded.user).exec();

    if (
      Log_Level == 4 ||
      Log_Level == 6 ||
      Log_Level == 8 ||
      Log_Level == 10 ||
      Log_Level == 0
    ) {
      businessFunctions.logs(
        "DEBUG: Fatching Sale Details for the given SaleId, SaleId:" +
          req.query.sale
      );
    }
    var sale = await Sales.findOne({ _id: req.query.sale, business: business })
      .populate({
        path: "user",
        select: "name contact_no username email account_info business_info",
      })
      .populate({
        path: "business",
        select:
          "name address business_info contact_no email account_info bank_details",
      })
      .populate("address")
      .exec();
    if (sale) {
      if (
        Log_Level == 4 ||
        Log_Level == 6 ||
        Log_Level == 8 ||
        Log_Level == 10 ||
        Log_Level == 0
      ) {
        businessFunctions.logs(
          "DEBUG: fun.getSalesTransaction(sale._id, business) function called from function.js"
        );
      }
      var transactions = await q.all(
        fun.getSalesTransaction(sale._id, business)
      );
      // var transactions = await q.all(fun.getOrderTransaction(sale._id, business))
      var statementData = {};
      var details = await q.all(
        businessFunctions.getStatementDetails({
          user: sale.user,
          business: business,
        })
      );
      if (details) {
        // console.l.log("Data = " + JSON.stringify(details));
        statementData = {
          // totalSale: details.totalSale - details.totalSaleCancelled,
          // totalPurchase: details.totalPurchase - details.totalPurchaseCancelled,
          // totalPaymentIn: details.totalPaymentIn,
          // totalPaymentOut: details.totalPaymentOut,
          // totalPurchaseCancelled: details.totalPurchaseCancelled,
          // totalSaleCancelled: details.totalPurchaseCancelled,
          balance: details.balance,
          // lastTransaction: details.lastTransaction
        };
      }

      var has_invoice = false;
      if (
        Log_Level == 4 ||
        Log_Level == 6 ||
        Log_Level == 8 ||
        Log_Level == 10 ||
        Log_Level == 0
      ) {
        businessFunctions.logs(
          "DEBUG: Fatching Invoice Details for the given SaleId, SaleId:" +
            req.query.sale +
            ", " +
            "Name:" +
            sale.user.name
        );
      }
      var invoices = await OrderInvoice.find({
        sale: sale._id,
        business: business,
      })
        .select("status invoice_no")
        .exec();
      var activeInvoice = await OrderInvoice.findOne({
        sale: sale._id,
        business: business,
        status: "Active",
      })
        .select("status invoice_no updated_at")
        .sort({ created_at: -1 })
        .exec();

      var isInvoiceUpToDate = false;
      if (invoices.length > 0) {
        has_invoice = true;
        // console.log("Order Date = " + new Date(p.updated_at))
        // console.log("Invoice  Date = " + new Date(activeInvoice.updated_at))
        if (activeInvoice) {
          var serverTime = moment.tz(
            new Date(sale.updated_at),
            req.headers["tz"]
          );
          var bar = moment.tz(
            new Date(activeInvoice.updated_at),
            req.headers["tz"]
          );
          var baz = serverTime.diff(bar);
          // console.log("-- " + baz);   ///Used to take diffrence between Order updated Date and Invoice Updated Date Average time is 30 to 40 When both  updated at same time.
          if (baz < 50) {
            isInvoiceUpToDate = true;
          }
        }
      }
      var total_quantity = 0;
      var tax_Amount_CGST = 0;
      var tax_Amount_SGST = 0;
      var tax_Amount_IGST = 0;
      var total_partcost = 0;
      var requirment_total_amount = 0;
      for (var i = 0; i < sale.parts.length; i++) {
        total_quantity = total_quantity + sale.parts[i].quantity;
        if (sale.parts[i].tax_info) {
          var tax_info = sale.parts[i].tax_info;
          if (tax_info.length == 2) {
            tax_Amount_CGST = tax_Amount_CGST + tax_info[0].amount;
            tax_Amount_SGST = tax_Amount_SGST + tax_info[1].amount;
          }
          if (tax_info.length == 1) {
            tax_Amount_IGST = tax_Amount_IGST + tax_info[0] + amount;
          }
        }
        // console.log("parts== ", JSON.stringify(sale.parts))
        total_partcost = total_partcost + sale.parts[i].amount;
      }

      var total_amount = (total_partcost - sale.payment.order_discount).toFixed(
        2
      );
      var total = {
        total_partcost: total_partcost.toFixed(2),
        discount: sale.payment.order_discount.toFixed(2),
        discount_type: sale.payment.discount_type,
        total_quantity: total_quantity,
        tax_Amount_CGST: tax_Amount_CGST.toFixed(2),
        tax_Amount_SGST: tax_Amount_SGST.toFixed(2),
        tax_Amount_IGST: tax_Amount_IGST.toFixed(2),
        due: sale.due.due,
        total_amount: total_amount,
      };
      if (
        Log_Level == 4 ||
        Log_Level == 6 ||
        Log_Level == 8 ||
        Log_Level == 10 ||
        Log_Level == 0
      ) {
        businessFunctions.logs(
          "DEBUG: Sending Sale Details for the given SaleId, SaleId:" +
            req.query.sale +
            ", " +
            "Name:" +
            sale.user.name +
            ", " +
            "User:" +
            user.name
        );
      }
      var parchi = "";
      if (sale.parchi) {
        parchi = sale.parchi;
      }

      res.status(200).json({
        responseCode: 200,
        responseMessage: "success",
        responseData: {
          total: total,
          party_balance: currencyFormatter.format(
            statementData.balance.toFixed(2),
            { code: "INR" }
          ),
          _id: sale._id,
          id: sale._id,
          parts: sale.parts,
          labours: sale.labours,
          user: sale.user,
          car: sale.car,
          address: sale.address,
          due_date: moment(sale.due_date).tz(req.headers["tz"]).format("lll"),
          delivery_date: moment(sale.delivery_date)
            .tz(req.headers["tz"])
            .format("lll"),
          time_slot: sale.time_slot,
          convenience: sale.convenience,
          _order: sale._order,
          sale_no: sale.sale_no,
          business: sale.business,
          address: sale.address,
          payment: sale.payment,
          status: sale.status,
          due: sale.due,
          note: sale.note,
          logs: sale.logs,
          has_invoice: has_invoice,
          invoices: invoices,
          activeInvoice: activeInvoice,
          transactions: transactions.transactions,
          parchi: parchi,
          created_at: moment(sale.created_at)
            .tz(req.headers["tz"])
            .format("lll"),
          updated_at: moment(sale.updated_at)
            .tz(req.headers["tz"])
            .format("lll"),
          isInvoiceUpToDate: isInvoiceUpToDate,
        },
      });
      if (
        Log_Level == 3 ||
        Log_Level == 7 ||
        Log_Level == 9 ||
        Log_Level == 10 ||
        Log_Level == 0
      ) {
        businessFunctions.logs(
          "INFO: Sale Details send in Response Successfully, SaleId:" +
            req.query.sale +
            ", " +
            "Name:" +
            sale.user.name +
            ", " +
            "User:" +
            user.name
        );
      }
    } else {
      if (
        Log_Level == 2 ||
        Log_Level == 5 ||
        Log_Level == 8 ||
        Log_Level == 9 ||
        Log_Level == 0
      ) {
        businessFunctions.logs(
          "WARNING: No Sale found with the given saleId, SaleId:" +
            req.query.sale +
            ", " +
            "User:" +
            user.name
        );
      }
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Sale Not Found",
        responseData: {},
      });
    }
    // console.timeEnd('looper')
  }
);
router.post(
  "/sale/item/add",
  xAccessToken.token,
  async function (req, res, next) {
    var business = req.headers["business"];
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var date = new Date();
    var loggedInDetails = decoded.user;
    var items = [];
    var convenience_charges = 0;
    var discount = 0;
    var item_total = 0;
    var sale = await Sales.findById(req.body.sale).exec();
    var parts = sale.parts;
    var loggedInDetails = await User.findById(decoded.user).exec();
    if (sale) {
      var products = req.body.items;
      if (products.title != "") {
        if (products) {
          var tax_info = await Tax.findOne({ tax: products.tax }).exec();
          if (products.product) {
            var product = await BusinessProduct.findOne({
              _id: products.product,
              business: business,
            }).exec();
            if (product) {
              var tax = [];
              var rate = products.rate;
              var amount = products.rate * products.quantity;
              var tax_rate = tax_info.detail;
              var discount_total = 0;
              var base = amount;

              var discount = products.discount;

              if (discount.indexOf("%") >= 0) {
                discount = parseFloat(discount);
                if (!isNaN(discount) && discount > 0) {
                  discount_total = amount * (discount / 100);
                  amount = amount - parseFloat(discount_total.toFixed(2));
                }
              } else {
                if (discount == "") {
                  discount = "0";
                }

                discount_total = parseFloat(discount);

                if (!isNaN(discount_total) && discount_total > 0) {
                  amount = amount - parseFloat(discount_total.toFixed(2));
                }
              }

              if (products.amount_is_tax == "exclusive") {
                var tax_on_amount = amount;
                if (tax_rate.length > 0) {
                  for (var r = 0; r < tax_rate.length; r++) {
                    if (tax_rate[r].rate != tax_info.rate) {
                      var t = tax_on_amount * (tax_rate[r].rate / 100);
                      amount = amount + t;
                      tax.push({
                        tax: tax_rate[r].tax,
                        rate: tax_rate[r].rate,
                        amount: parseFloat(t.toFixed(2)),
                      });
                    } else {
                      var t = tax_on_amount * (tax_info.rate / 100);
                      amount = amount + t;
                      tax.push({
                        tax: tax_info.tax,
                        tax_rate: tax_info.rate,
                        rate: tax_info.rate,
                        amount: parseFloat(t.toFixed(2)),
                      });
                    }
                  }
                }
              }

              if (products.amount_is_tax == "inclusive") {
                var x = (100 + tax_info.rate) / 100;
                var tax_on_amount = amount / x;
                if (tax_rate.length > 0) {
                  for (var r = 0; r < tax_rate.length; r++) {
                    if (tax_rate[r].rate != tax_info.rate) {
                      var t = tax_on_amount * (tax_rate[r].rate / 100);
                      base = base - t;
                      tax.push({
                        tax: tax_rate[r].tax,
                        rate: tax_rate[r].rate,
                        amount: parseFloat(t.toFixed(2)),
                      });
                    } else {
                      var t = amount - tax_on_amount;
                      base = base - t;
                      tax.push({
                        tax: tax_info.tax,
                        rate: tax_info.rate,
                        amount: parseFloat(t.toFixed(2)),
                      });
                    }
                  }
                }
                //base = base - discount_total;
              }

              var tax_details = {
                tax: tax_info.tax,
                rate: tax_info.rate,
                amount: total,
                detail: tax,
              };
              // var issued = await q.all(businessFunctions.salesPartIssue(products, business, user, loggedInDetails));
              // if (issued) {

              // }
              var user = await User.findById(sale.user).exec();
              parts.push({
                product: product._id,
                category: product.category,
                _category: product._category,
                subcategory: product.subcategory,
                _subcategory: product._subcategory,
                product_brand: product.product_brand,
                _brand: product.product_brand,
                product_model: product.product_model,
                _model: product.product_model,
                source: product.source,
                part_no: products.part_no,
                hsn_sac: products.hsn_sac,
                unit: products.unit,
                title: products.title,
                sku: products.sku,
                mrp: products.mrp,
                selling_price: products.selling_price,
                rate: products.rate,
                quantity: products.quantity,
                base: parseFloat(base.toFixed(2)),
                amount: amount,
                discount: products.discount,
                discount_total: parseFloat(discount_total.toFixed(2)),
                amount_is_tax: products.amount_is_tax,
                tax_amount: parseFloat(
                  _.sumBy(tax, (x) => x.amount).toFixed(2)
                ),
                amount: parseFloat(amount.toFixed(2)),
                tax: tax_info.tax,
                tax_rate: tax_info.rate,
                tax_info: tax,
                issued: await q.all(
                  businessFunctions.salesPartIssue(
                    products,
                    business,
                    user,
                    loggedInDetails
                  )
                ),
                added_by_customer: false,
                created_at: new Date(),
                updated_at: new Date(),
              });
            } else {
              return res.status(400).json({
                responseCode: 400,
                responseMessage: "Item not found",
                responseData: {},
              });
            }
          }
        }
        if (sale.payment.convenience_charges) {
          convenience_charges = Math.ceil(sale.payment.convenience_charges);
        }
        var discount = parseFloat(
          _.sumBy(parts, (x) => x.discount_total).toFixed(2)
        );
        var amount = parseFloat(_.sumBy(parts, (x) => x.amount).toFixed(2));
        var total = amount + discount + convenience_charges;
        var transaction_log = await q.all(
          fun.getSalesTransaction(sale._id, business)
        );
        var paid_total = transaction_log.paid_total;
        var data = {
          updated_at: new Date(),
          "payment.paid_total": paid_total,
          "payment.amount": parseFloat(amount.toFixed(2)),
          "payment.discount_total": parseFloat(discount.toFixed(2)),
          "payment.total": parseFloat(total.toFixed(2)),
          "payment.order_discount": parseFloat(sale.payment.order_discount),
          due: {
            due:
              Math.ceil(amount) +
              convenience_charges -
              paid_total -
              (parseFloat(sale.payment.order_discount) +
                parseFloat(sale.payment.discount_total)),
          },
          parts: parts,
        };

        await Sales.findOneAndUpdate(
          { _id: sale._id, business: business },
          { $set: data },
          { new: false },
          async function (err, doc) {
            if (err) {
              res.status(422).json({
                responseCode: 422,
                responseMessage: "Server Error",
                responseData: err,
              });
            } else {
              var has_invoice = false;
              var invoices = await OrderInvoice.find({
                sale: sale._id,
                business: business,
              })
                .select("status invoice_no")
                .exec();
              if (invoices.length > 0) {
                has_invoice = true;
              }
              var orders = {
                _id: sale._id,
                id: sale._id,
                items: sale.parts,
                user: sale.user,
                car: sale.car,
                address: sale.address,
                due_date: moment(sale.due_date)
                  .tz(req.headers["tz"])
                  .format("lll"),
                delivery_date: moment(sale.delivery_date)
                  .tz(req.headers["tz"])
                  .format("lll"),
                time_slot: sale.time_slot,
                convenience: sale.convenience,
                order_no: sale.order_no,
                address: sale.address,
                payment: sale.payment,
                due: sale.due,
                logs: sale.logs,
                status: sale.status,
                has_invoice: has_invoice,
                invoices: invoices,
                created_at: moment(sale.created_at)
                  .tz(req.headers["tz"])
                  .format("lll"),
                updated_at: moment(sale.updated_at)
                  .tz(req.headers["tz"])
                  .format("lll"),
              };
              var activity = {
                business: business,
                activity_by: loggedInDetails.name,
                activity: "'" + products.title + "'  -Added to Order",
                remark: "Item Added",
                created_at: new Date(),
              };
              businessFunctions.salesLogs(sale._id, activity);

              res.status(200).json({
                responseCode: 200,
                responseMessage: "success",
                responseData: orders,
              });
            }
          }
        );

        // });
      } else {
        res.status(200).json({
          responseCode: 200,
          responseMessage: "Add New Item",
          responseData: {},
        });
      }
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Order not found",
        responseData: {},
      });
    }
  }
);

router.put(
  "/sale/item/return",
  xAccessToken.token,
  async function (req, res, next) {
    var business = req.headers["business"];
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var date = new Date();
    var loggedInDetails = decoded.user;
    var items = [];
    var data = [];
    var convenience_charges = 0;
    var amount = 0;
    var discount = 0;
    var total = 0;
    var index = req.body.index;
    var sale = await Sales.findOne({
      _id: req.body.sale,
      status: { $nin: ["Cancelled"] },
    }).exec();
    var loggedInDetails = await User.findById(decoded.user).exec();
    if (sale) {
      // var businessOrder = await BusinessOrder.findOne({ order: item.order, business: business }).exec();
      var item = sale.parts[index];
      // console.log("Is Id Same  = " + item._id.equals(req.body.id))
      // console.log("Product   = " + item._id)
      // console.log("Item = " + req.body.id)
      // return res.json({
      //     item: item
      // })
      if (item.issued == true && item._id.equals(req.body.id)) {
        var r = await q.all(businessFunctions.orderItemReturn(item));
        // console.log("Item Removed " + r)
        if (r) {
          // console.log("partslength  ", sale.parts.length)

          sale.parts.splice(index, 1);
          // console.log("partslength  ", sale.parts.length)
          await sale.save();
          var items = sale.parts;
          // var items = await OrderLine.find({ order: item.order, business: business, issued: true, status: { $nin: ["Cancelled"] } }).exec();

          if (sale.payment.convenience_charges) {
            convenience_charges = Math.ceil(sale.payment.convenience_charges);
          }

          var discount = parseFloat(
            _.sumBy(items, (x) => x.discount_total).toFixed(2)
          );
          var amount = parseFloat(_.sumBy(items, (x) => x.amount).toFixed(2));
          var total = amount + discount + convenience_charges;
          // console.log("2828 Total =" + total)
          var transaction_log = await q.all(
            fun.getSalesTransaction(sale._id, business)
          );
          var paid_total = transaction_log.paid_total;

          var data = {
            updated_at: new Date(),
            "payment.paid_total": paid_total,
            "payment.amount": parseFloat(amount.toFixed(2)),
            "payment.discount_total": parseFloat(discount.toFixed(2)),
            "payment.total": parseFloat(total.toFixed(2)),
            "payment.order_discount": parseFloat(sale.payment.order_discount),
            due: {
              due:
                Math.ceil(amount) +
                convenience_charges -
                paid_total -
                (parseFloat(sale.payment.order_discount) +
                  parseFloat(discount)),
            },
            parts: items,
          };

          await OrderInvoice.findOneAndUpdate(
            { sale: sale._id, status: "Active" },
            {
              $set: {
                due: {
                  due: Math.ceil(amount) + convenience_charges - paid_total,
                },
              },
            },
            { new: true },
            async function (err, doc) {}
          );

          await Sales.findOneAndUpdate(
            { _id: sale._id },
            { $set: data },
            { new: false },
            async function (err, doc) {
              if (err) {
                res.status(422).json({
                  responseCode: 422,
                  responseMessage: "Server Error",
                  responseData: err,
                });
              } else {
                var has_invoice = false;
                var invoices = await OrderInvoice.find({
                  sale: sale._id,
                  business: business,
                })
                  .select("status invoice_no")
                  .exec();
                if (invoices.length > 0) {
                  has_invoice = true;
                }
                var orders = {
                  _id: sale._id,
                  id: sale._id,
                  items: sale.parts,
                  user: sale.user,
                  car: sale.car,
                  address: sale.address,
                  due_date: moment(sale.due_date)
                    .tz(req.headers["tz"])
                    .format("lll"),
                  delivery_date: moment(sale.delivery_date)
                    .tz(req.headers["tz"])
                    .format("lll"),
                  time_slot: sale.time_slot,
                  convenience: sale.convenience,
                  order_no: sale.order_no,
                  address: sale.address,
                  payment: sale.payment,
                  due: sale.due,
                  logs: sale.logs,
                  status: sale.status,
                  has_invoice: has_invoice,
                  invoices: invoices,
                  created_at: moment(sale.created_at)
                    .tz(req.headers["tz"])
                    .format("lll"),
                  updated_at: moment(sale.updated_at)
                    .tz(req.headers["tz"])
                    .format("lll"),
                };
                // var activity = {
                //     business: business,
                //     activity_by: loggedInDetails.name,
                //     activity: "'" + products.title + "' Returned from Order",
                //     remark: "Item Added",
                //     created_at: new Date(),
                // }
                // businessFunctions.salesOrderLogs(order._id, activity);

                res.status(200).json({
                  responseCode: 200,
                  responseMessage: "success",
                  responseData: orders,
                });
              }
            }
          );
        } else {
          res.status(400).json({
            responseCode: 400,
            responseMessage: "Item not Returned",
            responseData: {},
          });
        }
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Item not issued / Found",
          responseData: {},
        });
      }
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Sale not found",
        responseData: {},
      });
    }
  }
);

router.put(
  "/sale/discount/add",
  xAccessToken.token,
  async function (req, res, next) {
    var business = req.headers["business"];
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var data = [];
    var convenience_charges = 0;
    var discount = 0;
    var total = 0;
    var orderDiscount = req.body.discount;
    var discountType = req.body.discount_type;
    var sale = await Sales.findById(req.body.sale).exec();
    var loggedInDetails = await User.findById(decoded.user).exec();
    if (sale) {
      if (sale.payment.convenience_charges) {
        convenience_charges = Math.ceil(sale.payment.convenience_charges);
      }
      var discount = parseFloat(
        _.sumBy(sale.parts, (x) => x.discount_total).toFixed(2)
      );
      var amount = parseFloat(_.sumBy(sale.parts, (x) => x.amount).toFixed(2));
      console.log("Discount = " + discount);
      var total = amount + discount + convenience_charges;
      var transaction_log = await q.all(
        fun.getSalesTransaction(sale._id, business)
      );
      var paid_total = transaction_log.paid_total;
      var data = {
        updated_at: new Date(),
        "payment.paid_total": paid_total,
        "payment.amount": parseFloat(amount.toFixed(2)),
        "payment.order_discount": parseFloat(orderDiscount),
        "payment.discount_type": discountType,
        "payment.discount_total": parseFloat(discount.toFixed(2)),
        "payment.total": parseFloat(total.toFixed(2)),
        due: {
          due:
            Math.ceil(amount) +
            convenience_charges -
            paid_total -
            parseFloat(orderDiscount),
        },
      };
      await Sales.findOneAndUpdate(
        { _id: sale._id },
        { $set: data },
        { new: true },
        async function (err, doc) {
          if (err) {
            res.status(422).json({
              responseCode: 422,
              responseMessage: "Server Error",
              responseData: err,
            });
          } else {
            var activity = {
              business: business,
              activity_by: loggedInDetails.name,
              activity: "Discount applied : " + parseFloat(orderDiscount),
              remark: "Discount applied",
              created_at: new Date(),
            };
            businessFunctions.salesLogs(sale._id, activity);
            res.status(200).json({
              responseCode: 200,
              responseMessage: "Discount Applied",
              responseData: {},
            });
          }
        }
      );
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Sale not found",
        responseData: {},
      });
    }
  }
);

router.put(
  "/sale/address/update",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      sale: "required",
      address: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Due Date required",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var business = req.headers["business"];
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var loggedInDetails = decoded.user;
      var sale = await Sales.findById(req.body.sale).exec();
      var loggedInDetails = await User.findById(decoded.user).exec();
      if (sale) {
        var address = await Address.findOne({
          _id: req.body.address,
          user: sale.user,
        }).exec();
        if (address) {
          Sales.findOneAndUpdate(
            { _id: sale._id },
            { $set: { address: address._id } },
            { new: false },
            async function (err, doc) {
              if (err) {
                res.status(422).json({
                  responseCode: 422,
                  responseMessage: "Server Error",
                  responseData: err,
                });
              } else {
                var activity = {
                  business: business,
                  activity_by: loggedInDetails.name,
                  activity: "Address Updated",
                  remark: "Address Updated",
                  created_at: new Date(),
                };
                businessFunctions.salesLogs(sale._id, activity);
                res.status(200).json({
                  responseCode: 200,
                  responseMessage: "Saved",
                  responseData: {
                    address: address,
                  },
                });
              }
            }
          );
        } else {
          res.status(400).json({
            responseCode: 400,
            responseMessage: "Address not found",
            responseData: {},
          });
        }
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Sale not found",
          responseData: {},
        });
      }
    }
  }
);

router.get(
  "/user/sales/get/old",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var business = req.headers["business"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var sales = [];
    // console.log("User = " + req.query.user)
    // parchi: { $ne: req.query.parchi }, isParchi: false,
    await Sales.find({
      user: req.query.user,
      business: business,
      status: { $in: ["Confirmed", "Open"] },
    })
      .select("_id id invoice sale_no parchi isParchi")
      .cursor()
      .eachAsync(async (sale) => {
        // package.booking.equals(data.booking)

        // console.log("sale.parchi = " + sale.parchi)
        // console.log("!sale.isParchi = " + !sale.isParchi)
        // console.log("req.query.parchi = " + req.query.parchi)
        if (sale.isParchi) {
          if (sale.parchi.equals(req.query.parchi)) {
            sales.push({
              _id: sale._id,
              id: sale._id,
              sale_no: sale.sale_no,
              type: "sale",
              parchi: sale.parchi,
              isParchi: sale.sParchi,
              created_at: sale.created_at,
              updated_at: sale.updated_at,
            });
          }
        } else if (!sale.isParchi) {
          sales.push({
            _id: sale._id,
            id: sale._id,
            sale_no: sale.sale_no,
            type: "sale",
            parchi: sale.parchi,
            isParchi: sale.sParchi,
            created_at: sale.created_at,
            updated_at: sale.updated_at,
          });
        }
      });

    // , parchi: { $ne: req.query.parchi }, isParchi: false,
    await Order.find({
      user: req.query.user,
      business: business,
      status: { $nin: ["Cancelled"] },
    })
      .select("_id id invoice order_no parchi isParchi")
      .cursor()
      .eachAsync(async (order) => {
        if (order.parchi) {
          if (
            (order.parchi.equals(req.query.parchi) && order.isParchi) ||
            !order.isParchi
          ) {
            sales.push({
              _id: order._id,
              id: order._id,
              sale_no: order.order_no,
              type: "order",
              parchi: order.parchi,
              isParchi: order.sParchi,
              created_at: order.created_at,
              updated_at: order.updated_at,
            });
          }
        }
      });

    sales = _.sortBy(sales, "created_at");
    res.status(200).json({
      responseCode: 200,
      responseMessage: "Sucesss",
      responseInfo: {
        totalResult: 0,
      },
      responseData: {
        sales: sales,
        // order: order
      },
    });
  }
);
router.get(
  "/user/sales/get",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var business = req.headers["business"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var sales = [];
    // console.log("User = " + req.query.user)
    // parchi: { $ne: req.query.parchi }, isParchi: false,
    await Sales.find({
      user: req.query.user,
      business: business,
      status: { $in: ["Confirmed", "Open"] },
    })
      .select("_id id invoice sale_no parchi isParchi created_at updated_at")
      .cursor()
      .eachAsync(async (sale) => {
        // package.booking.equals(data.booking)

        // console.log("sale.parchi = " + sale.parchi)
        // console.log("!sale.isParchi = " + !sale.isParchi)
        // console.log("req.query.parchi = " + req.query.parchi)
        if (sale.isParchi) {
          if (sale.parchi.equals(req.query.parchi)) {
            sales.push({
              _id: sale._id,
              id: sale._id,
              sale_no: sale.sale_no,
              type: "Sale",
              parchi: sale.parchi,
              isParchi: sale.sParchi,
              created_at: sale.created_at,
              updated_at: sale.updated_at,
            });
          }
        } else if (!sale.isParchi) {
          sales.push({
            _id: sale._id,
            id: sale._id,
            sale_no: sale.sale_no,
            type: "Sale",
            parchi: sale.parchi,
            isParchi: sale.sParchi,
            created_at: sale.created_at,
            updated_at: sale.updated_at,
          });
        }
      });

    // , parchi: { $ne: req.query.parchi }, isParchi: false,
    await Order.find({
      user: req.query.user,
      business: business,
      status: { $nin: ["Cancelled"] },
    })
      .select("_id id invoice order_no parchi isParchi created_at updated_at ")
      .cursor()
      .eachAsync(async (order) => {
        if (order.isParchi) {
          if (order.parchi.equals(req.query.parchi)) {
            sales.push({
              _id: order._id,
              id: order._id,
              sale_no: order.order_no,
              type: "SaleOrder",
              parchi: order.parchi,
              isParchi: order.sParchi,
              created_at: order.created_at,
              updated_at: order.updated_at,
            });
          }
        } else if (!order.isParchi) {
          sales.push({
            _id: order._id,
            id: order._id,
            sale_no: order.order_no,
            type: "SaleOrder",
            parchi: order.parchi,
            isParchi: order.sParchi,
            created_at: order.created_at,
            updated_at: order.updated_at,
          });
        }
      });

    sales = _.sortBy(sales, "created_at");
    res.status(200).json({
      responseCode: 200,
      responseMessage: "Sucesss",
      responseInfo: {
        totalResult: 0,
      },
      responseData: {
        sales: sales,
        // order: order
      },
    });
  }
);

router.post(
  "/sale/payment/add",
  xAccessToken.token,
  async function (req, res, next) {
    businessFunctions.logs(
      "INFO: /sale/payment/add Api Called from sales.js," +
        " " +
        "Request Headers:" +
        JSON.stringify(req.headers) +
        ", " +
        "Request Body:" +
        JSON.stringify(req.body)
    );
    console.log("Body= ", JSON.stringify(req.body));
    var rules = {
      sale: "required",
      amount: "required",
      date: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      if (
        Log_Level == 1 ||
        Log_Level == 5 ||
        Log_Level == 6 ||
        Log_Level == 7 ||
        Log_Level == 0
      ) {
        businessFunctions.logs(
          "ERROR: Validation failed, Amount & Date are mandatory."
        );
      }
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Amount & Date are mandatory",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var business = req.headers["business"];
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var data = [];
      var loggedInDetails = await User.findById(decoded.user).exec();

      if (
        Log_Level == 4 ||
        Log_Level == 6 ||
        Log_Level == 8 ||
        Log_Level == 10 ||
        Log_Level == 0
      ) {
        businessFunctions.logs(
          "DEBUG: Validated successfully and Fatching Sale details, SaleId:" +
            req.body.sale
        );
      }
      var sale = await Sales.findOne({ _id: req.body.sale }).exec();
      if (sale) {
        var recieved = parseFloat(req.body.amount);
        var date = new Date();
        var payment_mode = req.body.payment_mode;
        var transaction_id = req.body.transaction_id;
        var due_amount = 0;
        if (sale.due) {
          if (sale.due.due) {
            due_amount = sale.due.due;
          }
        }
        if (
          Log_Level == 4 ||
          Log_Level == 6 ||
          Log_Level == 8 ||
          Log_Level == 10 ||
          Log_Level == 0
        ) {
          businessFunctions.logs(
            "DEBUG: Creating Transaction logs, SaleId:" + sale._id
          );
        }
        await TransactionLog.create({
          user: sale.user,
          activity: "Sales",
          business: business,
          source: sale._id,
          paid_total: recieved,
          total: sale.payment.total,
          due: due_amount,
          payment_status: "Success",
          payment_mode: payment_mode,
          transaction_id: transaction_id,
          transaction_date: new Date(req.body.date).toISOString(),
          transaction_status: "Success",
          transaction_response: "Success",
          created_at: new Date(),
          updated_at: new Date(),
        }).then(async function (transaction) {
          var data = {
            user: sale.user,
            business: business,
            status: "Payment-In",
            type: "Payment-In",
            paid_by: "Customer",
            activity: "Payment-In",
            source: sale.user,
            bill_id: "N/A",
            bill_amount: recieved,
            transaction_amount: recieved,
            balance: recieved,
            total: recieved,
            paid_total: 0,
            due: 0,
            payment_status: "Success",
            payment_mode: payment_mode,
            received_by: loggedInDetails.name,
            transaction_id: transaction_id,
            transaction_date: new Date(req.body.date),
            transaction_status: "Success",
            transaction_response: "Success",
            transaction_type: "Payment-In",
            remark: req.body.remark,
          };
          if (
            Log_Level == 4 ||
            Log_Level == 6 ||
            Log_Level == 8 ||
            Log_Level == 10 ||
            Log_Level == 0
          ) {
            businessFunctions.logs(
              "DEBUG: businessFunctions.addTransaction(data) function called from businessFunction.js."
            );
          }
          var valid = q.all(businessFunctions.addTransaction(data));

          var convenience_charges = 0;
          if (sale.payment.convenience_charges) {
            convenience_charges = Math.ceil(sale.payment.convenience_charges);
          }

          // var items = await OrderLine.find({ order: order._id, business: business, status: { $nin: ['Cancelled'] } }).exec();
          var amount = _.sumBy(sale.parts, (x) => x.amount);
          var discount = _.sumBy(sale.parts, (x) => x.discount_total);
          var total = amount + discount + convenience_charges;

          var transaction_log = await TransactionLog.find({
            source: sale._id,
            payment_status: "Success",
          }).exec();

          var paid_total = _.sumBy(transaction_log, (x) => x.paid_total);

          var due =
            Math.ceil(amount.toFixed(2)) +
            Math.ceil(convenience_charges) -
            paid_total;

          var data = {
            updated_at: date,
            "payment.paid_total": paid_total,
            "payment.amount": parseFloat(amount.toFixed(2)),
            "payment.discount_total": parseFloat(discount.toFixed(2)),
            "payment.total": parseFloat(total.toFixed(2)),
            "payment.order_discount": parseFloat(sale.payment.order_discount),
            due: {
              due:
                Math.ceil(amount) +
                convenience_charges -
                paid_total -
                parseFloat(sale.payment.order_discount),
            },
          };

          var orderInvoice = await OrderInvoice.findOne({
            sale: sale._id,
            business: business,
            status: "Active",
          }).exec();
          if (orderInvoice) {
            OrderInvoice.findOneAndUpdate(
              { sale: sale._id, business: business, status: "Active" },
              { $set: data },
              { new: false },
              async function (err, doc) {
                if (err) {
                  if (
                    Log_Level == 1 ||
                    Log_Level == 5 ||
                    Log_Level == 6 ||
                    Log_Level == 7 ||
                    Log_Level == 0
                  ) {
                    businessFunctions.logs(
                      "ERROR: Error Occured while updating invoice details for the sale, SaleId:" +
                        sale._id +
                        ", " +
                        "User:" +
                        loggedInDetails.name
                    );
                  }
                  return res.status(422).json({
                    responseCode: 422,
                    responseMessage: "Server Error",
                    responseData: err,
                  });
                }
              }
            );
          }

          if (
            Log_Level == 4 ||
            Log_Level == 6 ||
            Log_Level == 8 ||
            Log_Level == 10 ||
            Log_Level == 0
          ) {
            businessFunctions.logs(
              "DEBUG: Updating sale details for the sale order, SaleId:" +
                sale._id
            );
          }
          await Sales.findOneAndUpdate(
            { _id: sale._id },
            { $set: data },
            { new: false },
            async function (err, doc) {
              if (err) {
                if (
                  Log_Level == 1 ||
                  Log_Level == 5 ||
                  Log_Level == 6 ||
                  Log_Level == 7 ||
                  Log_Level == 0
                ) {
                  businessFunctions.logs(
                    "ERROR: Error Occured while updating sale details for the sale, SaleId:" +
                      sale._id +
                      ", " +
                      "User:" +
                      loggedInDetails.name
                  );
                }
                res.status(422).json({
                  responseCode: 422,
                  responseMessage: "Server Error",
                  responseData: err,
                });
              } else {
                var updated = await Sales.findOne({
                  _id: sale._id,
                  business: business,
                }).exec();
                var activity = {
                  business: business,
                  activity_by: loggedInDetails.name,
                  activity: "Payment Recieved: " + recieved,
                  remark: "Payment Recieved",
                  created_at: new Date(),
                };
                businessFunctions.salesLogs(sale._id, activity);

                res.status(200).json({
                  responseCode: 200,
                  responseMessage: "Payment Recieved",
                  responseData: {
                    item: {},
                    payment: transaction,
                    due: updated.due,
                  },
                });
                if (
                  Log_Level == 3 ||
                  Log_Level == 7 ||
                  Log_Level == 9 ||
                  Log_Level == 10 ||
                  Log_Level == 0
                ) {
                  businessFunctions.logs(
                    "INFO: Payment Received Successfully for the sale order, SaleId:" +
                      sale._id +
                      ", " +
                      "Amount:" +
                      req.body.amount +
                      ", " +
                      "User:" +
                      loggedInDetails.name
                  );
                }
              }
            }
          );
        });
      } else {
        if (
          Log_Level == 1 ||
          Log_Level == 5 ||
          Log_Level == 6 ||
          Log_Level == 7 ||
          Log_Level == 0
        ) {
          businessFunctions.logs(
            "ERROR: Order not found for the given saleId, SaleId:" +
              req.body.sale +
              ", " +
              "User:" +
              loggedInDetails.name
          );
        }
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Order not found",
          responseData: {},
        });
      }
    }
  }
);
router.post(
  "/order/stock/item/create",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers["business"];
    var product = new Object();
    var result = [];
    var tax = [];
    var total = 0;
    var part = req.body.items;
    var margin_total = 0;
    var part_no = part.part_no;
    part_no = part_no.replace(/,/g, ", ");
    part_no = part_no.toUpperCase();
    var unit = "Piece";
    // console.log("User  = " + user)
    var loggedInDetails = await User.findById(user).exec();
    var businessProduct = await BusinessProduct.find({
      part_no: part_no,
      unit: unit,
      business: business,
    }).exec();
    if (businessProduct.length == 0) {
      var tax_slab = part.tax;
      var sale_price = parseFloat(part.rate); //Sale Price
      part.selling_price = part.rate;
      var base = parseFloat(sale_price);
      var margin = "10%"; //Default Margin

      // var margin = part.margin  //Margin
      var product_brand = null;
      var brand_category = null;
      var category = part.category; //OEM or OES   partNo_category
      var item_name = part.title; //Item name
      var models = [];
      var discount = part.discount;
      var quantity = part.quantity;
      var tax_info = await Tax.findOne({ tax: tax_slab }).exec(); //products[p].tax = "28.0% GST"
      var tax_rate = tax_info.detail;
      var total_amount = 0;

      if (margin) {
        margin = margin.toString();
        if (margin.indexOf("%") >= 0) {
          margin = parseFloat(margin);
          if (!isNaN(margin) && margin > 0) {
            margin_total = sale_price * (margin / 100);
            base = sale_price - margin_total; //To Set By Default 5% Margin to every Product
          }
        } else {
          margin_total = parseFloat(margin);
          base = sale_price - margin_total;
        }
      }
      // console.log("Base Price = " + base)
      // console.log("Margin Price = " + margin_total)
      // console.log("Sale Price  = " + sale_price)
      if (part.isDiscount) {
        // console.log("Discount prints here...", discount)
        if (discount.indexOf("%") >= 0) {
          // console.log("602 - Discount If Condition = " + discount)
          discount = parseFloat(discount);
          if (!isNaN(discount) && discount > 0) {
            var discount_total = base * (discount / 100);
            base = base - parseFloat(discount_total.toFixed(2));
          }
        } else {
          // console.log("610 - Discount ELSE Condition= " + discount)

          discount = parseFloat(discount);
          if (!isNaN(discount) && discount > 0) {
            base = base - parseFloat(discount.toFixed(2));
          }
        }
      }
      var rate = base;
      var amount_is_tax = "exclusive";
      if (amount_is_tax == "exclusive") {
        var tax_on_amount = base;
        if (tax_rate.length > 0) {
          for (var r = 0; r < tax_rate.length; r++) {
            if (tax_rate[r].rate != tax_info.rate) {
              var t = tax_on_amount * (tax_rate[r].rate / 100);
              rate = rate + t;
              tax.push({
                tax: tax_rate[r].tax,
                rate: tax_rate[r].rate,
                amount: parseFloat(t.toFixed(2)),
              });
            } else {
              var t = tax_on_amount * (tax_info.rate / 100);
              rate = rate + t;
              tax.push({
                tax: tax_info.tax,
                tax_rate: tax_info.rate,
                rate: tax_info.rate,
                amount: parseFloat(t.toFixed(2)),
              });
            }
          }
        }
      }
      // console.log("Base + GST +Margin  = ", (rate + margin_total))
      // console.log("Purchase Price  = " + rate)
      // console.log("Amount Price  = " + rate)

      /*
       if (amount_is_tax == "inclusive") {
              var x = (100 + tax_info.rate) / 100;
              var tax_on_amount = amount / x;
              if (tax_rate.length > 0) {
                  for (var r = 0; r < tax_rate.length; r++) {
                      if (tax_rate[r].rate != tax_info.rate) {
                          var t = tax_on_amount * (tax_rate[r].rate / 100);
                          base = base - t;
                          tax.push({
                              tax: tax_rate[r].tax,
                              rate: tax_rate[r].rate,
                              amount: parseFloat(t.toFixed(2))
                          });
                      }
                      else {
                          var t = amount - tax_on_amount;
                          base = base - t;
                          tax.push({
                              tax: tax_info.tax,
                              rate: tax_info.rate,
                              amount: parseFloat(t.toFixed(2))
                          });
                      }
                  }
              }
          }*/
      var taxes = {
        tax: tax_info.tax,
        rate: tax_info.rate,
        amount: amount,
        detail: tax,
      };
      var sku = {
        sku: "Direct Sale",
        total: 0,
        available: 0,
        created_at: new Date(),
      };
      var stock = {
        // total: quantity,
        // consumed: quantity,
        // available: 0 - quantity,
        total: 0,
        consumed: 0,
        available: 0,
      };
      var amount = parseFloat(base) + parseFloat(margin_total);
      // console.log("Total Amountn = " + total_amount)
      var tax_on_amount = amount;
      if (tax_rate.length > 0) {
        for (var r = 0; r < tax_rate.length; r++) {
          if (tax_rate[r].rate != tax_info.rate) {
            var t = tax_on_amount * (tax_rate[r].rate / 100);
            amount = amount + t;
          } else {
            var t = tax_on_amount * (tax_info.rate / 100);
            amount = amount + t;
          }
        }
      }
      // console.log("Amount  = " + amount)

      var price = {
        base: base, //base price with GST
        tax_amount: _.sumBy(tax, (x) => x.amount), //Tax Amount
        purchase_price: rate, //base + GST on base
        rate: parseFloat(part.rate),
        amount: amount,
        mrp: amount,
        discount: 0,
        discount_type: "Not Applicable",
        isDiscount: false,
        margin: margin,
        sell_price: parseFloat(part.rate),
        margin_total: margin_total,
      };

      var list_type = [];
      list_type.push("Offline");
      var purchases = [];
      // console.log("1772 Amount = " + amount)
      var data = {
        purchase: null,
        purchases: purchases,
        business: business,
        product: null,
        product_id:
          Math.round(+new Date() / 1000) + Math.round(Math.random() * 9999 + 1),
        part_no: part_no, //mend
        product_brand: product_brand, //
        product_model: null,
        model: null,
        category: null,
        // _subcategory: brand_category,
        subcategory: brand_category,
        title: item_name,
        short_description: "",
        long_description: "",
        thumbnail: "",
        specification: "",
        hsn_sac: "",
        quantity: 0,
        unit: unit,
        models: models,
        stock: 0,
        sku: sku,
        list_type: list_type,
        price: price,
        amount_is_tax: amount_is_tax,
        tax: tax_info.tax,
        tax_rate: tax_info.rate,
        tax_type: tax_info.tax.split("% ").pop(),
        // tax_type: "GST",
        part_category: category,
        tax_info: taxes,
        list_type: list_type,

        created_at: new Date(),
        updated_at: new Date(),
      };
      var updatedData = {};
      await BusinessProduct.create(data).then(async function (bp) {
        // console.log(bp._id)
        var activity = {
          vendor_name: "Created",
          quantity: 0,
          unit_price: bp.purchase_price,
          price: 0,
          received_by: loggedInDetails.name,
          purchase: null,
          remark: "remark",
          business: business,
          activity: "Created",
          created_at: new Date(),
        };
        fun.productLog(bp._id, activity);
        var product = await BusinessProduct.findOne({ _id: bp._id }).exec();
        updatedData = {
          _id: product._id,
          id: product._id,
          product: product.title,
          part_no: product.part_no,
          hsn_sac: product.hsn_sac,
          specification: product.specification,
          base: product.price.base,
          price: product.price.purchase_price,
          unit: product.unit,
          item_details: product,
        };

        ///////  Next Step Is to Add Item In Order
        var items = [];
        var convenience_charges = 0;
        var discount = 0;
        var total = 0;
        var order = await Order.findById(req.body.order).exec();
        // var loggedInDetails = await User.findById(decoded.user).exec();
        if (order) {
          if (product.title != "" && product.part_no != "") {
            var businessOrder = await BusinessOrder.findOne({
              order: order._id,
              business: business,
            }).exec();

            var log = {
              status: "Confirmed",
              type: "Counter",
              activity: "Confirmed",
              user: loggedInDetails._id,
              name: loggedInDetails.name,
              created_at: new Date(),
              updated_at: new Date(),
            };
            // var id = mongoose.Types.ObjectId();
            var id = null;
            if (part.id != null) {
              id = part.id;
            }
            if (product) {
              var tax_info = await Tax.findOne({ tax: part.tax }).exec();
              if (product) {
                // var product = await BusinessProduct.findOne({ _id: products.product, business: business }).exec();
                // if (product) {
                var tax = [];
                var rate = product.price.rate;
                // console.log("New ORderLine   rate = " + product.price.rate)
                var amount = product.price.rate * quantity;
                // console.log("New ORderLine   quantity = " + quantity)

                // console.log("New ORderLine   amount = " + amount)

                // return res.json(product)
                var tax_rate = tax_info.detail;
                var discount_total = 0;
                var base = amount;

                var discount = product.price.discount;
                if (product.price.isDiscount) {
                  if (discount.indexOf("%") >= 0) {
                    discount = parseFloat(discount);
                    if (!isNaN(discount) && discount > 0) {
                      discount_total = amount * (discount / 100);
                      amount = amount - parseFloat(discount_total.toFixed(2));
                    }
                  } else {
                    if (discount == "") {
                      discount = "0";
                    }

                    discount_total = parseFloat(discount);

                    if (!isNaN(discount_total) && discount_total > 0) {
                      amount = amount - parseFloat(discount_total.toFixed(2));
                    }
                  }
                }

                if (product.amount_is_tax == "exclusive") {
                  var tax_on_amount = amount;
                  if (tax_rate.length > 0) {
                    for (var r = 0; r < tax_rate.length; r++) {
                      if (tax_rate[r].rate != tax_info.rate) {
                        var t = tax_on_amount * (tax_rate[r].rate / 100);
                        amount = amount + t;
                        tax.push({
                          tax: tax_rate[r].tax,
                          rate: tax_rate[r].rate,
                          amount: parseFloat(t.toFixed(2)),
                        });
                      } else {
                        var t = tax_on_amount * (tax_info.rate / 100);
                        amount = amount + t;
                        tax.push({
                          tax: tax_info.tax,
                          tax_rate: tax_info.rate,
                          rate: tax_info.rate,
                          amount: parseFloat(t.toFixed(2)),
                        });
                      }
                    }
                  }
                }
                // console.log("Amount OrderLine  = " + amount);
                if (product.price.amount_is_tax == "inclusive") {
                  var x = (100 + tax_info.rate) / 100;
                  var tax_on_amount = amount / x;
                  if (tax_rate.length > 0) {
                    for (var r = 0; r < tax_rate.length; r++) {
                      if (tax_rate[r].rate != tax_info.rate) {
                        var t = tax_on_amount * (tax_rate[r].rate / 100);
                        base = base - t;
                        tax.push({
                          tax: tax_rate[r].tax,
                          rate: tax_rate[r].rate,
                          amount: parseFloat(t.toFixed(2)),
                        });
                      } else {
                        var t = amount - tax_on_amount;
                        base = base - t;
                        tax.push({
                          tax: tax_info.tax,
                          rate: tax_info.rate,
                          amount: parseFloat(t.toFixed(2)),
                        });
                      }
                    }
                  }
                  //base = base - discount_total;
                }
                // console.log("Base  = " + base)
                var tax_details = {
                  tax: tax_info.tax,
                  rate: tax_info.rate,
                  amount: total,
                  detail: tax,
                };

                items = {
                  order: order._id,
                  product: product._id,
                  category: product.category,
                  _category: product._category,
                  subcategory: product.subcategory,
                  _subcategory: product._subcategory,
                  product_brand: product.product_brand,
                  _brand: product.product_brand,
                  product_model: product.product_model,
                  _model: product.product_model,
                  source: product._id,
                  part_no: product.part_no,
                  hsn_sac: product.hsn_sac,
                  unit: product.unit,
                  title: product.title,
                  sku: product.sku,
                  mrp: product.price.mrp,
                  selling_price: part.rate,
                  rate: product.price.rate,
                  quantity: quantity,
                  base: parseFloat(base.toFixed(2)),
                  amount: amount,
                  discount: part.discount,
                  discount_total: parseFloat(discount_total.toFixed(2)),
                  amount_is_tax: part.amount_is_tax,
                  tax_amount: parseFloat(
                    _.sumBy(tax, (x) => x.amount).toFixed(2)
                  ),
                  amount: parseFloat(amount.toFixed(2)),
                  tax: tax_info.tax,
                  tax_rate: tax_info.rate,
                  tax_info: tax,
                  issued: true,
                  added_by_customer: false,
                  delivery_date: businessOrder.delivery_date,
                  tracking_no:
                    Math.round(+new Date() / 1000) +
                    "-" +
                    Math.ceil(Math.random() * 90000 + 10000),
                  business: business,
                  created_at: new Date(),
                  updated_at: new Date(),
                };
                // }
                // else {
                //     return res.status(400).json({
                //         responseCode: 400,
                //         responseMessage: "Items not found",
                //         responseData: {}
                //     });
                // }
              }
            }

            await OrderLine.create(items).then(async function (ol) {
              var items = await OrderLine.find({
                order: order._id,
                business: business,
                status: { $nin: ["Cancelled"] },
              }).exec();

              if (businessOrder.payment.convenience_charges) {
                convenience_charges = Math.ceil(
                  businessOrder.payment.convenience_charges
                );
              }

              var discount = parseFloat(
                _.sumBy(items, (x) => x.discount_total).toFixed(2)
              );
              var amount = parseFloat(
                _.sumBy(items, (x) => x.amount).toFixed(2)
              );
              var total = amount + discount + convenience_charges;

              var transaction_log = await q.all(
                fun.getOrderTransaction(order._id, business)
              );
              var paid_total = transaction_log.paid_total;

              var data = {
                updated_at: new Date(),
                "payment.paid_total": paid_total,
                "payment.amount": parseFloat(amount.toFixed(2)),
                "payment.discount_total": parseFloat(discount.toFixed(2)),
                "payment.total": parseFloat(total.toFixed(2)),
                "payment.order_discount": parseFloat(
                  order.payment.order_discount
                ),
                due: {
                  due:
                    Math.ceil(amount) +
                    convenience_charges -
                    paid_total -
                    parseFloat(order.payment.order_discount),
                },
              };
              var user = await User.findById(order.user).exec();
              var issued = await q.all(
                businessFunctions.salesPartIssue(
                  ol,
                  business,
                  user,
                  loggedInDetails
                )
              );
              if (issued) {
                await OrderLine.findOneAndUpdate(
                  { _id: order._id },
                  { $set: { issued: issued, updated_at: new Date() } },
                  { new: false },
                  async function (err, doc) {}
                );
              }
              // console.log("Issued = " + issued)

              await Order.findOneAndUpdate(
                { _id: ol._id },
                { $set: data },
                { new: false },
                async function (err, doc) {
                  if (err) {
                    res.status(422).json({
                      responseCode: 422,
                      responseMessage: "Server Error",
                      responseData: err,
                    });
                  } else {
                    // console.log("6212 = " + issued)
                    await BusinessOrder.findOneAndUpdate(
                      { order: order._id, business: business },
                      { $set: data },
                      { new: false },
                      async function (err, doc) {
                        if (err) {
                          res.status(422).json({
                            responseCode: 422,
                            responseMessage: "Server Error",
                            responseData: err,
                          });
                        } else {
                          // console.log("6222  Business = " + business)

                          await BusinessOrder.find({
                            order: businessOrder.order,
                            business: business,
                          })
                            .populate({
                              path: "order",
                              populate: [
                                {
                                  path: "user",
                                  select:
                                    "name contact_no username email account_info ",
                                },
                                {
                                  path: "car",
                                  select:
                                    "title variant registration_no _automaker _model",
                                },
                                { path: "address" },
                              ],
                            })
                            .cursor()
                            .eachAsync(async (p) => {
                              var has_invoice = false;
                              var invoices = await OrderInvoice.find({
                                order: p.order._id,
                                business: business,
                              })
                                .select("status invoice_no")
                                .exec();

                              if (invoices.length > 0) {
                                has_invoice = true;
                              }

                              var orders = {
                                _id: p.order._id,
                                id: p.order._id,
                                items: await q.all(
                                  fun.getBusinessOrderItems(
                                    p.order._id,
                                    business,
                                    req.headers["tz"]
                                  )
                                ),
                                user: p.order.user,
                                car: p.order.car,
                                address: p.order.address,
                                due_date: moment(p.due_date)
                                  .tz(req.headers["tz"])
                                  .format("lll"),
                                delivery_date: moment(p.delivery_date)
                                  .tz(req.headers["tz"])
                                  .format("lll"),
                                time_slot: p.time_slot,
                                convenience: p.order.convenience,
                                order_no: p.order.order_no,
                                address: p.order.address,
                                payment: p.payment,
                                due: p.due,
                                log: p.log,
                                status: p.status,
                                has_invoice: has_invoice,
                                invoices: invoices,
                                created_at: moment(p.created_at)
                                  .tz(req.headers["tz"])
                                  .format("lll"),
                                updated_at: moment(p.updated_at)
                                  .tz(req.headers["tz"])
                                  .format("lll"),
                              };

                              res.status(200).json({
                                responseCode: 200,
                                responseMessage: "success",
                                responseData: orders,
                              });
                            });
                        }
                      }
                    );
                  }
                }
              );
            });
          } else {
            res.status(200).json({
              responseCode: 200,
              responseMessage: "Add New Item",
              responseData: {},
            });
          }
        } else {
          res.status(400).json({
            responseCode: 400,
            responseMessage: "Order not found",
            responseData: {},
          });
        }
      });

      // res.status(200).json({
      //     responseCode: 200,
      //     responseMessage: "Item Created Successfully",
      //     responseData: updatedData
      // });
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Item Already Exist",
        responseData: {},
      });
    }
  }
);

router.post(
  "/sale/stock/item/create",
  xAccessToken.token,
  async function (req, res, next) {
    businessFunctions.logs(
      "INFO: /sale/stock/item/create Api Called from sales.js," +
        " " +
        "Request Headers:" +
        JSON.stringify(req.headers) +
        ", " +
        "Request Body:" +
        JSON.stringify(req.body)
    );

    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers["business"];
    var tax = [];
    var part = req.body.items;
    var margin_total = 0;
    var part_no = part.part_no;
    part_no = part_no.replace(/,/g, ", ");
    part_no = part_no.toUpperCase();
    var unit = "Piece";
    // console.log("User  = " + user)
    var loggedInDetails = await User.findById(user).exec();
    if (
      Log_Level == 4 ||
      Log_Level == 6 ||
      Log_Level == 8 ||
      Log_Level == 10 ||
      Log_Level == 0
    ) {
      businessFunctions.logs(
        "DEBUG: Fatching Part details, part_no:" +
          part_no +
          ", User:" +
          loggedInDetails.name
      );
    }
    var businessProduct = await BusinessProduct.find({
      part_no: part_no,
      unit: unit,
      business: business,
    }).exec();
    if (businessProduct.length == 0) {
      var tax_slab = part.tax;
      var sale_price = parseFloat(part.rate); //Sale Price
      part.selling_price = part.rate;
      var base = parseFloat(sale_price);
      var margin = "7%"; //Default Margin

      // var margin = part.margin  //Margin
      var product_brand = null;
      var brand_category = null;
      var category = part.category; //OEM or OES   partNo_category
      var item_name = part.title; //Item name
      var models = [];
      var discount = part.discount;
      var quantity = part.quantity;
      var tax_info = await Tax.findOne({ tax: tax_slab }).exec(); //products[p].tax = "28.0% GST"
      var tax_rate = tax_info.detail;
      var total_amount = 0;
      // console.log("RATE = " + sale_price)
      if (margin) {
        margin = margin.toString();
        if (margin.indexOf("%") >= 0) {
          margin = parseFloat(margin);
          if (!isNaN(margin) && margin > 0) {
            margin_total = sale_price * (margin / 100);

            base = sale_price - margin_total; //To Set By Default 7% Margin to every Product
          }
        } else {
          margin_total = parseFloat(margin);
          base = sale_price - margin_total;
        }
      }
      // console.log("Base Price = " + base)
      // console.log("Margin Price = " + margin_total)
      // console.log("Sale Price  = " + sale_price)
      if (part.isDiscount) {
        // console.log("Discount prints here...", discount)
        if (discount.indexOf("%") >= 0) {
          // console.log("602 - Discount If Condition = " + discount)
          discount = parseFloat(discount);
          if (!isNaN(discount) && discount > 0) {
            var discount_total = base * (discount / 100);
            base = base - parseFloat(discount_total.toFixed(2));
          }
        } else {
          // console.log("610 - Discount ELSE Condition= " + discount)

          discount = parseFloat(discount);
          if (!isNaN(discount) && discount > 0) {
            base = base - parseFloat(discount.toFixed(2));
          }
        }
      }
      var rate = base;
      var amount_is_tax = "exclusive";
      if (amount_is_tax == "exclusive") {
        var tax_on_amount = base;
        if (tax_rate.length > 0) {
          for (var r = 0; r < tax_rate.length; r++) {
            if (tax_rate[r].rate != tax_info.rate) {
              var t = tax_on_amount * (tax_rate[r].rate / 100);
              rate = rate + t;
              tax.push({
                tax: tax_rate[r].tax,
                rate: tax_rate[r].rate,
                amount: parseFloat(t.toFixed(2)),
              });
            } else {
              var t = tax_on_amount * (tax_info.rate / 100);
              rate = rate + t;
              tax.push({
                tax: tax_info.tax,
                tax_rate: tax_info.rate,
                rate: tax_info.rate,
                amount: parseFloat(t.toFixed(2)),
              });
            }
          }
        }
      }
      // console.log("Base + GST +Margin  = ", (rate + margin_total))
      // console.log("Purchase Price  = " + rate)
      // console.log("Amount Price  = " + rate)

      /*
       if (amount_is_tax == "inclusive") {
              var x = (100 + tax_info.rate) / 100;
              var tax_on_amount = amount / x;
              if (tax_rate.length > 0) {
                  for (var r = 0; r < tax_rate.length; r++) {
                      if (tax_rate[r].rate != tax_info.rate) {
                          var t = tax_on_amount * (tax_rate[r].rate / 100);
                          base = base - t;
                          tax.push({
                              tax: tax_rate[r].tax,
                              rate: tax_rate[r].rate,
                              amount: parseFloat(t.toFixed(2))
                          });
                      }
                      else {
                          var t = amount - tax_on_amount;
                          base = base - t;
                          tax.push({
                              tax: tax_info.tax,
                              rate: tax_info.rate,
                              amount: parseFloat(t.toFixed(2))
                          });
                      }
                  }
              }
          }*/
      var taxes = {
        tax: tax_info.tax,
        rate: tax_info.rate,
        amount: amount,
        detail: tax,
      };
      var sku = {
        sku: "Direct Sale",
        total: 0,
        available: 0,
        created_at: new Date(),
      };
      var stock = {
        // total: quantity,
        // consumed: quantity,
        // available: 0 - quantity,
        total: 0,
        consumed: 0,
        available: 0,
      };
      var amount = parseFloat(base) + parseFloat(margin_total);
      // console.log("Total Amountn = " + total_amount)
      var tax_on_amount = amount;
      if (tax_rate.length > 0) {
        for (var r = 0; r < tax_rate.length; r++) {
          if (tax_rate[r].rate != tax_info.rate) {
            var t = tax_on_amount * (tax_rate[r].rate / 100);
            amount = amount + t;
          } else {
            var t = tax_on_amount * (tax_info.rate / 100);
            amount = amount + t;
          }
        }
      }
      // console.log("Amount  = " + amount)

      var price = {
        base: base, //base price with GST
        tax_amount: _.sumBy(tax, (x) => x.amount), //Tax Amount
        purchase_price: rate, //base + GST on base
        rate: parseFloat(part.rate),
        amount: amount,
        mrp: amount,
        discount: 0,
        discount_type: "Not Applicable",
        isDiscount: false,
        margin: margin,
        sell_price: parseFloat(part.rate),
        margin_total: margin_total,
      };

      var list_type = [];
      list_type.push("Offline");
      var purchases = [];
      // console.log("1772 Amount = " + amount)
      var data = {
        purchase: null,
        purchases: purchases,
        business: business,
        product: null,
        product_id:
          Math.round(+new Date() / 1000) + Math.round(Math.random() * 9999 + 1),
        part_no: part_no, //mend
        product_brand: product_brand, //
        product_model: null,
        model: null,
        category: null,
        // _subcategory: brand_category,
        subcategory: brand_category,
        title: item_name,
        short_description: "",
        long_description: "",
        thumbnail: "",
        specification: "",
        hsn_sac: "",
        quantity: 0,
        unit: unit,
        models: models,
        stock: 0,
        sku: sku,
        list_type: list_type,
        price: price,
        amount_is_tax: amount_is_tax,
        tax: tax_info.tax,
        tax_rate: tax_info.rate,
        tax_type: tax_info.tax.split("% ").pop(),
        // tax_type: "GST",
        part_category: category,
        tax_info: taxes,
        list_type: list_type,

        created_at: new Date(),
        updated_at: new Date(),
      };
      var updatedData = {};
      if (
        Log_Level == 4 ||
        Log_Level == 6 ||
        Log_Level == 8 ||
        Log_Level == 10 ||
        Log_Level == 0
      ) {
        businessFunctions.logs(
          "DEBUG: Creating Stock item, Item_Name:" +
            item_name +
            ", User:" +
            loggedInDetails.name
        );
      }
      await BusinessProduct.create(data).then(async function (bp) {
        // console.log(bp._id)
        var activity = {
          vendor_name: "Created",
          quantity: 0,
          unit_price: bp.purchase_price,
          price: 0,
          received_by: loggedInDetails.name,
          purchase: null,
          remark: "remark",
          business: business,
          activity: "Created",
          created_at: new Date(),
        };
        fun.productLog(bp._id, activity);
        var product = await BusinessProduct.findOne({ _id: bp._id }).exec();
        updatedData = {
          _id: product._id,
          id: product._id,
          product: product.title,
          part_no: product.part_no,
          hsn_sac: product.hsn_sac,
          specification: product.specification,
          base: product.price.base,
          price: product.price.purchase_price,
          unit: product.unit,
          item_details: product,
        };

        ///////  Next Step Is to Add Item In Order
        var items = [];
        var convenience_charges = 0;
        var discount = 0;
        var total = 0;
        var sale = await Sales.findById(req.body.sale).exec();
        var parts = sale.parts;
        // var loggedInDetails = await User.findById(decoded.user).exec();
        if (sale) {
          if (part.title != "") {
            var tax_info = await Tax.findOne({ tax: product.tax }).exec();
            if (tax_info) {
              // if (products.product) {
              // var product = await BusinessProduct.findOne({ _id: product.product, business: business }).exec();
              if (product) {
                var tax = [];
                var rate = product.price.rate;
                var amount = product.price.rate * part.quantity;
                var tax_rate = tax_info.detail;
                var discount_total = 0;
                var base = amount;

                var discount = part.discount;

                if (discount.indexOf("%") >= 0) {
                  discount = parseFloat(discount);
                  if (!isNaN(discount) && discount > 0) {
                    discount_total = amount * (discount / 100);
                    amount = amount - parseFloat(discount_total.toFixed(2));
                  }
                } else {
                  if (discount == "") {
                    discount = "0";
                  }

                  discount_total = parseFloat(discount);

                  if (!isNaN(discount_total) && discount_total > 0) {
                    amount = amount - parseFloat(discount_total.toFixed(2));
                  }
                }

                if (part.amount_is_tax == "exclusive") {
                  if (
                    Log_Level == 4 ||
                    Log_Level == 6 ||
                    Log_Level == 8 ||
                    Log_Level == 10 ||
                    Log_Level == 0
                  ) {
                    businessFunctions.logs(
                      "DEBUG: Calculate Tax Amount fot tax type Exclusive."
                    );
                  }
                  var tax_on_amount = amount;
                  if (tax_rate.length > 0) {
                    for (var r = 0; r < tax_rate.length; r++) {
                      if (tax_rate[r].rate != tax_info.rate) {
                        var t = tax_on_amount * (tax_rate[r].rate / 100);
                        amount = amount + t;
                        tax.push({
                          tax: tax_rate[r].tax,
                          rate: tax_rate[r].rate,
                          amount: parseFloat(t.toFixed(2)),
                        });
                      } else {
                        var t = tax_on_amount * (tax_info.rate / 100);
                        amount = amount + t;
                        tax.push({
                          tax: tax_info.tax,
                          tax_rate: tax_info.rate,
                          rate: tax_info.rate,
                          amount: parseFloat(t.toFixed(2)),
                        });
                      }
                    }
                  }
                }

                if (part.amount_is_tax == "inclusive") {
                  var x = (100 + tax_info.rate) / 100;
                  var tax_on_amount = amount / x;
                  if (tax_rate.length > 0) {
                    for (var r = 0; r < tax_rate.length; r++) {
                      if (tax_rate[r].rate != tax_info.rate) {
                        var t = tax_on_amount * (tax_rate[r].rate / 100);
                        base = base - t;
                        tax.push({
                          tax: tax_rate[r].tax,
                          rate: tax_rate[r].rate,
                          amount: parseFloat(t.toFixed(2)),
                        });
                      } else {
                        var t = amount - tax_on_amount;
                        base = base - t;
                        tax.push({
                          tax: tax_info.tax,
                          rate: tax_info.rate,
                          amount: parseFloat(t.toFixed(2)),
                        });
                      }
                    }
                  }
                  //base = base - discount_total;
                }

                var tax_details = {
                  tax: tax_info.tax,
                  rate: tax_info.rate,
                  amount: total,
                  detail: tax,
                };
                // var issued = await q.all(businessFunctions.salesPartIssue(part, business, user, loggedInDetails));
                // if (issued) {

                // }
                var user = await User.findById(sale.user).exec();
                part.product = product._id;
                var item = {
                  product: product._id,
                  category: product.category,
                  _category: product._category,
                  subcategory: product.subcategory,
                  _subcategory: product._subcategory,
                  product_brand: product.product_brand,
                  _brand: product.product_brand,
                  product_model: product.product_model,
                  _model: product.product_model,
                  source: product.source,
                  part_no: part.part_no,
                  hsn_sac: part.hsn_sac,
                  unit: part.unit,
                  title: part.title,
                  sku: part.sku,
                  mrp: product.price.mrp,
                  selling_price: part.selling_price,
                  rate: product.price.rate,
                  quantity: part.quantity,
                  base: parseFloat(base.toFixed(2)),
                  discount: product.price.discount,
                  discount_total: parseFloat(discount_total.toFixed(2)),
                  amount_is_tax: product.amount_is_tax,
                  tax_amount: parseFloat(
                    _.sumBy(tax, (x) => x.amount).toFixed(2)
                  ),
                  amount: parseFloat(amount.toFixed(2)),
                  tax: tax_info.tax,
                  tax_rate: tax_info.rate,
                  tax_info: tax,
                  issued: await q.all(
                    businessFunctions.salesPartIssue(
                      part,
                      business,
                      user,
                      loggedInDetails
                    )
                  ),
                  added_by_customer: false,
                  created_at: new Date(),
                  updated_at: new Date(),
                };
                // console.log("Issued  = " + item.issued)
                parts.push(item);
              }
            } else {
              res.status(422).json({
                responseCode: 422,
                responseMessage: "Tax Error",
                responseData: err,
              });
            }

            if (sale.payment.convenience_charges) {
              convenience_charges = Math.ceil(sale.payment.convenience_charges);
            }
            var discount =
              parseFloat(_.sumBy(parts, (x) => x.discount_total).toFixed(2)) +
              parseFloat(
                _.sumBy(sale.labours, (x) => x.discount_total).toFixed(2)
              );
            var amount =
              parseFloat(_.sumBy(parts, (x) => x.amount).toFixed(2)) +
              parseFloat(_.sumBy(sale.labours, (x) => x.amount).toFixed(2));
            var total = amount + discount + convenience_charges;
            var transaction_log = await q.all(
              fun.getSalesTransaction(sale._id, business)
            );
            var paid_total = transaction_log.paid_total;
            var data = {
              updated_at: new Date(),
              "payment.paid_total": paid_total,
              "payment.amount": parseFloat(amount.toFixed(2)),
              "payment.discount_total": parseFloat(discount.toFixed(2)),
              "payment.total": parseFloat(total.toFixed(2)),
              "payment.order_discount": parseFloat(sale.payment.order_discount),
              due: {
                due:
                  Math.ceil(amount) +
                  convenience_charges -
                  paid_total -
                  (parseFloat(sale.payment.order_discount) +
                    parseFloat(sale.payment.discount_total)),
              },
              parts: parts,
            };
            await Sales.findOneAndUpdate(
              { _id: sale._id, business: business },
              { $set: data },
              { new: false },
              async function (err, doc) {
                if (err) {
                  if (
                    Log_Level == 1 ||
                    Log_Level == 5 ||
                    Log_Level == 6 ||
                    Log_Level == 7 ||
                    Log_Level == 0
                  ) {
                    businessFunctions.logs(
                      "ERROR: Error Occured while updating sale details, SaleId:" +
                        sale._id +
                        ", User:" +
                        loggedInDetails.name
                    );
                  }
                  res.status(422).json({
                    responseCode: 422,
                    responseMessage: "Server Error",
                    responseData: err,
                  });
                } else {
                  var has_invoice = false;
                  if (
                    Log_Level == 4 ||
                    Log_Level == 6 ||
                    Log_Level == 8 ||
                    Log_Level == 10 ||
                    Log_Level == 0
                  ) {
                    businessFunctions.logs(
                      "DEBUG: Fatching Order Invoice details for the sale, SaleId:" +
                        sale._id
                    );
                  }
                  var invoices = await OrderInvoice.find({
                    sale: sale._id,
                    business: business,
                  })
                    .select("status invoice_no")
                    .exec();
                  if (invoices.length > 0) {
                    has_invoice = true;
                  }
                  var orders = {
                    _id: sale._id,
                    id: sale._id,
                    items: sale.parts,
                    user: sale.user,
                    car: sale.car,
                    address: sale.address,
                    due_date: moment(sale.due_date)
                      .tz(req.headers["tz"])
                      .format("lll"),
                    delivery_date: moment(sale.delivery_date)
                      .tz(req.headers["tz"])
                      .format("lll"),
                    time_slot: sale.time_slot,
                    convenience: sale.convenience,
                    order_no: sale.order_no,
                    address: sale.address,
                    payment: sale.payment,
                    due: sale.due,
                    logs: sale.logs,
                    status: sale.status,
                    has_invoice: has_invoice,
                    invoices: invoices,
                    created_at: moment(sale.created_at)
                      .tz(req.headers["tz"])
                      .format("lll"),
                    updated_at: moment(sale.updated_at)
                      .tz(req.headers["tz"])
                      .format("lll"),
                  };
                  var activity = {
                    business: business,
                    activity_by: loggedInDetails.name,
                    activity: "'" + part.title + "' Added to Order",
                    remark: "Item Added",
                    created_at: new Date(),
                  };
                  // businessFunctions.salesOrderLogs(order._id, activity);

                  res.status(200).json({
                    responseCode: 200,
                    responseMessage: "success",
                    responseData: orders,
                  });
                  if (
                    Log_Level == 3 ||
                    Log_Level == 7 ||
                    Log_Level == 9 ||
                    Log_Level == 10 ||
                    Log_Level == 0
                  ) {
                    businessFunctions.logs(
                      "INFO: Item Added Successfully, Part_Name:" +
                        part.title +
                        ", User:" +
                        loggedInDetails.name
                    );
                  }
                }
              }
            );

            // });
          } else {
            res.status(200).json({
              responseCode: 200,
              responseMessage: "Add New Item",
              responseData: {},
            });
          }
        } else {
          if (
            Log_Level == 2 ||
            Log_Level == 5 ||
            Log_Level == 8 ||
            Log_Level == 9 ||
            Log_Level == 0
          ) {
            businessFunctions.logs(
              "WARNING: Sale order not found for the saleId:" +
                req.body.sale +
                ", User:" +
                loggedInDetails.name
            );
          }
          res.status(400).json({
            responseCode: 400,
            responseMessage: "Order not found",
            responseData: {},
          });
        }
      });
    } else {
      if (
        Log_Level == 2 ||
        Log_Level == 5 ||
        Log_Level == 8 ||
        Log_Level == 9 ||
        Log_Level == 0
      ) {
        businessFunctions.logs(
          "WARNING: Part already exists in the stock, Part_no:" +
            part_no +
            ", User:" +
            loggedInDetails.name
        );
      }
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Item Already Exist",
        responseData: {},
      });
    }
  }
);

router.post(
  "/sale/invoice/generate/old",
  xAccessToken.token,
  async function (req, res, next) {
    var business = req.headers["business"];
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var date = new Date();
    var loggedInDetails = decoded.user;
    var items = [];
    var data = [];

    var item_total = 0;
    var discount = 0;
    var item_total = 0;
    var total = 0;

    var sale = await Sales.findById(req.body.sale).exec();
    var loggedInDetails = await User.findById(decoded.user).exec();
    if (sale) {
      var invoice = await OrderInvoice.findOne({
        sale: sale._id,
        business: business,
        status: "Active",
      })
        .populate({
          path: "sale",
          populate: [
            {
              path: "user",
              select:
                "name contact_no username email account_info business_info",
            },
            { path: "car", select: "variant value" },
            { path: "address" },
          ],
        })
        .exec();
      // order
      if (invoice) {
        await OrderInvoice.findOneAndUpdate(
          { _id: invoice._id },
          { $set: { status: "Cancelled" } },
          { new: true },
          async function (err, invoice) {
            if (err) {
              // res.status(200).json({
              //     responseCode: 200,
              //     responseMessage: "success",
              //     responseData: {}
              // })
            } else {
              var transactionData = {
                user: invoice.user,
                business: invoice.business,
                status: "Sale Cancelled",
                type: "Sale Cancelled",
                paid_by: "-",
                activity: "Invoice",
                source: invoice._id,
                bill_id: invoice.invoice_no,
                bill_amount:
                  parseFloat(invoice.payment.total) -
                  parseFloat(invoice.payment.discount_total),
                transaction_amount:
                  parseFloat(invoice.payment.total) -
                  parseFloat(invoice.payment.discount_total),
                balance:
                  parseFloat(invoice.payment.total) -
                  parseFloat(invoice.payment.discount_total),
                total:
                  parseFloat(invoice.payment.total) -
                  parseFloat(invoice.payment.discount_total),
                paid_total: 0,
                due: 0,
                payment_status: "Cancelled",
                payment_mode: "-",
                received_by: loggedInDetails.name,
                transaction_id: "-",
                transaction_date: new Date(),
                transaction_status: "Success",
                transaction_response: "-",
                transaction_type: "Sale Cancelled",
              };
              q.all(businessFunctions.addTransaction(transactionData));

              var activity = {
                business: business,
                activity_by: loggedInDetails.name,
                activity: "Invoice Cancelled " + "#" + invoice.invoice_no,
                remark: "Invoice Cancelled",
                created_at: new Date(),
              };
              businessFunctions.salesLogs(sale._id, activity);
            }
          }
        );
      }
      var date = new Date();
      var availablity = false;
      // await OrderLine.updateMany({ order: order._id, business: business, issued: true, status: { $nin: ['Cancelled'] } }, { $set: { isInvoice: true } }).exec();
      // var items = await OrderLine.find({ order: order._id, business: business, status: { $nin: ['Cancelled'] } }).exec();

      var nd = _.filter(sale.parts, (status) => status.issued == true);

      if (nd.length <= 0) {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Error! Add some items",
          responseData: {},
        });
      } else {
        // var sale = await Sales.findOne({ _id: sale._id, business: business }).exec();

        OrderInvoice.create({
          business: business,
          user: sale.user,
          sale: sale._id,
          source: sale._id,
          delivery_date: sale.delivery_date,
          due_date: sale.due_date,
          // _order: businessOrder._order,
          sale_no: sale.sale_no,
          note: sale.note,
          invoice_no: sale.invoice_no,
          status: "Active",
          with_tax: true,
          payment: sale.payment,
          due: sale.due,
          created_at: new Date(),
          updated_at: new Date(),
        }).then(async function (inv) {
          var count = await OrderInvoice.find({
            _id: { $lt: inv._id },
            business: business,
            sale: { $ne: null },
          }).count();
          if (count == 0) {
            console.log("If ");
            var last_invoice = "";
            var position = 1;
          } else {
            console.log("ELSE " + count);

            var lv = await OrderInvoice.findOne({
              _id: { $lt: inv._id },
              business: business,
              sale: { $ne: null },
            })
              .sort({ _id: -1 })
              .exec();
            // return res.json({
            //     data: lv
            // })
            var last_invoice = lv.invoice_no;
            position = count + 1;
          }
          console.log("Lats Invoice  -= " + last_invoice);
          var fy = {
            with_tax: inv.with_tax,
            last_invoice: last_invoice,
            position: position,
          };

          var assigned_invoice_no = await q.all(fun.fiscalyear(fy));

          console.log("Assigned Onbocds = " + assigned_invoice_no.invoice);
          if (assigned_invoice_no) {
            if (assigned_invoice_no.invoice) {
              // console.log("Invoice no: " + assigned_invoice_no.invoice)
              await OrderInvoice.findOneAndUpdate(
                { _id: inv._id },
                { $set: { invoice_no: assigned_invoice_no.invoice } },
                { new: true },
                async function (err, doc) {
                  if (err) {
                    res.status(422).json({
                      responseCode: 422,
                      responseMessage: "Server Error",
                      responseData: err,
                    });
                  } else {
                    // status: "Shipped",
                    // var sales = await Sales.findOneAndUpdate({ _id: sale._id }).exec()
                    // sales.parts.forEach(async function (part) {

                    // });

                    await Sales.findOneAndUpdate(
                      { _id: sale._id },
                      {
                        $set: {
                          isInvoice: true,
                          invoice: inv._id,
                          updated_at: new Date(),
                        },
                      },
                      { new: false },
                      async function (err, doc) {
                        if (err) {
                          return res.status(422).json({
                            responseCode: 422,
                            responseMessage: "Server Error",
                            responseData: err,
                          });
                        } else {
                        }
                      }
                    );

                    var sales = await Sales.findOne({ _id: sale._id }).exec();
                    for (var i = 0; i < sales.parts.length; i++) {
                      sales.parts[i].isInvoice = true;
                    }
                    sales.markModified("parts");
                    sales.save();
                    var p = await OrderInvoice.findById(inv._id)
                      .populate({
                        path: "sale",
                        populate: [
                          {
                            path: "user",
                            select:
                              "name contact_no username email account_info business_info",
                          },
                          { path: "car", select: "variant value" },
                          { path: "address" },
                        ],
                      })
                      .exec();

                    var transactions = await q.all(
                      fun.getSalesTransaction(p.sale._id, business)
                    );

                    var transactionData = {
                      user: p.user,
                      business: p.business,
                      status: "Sale Created",
                      type: "Sale",
                      paid_by: "-",
                      activity: "Sales Order",
                      source: p._id,
                      bill_id: p.invoice_no,
                      bill_amount:
                        p.payment.total.toFixed(2) -
                        p.payment.discount_total.toFixed(2),
                      transaction_amount:
                        p.payment.total.toFixed(2) -
                        p.payment.discount_total.toFixed(2),
                      balance:
                        p.payment.total.toFixed(2) -
                        p.payment.discount_total.toFixed(2),
                      total:
                        p.payment.total.toFixed(2) -
                        p.payment.discount_total.toFixed(2),
                      paid_total: 0,
                      due: 0,
                      payment_status: "Pending",
                      payment_mode: "-",
                      received_by: loggedInDetails.name,
                      transaction_id: "-",
                      transaction_date: new Date(),
                      transaction_status: "Success",
                      transaction_response: "-",
                      transaction_type: "Sale",
                    };
                    q.all(businessFunctions.addTransaction(transactionData));

                    var activity = {
                      business: business,
                      activity_by: loggedInDetails.name,
                      activity:
                        "Invoice Generated " +
                        "#" +
                        assigned_invoice_no.invoice,
                      remark: "Invoice Generated",
                      created_at: new Date(),
                    };
                    businessFunctions.salesLogs(sale._id, activity);

                    res.status(200).json({
                      responseCode: 200,
                      responseMessage: "success",
                      responseData: {
                        _id: p._id,
                        id: p._id,
                        items: p.sale.parts,
                        user: p.sale.user,
                        car: p.sale.car,
                        address: p.sale.address,
                        due_date: moment(p.due_date)
                          .tz(req.headers["tz"])
                          .format("lll"),
                        delivery_date: moment(p.delivery_date)
                          .tz(req.headers["tz"])
                          .format("lll"),
                        time_slot: p.time_slot,
                        convenience: p.convenience,
                        order_no: p.order_no,
                        _order: p._order,
                        invoice_no: p.invoice_no,
                        address: p.sale.address,
                        payment: p.payment,
                        status: p.status,
                        due: p.due,
                        log: p.log,
                        transactions: transactions.transactions,
                        created_at: moment(p.created_at)
                          .tz(req.headers["tz"])
                          .format("lll"),
                        updated_at: moment(p.updated_at)
                          .tz(req.headers["tz"])
                          .format("lll"),
                      },
                    });
                  }
                }
              );
            } else {
              res.status(422).json({
                responseCode: 422,
                responseMessage: "Server Error",
                responseData: {},
              });
            }
          } else {
            res.status(422).json({
              responseCode: 422,
              responseMessage: "Server Error",
              responseData: {},
            });
          }
        });
      }
    }
    // }
    else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Order not found",
        responseData: {},
      });
    }
  }
);
router.post(
  "/sale/invoice/generate",
  xAccessToken.token,
  async function (req, res, next) {
    businessFunctions.logs(
      "INFO:/sale/invoice/generate Api Called from sales.js," +
        " " +
        "Request Headers:" +
        JSON.stringify(req.headers) +
        ", " +
        "Request Query:" +
        JSON.stringify(req.query)
    );

    var business = req.headers["business"];
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var date = new Date();
    var loggedInDetails = decoded.user;
    var items = [];
    var data = [];

    var item_total = 0;
    var discount = 0;
    var item_total = 0;
    var total = 0;

    var sale = await Sales.findById(req.body.sale).exec();
    var loggedInDetails = await User.findById(decoded.user).exec();
    if (sale) {
      var invoice = await OrderInvoice.findOne({
        sale: sale._id,
        business: business,
        status: "Active",
      })
        .populate({
          path: "sale",
          populate: [
            {
              path: "user",
              select:
                "name contact_no username email account_info business_info",
            },
            { path: "car", select: "variant value" },
            { path: "address" },
          ],
        })
        .exec();
      // order
      if (invoice) {
        await OrderInvoice.findOneAndUpdate(
          { _id: invoice._id },
          { $set: { status: "Cancelled" } },
          { new: true },
          async function (err, invoice) {
            if (err) {
              // res.status(200).json({
              //     responseCode: 200,
              //     responseMessage: "success",
              //     responseData: {}
              // })
            } else {
              var transactionData = {
                user: invoice.user,
                business: invoice.business,
                status: "Sale Cancelled",
                type: "Sale Cancelled",
                paid_by: "-",
                activity: "Invoice",
                source: invoice._id,
                bill_id: invoice.invoice_no,
                bill_amount:
                  parseFloat(invoice.payment.total) -
                  parseFloat(invoice.payment.discount_total),
                transaction_amount:
                  parseFloat(invoice.payment.total) -
                  parseFloat(invoice.payment.discount_total),
                balance:
                  parseFloat(invoice.payment.total) -
                  parseFloat(invoice.payment.discount_total),
                total:
                  parseFloat(invoice.payment.total) -
                  parseFloat(invoice.payment.discount_total),
                paid_total: 0,
                due: 0,
                payment_status: "Cancelled",
                payment_mode: "-",
                received_by: loggedInDetails.name,
                transaction_id: "-",
                transaction_date: new Date(),
                transaction_status: "Success",
                transaction_response: "-",
                transaction_type: "Sale Cancelled",
              };
              q.all(businessFunctions.addTransaction(transactionData));

              var activity = {
                business: business,
                activity_by: loggedInDetails.name,
                activity: "Invoice Cancelled " + "#" + invoice.invoice_no,
                remark: "Invoice Cancelled",
                created_at: new Date(),
              };
              businessFunctions.salesLogs(sale._id, activity);
            }
          }
        );
      }
      var date = new Date();
      var availablity = false;
      // await OrderLine.updateMany({ order: order._id, business: business, issued: true, status: { $nin: ['Cancelled'] } }, { $set: { isInvoice: true } }).exec();
      // var items = await OrderLine.find({ order: order._id, business: business, status: { $nin: ['Cancelled'] } }).exec();

      var nd = _.filter(sale.parts, (status) => status.issued == true);

      if (nd.length <= 0) {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Error! Add some items",
          responseData: {},
        });
      } else {
        // var sale = await Sales.findOne({ _id: sale._id, business: business }).exec();

        OrderInvoice.create({
          business: business,
          user: sale.user,
          sale: sale._id,
          source: sale._id,
          delivery_date: sale.delivery_date,
          due_date: sale.due_date,
          // _order: businessOrder._order,
          sale_no: sale.sale_no,
          note: sale.note,
          invoice_no: sale.invoice_no,
          status: "Active",
          with_tax: true,
          payment: sale.payment,
          due: sale.due,
          created_at: new Date(),
          updated_at: new Date(),
        }).then(async function (inv) {
          var count = await OrderInvoice.find({
            _id: { $lt: inv._id },
            business: business,
            sale: { $ne: null },
          }).count();
          if (count == 0) {
            // console.log("If ")
            var last_invoice = "";
            var position = 1;
          } else {
            // console.log("ELSE " + count)

            var lv = await OrderInvoice.findOne({
              _id: { $lt: inv._id },
              business: business,
              sale: { $ne: null },
            })
              .sort({ _id: -1 })
              .exec();
            // return res.json({
            //     data: lv
            // })
            var last_invoice = lv.invoice_no;
            position = count + 1;
          }
          // console.log("Lats Invoice  -= " + last_invoice)
          var fy = {
            with_tax: inv.with_tax,
            last_invoice: last_invoice,
            position: position,
          };

          var assigned_invoice_no = await q.all(fun.fiscalyear(fy));

          // console.log("Assigned Onbocds = " + assigned_invoice_no.invoice)
          if (assigned_invoice_no) {
            if (assigned_invoice_no.invoice) {
              // console.log("Invoice no: " + assigned_invoice_no.invoice)
              await OrderInvoice.findOneAndUpdate(
                { _id: inv._id },
                { $set: { invoice_no: assigned_invoice_no.invoice } },
                { new: true },
                async function (err, doc) {
                  if (err) {
                    res.status(422).json({
                      responseCode: 422,
                      responseMessage: "Server Error",
                      responseData: err,
                    });
                  } else {
                    // status: "Shipped",
                    // var sales = await Sales.findOneAndUpdate({ _id: sale._id }).exec()
                    // sales.parts.forEach(async function (part) {

                    // });

                    await Sales.findOneAndUpdate(
                      { _id: sale._id },
                      {
                        $set: {
                          isInvoice: true,
                          invoice: inv._id,
                          updated_at: new Date(),
                        },
                      },
                      { new: false },
                      async function (err, doc) {
                        if (err) {
                          return res.status(422).json({
                            responseCode: 422,
                            responseMessage: "Server Error",
                            responseData: err,
                          });
                        } else {
                        }
                      }
                    );

                    var sales = await Sales.findOne({ _id: sale._id }).exec();
                    for (var i = 0; i < sales.parts.length; i++) {
                      sales.parts[i].isInvoice = true;
                    }
                    sales.markModified("parts");
                    sales.save();
                    var p = await OrderInvoice.findById(inv._id)
                      .populate({
                        path: "sale",
                        populate: [
                          {
                            path: "user",
                            select:
                              "name contact_no username email account_info business_info",
                          },
                          { path: "car", select: "variant value" },
                          { path: "address" },
                        ],
                      })
                      .exec();

                    var transactions = await q.all(
                      fun.getSalesTransaction(p.sale._id, business)
                    );

                    var transactionData = {
                      user: p.user,
                      business: p.business,
                      status: "Sale Created",
                      type: "Sale",
                      paid_by: "-",
                      activity: "Sales Order",
                      source: p._id,
                      bill_id: p.invoice_no,
                      bill_amount:
                        p.payment.total.toFixed(2) -
                        p.payment.discount_total.toFixed(2),
                      transaction_amount:
                        p.payment.total.toFixed(2) -
                        p.payment.discount_total.toFixed(2),
                      balance:
                        p.payment.total.toFixed(2) -
                        p.payment.discount_total.toFixed(2),
                      total:
                        p.payment.total.toFixed(2) -
                        p.payment.discount_total.toFixed(2),
                      paid_total: 0,
                      due: 0,
                      payment_status: "Pending",
                      payment_mode: "-",
                      received_by: loggedInDetails.name,
                      transaction_id: "-",
                      transaction_date: new Date(),
                      transaction_status: "Success",
                      transaction_response: "-",
                      transaction_type: "Sale",
                    };
                    q.all(businessFunctions.addTransaction(transactionData));
                    // var itemDetails = await q.all(fun.getBusinessOrderItems(p.order._id, business, req.headers['tz']));
                    //console.log("P"+p.business);
                    fun.orderInvoice(p.sale.parts, p, p.sale.address);

                    var activity = "Invoice Generate-Sale";
                    fun.webNotification(activity, p);

                    var activity = {
                      business: business,
                      activity_by: loggedInDetails.name,
                      activity:
                        "Invoice Generated " +
                        "#" +
                        assigned_invoice_no.invoice,
                      remark: "Invoice Generated",
                      created_at: new Date(),
                    };
                    businessFunctions.salesLogs(sale._id, activity);

                    res.status(200).json({
                      responseCode: 200,
                      responseMessage: "Invoice Generated Successfully",
                      responseData: {
                        _id: p._id,
                        id: p._id,
                        items: p.sale.parts,
                        user: p.sale.user,
                        car: p.sale.car,
                        address: p.sale.address,
                        due_date: moment(p.due_date)
                          .tz(req.headers["tz"])
                          .format("lll"),
                        delivery_date: moment(p.delivery_date)
                          .tz(req.headers["tz"])
                          .format("lll"),
                        time_slot: p.time_slot,
                        convenience: p.convenience,
                        order_no: p.order_no,
                        _order: p._order,
                        invoice_no: p.invoice_no,
                        address: p.sale.address,
                        payment: p.payment,
                        status: p.status,
                        due: p.due,
                        log: p.log,
                        transactions: transactions.transactions,
                        created_at: moment(p.created_at)
                          .tz(req.headers["tz"])
                          .format("lll"),
                        updated_at: moment(p.updated_at)
                          .tz(req.headers["tz"])
                          .format("lll"),
                      },
                    });
                  }
                }
              );
            } else {
              res.status(422).json({
                responseCode: 422,
                responseMessage: "Server Error",
                responseData: {},
              });
            }
          } else {
            res.status(422).json({
              responseCode: 422,
              responseMessage: "Server Error",
              responseData: {},
            });
          }
        });
      }
    }
    // }
    else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Order not found",
        responseData: {},
      });
    }
  }
);

router.get(
  "/sale/invoice/get",
  xAccessToken.token,
  async function (req, res, next) {
    console.time("looper");
    var rules = {
      invoice: "required",
    };

    var validation = new Validator(req.query, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Invoice is required",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var business = req.headers["business"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);

      var p = await OrderInvoice.findById(req.query.invoice)
        .populate({
          path: "sale",
          populate: [
            {
              path: "user",
              select:
                "name contact_no username email account_info business_info",
            },
            {
              path: "business",
              select:
                "name contact_no username email account_info business_info bank_details",
            },
            { path: "car", select: "variant value" },
            { path: "address" },
          ],
        })
        .exec();
      if (p) {
        var transactions = await q.all(
          fun.getSalesTransaction(p.sale._id, business)
        );
        var business_info = await User.findById(p.business)
          .select(
            "name contact_no username email account_info business_info bank_details address"
          )
          .exec();
        var sale = await Sales.findById(p.sale._id)
          .select("parts id _id sale_no")
          .exec();

        res.status(200).json({
          responseCode: 200,
          responseMessage: "success",
          responseData: {
            _id: p._id,
            id: p._id,
            items: sale.parts,
            user: p.sale.user,
            car: p.sale.car,
            due_date: moment(p.due_date).tz(req.headers["tz"]).format("lll"),
            delivery_date: moment(p.delivery_date)
              .tz(req.headers["tz"])
              .format("lll"),
            time_slot: p.time_slot,
            convenience: p.convenience,
            order_no: p.sale_no,
            // _order: p._order,
            invoice_no: p.invoice_no,
            address: p.sale.address,
            payment: p.payment,
            status: p.status,
            business: business_info,
            due: p.due,

            note: p.note,
            log: p.log,
            transactions: transactions.transactions,
            created_at: moment(p.created_at)
              .tz(req.headers["tz"])
              .format("lll"),
            updated_at: moment(p.updated_at)
              .tz(req.headers["tz"])
              .format("lll"),
          },
        });
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Invoice not found",
          responseData: {},
        });
      }
    }
    // console.timeEnd('looper')
  }
);

router.get(
  "/sale/payments/log",
  xAccessToken.token,
  async function (req, res, next) {
    var business = req.headers["business"];
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    var sale = await Sales.findById(req.query.sale).exec();
    if (sale) {
      var logs = [];
      await TransactionLog.find({ source: req.query.sale, business: business })
        .sort({ updated_at: -1 })
        .cursor()
        .eachAsync(async (log) => {
          logs.push({
            _id: log._id,
            id: log._id,
            activity: log.activity,
            payment_mode: log.payment_mode,
            paid_total: log.paid_total,
            payment_status: log.payment_status,
            transaction_id: log.transaction_id,
            transaction_date: log.transaction_date,
            transaction_status: log.transaction_status,
            transaction_response: log.transaction_response,
            user: log.user,
            source: log.source,
            paid_total: log.paid_total,
            total: log.total,
            type: log.type,
            created_at: moment(log.created_at)
              .tz(req.headers["tz"])
              .format("lll"),
            updated_at: moment(log.updated_at)
              .tz(req.headers["tz"])
              .format("lll"),
          });
        });
      res.status(200).json({
        responseCode: 200,
        responseMessage: "Transaction Log",
        responseData: logs,
      });
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Sale not found",
        responseData: {},
      });
    }
  }
);

router.put("/sale/cancel", xAccessToken.token, async function (req, res, next) {
  var business = req.headers["business"];
  var token = req.headers["x-access-token"];
  var secret = config.secret;
  var decoded = jwt.verify(token, secret);
  var date = new Date();
  var loggedInDetails = decoded.user;
  var items = [];
  var data = [];

  var item_total = 0;
  var discount = 0;
  var item_total = 0;
  var total = 0;

  var sale = await Sales.findById(req.body.sale).exec();
  var loggedInDetails = await User.findById(decoded.user).exec();
  if (sale) {
    sale.parts.forEach(async function (part) {
      if (part.issued == true) {
        var r = await q.all(businessFunctions.orderItemReturn(part));
      }
    });
    var date = new Date();
    // var businessOrder = await BusinessOrder.findOne({ order: order._id, business: business }).exec();

    var data = {
      updated_at: new Date(),
      status: "Cancelled",
    };

    await Sales.findOneAndUpdate(
      { _id: sale._id },
      { $set: data },
      { new: false },
      async function (err, doc) {
        if (err) {
          res.status(422).json({
            responseCode: 422,
            responseMessage: "Server Error",
            responseData: err,
          });
        } else {
          // { order: order._id, business: business, status: "Active" }
          await OrderInvoice.findOneAndUpdate(
            { sale: sale._id, business: business, status: "Active" },
            { $set: { status: "Cancelled", updated_at: new Date() } },
            { new: false },
            async function (err, doc) {
              if (err) {
                res.status(422).json({
                  responseCode: 422,
                  responseMessage: "Server Error",
                  responseData: err,
                });
              } else {
              }
            }
          );

          var orders = {
            _id: sale._id,
            id: sale._id,
            items: sale.parts,
            user: sale.user,
            car: sale.car,
            address: sale.address,
            due_date: moment(sale.due_date).tz(req.headers["tz"]).format("lll"),
            delivery_date: moment(sale.delivery_date)
              .tz(req.headers["tz"])
              .format("lll"),
            time_slot: sale.time_slot,
            convenience: sale.convenience,
            order_no: sale.order_no,
            address: sale.address,
            payment: sale.payment,
            due: sale.due,
            log: sale.log,
            status: sale.status,
            created_at: moment(sale.created_at)
              .tz(req.headers["tz"])
              .format("lll"),
            updated_at: moment(sale.updated_at)
              .tz(req.headers["tz"])
              .format("lll"),
          };

          var activity = {
            business: business,
            activity_by: loggedInDetails.name,
            activity: "Sale Cancelled",
            remark: "Sale Cancelled",
            created_at: new Date(),
          };
          businessFunctions.salesLogs(sale._id, activity);

          res.status(200).json({
            responseCode: 200,
            responseMessage: "success",
            responseData: orders,
          });
        }
      }
    );
  } else {
    res.status(400).json({
      responseCode: 400,
      responseMessage: "Order not found",
      responseData: {},
    });
  }
});

router.post(
  "/sale/create",
  xAccessToken.token,
  async function (req, res, next) {
    var business = req.headers["business"];
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var date = new Date();
    var loggedInDetails = decoded.user;
    var items = [];
    var item_total = 0;
    var discount = 0;
    var total = 0;
    var due = {
      due: 0,
    };
    var loggedInDetails = await User.findById(decoded.user).exec();
    var user = await User.findById(req.body.user).exec();
    if (user) {
      var payment = {
        payment_mode: "",
        payment_status: "",
        extra_charges_limit: 0,
        convenience_charges: 0,
        discount_type: "",
        coupon_type: "",
        coupon: "",
        discount_applied: false,
        total: total,
        discount_total: discount,
        paid_total: 0,
      };
      var salesCount = await Sales.find({ business: business }).count().exec();
      var data = {
        business: business,
        user: user._id,
        created_by: loggedInDetails._id,
        sale_no: salesCount + 1,
        note: "note",
        status: "Open",
        items: items,
        payment: payment,
        due: due,
        logs: [],
        isInvoice: false,
        invoice: null,
        created_at: date,
        updated_at: date,
      };

      await Sales.create(data).then(async function (sale) {
        var activity = {
          business: business,
          activity_by: loggedInDetails.name,
          activity: "Sale Created",
          remark: "Sale",
          created_at: new Date(),
        };
        businessFunctions.salesLogs(sale._id, activity);
        res.status(200).json({
          responseCode: 200,
          responseMessage: "Sale Successfully Created",
          responseData: {
            sale: sale,
          },
        });
      });
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "User not found",
        responseData: {},
      });
    }
  }
);

router.post(
  "/bill/payment/out",
  xAccessToken.token,
  async function (req, res, next) {
    businessFunctions.logs(
      "INFO: /bill/payment/out Api Called from 3.0.js," +
        " " +
        "Request Headers:" +
        JSON.stringify(req.headers) +
        ", " +
        "Request Query:" +
        JSON.stringify(req.query)
    );

    var rules = {
      bill: "required",
      amount: "required",
      transaction_date: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      if (
        Log_Level == 1 ||
        Log_Level == 5 ||
        Log_Level == 6 ||
        Log_Level == 7 ||
        Log_Level == 0
      ) {
        businessFunctions.logs(
          "ERROR: Validation failed, Amount & Date are mandatory"
        );
      }
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Amount & Date are mandatory",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var business = req.headers["business"];
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var data = [];
      var loggedInDetails = await User.findById(decoded.user).exec();

      var purchase = await Purchase.findOne({ _id: req.body.bill }).exec();
      if (purchase) {
        var recieved = parseFloat(req.body.amount);
        var date = new Date();
        var payment_mode = req.body.payment_mode;
        var transaction_id = req.body.transaction_id;
        var due_amount = 0;
        if (purchase.due) {
          if (purchase.due.due) {
            due_amount = purchase.due.due;
          }
        }
        await TransactionLog.create({
          user: purchase.business,
          activity: "Sales",
          business: business,
          source: purchase._id,
          paid_total: recieved,
          total: purchase.total,
          due: due_amount,
          payment_status: "Success",
          payment_mode: payment_mode,
          transaction_id: transaction_id,
          transaction_date: new Date(req.body.transaction_date).toISOString(),
          transaction_status: "Success",
          transaction_response: "Success",
          created_at: new Date(),
          updated_at: new Date(),
        }).then(async function (transaction) {
          var data = {
            user: purchase.vendor,
            business: business,
            status: "Payment-Out",
            type: "Payment-Out",
            paid_by: "Business",
            activity: "Payment-Out",
            source: purchase.vendor,
            bill_id: "N/A",
            bill_amount: recieved,
            transaction_amount: recieved,
            balance: recieved,
            total: recieved,
            paid_total: 0,
            due: 0,
            payment_status: "Success",
            payment_mode: payment_mode,
            received_by: loggedInDetails.name,
            transaction_id: transaction_id,
            transaction_date: new Date(req.body.transaction_date),
            transaction_status: "Success",
            transaction_response: "Success",
            transaction_type: "Payment-Out",
            remark: req.body.remark,
          };
          var valid = q.all(businessFunctions.addTransaction(data));
          if (valid) {
            var data = {
              user: business,
              business: purchase.vendor,
              status: "Payment-In",
              type: "Payment-In",
              paid_by: loggedInDetails.name,
              activity: "Payment-In",
              source: business,
              bill_id: "N/A",
              bill_amount: recieved,
              transaction_amount: recieved,
              balance: recieved,
              total: recieved,
              paid_total: 0,
              due: 0,
              payment_status: "Success",
              payment_mode: payment_mode,
              received_by: loggedInDetails.name,
              transaction_id: transaction_id,
              transaction_date: new Date(req.body.transaction_date),
              transaction_status: "Success",
              transaction_response: "Success",
              transaction_type: "Payment-In",
              remark: req.body.remark,
            };
            var valid = q.all(businessFunctions.addTransaction(data));
          }
          var transaction_log = await TransactionLog.find({
            source: purchase._id,
            payment_status: "Success",
          }).exec();
          var paid_total = _.sumBy(transaction_log, (x) => x.paid_total);
          var due = Math.ceil(purchase.total) - paid_total;

          var data = {
            paid_total: paid_total,
            due: due,
            updated_at: new Date(),
          };
          await Purchase.findOneAndUpdate(
            { _id: purchase._id },
            { $set: data },
            { new: true },
            async function (err, doc) {
              if (err) {
                res.status(422).json({
                  responseCode: 422,
                  responseMessage: "Server Error",
                  responseData: err,
                });
              } else {
                var updated = await Purchase.findOne({
                  _id: purchase._id,
                  business: business,
                }).exec();
                // var activity = {
                //     business: business,
                //     activity_by: loggedInDetails.name,
                //     activity: "Payment Recieved: " + recieved,
                //     remark: "Payment Recieved",
                //     created_at: new Date(),
                // }
                // businessFunctions.salesLogs(sale._id, activity);

                res.status(200).json({
                  responseCode: 200,
                  responseMessage: "Payment Recieved",
                  responseData: {
                    item: {},
                    payment: transaction,
                    due: updated.due,
                  },
                });
              }
            }
          );
        });
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Order not found",
          responseData: {},
        });
      }
    }
  }
);

router.get(
  "/web/notifications/get",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var business = req.headers["business"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    // var role = await User.findById(decoded.user).exec();
    var role = await Management.findOne({
      user: decoded.user,
      business: business,
    }).exec();
    if (role) {
      var userlogged = role.user;
      var notifications = [];
      if (req.query.page == undefined) {
        var page = 0;
      } else {
        var page = req.query.page;
      }
      var page = Math.max(0, parseInt(page));
      var query = {};
      if (role.role == "CRE") {
        query = {
          title: "New Lead",
          assignee: userlogged,
        };
      } else if (role.role == "Service Advisor") {
        var page = Math.max(0, parseInt(page));
        query = {
          title: "New Booking",
          advisor: userlogged,
        };
      } else {
        query = {
          business: userlogged,
        };
      }

      // var counter = await WebNotification.find(query).count().exec()
      await WebNotification.find(query)
        .sort({ created_at: -1 })
        .limit(config.perPage)
        .skip(config.perPage * page)
        .cursor()
        .eachAsync(async (n) => {
          notifications.push({
            Id: n._id,
            business: n.business,
            name: n.name,
            contact_no: n.contact_no,
            type: n.type,
            source: n._id,
            leadSource: n.source,
            title: n.title,
            body: n.body,
            isChecked: n.isChecked,
            status: n.status,
            created_at: n.created_at,
          });
        });
      var counter = _.filter(notifications, (data) => data.isChecked == false);
      res.status(200).json({
        responseCode: 200,
        responseMessage: {
          //  totalRead:
          //  totalUnread:
          counter: counter.length,
        },
        responseData: notifications,
      });
    } else {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "User not found",
        responseData: {},
      });
    }
  }
);

router.put(
  "/sale-purchase/linked/item/mark",
  xAccessToken.token,
  async function (req, res, next) {
    businessFunctions.logs(
      "INFO:/sale-purchase/linked/item/mark Api Called from vendorOrder.js," +
        " " +
        "Request Headers:" +
        JSON.stringify(req.headers) +
        ", " +
        "Request Body:" +
        JSON.stringify(req.body)
    );

    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var business = req.headers["business"];
    var user = await User.findById(decoded.user).exec();

    var type = req.body.type;
    var item = req.body.item;
    var isMarked = req.body.isMarked;
    var index = req.body.index;

    if (type == "Sale") {
      if (
        Log_Level == 4 ||
        Log_Level == 6 ||
        Log_Level == 8 ||
        Log_Level == 10 ||
        Log_Level == 0
      ) {
        businessFunctions.logs(
          "DEBUG: Fatching Order Item Details, OrderId:" +
            item.order +
            ", " +
            "Order Type: Sale, " +
            "User:" +
            user.name
        );
      }
      var order = await Order.findById(item.order).exec();
      if (order) {
        if (
          Log_Level == 4 ||
          Log_Level == 6 ||
          Log_Level == 8 ||
          Log_Level == 10 ||
          Log_Level == 0
        ) {
          businessFunctions.logs(
            "DEBUG: Updating the item Status isMarked for the item:" +
              item.order +
              ", " +
              "User:" +
              user.name
          );
        }
        await OrderLine.findOneAndUpdate(
          { _id: item._id },
          { $set: { isMarked: isMarked, updated_at: new Date() } },
          { new: true },
          async function (err, doc) {
            if (err) {
              if (
                Log_Level == 1 ||
                Log_Level == 5 ||
                Log_Level == 6 ||
                Log_Level == 7 ||
                Log_Level == 0
              ) {
                businessFunctions.logs(
                  "ERROR: Error Occured while updating the item status, ItemId:" +
                    item._id +
                    ", " +
                    "OrderId:" +
                    item.order +
                    ", " +
                    "User:" +
                    user.name
                );
              }
              res.status(422).json({
                responseCode: 422,
                responseMessage: "Server Errro",
                responseData: err,
              });
            } else {
              res.status(200).json({
                responseCode: 200,
                responseMessage: "Item Marked",
                responseData: doc,
              });
              if (
                Log_Level == 3 ||
                Log_Level == 7 ||
                Log_Level == 9 ||
                Log_Level == 10 ||
                Log_Level == 0
              ) {
                businessFunctions.logs(
                  "INFO: Item Marked Successfully, Item" +
                    ", " +
                    "OrderId:" +
                    item.order +
                    ", " +
                    "User:" +
                    user.name
                );
              }
            }
          }
        );
      }
      // console.log("Item Id =" + item._id)
    } else if (type == "Purchase") {
      var vendorOrderId = req.body.vendorOrderId;
      if (
        Log_Level == 4 ||
        Log_Level == 6 ||
        Log_Level == 8 ||
        Log_Level == 10 ||
        Log_Level == 0
      ) {
        businessFunctions.logs(
          "DEBUG: Fatching Order Item Details, OrderId:" +
            vendorOrderId +
            ", " +
            "Order Type: Purchase, " +
            "User:" +
            user.name
        );
      }
      var vendorOrder = await VendorOrders.findById(vendorOrderId).exec();
      // var purchaserParts = _.filter(vendorOrder.parts, type => type._id.equals(item._id));
      for (var i = 0; i < vendorOrder.parts.length; i++) {
        if (
          Log_Level == 4 ||
          Log_Level == 6 ||
          Log_Level == 8 ||
          Log_Level == 10 ||
          Log_Level == 0
        ) {
          businessFunctions.logs(
            "DEBUG: Updating the item Status isMarked for the item" +
              ", " +
              "OrderId:" +
              vendorOrderId +
              ", " +
              "User:" +
              user.name
          );
        }
        if (vendorOrder.parts[i]._id.equals(item._id)) {
          vendorOrder.parts[i].isMarked = req.body.isMarked;
          break;
        }
      }
      vendorOrder.markModified("parts");
      await vendorOrder.save();

      res.status(200).json({
        responseCode: 200,
        responseMessage: "Item Marked",
        responseData: vendorOrder,
      });
      if (
        Log_Level == 3 ||
        Log_Level == 7 ||
        Log_Level == 9 ||
        Log_Level == 10 ||
        Log_Level == 0
      ) {
        businessFunctions.logs(
          "INFO: Item Marked Successfully, Item" +
            ", " +
            "OrderId:" +
            vendorOrderId +
            ", " +
            "User:" +
            user.name
        );
      }
    }

    // var order = await VendorOrders.findOne({ _id: req.body.order, business: business, order_status: { $nin: ['Cancelled'] } }).exec();
    // if (order) {
    //     await VendorOrders.findOneAndUpdate({ _id: order._id }, { $set: { status: 'Cancelled', order_status: 'Cancelled', updated_at: new Date() } }, { new: true }, async function (err, doc) {
    //         if (err) {
    //             var salesOrder = await Order.findOneAndUpdate({ vendorOrder: order._id, status: { $nin: ['Cancelled'] } }).exec();
    //             if (salesOrder) {

    //             }
    //             res.status(422).json({
    //                 responseCode: 422,
    //                 responseMessage: "Server Errro",
    //                 responseData: err
    //             });
    //         }
    //         else { }
    //     })
    //     res.status(200).json({
    //         responseCode: 200,
    //         responseMessage: "Order Cancelled",
    //         responseData: {

    //         }
    //     });
    // } else {
    //     res.status(400).json({
    //         responseCode: 400,
    //         responseMessage: "Order not found",
    //         responseData: {

    //         }
    //     });
    // }
  }
);

router.post(
  "/parchi/create",
  xAccessToken.token,
  async function (req, res, next) {
    var business = req.headers["business"];
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var date = new Date();
    var loggedInDetails = decoded.user;
    var items = [];
    var discount = 0;
    var total = 0;
    var due = {
      due: 0,
    };
    var loggedInDetails = await User.findById(decoded.user).exec();

    var sale = null;
    var order = null;
    var isLinked = false;
    var user = null;
    if (req.body.sale) {
      // console.log("Sale  =  " + req.body.sale)
      var counterSale = await Sales.findOne({
        _id: req.body.sale,
        isParchi: false,
        status: { $nin: ["Cancelled"] },
      })
        .select("_id id parts")
        .exec();
      if (counterSale) {
        // console.log("counterSale  =  " + req.body.sale)

        var parts = counterSale.parts;
        parts.forEach(async function (part) {
          items.push({
            product: part.product,
            part_no: part.part_no,
            hsn_sac: part.hsn_sac,
            title: part.title,
            quantity: parseFloat(part.quantity),
            sku: part.sku,
            unit: part.unit,
            amount: parseFloat(part.amount),
            selling_price: (
              parseFloat(part.amount) / parseFloat(part.quantity)
            ).toFixed(2),
            created_at: new Date(),
            updated_at: new Date(),
          });
        });
        sale = req.body.sale;
        isLinked = true;
      } else {
        res.status(422).json({
          responseCode: 200,
          responseMessage: "Parchi Already Attached ",
          responseData: {},
        });
      }
    } else if (req.body.order) {
      var order = await Order.findById(req.body.order).select("_id id").exec();
      if (order) {
        var parts = await OrderLine.find({
          order: req.body.order,
          issued: true,
          business: business,
          status: { $nin: ["Cancelled"] },
        }).exec();
        parts.forEach(async function (part) {
          items.push({
            product: part.product,
            part_no: part.part_no,
            hsn_sac: part.hsn_sac,
            title: part.title,
            quantity: parseFloat(part.quantity),
            sku: part.sku,
            unit: part.unit,
            amount: parseFloat(part.amount),
            selling_price: (
              parseFloat(part.amount) / parseFloat(part.quantity)
            ).toFixed(2),
            created_at: new Date(),
            updated_at: new Date(),
          });
        });
        order = req.body.order;
        isLinked = true;
      } else {
        res.status(422).json({
          responseCode: 422,
          responseMessage: "Parchi Already Attached ",
          responseData: err,
        });
      }
    }
    var user = await User.findById(req.body.user).exec();
    if (user) {
      // total=items
      // console.log("Items Length Outside = " + items.length)
      total = parseFloat(_.sumBy(items, (x) => x.amount));
      var payment = {
        payment_mode: "",
        payment_status: "",
        extra_charges_limit: 0,
        convenience_charges: 0,
        discount_type: "",
        coupon_type: "",
        coupon: "",
        discount_applied: false,
        total: total,
        discount_total: discount,
        paid_total: 0,
      };
      var parchiCounts = await Parchi.find({
        business: business,
        status: { $nin: ["Cancelled"] },
      })
        .count()
        .exec();
      var data = {
        business: business,
        user: user._id,
        created_by: loggedInDetails._id,
        parchi_no: parchiCounts + 1,
        note: "note",
        status: "Open",
        parts: items,
        payment: payment,
        "due.due": total,
        logs: [],
        sale: sale,
        order: order,
        isLinked: isLinked,
        created_at: date,
        updated_at: date,
      };

      await Parchi.create(data).then(async function (parchi) {
        if (parchi.sale) {
          await Sales.findOneAndUpdate(
            { _id: parchi.sale },
            {
              $set: {
                isParchi: true,
                parchi: parchi._id,
                updated_at: new Date(),
              },
            },
            { new: true },
            async function (err, doc) {
              if (!err) {
                var activity = {
                  business: business,
                  activity_by: loggedInDetails.name,
                  activity: "Prachi Created",
                  remark: parchi.parchi_no,
                  created_at: new Date(),
                };
                businessFunctions.salesLogs(parchi.sale, activity);
              } else {
                res.status(422).json({
                  responseCode: 422,
                  responseMessage: "Server Error",
                  responseData: {},
                });
              }
            }
          );
        } else if (parchi.order) {
          // console.log("Order Parchi Created " + parchi.order)
          await Order.findOneAndUpdate(
            { _id: parchi.order },
            {
              $set: {
                isParchi: true,
                parchi: parchi._id,
                updated_at: new Date(),
              },
            },
            { new: true },
            async function (err, doc) {
              if (!err) {
                var activity = {
                  business: business,
                  activity_by: loggedInDetails.name,
                  activity: "Prachi Created",
                  remark: parchi.parchi_no,
                  created_at: new Date(),
                };
                businessFunctions.salesOrderLogs(parchi.order, activity);
              } else {
                res.status(422).json({
                  responseCode: 422,
                  responseMessage: "Server Error",
                  responseData: {},
                });
              }
            }
          );
        }

        var activity = {
          business: business,
          activity_by: loggedInDetails.name,
          activity: "Parchi Created",
          remark: "Parchi",
          created_at: new Date(),
        };
        businessFunctions.parchiLogs(parchi._id, activity);
        res.status(200).json({
          responseCode: 200,
          responseMessage: "Parchi Successfully Created",
          responseData: {
            parchi: parchi,
          },
        });
      });
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "User not found",
        responseData: {},
      });
    }
  }
);

router.get(
  "/parchi/list/get",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var business = req.headers["business"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var allParchi = [];
    if (req.query.page == undefined) {
      var page = 0;
    } else {
      var page = req.query.page;
    }

    if (req.query.limit) {
      var limit = parseInt(req.query.limit);
    } else {
      var limit = 20;
    }

    var filters = [];
    var match = [];
    var queries = {};

    if (req.query.query) {
      var specification = {};
      specification["$lookup"] = {
        from: "User",
        localField: "user",
        foreignField: "_id",
        as: "user",
      };
      filters.push(specification);

      var specification = {};
      specification["$unwind"] = {
        path: "$user",
        preserveNullAndEmptyArrays: false,
      };
      filters.push(specification);

      req.query.query = req.query.query.replace(
        /([.?*+^$[\]\\(){}|-])/g,
        "\\$1"
      );
      var specification = {};
      specification["$match"] = {
        business: mongoose.Types.ObjectId(business),
        $or: [
          // { '_order': { $regex: req.query.query, $options: 'i' } },
          { status: { $regex: req.query.query, $options: "i" } },
          { parchi_no: { $regex: req.query.query, $options: "i" } },
          { "user.name": { $regex: req.query.query, $options: "i" } },
          { "user.contact_no": { $regex: req.query.query, $options: "i" } },
        ],
      };
      filters.push(specification);

      var specification = {};
      specification["$match"] = {
        status: { $in: ["Open"] },
      };
      filters.push(specification);

      var specification = {};
      specification["$sort"] = {
        created_at: -1,
      };
      filters.push(specification);

      var specification = {};
      specification["$skip"] = config.perPage * page;
      filters.push(specification);

      var specification = {};
      specification["$limit"] = limit;
      filters.push(specification);

      if (req.query.date) {
        var date = new Date();
        //from 10-05-21to13-07-21
        if (req.query.dateType == "range") {
          var query = req.query.date;
          var ret = query.split("to");
          var from = new Date(ret[0]);
          var to = new Date(ret[1]);
        }

        // 70 Days
        else if (req.query.dateType == "period") {
          if (parseInt(req.query.date) > 1) {
            var days = parseInt(req.query.date);
            var from = new Date(
              date.getFullYear(),
              date.getMonth(),
              date.getDate() - days
            );
            var to = new Date(
              date.getFullYear(),
              date.getMonth(),
              date.getDate() + 1
            );
          } else if (parseInt(req.query.date) == 0) {
            var query = parseInt(req.query.date);
            var from = new Date(
              date.getFullYear(),
              date.getMonth(),
              date.getDate()
            );
            var to = new Date(
              date.getFullYear(),
              date.getMonth(),
              date.getDate() + 1
            );
          } else if (parseInt(req.query.date) == 1) {
            var query = parseInt(req.query.date);
            var from = new Date(
              date.getFullYear(),
              date.getMonth(),
              date.getDate() - 1
            );
            var to = new Date(
              date.getFullYear(),
              date.getMonth(),
              date.getDate()
            );
          }
        } else {
          var from = new Date(
            date.getFullYear(),
            date.getMonth(),
            date.getDate()
          );
          var to = new Date(
            date.getFullYear(),
            date.getMonth(),
            date.getDate() + 1
          );
        }
        var specification = {};
        specification["$match"] = {
          created_at: { $gte: from, $lte: to },
        };
        filters.push(specification);
      }
    } else {
      var specification = {};
      specification["$match"] = {
        status: { $in: ["Open"] },
      };
      filters.push(specification);

      var specification = {};
      specification["$match"] = {
        business: mongoose.Types.ObjectId(business),
      };
      filters.push(specification);

      var specification = {};
      specification["$sort"] = {
        created_at: -1,
      };
      filters.push(specification);

      var specification = {};
      specification["$skip"] = config.perPage * page;
      filters.push(specification);

      var specification = {};
      specification["$limit"] = limit;
      filters.push(specification);

      if (req.query.date) {
        var date = new Date();
        //from 10-05-21to13-07-21
        if (req.query.dateType == "range") {
          var query = req.query.date;
          var ret = query.split("to");
          var from = new Date(ret[0]);
          var to = new Date(ret[1]);
        }

        // 70 Days
        else if (req.query.dateType == "period") {
          if (parseInt(req.query.date) > 1) {
            var days = parseInt(req.query.date);
            var from = new Date(
              date.getFullYear(),
              date.getMonth(),
              date.getDate() - days
            );
            var to = new Date(
              date.getFullYear(),
              date.getMonth(),
              date.getDate() + 1
            );
          } else if (parseInt(req.query.date) == 0) {
            var query = parseInt(req.query.date);
            var from = new Date(
              date.getFullYear(),
              date.getMonth(),
              date.getDate()
            );
            var to = new Date(
              date.getFullYear(),
              date.getMonth(),
              date.getDate() + 1
            );
          } else if (parseInt(req.query.date) == 1) {
            var query = parseInt(req.query.date);
            var from = new Date(
              date.getFullYear(),
              date.getMonth(),
              date.getDate() - 1
            );
            var to = new Date(
              date.getFullYear(),
              date.getMonth(),
              date.getDate()
            );
          }
        } else {
          var from = new Date(
            date.getFullYear(),
            date.getMonth(),
            date.getDate()
          );
          var to = new Date(
            date.getFullYear(),
            date.getMonth(),
            date.getDate() + 1
          );
        }
        var specification = {};
        specification["$match"] = {
          created_at: { $gte: from, $lte: to },
        };
        filters.push(specification);
      }
    }

    var query = filters;
    // , 'Confirmed'/
    await Parchi.aggregate(query)
      .cursor()
      .exec()
      .eachAsync(async (parchii) => {
        var parchi = await Parchi.findOne({
          _id: parchii._id,
          status: { $in: ["Open"] },
        })
          .populate({ path: "business", select: "name contact_no" })
          .populate({ path: "order", select: "_id order_no" })
          .populate({ path: "sale", select: "sale_no" })
          .populate({ path: "user", select: "name contact_no" })
          .populate({ path: "created_by", select: "name contact_no" })
          .exec();

        var statementData = {};
        var details = await q.all(
          businessFunctions.getStatementDetails({
            user: parchi.user,
            business: business,
          })
        );
        if (details) {
          // console.l.log("Data = " + JSON.stringify(details));
          statementData = {
            // totalSale: details.totalSale - details.totalSaleCancelled,
            // totalPurchase: details.totalPurchase - details.totalPurchaseCancelled,
            // totalPaymentIn: details.totalPaymentIn,
            // totalPaymentOut: details.totalPaymentOut,
            // totalPurchaseCancelled: details.totalPurchaseCancelled,
            // totalSaleCancelled: details.totalPurchaseCancelled,
            balance: currencyFormatter.format(details.balance, { code: "INR" }),
            // lastTransaction: details.lastTransaction
          };
        }
        if (parchi.order) {
          var businessOrder = await BusinessOrder.findOne({
            order: parchi.order._id,
          }).exec();
          parchi.order.order_no = businessOrder.order_no;
        }
        allParchi.push({
          _id: parchi._id,
          id: parchi._id,
          business: parchi.business,
          user: parchi.user,
          // created_by: parchi.created_by,
          parchi_no: parchi.parchi_no,
          status: parchi.status,
          payment: parchi.payment,
          payment_total: currencyFormatter.format(
            parchi.payment.total.toFixed(2),
            { code: "INR" }
          ),
          due: currencyFormatter.format(parchi.due, { code: "INR" }),
          isLinked: parchi.isLinked,
          sale: parchi.sale,
          order: parchi.order,
          // invoice: parchi.invoice,
          statementData: statementData,
          created_at: parchi.created_at,
          updated_at: parchi.updated_at,
        });
      });

    var linkedPrchiCount = 0;
    var unlinkedPrchiCount = 0;

    if (req.query.date) {
      var totalResult = await Parchi.find({
        business: business,
        status: { $in: ["Open"] },
        created_at: { $gte: from, $lte: to },
      }).exec();
      var parchi = await Parchi.find({
        business: business,
        isLinked: false,
        status: { $in: ["Open"] },
        created_at: { $gte: from, $lte: to },
      }).exec();
      linkedPrchiCount = await Parchi.find({
        business: business,
        isLinked: true,
        status: { $in: ["Open"] },
        created_at: { $gte: from, $lte: to },
      }).count();
      unlinkedPrchiCount = await Parchi.find({
        business: business,
        isLinked: false,
        status: { $in: ["Open"] },
        created_at: { $gte: from, $lte: to },
      }).count();
    } else {
      var totalResult = await Parchi.find({
        business: business,
        status: { $in: ["Open"] },
      }).exec();
      var parchi = await Parchi.find({
        business: business,
        isLinked: false,
        status: { $in: ["Open"] },
      }).exec();
      linkedPrchiCount = await Parchi.find({
        business: business,
        isLinked: true,
        status: { $in: ["Open"] },
      }).count();
      unlinkedPrchiCount = await Parchi.find({
        business: business,
        isLinked: false,
        status: { $in: ["Open"] },
      }).count();
    }

    var map_payment = _.map(totalResult, "payment");
    var parchiSales_Amount = parseFloat(
      _.sumBy(map_payment, (x) => x.total).toFixed(2)
    );

    var map_payment = _.map(parchi, "payment");

    var unlinkedAmount = parseFloat(
      _.sumBy(map_payment, (x) => x.total).toFixed(2)
    );
    // console.log("unlinkedAmount", unlinkedAmount)

    var unlinkedAmount_result = await businessFunctions.numberConversion(
      unlinkedAmount
    );
    var parchiSales_Amount_result = await businessFunctions.numberConversion(
      parchiSales_Amount
    );

    res.status(200).json({
      responseCode: 200,
      responseMessage: "Sucesss",
      responseInfo: {
        totalResult: await Parchi.find({
          business: business,
          status: { $in: ["Open"] },
        })
          .count()
          .exec(),
      },
      responseData: {
        parchi: allParchi,
        total: {
          linkedCount: linkedPrchiCount,
          unlinkedCount: unlinkedPrchiCount,
          unlinkedAmount: unlinkedAmount_result,
          parchiSales_Amount: parchiSales_Amount_result,
        },
      },
    });
  }
);
router.get(
  "/parchi/details/get",
  xAccessToken.token,
  async function (req, res, next) {
    console.time("looper");
    var token = req.headers["x-access-token"];
    var business = req.headers["business"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    var parchi = await Parchi.findOne({
      _id: req.query.parchi,
      business: business,
      status: { $nin: ["Cancelled"] },
    })
      .populate({
        path: "user",
        select: "name contact_no username email account_info business_info",
      })
      .populate({
        path: "business",
        select:
          "name address business_info contact_no email account_info bank_details",
      })
      .populate("address")
      .exec();
    if (parchi) {
      var statementData = {};
      var details = await q.all(
        businessFunctions.getStatementDetails({
          user: parchi.user,
          business: business,
        })
      );
      if (details) {
        // console.l.log("Data = " + JSON.stringify(details));
        statementData = {
          // totalSale: details.totalSale - details.totalSaleCancelled,
          // totalPurchase: details.totalPurchase - details.totalPurchaseCancelled,
          // totalPaymentIn: details.totalPaymentIn,
          // totalPaymentOut: details.totalPaymentOut,
          // totalPurchaseCancelled: details.totalPurchaseCancelled,
          // totalSaleCancelled: details.totalPurchaseCancelled,
          balance: details.balance,
          // lastTransaction: details.lastTransaction
        };
      }
      var activeInvoice = await OrderInvoice.find({
        user: parchi.user,
        business: business,
        status: "Active",
      })
        .populate({ path: "sale", select: "sale_no created_at id _id" })
        .populate({ path: "order", select: "order_no created_at id _id" })
        .select("status invoice_no updated_at sale order")
        .sort({ created_at: -1 })
        .exec();

      var parts = [];
      for (i = 0; i < parchi.parts.length; i++) {
        parts.push({
          product: parchi.parts[i].product,
          unit: parchi.parts[i].unit,
          part_no: parchi.parts[i].part_no,
          hsn_sac: parchi.parts[i].hsn_sac,
          title: parchi.parts[i].title,
          description: parchi.parts[i].description,
          selling_price: parchi.parts[i].selling_price.toFixed(2),
          issued: parchi.parts[i].issued,
          quantity: parchi.parts[i].quantity,
          amount: parchi.parts[i].amount.toFixed(2),
          _id: parchi.parts[i]._id,
          created_at: parchi.parts[i].created_at,
          updated_at: parchi.parts[i].updated_at,
        });
      }
      var map_quantity = _.map(parchi.parts, "quantity");
      var quantity = _.sumBy(map_quantity);

      var data = {
        _id: parchi._id,
        id: parchi._id,
        parts: parts,
        user: parchi.user,
        car: parchi.car,
        address: parchi.address,
        statementData: statementData,
        party_balance: currencyFormatter.format(
          statementData.balance.toFixed(2),
          { code: "INR" }
        ),
        parchi_no: parchi.parchi_no,
        business: parchi.business,
        address: parchi.address,
        payment: parchi.payment,
        payment_total: currencyFormatter.format(
          parchi.payment.total.toFixed(2),
          { code: "INR" }
        ),
        total_quantity: quantity,
        status: parchi.status,
        due: parchi.due,
        due_amount: currencyFormatter.format(parchi.due.due.toFixed(2), {
          code: "INR",
        }),
        note: parchi.note,
        logs: parchi.logs,
        sale: parchi.sale,
        order: parchi.order,
        isLinked: parchi.isLinked,
        created_at: moment(parchi.created_at)
          .tz(req.headers["tz"])
          .format("lll"),
        updated_at: moment(parchi.updated_at)
          .tz(req.headers["tz"])
          .format("lll"),

        // isInvoiceUpToDate: isInvoiceUpToDate,
      };
      fun.eParchiPdf(parchi._id, statementData);

      res.status(200).json({
        responseCode: 200,
        responseMessage: "success",
        responseData: data,
      });
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Parchi Not Found",
        responseData: {},
      });
    }
    // console.timeEnd('looper')
  }
);

router.get(
  "/parchi/items/search/",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      query: "required",
      // quantity: 'required',
    };
    var validation = new Validator(req.query, rules);
    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Part Name / Part No Required",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var id = mongoose.Types.ObjectId();
      var business = req.headers["business"];
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var data = [];
      await BusinessProduct.find({
        business: business,
        list_type: { $in: ["Offline"] },
        $or: [
          { part_no: new RegExp(req.query.query, "i") },
          { title: new RegExp(req.query.query, "i") },
          { models: { $in: new RegExp(req.query.query, "i") } },
        ],
      })
        .cursor()
        .eachAsync(async (p) => {
          var tax_rate = p.tax.split("% ")[0];
          var tax_amount = p.price.rate * (tax_rate / 100);
          var selling_price = p.price.rate + tax_amount;
          p.price.sell_price = selling_price;

          // console.log("p.price.rate = " + p.price.rate)
          // console.log("Tax Rate = " + tax_rate)
          // console.log("tax_amount = " + tax_amount)
          // console.log("p.price.selleing_price = " + p.price.selling_price)
          data.push({
            _id: p.id,
            id: p.id,
            title: p.title,
            sku: p.sku,
            part_no: p.part_no,
            hsn_sac: p.hsn_sac,
            product: p._id,
            unit: p.unit,
            issued: false,
            discount: p.price.discount,
            discount_type: p.price.discount_type,
            amount_is_tax: p.amount_is_tax,
            price: p.price,
            selling_price: selling_price,
            // tax_amount: parseFloat(_.sumBy(tax, x => x.amount).toFixed(2)),
            tax: p.tax,
            tax_rate: p.tax_info.rate,
            // tax_info: tax_details,
            available: p.stock.available,
            business: p.business,
          });
        });

      res.status(200).json({
        responseCode: 200,
        responseMessage: "",
        responseData: data,
      });
    }
  }
);

router.post("/parchi/items/add", async (req, res, next) => {
  var token = req.headers["x-access-token"];
  var secret = config.secret;
  var decoded = jwt.verify(token, secret);
  var user = decoded.user;
  var business = req.headers["business"];
  var loggedInDetails = await User.findById(decoded.user).exec();
  var part = req.body.items;
  var parchiId = req.body.parchi;
  // var status = req.body.status
  // console.log("parts  ", parts)
  var parchi = await Parchi.findById(parchiId).exec();
  if (parchi) {
    var items = parchi.parts;
    var tax = [];
    var total = 0;
    // console.log("parts ", parts)
    if (part) {
      // for (var p = 0; p < parts.length; p++) {
      if (part.quantity != null) {
        items.push({
          product: part.product,
          part_no: part.part_no,
          hsn_sac: part.hsn_sac,
          title: part.title,
          quantity: parseFloat(part.quantity),
          sku: part.sku,
          unit: part.unit,
          amount: parseFloat(part.amount),
          selling_price: parseFloat(part.selling_price),
          created_at: new Date(),
          updated_at: new Date(),
          // base: base,
          // unit_base_price: parseFloat(part.unit_base_price),
          // tax_amount: _.sumBy(tax, x => x.amount),
          // unit_price: amount / parseFloat(part.quantity),
          // amount_is_tax: part.amount_is_tax,
          // margin: parseFloat(part.margin),

          // discount: part.discount,
          // discount_type: part.discount_type,
          // discount_total: discount_total,
          // tax: tax_info.tax,
          // tax_rate: tax_info.rate,
          // tax_info: tax,
          // isChecked: part.false,
          // remark: part.remark,
          // sentDate: new Date(),
          // status: "confirmed"
        });
      } else {
        res.status(422).json({
          responseCode: 422,
          responseMessage: "Invalid Quantity  " + part.item,
          responseData: {},
        });
      }

      var total_amount = _.sumBy(items, (x) => x.amount);
      // order_status: 'Open',
      // order_status: "Open",
      // status: 'confirmed',
      await Parchi.findOneAndUpdate(
        { _id: parchiId },
        {
          $set: {
            parts: items,
            "payment.total": total_amount,
            updated_at: new Date(),
          },
        },
        { new: true },
        async function (err, doc) {
          if (err) {
            res.status(422).json({
              responseCode: 422,
              responseMessage: "Server Error...",
              responseData: err,
            });
          } else {
            var activity = {
              business: business,
              activity_by: loggedInDetails.name,
              activity:
                "Title: ' " +
                part.title +
                " ' , Qty: " +
                part.quantity +
                " , Amt: " +
                part.amount +
                " (Added)  ",
              // time: new Date().getTime.toLocaleTimeString(),
              remark: "New Part Added",
              created_at: new Date(),
            };
            businessFunctions.parchiLogs(parchiId, activity);
            // console.log("Activity")
            // businessFunctions.vendorOrderLogs(order._id, activity);
            // await QuotationOrders.findByOneAndUpdate({_id:order.quotation},{$set:{quotation_submitted:}})
          }
        }
      );
      res.status(200).json({
        responseCode: 200,
        responseMessage: "Successfully Saved",
        responseData: {},
      });
    }
  } else {
    res.status(422).json({
      responseCode: 422,
      responseMessage: "Order Not Found ",
      responseData: {},
    });
  }
});

router.put("/parchi/remark/add", xAccessToken.token, async (req, res, next) => {
  var token = req.headers["x-access-token"];
  var business = req.headers["business"];
  var secret = config.secret;
  var decoded = jwt.verify(token, secret);
  var user = decoded.user;
  var loggedInDetails = await User.findById(decoded.user).exec();

  var rules = {
    parchi: "required",
  };
  var validation = new Validator(req.body, rules);
  if (validation.fails()) {
    res.status(422).json({
      responseCode: 422,
      responseMessage: "Error",
      responseData: {
        res: validation.errors.all(),
      },
    });
  } else {
    var parchi = await Parchi.findOne({
      _id: req.body.parchi,
      business: business,
    }).exec();
    if (parchi) {
      await Parchi.findOneAndUpdate(
        { _id: parchi._id },
        { $set: { remark: req.body.remark, updated_at: new Date() } },
        { new: true },
        async function (err, doc) {
          if (err) {
            res.status(422).json({
              responseCode: 422,
              responseMessage: "Server Error...",
              responseData: err,
            });
          } else {
            var activity = {
              business: business,
              activity: "Parchi Reamrk added successfully",
              activity_by: loggedInDetails.name,
              remark: "Remark Added",
              created_at: new Date(),
            };
            businessFunctions.parchiLogs(parchi._id, activity);
          }
        }
      );

      res.status(200).json({
        responseCode: 200,
        responseMessage: "Remark added Successfully",
        responseData: {},
      });
    } else {
      if (
        Log_Level == 2 ||
        Log_Level == 5 ||
        Log_Level == 8 ||
        Log_Level == 9 ||
        Log_Level == 0
      ) {
        businessFunctions.logs(
          "WARNING: Parchi Not Found with the given quotationId:" +
            req.body.parchi +
            ", " +
            "User:" +
            loggedInDetails.name
        );
      }
      res.status(400).json({
        responseCode: 400,
        responseMessage: "parchi Not Found",
        responseData: {},
      });
    }
  }
});

router.put("/parchi/item/remove", async (req, res, next) => {
  var token = req.headers["x-access-token"];
  var business = req.headers["business"];
  var secret = config.secret;
  var decoded = jwt.verify(token, secret);
  var partIndex = req.body.index;
  var loggedInDetails = await User.findById(decoded.user).exec();

  var parchi = await Parchi.findById(req.body.parchi).exec();
  if (parchi) {
    var activity = {
      business: business,
      activity:
        "Item Removed- " +
        "Item: " +
        parchi.parts[partIndex].title +
        " " +
        "Part_No: " +
        parchi.parts[partIndex].part_no +
        " " +
        "Quantity: " +
        parchi.parts[partIndex].quantity,
      activity_by: loggedInDetails.name,
      remark: "",
      created_at: new Date(),
    };
    businessFunctions.parchiLogs(parchi._id, activity);

    parchi.parts.splice(partIndex, 1);
    parchi.markModified("parts");
    await parchi.save();

    var parchi = await Parchi.findById(req.body.parchi).exec();
    var total_amount = _.sumBy(parchi.parts, (x) => x.amount);
    await Parchi.findOneAndUpdate(
      { _id: req.body.parchi },
      { $set: { "payment.total": total_amount, updated_at: new Date() } },
      { new: true },
      async function (err, doc) {
        if (err) {
          res.status(422).json({
            responseCode: 422,
            responseMessage: "Server Error...",
            responseData: err,
          });
        } else {
        }
      }
    );

    res.status(200).json({
      responseCode: 200,
      responseMessage: "Removed Successfully",
      responseData: {},
    });
  } else {
    res.status(400).json({
      responseCode: 400,
      responseMessage: "Parchi Not Found",
      responseData: {},
    });
  }
});

router.put("/cancel/eParchi", async (req, res, next) => {
  var token = req.headers["x-access-token"];
  var business = req.headers["business"];
  var secret = config.secret;
  var decoded = jwt.verify(token, secret);
  var partIndex = req.body.partIndex;
  var loggedInDetails = await User.findById(decoded.user).exec();
  var parchi = await Parchi.findById(req.body.parchi).exec();
  if (parchi) {
    var data = {
      status: "Cancelled",
      updated_at: new Date(),
      isLinked: false,
      sale: null,
      order: null,
    };
    await Parchi.findOneAndUpdate(
      { _id: parchi._id, business: business },
      { $set: data },
      { new: true },
      async function (err, doc) {
        if (err) {
          res.status(422).json({
            responseCode: 422,
            responseMessage: "Server Error",
            responseData: err,
          });
        } else {
          var update = {
            parchi: null,
            isParchi: false,
            updated_at: new Date(),
          };
          if (parchi.sale) {
            console.log("Sales");
            await Sales.findOneAndUpdate(
              { _id: parchi.sale, business: business },
              { $set: update },
              { new: true },
              async function (err, doc) {
                if (err) {
                  res.status(422).json({
                    responseCode: 422,
                    responseMessage: "Server Error",
                    responseData: err,
                  });
                } else {
                  var activity = {
                    business: business,
                    activity_by: loggedInDetails.name,
                    activity: "Pacrhi liked with this sale has been Cancelled",
                    remark: "Cancelled",
                    created_at: new Date(),
                  };
                  businessFunctions.salesLogs(parchi.sale, activity);
                }
              }
            );
          } else if (parchi.order) {
            console.log("Orders");
            await Order.findOneAndUpdate(
              { _id: parchi.order, business: business },
              { $set: update },
              { new: true },
              async function (err, doc) {
                if (err) {
                  res.status(422).json({
                    responseCode: 422,
                    responseMessage: "Server Error",
                    responseData: err,
                  });
                } else {
                  var activity = {
                    business: business,
                    activity_by: loggedInDetails.name,
                    activity: "Pacrhi liked with this Order has been Cancelled",
                    remark: "Cancelled",
                    created_at: new Date(),
                  };
                  businessFunctions.OrderLogs(parchi.order, activity);
                }
              }
            );
          }
          var activity = {
            business: business,
            activity_by: loggedInDetails.name,
            activity: "Pacrhi Cancelled",
            remark: "Cancelled",
            created_at: new Date(),
          };
          businessFunctions.parchiLogs(parchi._id, activity);
        }
      }
    );
    res.status(200).json({
      responseCode: 200,
      responseMessage: "Cancelled Successfully",
      responseData: {},
    });
  } else {
    res.status(400).json({
      responseCode: 400,
      responseMessage: "Parchi Not Found",
      responseData: {},
    });
  }
});

router.put("/parchi/item/edit", async (req, res, next) => {
  var token = req.headers["x-access-token"];
  var business = req.headers["business"];
  var secret = config.secret;
  var decoded = jwt.verify(token, secret);
  var user = decoded.user;
  var index = req.body.index;
  var part = req.body.item;
  var loggedInDetails = await User.findById(user).exec();
  var parchi = await Parchi.findOne({ _id: req.body.parchi }).exec();
  if (parchi) {
    if (part) {
      if (!isNaN(parseFloat(part.quantity))) {
        parchi.parts[index].part_no = part.part_no;
        parchi.parts[index].item = part.title;
        parchi.parts[index].quantity = parseFloat(part.quantity);
        parchi.parts[index].amount = parseFloat(part.amount);
        parchi.parts[index].selling_price = parseFloat(part.selling_price);
        parchi.parts[index].updated_at = new Date();
        parchi.markModified("parts");
        parchi.save();
      } else {
        res.status(422).json({
          responseCode: 422,
          responseMessage: "Invalid Quantity, Rate " + part.item,
          responseData: {},
        });
      }
      var total_amount = _.sumBy(parchi.parts, (x) => x.amount);
      await Parchi.findOneAndUpdate(
        { _id: parchi._id },
        { $set: { "payment.total": total_amount, updated_at: new Date() } },
        { new: true },
        async function (err, doc) {
          if (err) {
            res.status(422).json({
              responseCode: 422,
              responseMessage: "Server Error...",
              responseData: err,
            });
          } else {
            var activity = {
              business: business,
              activity_by: loggedInDetails.name,
              activity:
                "Title: ' " +
                part.title +
                " ' , Qty: " +
                parseFloat(part.quantity) +
                " , Amt: " +
                parseFloat(part.amount) +
                " ( Updated )  ",
              // time: new Date().getTime.toLocaleTimeString(),
              remark: "Part Updated",
              created_at: new Date(),
            };
            businessFunctions.parchiLogs(parchi._id, activity);
          }
        }
      );
      res.status(200).json({
        responseCode: 200,
        responseMessage: "Successfully Saved",
        responseData: {},
      });
    }
  } else {
    res.status(400).json({
      responseCode: 400,
      responseMessage: "Order Not Found",
      responseData: {},
    });
  }
});

router.put("/link/parchi/with/sale/old", async (req, res, next) => {
  var token = req.headers["x-access-token"];
  var business = req.headers["business"];
  var secret = config.secret;
  var decoded = jwt.verify(token, secret);
  var partIndex = req.body.partIndex;
  var loggedInDetails = await User.findById(decoded.user).exec();
  var parchi = await Parchi.findById(req.body.parchi).exec();
  if (parchi) {
    // console.log("Type  = " + req.body.type)
    if (req.body.type == "sale") {
      // , parchi: { $ne: parchi }
      var sale = await Sales.findOne({
        _id: req.body.sale,
        isParchi: false,
      }).exec();
      if (sale) {
        sale.parchi = parchi._id;
        sale.isParchi = true;
        sale.updated_at = new Date();
        await sale.save();
        var activity = {
          business: business,
          activity_by: loggedInDetails.name,
          activity: "Sale Linked with parchi #" + parchi.parchi_no,
          remark: parchi.parchi_no,
          created_at: new Date(),
        };
        businessFunctions.salesLogs(sale._id, activity);

        await Sales.updateMany(
          { parchi: parchi._id, _id: { $ne: sale._id } },
          { $set: { parchi: null, isParchi: false } }
        ).exec();
        await Parchi.findOneAndUpdate(
          { _id: parchi._id },
          { $set: { sale: sale._id, isLinked: true } },
          { new: true },
          async function (err, doc) {
            if (err) {
              res.status(422).json({
                responseCode: 422,
                responseMessage: "Server Error",
                responseData: err,
              });
            } else {
            }
          }
        );
      } else {
        res.status(200).json({
          responseCode: 200,
          responseMessage: "Sale already linked",
          responseData: {},
        });
      }
    } else if (req.body.type == "order") {
      // , parchi: { $ne: parchi }
      var order = await Order.findOne({
        _id: req.body.sale,
        isParchi: false,
      }).exec();
      if (order) {
        order.parchi = parchi._id;
        order.isParchi = true;
        order.updated_at = new Date();
        await order.save();

        await Parchi.findOneAndUpdate(
          { _id: parchi._id },
          { $set: { order: order._id, isLinked: true } },
          { new: true },
          async function (err, doc) {
            if (err) {
              res.status(422).json({
                responseCode: 422,
                responseMessage: "Server Error",
                responseData: err,
              });
            } else {
            }
          }
        );
      }
    }
    // var activity = {
    //     business: business,
    //     activity: "Item Removed- " + "Item: " + order.parts[partIndex].title + " " + "Part_No: " + order.parts[partIndex].part_no + " " + "Quantity: " + order.parts[partIndex].quantity,
    //     activity_by: loggedInDetails.name,
    //     remark: "",
    //     created_at: new Date(),
    // }
    // businessFunctions.QuotationItemAddLog(quotation, activity);

    var activity = {
      business: business,
      activity_by: loggedInDetails.name,
      activity: "Parchi Linked Successfully",
      // time: new Date().getTime.toLocaleTimeString(),
      remark: "Parchi Linked",
      created_at: new Date(),
    };
    businessFunctions.parchiLogs(parchi._id, activity);
    res.status(200).json({
      responseCode: 200,
      responseMessage: "Linked Successfully",
      responseData: await Parchi.findById(req.body.parchi).exec(),
    });
  } else {
    res.status(400).json({
      responseCode: 400,
      responseMessage: "Parchi Not Found",
      responseData: {},
    });
  }
});

router.put("/link/parchi/with/sale", async (req, res, next) => {
  console.log("Body= ", req.body);
  var token = req.headers["x-access-token"];
  var business = req.headers["business"];
  var secret = config.secret;
  var decoded = jwt.verify(token, secret);
  var partIndex = req.body.partIndex;
  var loggedInDetails = await User.findById(decoded.user).exec();
  var parchi = await Parchi.findById(req.body.parchi).exec();
  if (parchi) {
    // console.log("Type  = " + req.body.type)
    if (req.body.type == "sale") {
      // , parchi: { $ne: parchi }
      var sale = await Sales.findOne({
        _id: req.body.sale,
        isParchi: false,
      }).exec();
      if (sale) {
        sale.parchi = parchi._id;
        sale.isParchi = true;
        sale.updated_at = new Date();
        await sale.save();
        var activity = {
          business: business,
          activity_by: loggedInDetails.name,
          activity: "Sale Linked with parchi #" + parchi.parchi_no,
          remark: parchi.parchi_no,
          created_at: new Date(),
        };
        businessFunctions.salesLogs(sale._id, activity);

        await Sales.updateMany(
          { parchi: parchi._id, _id: { $ne: sale._id } },
          { $set: { parchi: null, isParchi: false } }
        ).exec();
        await Parchi.findOneAndUpdate(
          { _id: parchi._id },
          { $set: { sale: sale._id, isLinked: true, order: null } },
          { new: true },
          async function (err, doc) {
            if (err) {
              res.status(422).json({
                responseCode: 422,
                responseMessage: "Server Error",
                responseData: err,
              });
            } else {
            }
          }
        );
      } else {
        res.status(200).json({
          responseCode: 200,
          responseMessage: "Sale already linked",
          responseData: {},
        });
      }
    } else if (req.body.type == "order") {
      // , parchi: { $ne: parchi }
      var order = await Order.findOne({ _id: req.body.sale }).exec();
      console.log("Order .id  = " + order._id);
      if (order) {
        order.parchi = parchi._id;
        order.isParchi = true;
        order.updated_at = new Date();
        // await markModified(;)
        await order.save();

        await Parchi.findOneAndUpdate(
          { _id: parchi._id },
          { $set: { order: order._id, isLinked: true, sale: null } },
          { new: true },
          async function (err, doc) {
            if (err) {
              res.status(422).json({
                responseCode: 422,
                responseMessage: "Server Error",
                responseData: err,
              });
            } else {
              await Order.updateMany(
                { parchi: parchi._id, _id: { $ne: order._id } },
                { $set: { parchi: null, isParchi: false } }
              ).exec();
              await Sales.updateMany(
                { parchi: parchi._id },
                { $set: { parchi: null, isParchi: false } }
              ).exec();
            }
          }
        );
      }
    }
    // var activity = {
    //     business: business,
    //     activity: "Item Removed- " + "Item: " + order.parts[partIndex].title + " " + "Part_No: " + order.parts[partIndex].part_no + " " + "Quantity: " + order.parts[partIndex].quantity,
    //     activity_by: loggedInDetails.name,
    //     remark: "",
    //     created_at: new Date(),
    // }
    // businessFunctions.QuotationItemAddLog(quotation, activity);

    var activity = {
      business: business,
      activity_by: loggedInDetails.name,
      activity: "Parchi Linked Successfully",
      // time: new Date().getTime.toLocaleTimeString(),
      remark: "Parchi Linked",
      created_at: new Date(),
    };
    businessFunctions.parchiLogs(parchi._id, activity);
    res.status(200).json({
      responseCode: 200,
      responseMessage: "Linked Successfully",
      responseData: await Parchi.findById(req.body.parchi).exec(),
    });
  } else {
    res.status(400).json({
      responseCode: 400,
      responseMessage: "Parchi Not Found",
      responseData: {},
    });
  }
});

router.post(
  "/parchi/to/sale/create",
  xAccessToken.token,
  async function (req, res, next) {
    var business = req.headers["business"];
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var date = new Date();
    var loggedInDetails = decoded.user;
    var items = [];
    var item_total = 0;
    var discount = 0;
    var total = 0;
    var due = {
      due: 0,
    };
    var loggedInDetails = await User.findById(decoded.user).exec();

    var saleItems = [];
    var parchi = await Parchi.findById(req.body.parchi).exec();
    if (parchi) {
      var user = await User.findById(parchi.user).exec();
      if (user) {
        var parts = parchi.parts;
        // console.log("3091 Parts Length  = " + parts.length)
        for (var i = 0; i < parts.length; i++) {
          // console.log("Iteration - = " + i + "  Part_no=  " + parts[i].part_no)
          var businessProduct = await BusinessProduct.find({
            part_no: parts[i].part_no,
            business: business,
          }).exec();
          if (businessProduct.length == 0) {
            // console.log("\n New Item -------------------------------------New ")
            var tax_slab = "18.0% GST";
            var sale_price = parts[i].selling_price; //Sale Price
            // part.selling_price = parts[i].selling_price;
            var tax_info = await Tax.findOne({ tax: tax_slab }).exec();
            if (tax_info) {
              // console.log("tax Info  = " + JSON.stringify(tax_info, null, '\t'))
              // return
              var tax_rate = tax_info.rate;
              var base = (sale_price / (tax_rate + 100)) * 100;

              // console.log("sale_price  = " + sale_price)
              // console.log("tax_info.rate  = " + tax_info.rate)
              // console.log("base  = " + base)
              // var margin = "7%";   //Default Margin
              var unit = "Piece";
              var product_brand = null;
              var brand_category = null;
              var category = "OEM"; //OEM or OES   partNo_category
              var item_name = parts[i].title; //Item name
              var models = [];
              var quantity = parts[i].quantity;
              //products[p].tax = "28.0% GST"
              // var tax_rate = tax_info.detail;
              // var total_amount = 0
              // console.log("RATE = " + sale_price)
              var margin = "0"; //Default Margin
              if (margin) {
                margin = margin.toString();
                if (margin.indexOf("%") >= 0) {
                  margin = parseFloat(margin);
                  if (!isNaN(margin) && margin > 0) {
                    margin_total = sale_price * (margin / 100);
                    // base = sale_price - margin_total;   //To Set By Default 7% Margin to every Product
                  }
                } else {
                  margin_total = parseFloat(margin);
                  // base = sale_price - margin_total;
                }
              }
              // console.log("Margin = " + margin + " Margin Total = " + margin_total)
              // if (part.isDiscount) {
              //     // console.log("Discount prints here...", discount)
              //     if (discount.indexOf("%") >= 0) {
              //         // console.log("602 - Discount If Condition = " + discount)
              //         discount = parseFloat(discount);
              //         if (!isNaN(discount) && discount > 0) {
              //             var discount_total = base * (discount / 100);
              //             base = base - parseFloat(discount_total.toFixed(2))
              //         }
              //     }
              //     else {
              //         // console.log("610 - Discount ELSE Condition= " + discount)

              //         discount = parseFloat(discount);
              //         if (!isNaN(discount) && discount > 0) {
              //             base = base - parseFloat(discount.toFixed(2))
              //         }
              //     }
              // }

              // 100
              var rate = base;
              var tax_detail = tax_info.detail;
              var tax = [];
              var amount_is_tax = "exclusive";
              if (amount_is_tax == "exclusive") {
                var tax_on_amount = base;
                if (tax_detail.length > 0) {
                  for (var r = 0; r < tax_detail.length; r++) {
                    if (tax_detail[r].rate != tax_info.rate) {
                      var t = tax_on_amount * (tax_detail[r].rate / 100);
                      rate = rate + t;
                      // console.log("Tax Amount " + t)
                      tax.push({
                        tax: tax_detail[r].tax,
                        rate: tax_detail[r].rate,
                        amount: parseFloat(t.toFixed(2)),
                      });
                    } else {
                      var t = tax_on_amount * (tax_info.rate / 100);
                      rate = rate + t;
                      // console.log("Tax Amount " + t)

                      tax.push({
                        tax: tax_info.tax,
                        tax_rate: tax_info.rate,
                        rate: tax_info.rate,
                        amount: parseFloat(t.toFixed(2)),
                      });
                    }
                  }
                }
              }
              // console.log("Base + GST +Margin  = ", (rate + margin_total))
              // console.log("Purchase Price  = " + rate)
              // console.log("Tax Amount  = " + t)

              var taxes = {
                tax: tax_info.tax,
                rate: tax_info.rate,
                amount: _.sumBy(tax, (x) => x.amount),
                detail: tax,
              };
              var sku = {
                sku: "Parchi Item",
                total: 0,
                available: 0,
                created_at: new Date(),
              };
              var stock = {
                // total: quantity,
                // consumed: quantity,
                // available: 0 - quantity,
                total: 0,
                consumed: 0,
                available: 0,
              };
              var margin_total = 0;
              var amount = parseFloat(rate) + margin_total;
              // console.log("Total Amountn = " + total_amount)
              // var tax_on_amount = amount;
              // if (tax_rate.length > 0) {
              //     for (var r = 0; r < tax_rate.length; r++) {
              //         if (tax_rate[r].rate != tax_info.rate) {
              //             var t = tax_on_amount * (tax_rate[r].rate / 100);
              //             amount = amount + t;
              //         }
              //         else {
              //             var t = tax_on_amount * (tax_info.rate / 100);
              //             amount = amount + t;
              //         }
              //     }
              // }
              // console.log("Amount  = " + amount)

              var price = {
                base: base, //base price with GST
                tax_amount: _.sumBy(tax, (x) => x.amount), //Tax Amount
                purchase_price: rate, //base + GST on base
                rate: base + margin_total,
                amount: amount,
                mrp: amount,
                discount: 0,
                discount_type: "Not Applicable",
                isDiscount: false,
                margin: margin,
                sell_price: base + margin_total,
                margin_total: margin_total,
              };
              // console.log("Price NEW Stock = " + JSON.stringify(price, null, '\t'))
              var list_type = [];
              list_type.push("Offline");
              var purchases = [];
              // console.log("1772 Amount = " + amount)
              var data = {
                purchase: null,
                purchases: purchases,
                business: business,
                product: null,
                product_id:
                  Math.round(+new Date() / 1000) +
                  Math.round(Math.random() * 9999 + 1),
                part_no: parts[i].part_no, //mend
                product_brand: product_brand, //
                product_model: null,
                model: null,
                category: null,
                // _subcategory: brand_category,
                subcategory: brand_category,
                title: item_name,
                short_description: "",
                long_description: "",
                thumbnail: "",
                specification: "",
                hsn_sac: "-",
                quantity: 0,
                unit: "Piece",
                models: models,
                stock: 0,
                sku: sku,
                list_type: list_type,
                price: price,
                amount_is_tax: amount_is_tax,
                tax: tax_info.tax,
                tax_rate: tax_info.rate,
                tax_type: tax_info.tax.split("% ").pop(),
                // tax_type: "GST",
                part_category: category,
                tax_info: taxes,
                list_type: list_type,

                created_at: new Date(),
                updated_at: new Date(),
              };
              var updatedData = {};
              await BusinessProduct.create(data).then(async function (bp) {
                // console.log(bp._id)
                var activity = {
                  vendor_name: "Created",
                  quantity: 0,
                  unit_price: bp.purchase_price,
                  price: 0,
                  received_by: loggedInDetails.name,
                  purchase: null,
                  remark: "remark",
                  business: business,
                  activity: "Created",
                  created_at: new Date(),
                };
                fun.productLog(bp._id, activity);

                // updatedData = {
                //     _id: product._id,
                //     id: product._id,
                //     product: product.title,
                //     part_no: product.part_no,
                //     hsn_sac: product.hsn_sac,
                //     specification: product.specification,
                //     base: product.price.base,
                //     price: product.price.purchase_price,
                //     unit: product.unit,
                //     item_details: product
                // }

                ///////  Next Step Is to Add Item In Sale
                var items = [];
                var convenience_charges = 0;
                var discount = 0;
                var total = 0;
                // var sale = await Sales.findById(req.body.sale).exec();
                // var parts = sale.parts;
                // var loggedInDetails = await User.findById(decoded.user).exec();
                // if (sale) {
                // if (part.title != "") {
                // var tax_info = await Tax.findOne({ tax: product.tax }).exec();
                // if (tax_info) {

                // if (products.product) {
                // var product = await BusinessProduct.findOne({ _id: product.product, business: business }).exec();\
                var product = await BusinessProduct.findOne({
                  _id: bp._id,
                }).exec();
                if (product) {
                  var tax = [];
                  var rate = product.price.rate;
                  var amount = product.price.rate * parts[i].quantity;
                  var tax_rate = tax_info.detail;
                  var discount_total = 0;
                  var base = amount;
                  var discount = "";

                  if (discount.indexOf("%") >= 0) {
                    discount = parseFloat(discount);
                    if (!isNaN(discount) && discount > 0) {
                      discount_total = amount * (discount / 100);
                      amount = amount - parseFloat(discount_total.toFixed(2));
                    }
                  } else {
                    if (discount == "") {
                      discount = "0";
                    }
                    discount_total = parseFloat(discount);
                    if (!isNaN(discount_total) && discount_total > 0) {
                      amount = amount - parseFloat(discount_total.toFixed(2));
                    }
                  }

                  if (product.amount_is_tax == "exclusive") {
                    var tax_on_amount = amount;
                    if (tax_rate.length > 0) {
                      for (var r = 0; r < tax_rate.length; r++) {
                        if (tax_rate[r].rate != tax_info.rate) {
                          var t = tax_on_amount * (tax_rate[r].rate / 100);
                          amount = amount + t;
                          tax.push({
                            tax: tax_rate[r].tax,
                            rate: tax_rate[r].rate,
                            amount: parseFloat(t.toFixed(2)),
                          });
                        } else {
                          var t = tax_on_amount * (tax_info.rate / 100);
                          amount = amount + t;
                          tax.push({
                            tax: tax_info.tax,
                            tax_rate: tax_info.rate,
                            rate: tax_info.rate,
                            amount: parseFloat(t.toFixed(2)),
                          });
                        }
                      }
                    }
                  }

                  if (product.amount_is_tax == "inclusive") {
                    var x = (100 + tax_info.rate) / 100;
                    var tax_on_amount = amount / x;
                    if (tax_rate.length > 0) {
                      for (var r = 0; r < tax_rate.length; r++) {
                        if (tax_rate[r].rate != tax_info.rate) {
                          var t = tax_on_amount * (tax_rate[r].rate / 100);
                          base = base - t;
                          tax.push({
                            tax: tax_rate[r].tax,
                            rate: tax_rate[r].rate,
                            amount: parseFloat(t.toFixed(2)),
                          });
                        } else {
                          var t = amount - tax_on_amount;
                          base = base - t;
                          tax.push({
                            tax: tax_info.tax,
                            rate: tax_info.rate,
                            amount: parseFloat(t.toFixed(2)),
                          });
                        }
                      }
                    }
                    //base = base - discount_total;
                  }

                  var tax_details = {
                    tax: tax_info.tax,
                    rate: tax_info.rate,
                    amount: total,
                    detail: tax,
                  };
                  var user = await User.findById(parchi.user).exec();
                  parts[i].product = product._id;
                  var item = {
                    product: product._id,
                    category: product.category,
                    _category: product._category,
                    subcategory: product.subcategory,
                    _subcategory: product._subcategory,
                    product_brand: product.product_brand,
                    _brand: product.product_brand,
                    product_model: product.product_model,
                    _model: product.product_model,
                    source: product.source,
                    part_no: product.part_no,
                    hsn_sac: product.hsn_sac,
                    unit: product.unit,
                    title: product.title,
                    sku: product.sku,
                    mrp: product.price.mrp,
                    selling_price: product.price.rate,
                    rate: product.price.rate,
                    quantity: parts[i].quantity,
                    base: parseFloat(base.toFixed(2)),
                    discount: product.price.discount,
                    discount_total: parseFloat(discount_total.toFixed(2)),
                    amount_is_tax: product.amount_is_tax,
                    tax_amount: parseFloat(
                      _.sumBy(tax, (x) => x.amount).toFixed(2)
                    ),
                    amount: parseFloat(amount.toFixed(2)),
                    tax: tax_info.tax,
                    tax_rate: tax_info.rate,
                    tax_info: tax,
                    issued: await q.all(
                      businessFunctions.salesPartIssue(
                        parts[i],
                        business,
                        user,
                        loggedInDetails
                      )
                    ),
                    added_by_customer: false,
                    created_at: new Date(),
                    updated_at: new Date(),
                  };
                  // console.log("Issued  = " + item.issued)
                  saleItems.push(item);
                }
              });
            } else {
              // console.log("Invlaid Tax ")
            }
          } else {
            // console.log(" 3474 ELSE Parts.product  =  --------------------------------------------- Old " + parts[i].product)
            if (parts[i].product) {
              var product = await BusinessProduct.findOne({
                _id: parts[i].product,
              }).exec();
              if (product) {
                var tax = [];
                var tax_slab = product.tax;
                var sale_price = parts[i].selling_price; //Sale Price

                // part.selling_price = parts[i].selling_price;
                var tax_info = await Tax.findOne({ tax: tax_slab }).exec();
                if (tax_info) {
                  // console.log("tax Info  = " + JSON.stringify(tax_info, null, '\t'))
                  // return
                  var tax_rate = tax_info.rate;
                  var base = ((sale_price / (tax_rate + 100)) * 100).toFixed(2);
                  var selling_price = base;
                  // console.log("sale_price  = " + sale_price)
                  // console.log("tax_info.rate  = " + tax_info.rate)
                  // console.log("base  = " + base)
                  // var margin = "7%";   //Default Margin
                  var item_name = parts[i].title; //Item name
                  var quantity = parts[i].quantity;
                  var amount = base * quantity;
                  var discount_total = 0;
                  var discount = 0;
                  var tax_rate = tax_info.detail;

                  // console.log("Base Amount = " + amount)
                  // console.log("Base Amount = " + amount)
                }
                // var tax_info = await Tax.findOne({ tax: product.tax }).exec();
                // var tax = [];
                // var rate = product.price.rate;
                // var amount = product.price.rate * parts[i].quantity;
                // var tax_rate = tax_info.detail;
                // var discount_total = 0;
                // var base = amount
                // var discount = '';

                // if (discount.indexOf("%") >= 0) {
                //     discount = parseFloat(discount);
                //     if (!isNaN(discount) && discount > 0) {
                //         discount_total = amount * (discount / 100);
                //         amount = amount - parseFloat(discount_total.toFixed(2))
                //     }
                // }
                // else {
                //     if (discount == "") {
                //         discount = "0"
                //     }
                //     discount_total = parseFloat(discount);
                //     if (!isNaN(discount_total) && discount_total > 0) {
                //         amount = amount - parseFloat(discount_total.toFixed(2))
                //     }
                // }
                var amount_is_tax = "exclusive";
                if (amount_is_tax == "exclusive") {
                  var tax_on_amount = amount;
                  if (tax_rate.length > 0) {
                    for (var r = 0; r < tax_rate.length; r++) {
                      if (tax_rate[r].rate != tax_info.rate) {
                        var t = tax_on_amount * (tax_rate[r].rate / 100);
                        amount = amount + t;
                        tax.push({
                          tax: tax_rate[r].tax,
                          rate: tax_rate[r].rate,
                          amount: parseFloat(t.toFixed(2)),
                        });
                      } else {
                        var t = tax_on_amount * (tax_info.rate / 100);
                        amount = amount + t;
                        tax.push({
                          tax: tax_info.tax,
                          tax_rate: tax_info.rate,
                          rate: tax_info.rate,
                          amount: parseFloat(t.toFixed(2)),
                        });
                      }
                    }
                  }
                }
                // console.log("Base = " + base)
                // console.log("Amount + Tax = " + amount)
                // console.log("Amount + Tax = " + amount)
                if (product.amount_is_tax == "inclusive") {
                  var x = (100 + tax_info.rate) / 100;
                  var tax_on_amount = amount / x;
                  if (tax_rate.length > 0) {
                    for (var r = 0; r < tax_rate.length; r++) {
                      if (tax_rate[r].rate != tax_info.rate) {
                        var t = tax_on_amount * (tax_rate[r].rate / 100);
                        base = base - t;
                        tax.push({
                          tax: tax_rate[r].tax,
                          rate: tax_rate[r].rate,
                          amount: parseFloat(t.toFixed(2)),
                        });
                      } else {
                        var t = amount - tax_on_amount;
                        base = base - t;
                        tax.push({
                          tax: tax_info.tax,
                          rate: tax_info.rate,
                          amount: parseFloat(t.toFixed(2)),
                        });
                      }
                    }
                  }
                  //base = base - discount_total;
                }

                // var tax_details = {
                //     tax: tax_info.tax,
                //     rate: tax_info.rate,
                //     amount: total,
                //     detail: tax
                // }
                var user = await User.findById(parchi.user).exec();
                parts[i].product = product._id;
                // console.log("parts[i].quantityp= " + parts[i].quantity)
                var item = {
                  product: product._id,
                  category: product.category,
                  _category: product._category,
                  subcategory: product.subcategory,
                  _subcategory: product._subcategory,
                  product_brand: product.product_brand,
                  _brand: product.product_brand,
                  product_model: product.product_model,
                  _model: product.product_model,
                  source: product.source,
                  part_no: product.part_no,
                  hsn_sac: product.hsn_sac,
                  unit: product.unit,
                  title: parts[i].title,
                  sku: product.sku,
                  mrp: product.price.mrp,
                  selling_price: selling_price,
                  rate: selling_price,
                  quantity: parts[i].quantity,
                  base: base,
                  discount: discount,
                  discount_total: parseFloat(discount_total.toFixed(2)),
                  amount_is_tax: amount_is_tax,
                  tax_amount: parseFloat(
                    _.sumBy(tax, (x) => x.amount).toFixed(2)
                  ),
                  amount: parseFloat(amount.toFixed(2)),
                  tax: tax_info.tax,
                  tax_rate: tax_info.rate,
                  tax_info: tax,
                  issued: await q.all(
                    businessFunctions.salesPartIssue(
                      parts[i],
                      business,
                      user,
                      loggedInDetails
                    )
                  ),
                  added_by_customer: false,
                  created_at: new Date(),
                  updated_at: new Date(),
                };
                // console.log("Issued  = " + item.issued)
                saleItems.push(item);
              }

              // var isssued = await q.all(businessFunctions.salesPartIssue(parts[i], business, user, loggedInDetails))
              // console.log("Old Item Updated ")
            }
          }
        }

        var convenience_charges = 0;
        // if (sale.payment.convenience_charges) {
        //     convenience_charges = Math.ceil(sale.payment.convenience_charges);
        // }
        var discount = parseFloat(
          _.sumBy(saleItems, (x) => x.discount_total).toFixed(2)
        );
        var amount = parseFloat(_.sumBy(saleItems, (x) => x.amount).toFixed(2));
        var total = amount + discount + convenience_charges;
        // var transaction_log = await q.all(fun.getSalesTransaction(sale._id, business));
        // var paid_total = transaction_log.paid_total;
        var paid_total = 0;
        // var data = {
        //     updated_at: new Date(),
        //     "payment.paid_total": paid_total,
        //     "payment.amount": parseFloat(amount.toFixed(2)),
        //     "payment.discount_total": parseFloat(discount.toFixed(2)),
        //     "payment.total": parseFloat(total.toFixed(2)),
        //     // "payment.order_discount": parseFloat(sale.payment.order_discount),
        //     "payment.order_discount": 0,
        //     due: {
        //         due: Math.ceil(amount) + convenience_charges - paid_total
        //     },
        // }

        var payment = {
          payment_mode: "",
          payment_status: "",
          extra_charges_limit: 0,
          convenience_charges: 0,
          discount_type: "",
          coupon_type: "",
          coupon: "",
          discount_applied: false,
          total: parseFloat(total.toFixed(2)),
          amount: parseFloat(amount.toFixed(2)),
          discount_total: parseFloat(discount.toFixed(2)),
          paid_total: paid_total,
          order_discount: 0,
        };

        var salesCount = await Sales.find({ business: business })
          .count()
          .exec();
        var data = {
          business: business,
          user: user._id,
          created_by: loggedInDetails._id,
          sale_no: salesCount + 1,
          note: "note",
          status: "Open",
          parts: saleItems,
          payment: payment,
          due: due,
          logs: [],
          isInvoice: false,
          isParchi: true,
          parchi: parchi._id,
          invoice: null,
          created_at: date,
          updated_at: date,
        };

        await Sales.create(data).then(async function (sale) {
          await Sales.findOneAndUpdate(
            { parchi: parchi._id, _id: { $ne: sale._id } },
            { $set: { parchi: null, isParchi: false } },
            { new: true },
            async function (err, doc) {
              if (err) {
                res.status(422).json({
                  responseCode: 422,
                  responseMessage: "Server Errro",
                  responseData: err,
                });
              } else {
                var salesActivity = {
                  business: business,
                  activity_by: loggedInDetails.name,
                  activity: "Sale Unlinked from parchi #" + parchi.parchi_no,
                  remark: parchi.parchi_no,
                  created_at: new Date(),
                };
                // businessFunctions.salesLogs(doc._id, salesActivity);
                // q.all(businessFunctions.salesLogs())

                //ParchiLogs
                var parchiActivity = {
                  business: business,
                  activity_by: loggedInDetails.name,
                  activity: "Sale #" + doc.sale_no + " Unlinked.",
                  // time: new Date().getTime.toLocaleTimeString(),
                  remark: "Parchi Un-Linked",
                  created_at: new Date(),
                };
                businessFunctions.parchiLogs(parchi._id, parchiActivity);
              }
            }
          );

          await Order.findOneAndUpdate(
            { parchi: parchi._id, _id: { $ne: sale._id } },
            { $set: { parchi: null, isParchi: false } },
            { new: true },
            async function (err, doc) {
              if (err) {
                res.status(422).json({
                  responseCode: 422,
                  responseMessage: "Server Errro",
                  responseData: err,
                });
              } else {
                var salesActivity = {
                  business: business,
                  activity_by: loggedInDetails.name,
                  activity: "Unlinked from parchi #" + parchi.parchi_no,
                  remark: parchi.parchi_no,
                  created_at: new Date(),
                };
                // businessFunctions.salesOrderLogs(doc._id, salesActivity);
                // q.all(businessFunctions.salesLogs())

                //ParchiLogs
                // var parchiActivity = {
                //     business: business,
                //     activity_by: loggedInDetails.name,
                //     activity: "Order #" + doc.order_no + " Unlinked.",
                //     // time: new Date().getTime.toLocaleTimeString(),
                //     remark: "Parchi Un-Linked",
                //     created_at: new Date(),
                // }
                // businessFunctions.parchiLogs(parchi._id, parchiActivity);
              }
            }
          );

          var salesActivity = {
            business: business,
            activity_by: loggedInDetails.name,
            activity: "Sale Created from Parchi #" + parchi.parchi_no,
            remark: "Sale",
            created_at: new Date(),
          };
          parchi.sale = sale._id;
          parchi.isLinked = true;
          await parchi.save();
          businessFunctions.salesLogs(sale._id, salesActivity);
          var parchiActivity = {
            business: business,
            activity_by: loggedInDetails.name,
            activity: "Sale #" + sale.sale_no + " created.",
            // time: new Date().getTime.toLocaleTimeString(),
            remark: "Parchi Linked",
            created_at: new Date(),
          };
          businessFunctions.parchiLogs(parchi._id, parchiActivity);
          res.status(200).json({
            responseCode: 200,
            responseMessage: "Sale Successfully Created",
            responseData: {
              sale: sale,
            },
          });
        });
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "User not found",
          responseData: {},
        });
      }
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Parchi not found",
        responseData: {},
      });
    }
  }
);

router.get(
  "/quotations/list/get",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers["business"];
    var filters = [];
    var match = [];

    var quotations = [];
    if (req.query.page == undefined) {
      var page = 0;
    } else {
      var page = req.query.page;
    }

    if (req.query.limit) {
      var limit = parseInt(req.query.limit);
    } else {
      var limit = 10;
    }

    if (req.query.query) {
      var specification = {};
      specification["$lookup"] = {
        from: "User",
        localField: "vendor",
        foreignField: "_id",
        as: "vendor",
      };
      filters.push(specification);
      var specification = {};
      specification["$unwind"] = {
        path: "$vendor",
        preserveNullAndEmptyArrays: false,
      };
      filters.push(specification);

      var specification = {};
      specification["$lookup"] = {
        from: "QuotationOrders",
        localField: "quotation",
        foreignField: "_id",
        as: "quotation",
      };
      filters.push(specification);
      var specification = {};
      specification["$unwind"] = {
        path: "$quotation",
        preserveNullAndEmptyArrays: false,
      };
      var specification = {};
      specification["$match"] = {
        quotation: { $ne: [] },
      };
      filters.push(specification);

      req.query.query = req.query.query.replace(
        /([.?*+^$[\]\\(){}|-])/g,
        "\\$1"
      );
      var specification = {};
      specification["$match"] = {
        business: mongoose.Types.ObjectId(business),
        $or: [
          { "vendor.name": { $regex: req.query.query, $options: "i" } },
          { "vendor.contact_no": { $regex: req.query.query, $options: "i" } },
          // { 'car.title': { $regex: req.query.query, $options: 'i' } },
          // { 'car.registration_no': { $regex: req.query.query, $options: 'i' } },
          // { 'vendor.quotation.quotation_no': { $regex: req.query.query, $options: 'i' } },
          // { 'order_no': { $regex: req.query.query, $options: 'i' } },

          // { 'car.insurance_info.insurance_company': { $regex: req.query.query, $options: 'i' } },
          // { 'car.insurance_info.insurance_company': { $regex: req.query.query, $options: 'i' } },
        ],
      };
      filters.push(specification);

      var specification = {};
      specification["$sort"] = {
        updated_at: -1,
      };
      filters.push(specification);

      var specification = {};
      // specification['$skip'] = config.perPage * page;
      specification["$skip"] = config.perPage * page;
      filters.push(specification);

      var specification = {};
      // specification['$limit'] = config.perPage;
      specification["$limit"] = limit;
      filters.push(specification);

      var query = filters;

      await VendorOrders.aggregate(query)
        .allowDiskUse(true)
        .cursor({ batchSize: 25 })
        .exec()
        .eachAsync(async function (quotationOrder) {
          var order = await VendorOrders.find({
            quotation: quotationOrder.quotation,
          })
            .populate({ path: "vendor", select: "name contact_no" })
            .select("parts vendor")
            .exec();

          var quotation = await QuotationOrders.findOne({
            _id: quotationOrder.quotation,
          }).exec();
          // var order = await VendorOrders.find({ quotation: p._id }).populate({ path: 'vendor', select: 'name contact_no' }).select('parts vendor').exec()
          vendorsName = [];
          order.forEach((data) => {
            vendorsName.push(data.vendor.name);
          });

          if (quotation) {
            quotations.push({
              _id: quotation._id,
              id: quotation._id,
              booking: quotation.booking,
              car: quotation.car,
              vendors: quotation.vendors,
              totalParts: order[0].parts.length,
              order: order,
              order_no: quotation.order_no,
              status: quotation.status,
              quotation_submitted: quotation.quotation_submitted,
              quotation_received: quotation.quotation_received,
              vendorsName: vendorsName,
              created_at: quotation.created_at,
              updated_at: quotation.updated_at,
            });
          }
        });
      // quotations = await q.all(businessFunctions.removeDublicateDoumnets(quotations, "order_no"));
    } else {
      await QuotationOrders.find({
        business: business,
        status: { $in: ["Requested", "created", "Confirmed"] },
      })
        .sort({ created_at: -1 })
        .skip(limit * page)
        .limit(limit)
        .cursor()
        .eachAsync(async (p) => {
          var order = await VendorOrders.find({ quotation: p._id })
            .populate({ path: "vendor", select: "name contact_no" })
            .select("parts vendor")
            .exec();

          vendorsName = [];
          order.forEach((data) => {
            vendorsName.push(data.vendor.name);
          });
          var parts_length = 0;
          if (order) {
            if (order.length > 0) {
              var parts_length = order[0].parts.length;
            }
            var order = order;
          }
          quotations.push({
            _id: p._id,
            id: p._id,
            booking: p.booking,
            car: p.car,
            vendors: p.vendors,
            totalParts: parts_length,
            order: order,
            order_no: p.order_no,
            status: p.status,
            quotation_submitted: p.quotation_submitted,
            quotation_received: p.quotation_received,
            vendorsName: vendorsName,
            created_at: p.created_at,
            updated_at: p.updated_at,
          });
        });
    }
    // quotations = await q.all(businessFunctions.removeDublicateDoumnets(quotations, "order_no"));
    res.status(200).json({
      responseCode: 200,
      responseMessage: "Success",
      responseInfo: {
        // filters: filters,
        totalResult: quotations.length,
      },
      responseData: {
        quotations: quotations,
      },
    });
  }
);

// router.get('/quotations/list/get', xAccessToken.token, async function (req, res, next) {
//     businessFunctions.logs("INFO: /quotations/list/get Api Called from 3.0.js," + " " + "Request Headers:" + JSON.stringify(req.headers) + ", " + "Request Query:" + JSON.stringify(req.query));

//     var token = req.headers['x-access-token'];
//     var secret = config.secret;
//     var decoded = jwt.verify(token, secret);
//     var business = req.headers['business'];
//     var user = await User.findById(decoded.user).exec();

//     var quotations = [];
//     if (req.query.page == undefined) {
//         var page = 0;
//     } else {
//         var page = req.query.page;
//     }

//     if (req.query.limit) {
//         var limit = parseInt(req.query.limit);
//     } else {
//         var limit = 10;
//     }
//     if (Log_Level == 4 || Log_Level == 6 || Log_Level == 8 || Log_Level == 10 || Log_Level == 0) {
//         businessFunctions.logs("DEBUG: Fatching Quotation Orders List, User:" + user.name);
//     }
//     await QuotationOrders.find({ business: business, status: { $in: ['Requested', 'created', 'Confirmed'] } })
//         .sort({ created_at: -1 })
//         .skip(limit * page).limit(limit)
//         .cursor().eachAsync(async (p) => {

//             var order = await VendorOrders.find({ quotation: p._id }).populate({ path: 'vendor', select: 'name contact_no' }).select('parts vendor').exec()

//             vendorsName = []
//             order.forEach(data => {
//                 vendorsName.push(data.vendor.name)

//             })
//             var parts_length = 0
//             if (order) {
//                 if (order.length > 0) {
//                     var parts_length = order[0].parts.length
//                 }
//                 var order = order
//             }
//             quotations.push({
//                 _id: p._id,
//                 id: p._id,
//                 booking: p.booking,
//                 car: p.car,
//                 vendors: p.vendors,
//                 totalParts: parts_length,
//                 order: order,
//                 order_no: p.order_no,
//                 status: p.status,
//                 quotation_submitted: p.quotation_submitted,
//                 quotation_received: p.quotation_received,
//                 vendorsName: vendorsName,
//                 created_at: p.created_at,
//                 updated_at: p.updated_at,

//             });
//         });
//     if (Log_Level == 4 || Log_Level == 6 || Log_Level == 8 || Log_Level == 10 || Log_Level == 0) {
//         businessFunctions.logs("DEBUG: Sending Quotation Listin Response, User:" + user.name);
//     }

//     res.status(200).json({
//         responseCode: 200,
//         responseMessage: "Sucesss",
//         responseInfo: {
//             totalResult: await QuotationOrders.find({ business: business, status: { $in: ['Requested', 'created', 'Confirmed'] } }).count().exec()
//         },
//         responseData: {
//             quotations: quotations
//         }
//     });
//     if (Log_Level == 3 || Log_Level == 7 || Log_Level == 9 || Log_Level == 10 || Log_Level == 0) {
//         businessFunctions.logs("INFO: Quotation List Send in Response Successfully, User:" + user.name);
//     }

// });

router.get("/quotation/info/get", async (req, res, next) => {
  businessFunctions.logs(
    "INFO: /quotation/info/get Api Called from 3.0.js," +
      " " +
      "Request Headers:" +
      JSON.stringify(req.headers) +
      ", " +
      "Request Query:" +
      JSON.stringify(req.query)
  );

  var token = req.headers["x-access-token"];
  var business = req.headers["business"];
  var secret = config.secret;
  var decoded = jwt.verify(token, secret);
  var user = decoded.user;
  var loggedInDetails = await User.findById(decoded.user).exec();
  let booking = req.query.booking;
  let vendor = req.query.vendor;
  let quotation = req.query.quotation;
  var quotation_details = [];
  var item = [];
  // var total_quantity = 0

  if (
    Log_Level == 4 ||
    Log_Level == 6 ||
    Log_Level == 8 ||
    Log_Level == 10 ||
    Log_Level == 0
  ) {
    businessFunctions.logs(
      "DEBUG: Fatching Quotation Details, QuotationId:" +
        quotation +
        ", " +
        "User:" +
        loggedInDetails.name
    );
  }
  var quotationDetails = await VendorOrders.find({
    quotation: quotation,
    business: business,
  })
    .populate({ path: "quotation", select: "created_at order_no" })
    .populate({ path: "vendor" })
    .exec();
  var parts = 0;
  if (quotationDetails.length > 0) {
    for (let i = 0; i < quotationDetails.length; i++) {
      // console.log("Date", moment(quotationDetails[i].quotation.created_at).tz(req.headers['tz']).format('lll'))
      quotationDetails[i].quotation.created_at = moment(
        quotationDetails[i].quotation.created_at
      )
        .tz(req.headers["tz"])
        .format("lll");
      quotation_details.push({
        parts: quotationDetails[i].parts,
        vendor_name: quotationDetails[i].vendor.name,
        contact_no: quotationDetails[i].vendor.contact_no,
        address: quotationDetails[i].vendor.address,
        status: quotationDetails[i].vendor.status,
      });
      parts = quotationDetails[i].parts.length;
    }
    var parts_length = quotationDetails[0].parts.length;
    var map_quantity = _.map(quotationDetails[0].parts, "quantity");
    var total_quantity = _.sumBy(map_quantity);

    for (var i = 0; i < parts_length; i++) {
      for (let j = 0; j < quotationDetails.length; j++) {
        var amount = "";
        if (
          quotationDetails[j].parts[i].status == "Price Updated" ||
          quotationDetails[j].parts[i].status == "confirmed"
        ) {
          amount = quotationDetails[j].parts[i].amount.toFixed(2);
        }
        item.push({
          orderId: quotationDetails[j]._id,
          status: quotationDetails[j].parts[i].status,
          amount: amount,
          name: quotationDetails[j].vendor.name,
        });
      }
    }

    var length = quotationDetails.length;
    var result = [];
    for (let i = 0; i < item.length; i += length) {
      const chunk = item.slice(i, i + length);
      result.push(chunk);
    }

    if (
      Log_Level == 4 ||
      Log_Level == 6 ||
      Log_Level == 8 ||
      Log_Level == 10 ||
      Log_Level == 0
    ) {
      businessFunctions.logs(
        "DEBUG: Sending Quotation Details in Response, QuotationId:" +
          quotation +
          ", " +
          ", " +
          "User:" +
          loggedInDetails.name
      );
    }
    res.status(200).json({
      responseCode: 200,
      responseMessage: "Success",
      responseData: {
        quotation: quotation_details,
        quotationOrder: await QuotationOrders.findById(quotation).exec(),
        createdBy: loggedInDetails.name,
        suppliers: result,
        total_quantity: total_quantity,
      },
    });
    if (
      Log_Level == 3 ||
      Log_Level == 7 ||
      Log_Level == 9 ||
      Log_Level == 10 ||
      Log_Level == 0
    ) {
      businessFunctions.logs(
        "INFO: Quotation Details send in Response Successfully, QuotationId:" +
          quotation +
          ", " +
          "User:" +
          loggedInDetails.name
      );
    }
  } else {
    if (
      Log_Level == 2 ||
      Log_Level == 5 ||
      Log_Level == 8 ||
      Log_Level == 9 ||
      Log_Level == 0
    ) {
      businessFunctions.logs(
        "WARNING: Quotation not found, QuotationId:" +
          quotation +
          ", " +
          "User:" +
          loggedInDetails.name
      );
    }
    res.status(422).json({
      responseCode: 422,
      responseMessage: "Quotation not found",
      responseData: {},
    });
  }
  // res.json({
  //     logs: {},
  //     quotations: quotations
  // })
});

router.post(
  "/quotation/cars/add",
  xAccessToken.token,
  async function (req, res, next) {
    console.log("Body= ", JSON.stringify(req.body));
    var token = req.headers["x-access-token"];
    var business = req.headers["business"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var loggedInDetails = await User.findById(decoded.user).exec();
    var rules = {
      quotation: "required",
      title: "required",
      vin: "required",
      mfg: "required",
    };
    var validation = new Validator(req.body, rules);
    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Error",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var cars = [];
      var quotation = await QuotationOrders.findById(req.body.quotation).exec();
      if (quotation) {
        cars = quotation.cars;
        var data = {
          title: req.body.title,
          vin: req.body.vin,
          varinat: req.body.varinat,
          mfg: req.body.mfg,
        };
        cars.push(data);
        await QuotationOrders.findOneAndUpdate(
          { _id: quotation._id },
          { $set: { cars: cars } },
          { new: true },
          async function (err, doc) {
            if (err) {
              var json = {
                responseCode: 400,
                responseMessage: "Please Try Again",
                responseData: err,
              };
              res.status(400).json(json);
            } else {
              res.status(200).json({
                responseCode: 200,
                responseMessage: "Car Added Succesfully",
                // responseData: await QuotationOrders.findById(req.body.quotation).select('cars').exec()
                responseData: {},
              });
            }
          }
        );
      } else {
        var json = {
          responseCode: 400,
          responseMessage: "Quotation not found",
          responseData: {},
        };
        res.status(400).json(json);
      }
    }
  }
);

router.put(
  "/quotation/items/car/set",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var business = req.headers["business"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var loggedInDetails = await User.findById(decoded.user).exec();
    var rules = {
      quotation: "required",
    };
    var validation = new Validator(req.body, rules);
    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Error",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      await VendorOrders.find({ quotation: req.body.quotation })
        .cursor()
        .eachAsync(async (order) => {
          var vendorOrder = await VendorOrders.findById(order._id).exec();
          var index = parseInt(req.body.index);
          // if (p == req.body.index) {
          var data = {
            title: req.body.title,
            vin: req.body.vin,
            mfg: req.body.mfg,
            varinat: req.body.varinat,
          };
          // console.log("Data = " + vendorOrder.parts[index].part_no)
          vendorOrder.parts[index].car = data;
          await vendorOrder.markModified("car");
          await vendorOrder.save();
          // }
        });
      res.status(200).json({
        responseCode: 200,
        responseMessage: "Car attached Succesfully",
        // responseData: await VendorOrders.find({ quotation: req.body.quotation }).select('parts').exec()
        responseData: { quotationId: req.body.quotation },
      });
    }
  }
);

router.get(
  "/quotation/items/cars/get",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var loggedInDetails = await User.findById(decoded.user).exec();
    var business = req.headers["business"];

    var rules = {
      quotation: "required",
      item_index: "required",
    };
    var validation = new Validator(req.query, rules);
    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Error",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var quotation = await QuotationOrders.findOne({
        _id: req.query.quotation,
        business: business,
      }).exec();
      if (quotation) {
        var cars = [];
        var car = {};
        if (quotation.cars) {
          await VendorOrders.find({ quotation: req.query.quotation })
            .cursor()
            .eachAsync(async (order) => {
              var vendorOrder = await VendorOrders.findById(order._id).exec();
              for (var p = 0; p < vendorOrder.parts.length; p++) {
                // var images = vendorOrder.parts[p].images;
                if (p == req.query.item_index) {
                  car = vendorOrder.parts[p].car;
                }
              }
            });
          for (var i = 0; i < quotation.cars.length; i++) {
            var is_checked = false;
            if (car) {
              if (car.vin == quotation.cars[i].vin) {
                is_checked = true;
              }
            }

            cars.push({
              _id: quotation.cars[i]._id,
              title: quotation.cars[i].title,
              vin: quotation.cars[i].vin,
              mfg: quotation.cars[i].mfg,
              registration_no: quotation.cars[i].registration_no,
              created_at: quotation.cars[i].created_at,
              is_checked: is_checked,
            });
          }
        }
        res.status(200).json({
          responseCode: 200,
          responseMessage: "cars get successfully",
          responseData: cars,
        });
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "quotation not found",
          responseData: {},
        });
      }
    }
  }
);

router.put(
  "/quotation/part/link/update",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var business = req.headers["business"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var loggedInDetails = await User.findById(decoded.user).exec();
    var rules = {
      quotation: "required",
    };
    var validation = new Validator(req.body, rules);
    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Error",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var quotation = await QuotationOrders.findById(req.body.quotation).exec();
      if (quotation) {
        await VendorOrders.find({ quotation: req.body.quotation })
          .cursor()
          .eachAsync(async (order) => {
            var vendorOrder = await VendorOrders.findById(order._id).exec();
            var index = parseInt(req.body.item_index);
            console.log("Index  = " + index + " Link = " + req.body.link);
            vendorOrder.parts[index].part_link = req.body.link;
            await vendorOrder.markModified("parts");
            await vendorOrder.save();
          });
        res.status(200).json({
          responseCode: 200,
          responseMessage: "Part_link Added Successfully",
          responseData: {},
        });
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Quotation Not Found",
          responseData: {},
        });
      }
    }
  }
);

router.put(
  "/quotation/items/images/add",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var business = req.headers["business"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var loggedInDetails = await User.findById(decoded.user).exec();

    var file_type = "";

    var upload = multer({
      storage: multerS3({
        s3: s3,
        bucket: config.BUCKET_NAME + "/partsImages",
        acl: "public-read",
        contentType: multerS3.AUTO_CONTENT_TYPE,
        // contentDisposition: 'attachment',
        key: function (req, file, cb) {
          let extArray = file.mimetype.split("/");
          let extension = extArray[extArray.length - 1];

          var filename = uuidv1() + "." + extension;
          if (
            extension == "png" ||
            extension == "jpg" ||
            extension == "jpeg" ||
            extension == "gif"
          ) {
            cb(null, filename);
          } else {
            var params = {
              Bucket: config.BUCKET_NAME + "/partsImages",
              Key: filename,
            };
            s3.deleteObject(params, async function (err, data) {
              var json = {
                responseCode: 422,
                responseMessage: "Invalid extension",
                responseData: {},
              };
              res.status(422).json(json);
            });
          }
        },
      }),
    }).array("media", 1);

    upload(req, res, async function (error) {
      if (error) {
        var json = {
          responseCode: 400,
          responseMessage: "Error occured",
          responseData: {},
        };
        res.status(400).json(json);
      }
      if (req.files.length == 0) {
        var json = {
          responseCode: 400,
          responseMessage: "Media is required",
          responseData: {},
        };
        res.status(400).json(json);
      } else {
        var rules = {
          quotation: "required",
        };
        var validation = new Validator(req.body, rules);
        if (validation.fails()) {
          res.status(422).json({
            responseCode: 422,
            responseMessage: "Error",
            responseData: {
              res: validation.errors.all(),
            },
          });
        } else {
          // file: req.files[0].key,
          // type: file_type,
          var response = [];
          await VendorOrders.find({ quotation: req.body.quotation })
            .cursor()
            .eachAsync(async (order) => {
              var vendorOrder = await VendorOrders.findById(order._id).exec();
              for (var p = 0; p < vendorOrder.parts.length; p++) {
                var images = vendorOrder.parts[p].images;
                // vendorOrder.parts[p]._id.equals(req.body.part_id) &&
                // "https://s3.ap-south-1.amazonaws.com/careager/partsImages/"
                if (p == req.body.index) {
                  var data = {
                    // file_address: "https://s3.ap-south-1.amazonaws.com/" + config.BUCKET_NAME + "/partsImages/" + req.files[0].key,
                    src:
                      "https://s3.ap-south-1.amazonaws.com/" +
                      config.BUCKET_NAME +
                      "/partsImages/" +
                      req.files[0].key,
                    file: req.files[0].key,
                    index: order.parts[p].images.length + 1,
                    status: "Active",
                    created_at: new Date(),
                    updated_at: new Date(),
                  };
                  images.push(data);
                  vendorOrder.parts[p].images = images;
                  await vendorOrder.markModified("parts");
                  await vendorOrder.save();
                  response = [data];
                  break;
                }
              }
            });
          var vOrder = await VendorOrders.findOne({
            quotation: req.body.quotation,
          })
            .select("parts")
            .exec();
          res.status(200).json({
            responseCode: 200,
            responseMessage: "File has been uploaded",
            responseData: { image: response[0] },
          });
        }
      }
    });
  }
);
router.put(
  "/quotation/items/image/delete",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var loggedInDetails = await User.findById(decoded.user).exec();

    // var image_id = req.body.id;
    // const media = await VendorOrders.findOne({ quotation: req.body.quotation }).exec();

    if (req.body.file) {
      var params = {
        Bucket: config.BUCKET_NAME + "/partsImages",
        Key: req.body.file,
      };

      s3.deleteObject(params, async function (err, data) {
        if (err) {
          res.status(400).json({
            responseCode: 400,
            responseMessage: "Error occured",
            responseData: {},
          });
        } else {
          await VendorOrders.find({ quotation: req.body.quotation })
            .cursor()
            .eachAsync(async (order) => {
              var vendorOrder = await VendorOrders.findById(order._id).exec();
              for (var p = 0; p < vendorOrder.parts.length; p++) {
                // var images = vendorOrder.parts[p].images;
                if (p == req.body.item_index) {
                  // console.log("Image File = " + req.body.file)
                  for (var i = 0; i < vendorOrder.parts[p].images.length; i++) {
                    if (vendorOrder.parts[p].images[i].file == req.body.file) {
                      vendorOrder.parts[p].images.splice(i, 1);
                      await vendorOrder.markModified("images");
                      await vendorOrder.markModified("parts");
                      // await vendorOrder.markModified('images');
                      await vendorOrder.save();
                      break;
                    }
                  }
                }
              }
            });
          res.status(200).json({
            responseCode: 200,
            responseMessage: "File has been deleted",
            responseData: {},
          });
        }
      });
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Wrong image",
        responseData: {},
      });
    }
  }
);

router.get(
  "/quotation/items/image/get",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var loggedInDetails = await User.findById(decoded.user).exec();
    var business = req.headers["business"];
    var images = [];
    var rules = {
      quotation: "required",
      item_index: "required",
    };
    var validation = new Validator(req.query, rules);
    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Error",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var quotation = await VendorOrders.find({
        quotation: req.query.quotation,
        business: business,
      }).exec();
      if (quotation) {
        await VendorOrders.find({ quotation: req.query.quotation })
          .cursor()
          .eachAsync(async (order) => {
            var vendorOrder = await VendorOrders.findById(order._id).exec();
            for (var p = 0; p < vendorOrder.parts.length; p++) {
              // var images = vendorOrder.parts[p].images;
              if (p == req.query.item_index) {
                images = vendorOrder.parts[p].images;
              }
            }
          });
        res.status(200).json({
          responseCode: 200,
          responseMessage: "images get successfully",
          responseData: images,
        });
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "quotation not found",
          responseData: {},
        });
      }
    }
  }
);

router.put("/buyer/remark/add", xAccessToken.token, async (req, res, next) => {
  var token = req.headers["x-access-token"];
  var business = req.headers["business"];
  var secret = config.secret;
  var decoded = jwt.verify(token, secret);
  var user = decoded.user;
  var quotation = req.body.quotationId;
  var partIndex = req.body.partIndex;
  var loggedInDetails = await User.findById(decoded.user).exec();
  // console.log("quotationId", quotation)
  // console.log("partIndex", partIndex)
  var quotation = await QuotationOrders.findById(req.body.quotationId).exec();
  if (quotation) {
    var order = await VendorOrders.updateMany(
      { quotation: quotation._id },
      { $set: { buyerRemark: req.body.remark } }
    ).exec();
    quotation.buyerRemark = req.body.remark;
    await quotation.save();
    var activity = {
      business: business,
      activity: "Buyer Reamrk added successfully",
      activity_by: loggedInDetails.name,
      remark: req.body.remark,
      created_at: new Date(),
    };
    businessFunctions.QuotationItemAddLog(quotation._id, activity);
    // await VendorOrders.find({ quotation: quotation._id }).cursor()
    //     .eachAsync(async (v) => {
    //         // console.log("partslength  ", v.parts.length)
    //         // v.parts.splice(partIndex, 1)
    //         // console.log("partslength  ", v.parts.length)
    //         await v.save()
    //     })

    // console.log("Order= ", order.parts[partIndex]);

    res.status(200).json({
      responseCode: 200,
      responseMessage: "Remark added Successfully",
      responseData: {},
    });
  } else {
    if (
      Log_Level == 2 ||
      Log_Level == 5 ||
      Log_Level == 8 ||
      Log_Level == 9 ||
      Log_Level == 0
    ) {
      businessFunctions.logs(
        "WARNING: Quotation Not Found with the given quotationId:" +
          quotation +
          ", " +
          "User:" +
          loggedInDetails.name
      );
    }
    res.status(400).json({
      responseCode: 400,
      responseMessage: "Quotation Not Found",
      responseData: {},
    });
  }
});

router.put("/quotation/parts/remove", async (req, res, next) => {
  businessFunctions.logs(
    "INFO: /quotation/parts/remove Api Called from quotation-service.js," +
      " " +
      "Request Headers:" +
      JSON.stringify(req.headers) +
      ", " +
      "Request Body:" +
      JSON.stringify(req.body)
  );

  var token = req.headers["x-access-token"];
  var business = req.headers["business"];
  var secret = config.secret;
  var decoded = jwt.verify(token, secret);
  var user = decoded.user;
  var quotation = req.body.quotationId;
  var partIndex = req.body.partIndex;
  var loggedInDetails = await User.findById(decoded.user).exec();
  // console.log("quotationId", quotation)
  // console.log("partIndex", partIndex)
  if (quotation) {
    if (
      Log_Level == 4 ||
      Log_Level == 6 ||
      Log_Level == 8 ||
      Log_Level == 10 ||
      Log_Level == 0
    ) {
      businessFunctions.logs(
        "DEBUG: Fatching Quotation Order Details, QuotationId:" +
          quotation +
          ", " +
          "User:" +
          loggedInDetails.name
      );
    }
    var order = await VendorOrders.findOne({ quotation: quotation }).exec();
    var activity = {
      business: business,
      activity:
        "Item Removed- " +
        "Item: " +
        order.parts[partIndex].item +
        " " +
        "Part_No: " +
        order.parts[partIndex].part_no +
        " " +
        "Quantity: " +
        order.parts[partIndex].quantity,
      activity_by: loggedInDetails.name,
      remark: "",
      created_at: new Date(),
    };

    businessFunctions.QuotationItemAddLog(quotation, activity);
    if (
      Log_Level == 4 ||
      Log_Level == 6 ||
      Log_Level == 8 ||
      Log_Level == 10 ||
      Log_Level == 0
    ) {
      businessFunctions.logs(
        "DEBUG: Removing the Part from the quotation, QuotationId:" +
          quotation +
          ", " +
          "User:" +
          loggedInDetails.name
      );
    }
    await VendorOrders.find({ quotation: quotation })
      .cursor()
      .eachAsync(async (v) => {
        // console.log("partslength  ", v.parts.length)
        v.parts.splice(partIndex, 1);
        // console.log("partslength  ", v.parts.length)

        await v.save();
      });

    // console.log("Order= ", order.parts[partIndex]);

    res.status(200).json({
      responseCode: 200,
      responseMessage: "Removed Successfully",
      responseData: {},
    });
    if (
      Log_Level == 3 ||
      Log_Level == 7 ||
      Log_Level == 9 ||
      Log_Level == 10 ||
      Log_Level == 0
    ) {
      businessFunctions.logs(
        "INFO: Part Removed Successfully from the quotation, QuotationId:" +
          quotation +
          ", " +
          "User:" +
          loggedInDetails.name
      );
    }
  } else {
    if (
      Log_Level == 2 ||
      Log_Level == 5 ||
      Log_Level == 8 ||
      Log_Level == 9 ||
      Log_Level == 0
    ) {
      businessFunctions.logs(
        "WARNING: Quotation Not Found with the given quotationId:" +
          quotation +
          ", " +
          "User:" +
          loggedInDetails.name
      );
    }
    res.status(400).json({
      responseCode: 400,
      responseMessage: "Quotation Not Found",
      responseData: {},
    });
  }
});

router.post("/quotation/add", async (req, res, next) => {
  businessFunctions.logs(
    "INFO: /quotation/add Api Called from supplier.js," +
      " " +
      "Request Headers:" +
      JSON.stringify(req.headers) +
      ", " +
      "Request Body:" +
      JSON.stringify(req.body)
  );

  var token = req.headers["x-access-token"];
  var business = req.headers["business"];
  var secret = config.secret;
  var decoded = jwt.verify(token, secret);
  var user = decoded.user;
  // console.log("Api Called ")
  var status = req.body.status;
  var quotations = req.body.quotations;
  var vendors = req.body.vendors;
  var quotationsPart = req.body.parts;
  // console.log("Parts = " + JSON.stringify(quotationsPart))
  let quotationId = req.body.quotationId;
  var parts = [];
  var loggedInDetails = await User.findById(decoded.user).exec();
  if (quotationId) {
    var data = [];
    if (
      Log_Level == 4 ||
      Log_Level == 6 ||
      Log_Level == 8 ||
      Log_Level == 10 ||
      Log_Level == 0
    ) {
      businessFunctions.logs(
        "DEBUG: Fatching Quotation Request Details, QuotationId:" +
          quotationId +
          ", " +
          "User:" +
          loggedInDetails.name
      );
    }
    var quotation = await QuotationOrders.findOne({
      _id: mongoose.Types.ObjectId(quotationId),
    }).exec();
    if (quotation) {
      // var quot = await QuotationOrders.findOne({ _id: quotationId }).exec();
      // for (var i = 0; i < quot.orders.length; i++) {
      //     quot.orders[i].parts.push(
      //         quotationsPart
      //     )
      // }
      // quot.markModified('orders')
      // quot.save();
      if (
        Log_Level == 4 ||
        Log_Level == 6 ||
        Log_Level == 8 ||
        Log_Level == 10 ||
        Log_Level == 0
      ) {
        businessFunctions.logs(
          "DEBUG: Fatching Vendors Details for that Quotation Request, QuotationId:" +
            quotationId +
            ", " +
            "User:" +
            loggedInDetails.name
        );
      }
      await VendorOrders.find({
        quotation: mongoose.Types.ObjectId(quotationId),
      })
        .cursor()
        .eachAsync(async (order) => {
          orderParts = order.parts;
          orderParts.push(quotationsPart);
          if (
            Log_Level == 4 ||
            Log_Level == 6 ||
            Log_Level == 8 ||
            Log_Level == 10 ||
            Log_Level == 0
          ) {
            businessFunctions.logs(
              "DEBUG: Adding New Part in the Quotation, QuotationId:" +
                quotationId +
                ", " +
                "User:" +
                loggedInDetails.name
            );
          }
          await VendorOrders.findOneAndUpdate(
            { _id: order._id },
            { $set: { parts: orderParts, updated_at: new Date() } },
            { new: true },
            async function (err, doc) {}
          );
        });
      var result = await VendorOrders.find({ quotation: quotationId })
        .populate({ path: "quotation", select: "created_at order_no" })
        .populate({ path: "vendor" })
        .exec();

      var activity = {
        business: business,
        activity:
          "Item Added- " +
          "Item: " +
          quotationsPart.item +
          " " +
          "Part_No: " +
          quotationsPart.part_no +
          " " +
          "Quantity: " +
          quotationsPart.quantity,
        activity_by: loggedInDetails.name,
        remark: "",
        created_at: new Date(),
      };

      businessFunctions.QuotationItemAddLog(quotationId, activity);
      return res.status(200).json({
        responseCode: 200,
        responseMessage: "Item Added Successfully",
        responseData: {
          quotation: result,
          quotationId: quotation._id,
          quotationOrder: await QuotationOrders.findById(quotation._id).exec(),
        },
        quotation: result,
      });
      if (
        Log_Level == 3 ||
        Log_Level == 7 ||
        Log_Level == 9 ||
        Log_Level == 10 ||
        Log_Level == 0
      ) {
        businessFunctions.logs(
          "INFO: Item Added Successfully, QuotationId:" +
            quotationId +
            ", " +
            "User:" +
            loggedInDetails.name
        );
      }
    } else {
      if (
        Log_Level == 2 ||
        Log_Level == 5 ||
        Log_Level == 8 ||
        Log_Level == 9 ||
        Log_Level == 0
      ) {
        businessFunctions.logs(
          "WARNING: Quotation not found with the given QuotationId:" +
            quotationId +
            ", " +
            "User:" +
            loggedInDetails.name
        );
      }
      return res.status(422).json({
        responseCode: 422,
        responseMessage: "Quotation not found",
        responseData: {},
      });
    }
  } else {
    parts.push(quotationsPart);
    var count = await QuotationOrders.find({ business: business }).count();
    var activity = {
      business: business,
      activity: "Quotation Created",
      activity_by: loggedInDetails.name,
      remark: "",
      created_at: new Date(),
    };

    // businessFunctions.QuotationItemAddLog(quotationId, activity);
    var quotationOrder = {
      business: business,
      car: null,
      booking: null,
      vendors: vendors,
      created_at: new Date(),
      updated_at: new Date(),
      order_no: count,
      status: "created",
      logs: activity,
    };
    if (
      Log_Level == 4 ||
      Log_Level == 6 ||
      Log_Level == 8 ||
      Log_Level == 10 ||
      Log_Level == 0
    ) {
      businessFunctions.logs(
        "DEBUG: Creating Quotation Request, User:" + loggedInDetails.name
      );
    }
    await QuotationOrders.create(quotationOrder).then(async function (
      quotation
    ) {
      var last_order = "";
      var count = await QuotationOrders.find({
        _id: { $lt: quotation._id },
        business: business,
      }).count();
      if (count == 0) {
        // console.log("If ")
        var last_order = "";
        var position = 1;
      } else {
        // console.log("ELSE " + count)
        var lq = await QuotationOrders.findOne({
          _id: { $lt: quotation._id },
          business: business,
        })
          .sort({ _id: -1 })
          .exec();
        var last_order = lq.quotation_no;
        position = count + 1;
      }
      // console.log("Lats Invoice  -= " + last_order)
      var fy = {
        with_tax: false,
        last_order: last_order,
        position: position,
        type: "quotation",
      };
      if (
        Log_Level == 4 ||
        Log_Level == 6 ||
        Log_Level == 8 ||
        Log_Level == 10 ||
        Log_Level == 0
      ) {
        businessFunctions.logs(
          "DEBUG: fun.fiscalyear(fy) function called from function.js."
        );
      }
      var assigned_quotation_no = await q.all(fun.fiscalyear(fy));
      if (assigned_quotation_no) {
        if (assigned_quotation_no.invoice) {
          // console.log("Invoice no: " + assigned_invoice_no.invoice)
          if (
            Log_Level == 4 ||
            Log_Level == 6 ||
            Log_Level == 8 ||
            Log_Level == 10 ||
            Log_Level == 0
          ) {
            businessFunctions.logs(
              "DEBUG: Update Quotation Request Details, User:" +
                loggedInDetails.name
            );
          }
          await QuotationOrders.findOneAndUpdate(
            { _id: quotation._id },
            { $set: { quotation_no: assigned_quotation_no.invoice } },
            { new: true },
            async function (err, doc) {
              if (err) {
                if (
                  Log_Level == 1 ||
                  Log_Level == 5 ||
                  Log_Level == 6 ||
                  Log_Level == 7 ||
                  Log_Level == 0
                ) {
                  businessFunctions.logs(
                    "ERROR: Error Occured while updating the quotation order details, QuotationId:" +
                      quotation._id +
                      ", " +
                      "User:" +
                      loggedInDetails.name
                  );
                }
                res.status(422).json({
                  responseCode: 422,
                  responseMessage: "Server Error",
                  responseData: err,
                });
              } else {
                // console.log("NO Assigned  = " + doc.quotation_no)
              }
            }
          );
        }
      }
      var orderNo = await VendorOrders.find({ business: business }).count();

      let vendorQuery = { _id: { $in: quotation.vendors } };
      var counter = 0;
      await User.find(vendorQuery)
        .populate({ path: "car", select: "vin title manufacture_year" })
        .cursor()
        .eachAsync(async (v) => {
          var car = null;
          var booking = null;
          if (req.body.booking) {
            car = booking.car;
            booking = req.body.booking;
          }
          var data = {
            vendor: v._id,
            business: business,
            car: car,
            booking: booking,
            parts: parts,
            // parts: quotationsPart,
            order_link: "http://localhost:4200/vendors/orders?id=",
            shop_name: v.name,
            contact_no: v.contact_no,
            email: v.email,
            totalQuotations: 0,
            status: "Created",
            quotation: quotation._id,
            order_no: orderNo + 1,
            created_at: new Date(),
            updated_at: new Date(),
          };
          if (
            Log_Level == 4 ||
            Log_Level == 6 ||
            Log_Level == 8 ||
            Log_Level == 10 ||
            Log_Level == 0
          ) {
            businessFunctions.logs(
              "DEBUG: Creating Vendor Orders, User:" + loggedInDetails.name
            );
          }

          await VendorOrders.create(data).then(async function (order) {
            await VendorOrders.findOneAndUpdate(
              { _id: order._id },
              {
                $set: {
                  order_link:
                    "http://localhost:4200/vendors/orders?id=" + order._id,
                },
              },
              { new: true },
              async function (err, doc) {
                //    for(var i=0;)
                // quot.orders.push({
                //     vendor: order.vendor,
                //     parts: order.parts
                // })
                // quot.markModified('orders')
                // quot.save();
              }
            );
          });
        });
      var result = await VendorOrders.find({ quotation: quotation._id })
        .populate({ path: "quotation", select: "created_at order_no" })
        .populate({ path: "vendor" })
        .exec();
      res.status(200).json({
        responseCode: 200,
        responseMessage: "Quotation Created Successfully",
        responseData: {
          quotation: result,
          quotationId: quotation._id,
          quotationOrder: await QuotationOrders.findById(quotation._id).exec(),
        },
      });
      if (
        Log_Level == 3 ||
        Log_Level == 7 ||
        Log_Level == 9 ||
        Log_Level == 10 ||
        Log_Level == 0
      ) {
        businessFunctions.logs(
          "INFO: Quotation Created Successfully, QuotationId:" +
            quotation._id +
            ", " +
            "User:" +
            loggedInDetails.name
        );
      }
    });
  }
});

router.put("/vendor/quotation/request", async (req, res, next) => {
  businessFunctions.logs(
    "INFO: /vendor/quotation/request Api Called from 3.0.js," +
      " " +
      "Request Headers:" +
      JSON.stringify(req.headers) +
      ", " +
      "Request Body:" +
      JSON.stringify(req.body)
  );

  var token = req.headers["x-access-token"];
  var business = req.headers["business"];
  var secret = config.secret;
  var decoded = jwt.verify(token, secret);
  var user = decoded.user;
  var loggedInDetails = await User.findById(decoded.user).exec();
  var selectedData = req.body.data;
  var quotationOrders = [];

  if (
    Log_Level == 4 ||
    Log_Level == 6 ||
    Log_Level == 8 ||
    Log_Level == 10 ||
    Log_Level == 0
  ) {
    businessFunctions.logs(
      "DEBUG: Fatching Quotation Details, QuotationId:" +
        quotation +
        ", " +
        "User:" +
        loggedInDetails.name
    );
  }
  var quotation = await QuotationOrders.findById(req.body.quotation).exec();
  if (quotation) {
    if (
      Log_Level == 4 ||
      Log_Level == 6 ||
      Log_Level == 8 ||
      Log_Level == 10 ||
      Log_Level == 0
    ) {
      businessFunctions.logs(
        "DEBUG: Fatching Vendors for the Quotation, QuotationId:" +
          req.body.quotation +
          ", " +
          "User:" +
          loggedInDetails.name
      );
    }
    await VendorOrders.find({ quotation: quotation._id })
      .cursor()
      .eachAsync(async (order) => {
        quotationOrders.push(order);
        var currentOrderData = selectedData.filter(
          (x) => x.orderId == order._id
        );
        var vendorOrder = await VendorOrders.findById(order._id).exec();
        if (vendorOrder) {
          for (var i = 0; i < currentOrderData.length; i++) {
            // console.log("Data = " + JSON.stringify(currentOrderData[i]) + "\n")
            var details = currentOrderData[i];
            vendorOrder.parts[details.partIndex].item =
              details.itemInputDetails.item;
            vendorOrder.parts[details.partIndex].part_no =
              details.itemInputDetails.part_no;
            vendorOrder.parts[details.partIndex].quantity =
              details.itemInputDetails.quantity;
            vendorOrder.parts[details.partIndex].status = "requested";
            vendorOrder.parts[details.partIndex].isChecked = true;
            // console.log("Sumit"+ vendorOrder._id);
            if (
              Log_Level == 4 ||
              Log_Level == 6 ||
              Log_Level == 8 ||
              Log_Level == 10 ||
              Log_Level == 0
            ) {
              businessFunctions.logs(
                "DEBUG: whatsappEvent.partsRequest(vendorDetail._id, business) function calles from whatappEvent.js" +
                  ", " +
                  "User:" +
                  loggedInDetails.name
              );
            }
            whatsAppEvent.partsRequest(vendorOrder._id, business);
            var activity = "Quotation Request";
            fun.webNotification(activity, vendorOrder);
            event.requestParts(vendorOrder._id);
          }
          vendorOrder.status = "Requested";
          vendorOrder.updated_at = new Date();
          vendorOrder.request_date = new Date();

          vendorOrder.markModified("parts");
          vendorOrder.save();
        }
      });
    var vendorDetail = await VendorOrders.findOne({
      quotation: quotation._id,
    }).exec();

    //

    if (
      Log_Level == 4 ||
      Log_Level == 6 ||
      Log_Level == 8 ||
      Log_Level == 10 ||
      Log_Level == 0
    ) {
      businessFunctions.logs(
        "DEBUG: Sending Quotation Vendors Details in Response, QuotationId:" +
          req.body.quotation +
          ", " +
          "User:" +
          loggedInDetails.name
      );
    }
    res.status(200).json({
      responseCode: 200,
      responseMessage: "Requested Successfully",
      responseData: {
        quotation: await VendorOrders.find({ quotation: quotation._id }).exec(),
        quotationId: quotation._id,
      },
    });
  } else {
    if (
      Log_Level == 2 ||
      Log_Level == 5 ||
      Log_Level == 8 ||
      Log_Level == 9 ||
      Log_Level == 0
    ) {
      businessFunctions.logs(
        "WARNING: Quotation not found, QuotationId:" +
          quotation +
          ", " +
          "User:" +
          loggedInDetails.name
      );
    }
    res.status(422).json({
      responseCode: 422,
      responseMessage: "Quotation not found",
      responseData: {},
    });
  }
});

router.put("/quotation/order/confirmation", async (req, res, next) => {
  console.log("Body= ", JSON.stringify(req.body));
  businessFunctions.logs(
    "INFO:/quotation/order/confirmation Api Called from 3.0.js," +
      " " +
      "Request Headers:" +
      JSON.stringify(req.headers) +
      ", " +
      "Request Body:" +
      JSON.stringify(req.body)
  );

  var token = req.headers["x-access-token"];
  var business = req.headers["business"];
  var secret = config.secret;
  var decoded = jwt.verify(token, secret);
  var user = decoded.user;
  var loggedInDetails = await User.findById(decoded.user).exec();
  var selectedData = req.body.data;
  var quotationOrders = [];

  if (
    Log_Level == 4 ||
    Log_Level == 6 ||
    Log_Level == 8 ||
    Log_Level == 10 ||
    Log_Level == 0
  ) {
    businessFunctions.logs(
      "DEBUG: Fatching Quotation Details, QuotationId:" +
        req.body.quotationId +
        ", " +
        "User:" +
        loggedInDetails.name
    );
  }
  var quotation = await QuotationOrders.findById(req.body.quotationId).exec();
  if (quotation) {
    if (
      Log_Level == 4 ||
      Log_Level == 6 ||
      Log_Level == 8 ||
      Log_Level == 10 ||
      Log_Level == 0
    ) {
      businessFunctions.logs(
        "DEBUG: Fatching Vendors Details, QuotationId:" +
          req.body.quotationId +
          ", " +
          "User:" +
          loggedInDetails.name
      );
    }
    await VendorOrders.find({ quotation: quotation._id })
      .cursor()
      .eachAsync(async (order) => {
        quotationOrders.push(order);
        // console.log("Ordert Id = " + order._id)
        var currentOrderData = selectedData.filter(
          (x) => x.orderId == order._id
        );
        // console.log("Ordert length = " + currentOrderData.length)
        var vendorOrder = await VendorOrders.findById(order._id).exec();
        if (vendorOrder) {
          for (var i = 0; i < currentOrderData.length; i++) {
            // console.log("Data = " + JSON.stringify(currentOrderData[i]) + "\n")
            var details = currentOrderData[i];
            vendorOrder.parts[details.partIndex].item =
              details.itemInputDetails.item;
            vendorOrder.parts[details.partIndex].part_no =
              details.itemInputDetails.part_no;
            vendorOrder.parts[details.partIndex].quantity =
              details.itemInputDetails.quantity;
            vendorOrder.parts[details.partIndex].status = "confirmed";
            vendorOrder.parts[details.partIndex].sentDate = new Date();
            vendorOrder.status = "Confirmed";
            vendorOrder.updated_at = new Date();
          }
          // console.log("Sletected Length = " + currentOrderData.length)
          vendorOrder.markModified("parts");
          await vendorOrder.save();
        } else {
          // console.log("Vendors = " + vendorOrder._id)
        }
      });
    if (
      Log_Level == 4 ||
      Log_Level == 6 ||
      Log_Level == 8 ||
      Log_Level == 10 ||
      Log_Level == 0
    ) {
      businessFunctions.logs(
        "DEBUG: Sending Quotation Vendors Details in Response, QuotationId:" +
          req.body.quotationId +
          ", " +
          "User:" +
          loggedInDetails.name
      );
    }
    res.status(200).json({
      responseCode: 200,
      responseMessage: "Success",
      responseData: {
        quotation: await VendorOrders.find({ quotation: quotation._id }).exec(),
        quotationId: quotation._id,
      },
    });
  } else {
    if (
      Log_Level == 2 ||
      Log_Level == 5 ||
      Log_Level == 8 ||
      Log_Level == 9 ||
      Log_Level == 0
    ) {
      businessFunctions.logs(
        "WARNING: Quotation not found, QuotationId:" +
          req.body.quotationId +
          ", " +
          "User:" +
          loggedInDetails.name
      );
    }
    res.status(422).json({
      responseCode: 422,
      responseMessage: "Quotation not found",
      responseData: {},
    });
  }
  // res.json({
  //     logs: {},
  //     quotations: quotations
  // })
});

router.put("/quotation/order/cancel/confirmation", async (req, res, next) => {
  businessFunctions.logs(
    "INFO: /quotation/order/cancel/confirmation Api Called from 3.0.js," +
      " " +
      "Request Headers:" +
      JSON.stringify(req.headers) +
      ", " +
      "Request Body:" +
      JSON.stringify(req.body)
  );

  var token = req.headers["x-access-token"];
  var business = req.headers["business"];
  var secret = config.secret;
  var decoded = jwt.verify(token, secret);
  var user = decoded.user;
  var loggedInDetails = await User.findById(decoded.user).exec();
  console;
  if (
    Log_Level == 4 ||
    Log_Level == 6 ||
    Log_Level == 8 ||
    Log_Level == 10 ||
    Log_Level == 0
  ) {
    businessFunctions.logs(
      "DEBUG: Fatching Quotation Details, QuotationId:" +
        req.body.quotationId +
        ", " +
        "User:" +
        loggedInDetails.name
    );
  }
  var quotation = await QuotationOrders.findById(req.body.quotationId).exec();
  // console.log("Quotation ID =")
  if (quotation) {
    if (
      Log_Level == 4 ||
      Log_Level == 6 ||
      Log_Level == 8 ||
      Log_Level == 10 ||
      Log_Level == 0
    ) {
      businessFunctions.logs(
        "DEBUG: Fatching Vendors Details from the Quotation is Requested and Mark Status as Confirmation, QuotationId:" +
          quotation._id +
          ", " +
          "User:" +
          loggedInDetails.name
      );
    }
    await VendorOrders.find({ quotation: quotation._id })
      .cursor()
      .eachAsync(async (order) => {
        // console.log("Order Id = " + order._id)
        var vendorOrder = await VendorOrders.findById(order._id).exec();
        if (vendorOrder) {
          for (var i = 0; i < vendorOrder.parts.length; i++) {
            // console.log("tOATL pARTS  = " + vendorOrder.parts.length)
            if (vendorOrder.parts[i].status == "confirmed") {
              // console.log("Confirmed  pARTS  = " + vendorOrder.parts.length)
              vendorOrder.parts[i].status = "Price Updated";
              vendorOrder.status = "Submitted";
              vendorOrder.updated_at = new Date();
            }
          }
          vendorOrder.markModified("parts");
          await vendorOrder.save();
        } else {
          // console.log("Vendors = " + vendorOrder._id)
        }
      });

    // quotation: await VendorOrders.find({ quotation: quotation._id }).exec(),
    // quotationId: quotation._id,
    res.status(200).json({
      responseCode: 200,
      responseMessage: "Success",
      responseData: {},
    });
    if (
      Log_Level == 3 ||
      Log_Level == 7 ||
      Log_Level == 9 ||
      Log_Level == 10 ||
      Log_Level == 0
    ) {
      businessFunctions.logs(
        "INFO: Quotation Order Cancel Confirmation Successfully, QuotationId:" +
          quotation._id +
          ", " +
          "User:" +
          loggedInDetails.name
      );
    }
  } else {
    if (
      Log_Level == 2 ||
      Log_Level == 5 ||
      Log_Level == 8 ||
      Log_Level == 9 ||
      Log_Level == 0
    ) {
      businessFunctions.logs(
        "WARNING: Quotation Not Found with the given quotationId:" +
          req.body.quotationId +
          ", " +
          "User:" +
          loggedInDetails.name
      );
    }
    res.status(422).json({
      responseCode: 422,
      responseMessage: "Quotation not found",
      responseData: {},
    });
  }
});
router.put("/send/quotation/order", async (req, res, next) => {
  console.log("Body= ", JSON.stringify(req.body));
  businessFunctions.logs(
    "INFO: /send/quotation/order Api Called from 3.0.js," +
      " " +
      "Request Headers:" +
      JSON.stringify(req.headers) +
      ", " +
      "Request Body:" +
      JSON.stringify(req.body)
  );

  var token = req.headers["x-access-token"];
  var business = req.headers["business"];
  var secret = config.secret;
  var decoded = jwt.verify(token, secret);
  var user = decoded.user;
  var loggedInDetails = await User.findById(decoded.user).exec();
  var quotation = await QuotationOrders.findById(req.body.quotationId).exec();
  if (quotation) {
    if (
      Log_Level == 4 ||
      Log_Level == 6 ||
      Log_Level == 8 ||
      Log_Level == 10 ||
      Log_Level == 0
    ) {
      businessFunctions.logs(
        "DEBUG: Fatching Quotation Order vendors details for the purchase, QuotationId:" +
          quotation._id +
          ", " +
          "User:" +
          loggedInDetails.name
      );
    }
    await VendorOrders.find({ quotation: quotation._id, status: "Confirmed" })
      .cursor()
      .eachAsync(async (order) => {
        var data = {
          order_status: "Open",
          // remark: req.body.remark,
          status: "Confirmed",
          updated_at: new Date(),
        };
        if (
          Log_Level == 4 ||
          Log_Level == 6 ||
          Log_Level == 8 ||
          Log_Level == 10 ||
          Log_Level == 0
        ) {
          businessFunctions.logs(
            "DEBUG: Sending Quotation Order to the vendors for the purchase, QuotationId:" +
              quotation._id +
              ", " +
              "User:" +
              loggedInDetails.name
          );
        }
        await VendorOrders.findOneAndUpdate(
          { _id: order._id },
          { $set: data },
          { new: true },
          async function (err, doc) {
            if (err) {
            } else {
              // console.log("Created Order Successfull")
              // console.log("Api Called")
              var QuotationData = {
                // remark: req.body.remark,
                status: "Confirmed",
                updated_at: new Date(),
              };
              // console.log("Sumit" + doc);
              whatsAppEvent.newParts(doc._id);
              var activity = "New Order";
              fun.webNotification(activity, doc);

              await QuotationOrders.findOneAndUpdate(
                { _id: quotation._id },
                { $set: QuotationData },
                { new: true },
                async function (err, doc) {
                  if (err) {
                  } else {
                    // console.log("Created Order Successfull")
                  }
                }
              );
            }
          }
        );
      });
    res.status(200).json({
      responseCode: 200,
      responseMessage: "Success",
      responseData: {
        quotation: await VendorOrders.find({ quotation: quotation._id }).exec(),
        quotationId: quotation._id,
      },
    });
    if (
      Log_Level == 3 ||
      Log_Level == 7 ||
      Log_Level == 9 ||
      Log_Level == 10 ||
      Log_Level == 0
    ) {
      businessFunctions.logs(
        "INFO: Quotation Order Send Successfully to the vendor for the Purchase, QuotationId:" +
          quotation._id +
          ", " +
          "User:" +
          loggedInDetails.name
      );
    }
  } else {
    if (
      Log_Level == 2 ||
      Log_Level == 5 ||
      Log_Level == 8 ||
      Log_Level == 9 ||
      Log_Level == 0
    ) {
      businessFunctions.logs(
        "WARNING: Quotation Not Found with the given quotationId:" +
          req.body.quotationId +
          ", " +
          "User:" +
          loggedInDetails.name
      );
    }
    res.status(422).json({
      responseCode: 422,
      responseMessage: "Quotation not found",
      responseData: {},
    });
  }
});

router.post(
  "/vendors/sales/order/create",
  xAccessToken.token,
  async function (req, res, next) {
    console.log("Body= ", JSON.stringify(req.query));
    businessFunctions.logs(
      "INFO: /vendors/sales/order/create Api Called from 3.0.js," +
        " " +
        "Request Headers:" +
        JSON.stringify(req.headers) +
        ", " +
        "Request Query:" +
        JSON.stringify(req.query)
    );

    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = await User.findById(decoded.user).exec();
    var date = new Date();
    var car = null;
    var address = null;
    var items = [];
    var discount = 0;
    var total = 0;
    var due = {
      due: 0,
    };
    var quotationDetails = await VendorOrders.find({
      quotation: req.query.quotationId,
    })
      .populate({ path: "quotation", select: "created_at order_no" })
      .populate({ path: "vendor" })
      .exec();
    var vendors = quotationDetails;
    for (var i = 0; i < vendors.length; i++) {
      if (vendors[i].status == "Confirmed") {
        var vendorOrderId = vendors[i].id;
        // console.log("Order Id " + vendorOrderId)
        // console.log("User + " + vendors[i].vendor)
        // console.log("business + " + vendors[i].business)
        var business = vendors[i].vendor;
        var seller = await User.findById(vendors[i].vendor).exec();
        var user = await User.findById(vendors[i].business).exec();
        var loggedInDetails = await User.findById(decoded.user).exec();
        if (user) {
          if (req.body.address) {
            var checkAddress = await Address.findOne({
              _id: req.body.address,
              user: user._id,
            }).exec();
            if (checkAddress) {
              address = checkAddress._id;
            } else {
              if (
                Log_Level == 2 ||
                Log_Level == 5 ||
                Log_Level == 8 ||
                Log_Level == 9 ||
                Log_Level == 0
              ) {
                businessFunctions.logs(
                  "WARNING:Address Not Found for the given user, UserId:" +
                    user._id
                );
              }
              return res.status(400).json({
                responseCode: 400,
                responseMessage: "Address not found",
                responseData: {},
              });
            }
          }
          /*else
                {
                    return res.status(400).json({
                        responseCode: 400,
                        responseMessage: "Address not found",
                        responseData: {}
                    });
                }*/

          if (req.body.car) {
            var checkCar = await Car.findOne({
              _id: req.body.car,
              user: user._id,
            }).exec();
            if (checkCar) {
              car = checkCar._id;
            } else {
              if (
                Log_Level == 2 ||
                Log_Level == 5 ||
                Log_Level == 8 ||
                Log_Level == 9 ||
                Log_Level == 0
              ) {
                businessFunctions.logs(
                  "WARNING: Address Not Found for the given user, UserId:" +
                    user._id
                );
              }
              return res.status(400).json({
                responseCode: 400,
                responseMessage: "Car not found",
                responseData: {},
              });
            }
          }

          var date = new Date();
          var payment = {
            payment_mode: "",
            payment_status: "",
            extra_charges_limit: 0,
            convenience_charges: 0,
            discount_type: "",
            coupon_type: "",
            coupon: "",
            discount_applied: false,
            transaction_id: "",
            transaction_date: "",
            transaction_status: "",
            transaction_response: "",
            total: total,
            discount_total: discount,
            paid_total: 0,
          };

          if (
            Log_Level == 4 ||
            Log_Level == 6 ||
            Log_Level == 8 ||
            Log_Level == 10 ||
            Log_Level == 0
          ) {
            businessFunctions.logs(
              "DEBUG: Creating New Purchase Order, User:" + loggedInDetails.name
            );
          }
          await Order.create({
            convenience: req.body.convenience,
            time_slot: req.body.time_slot,
            user: user._id,
            car: car,
            address: address,
            items: items,
            business: business,
            payment: payment,
            due: due,
            status: "Ordered",
            isPurchaseOrder: true,
            vendorOrder: vendorOrderId,
            created_at: date,
            updated_at: date,
          }).then(async function (o) {
            var count = await Order.find({ _id: { $lt: o._id } }).count();

            var order_no =
              Math.round(+new Date() / 1000) +
              "-" +
              Math.ceil(Math.random() * 90000 + 10000) +
              "-" +
              Math.ceil(count + 1);

            await Order.findOneAndUpdate(
              { _id: o._id },
              { $set: { order_no: order_no } },
              { new: true },
              async function (err, doc) {
                if (err) {
                  res.status(422).json({
                    responseCode: 422,
                    responseMessage: "Server Error",
                    responseData: err,
                  });
                } else {
                  var businessOrder = {
                    order: o._id,
                    _order: order_no,
                    due_date: null,
                    delivery_date: null,
                    convenience: req.body.convenience,
                    time_slot: req.body.time_slot,
                    user: user._id,
                    items: items,
                    business: business,
                    payment: payment,
                    status: "Confirmed",
                    vendorOrder: vendorOrderId,
                    isPurchaseOrder: true,
                    created_at: date,
                    updated_at: date,
                    due: due,
                  };
                  if (
                    Log_Level == 4 ||
                    Log_Level == 6 ||
                    Log_Level == 8 ||
                    Log_Level == 10 ||
                    Log_Level == 0
                  ) {
                    businessFunctions.logs(
                      "DEBUG: Creating New Business Order, OrderId:" + o._id
                    );
                  }
                  await BusinessOrder.create(businessOrder).then(
                    async function (bo) {
                      var count = await BusinessOrder.find({
                        _id: { $lt: bo._id },
                        business: business,
                      }).count();
                      var order_no = count + 1;

                      await BusinessOrder.findOneAndUpdate(
                        { _id: bo._id },
                        { $set: { order_no: order_no } },
                        { new: true },
                        async function (err, doc) {
                          var order = await BusinessOrder.findById(bo._id)
                            .populate({
                              path: "order",
                              populate: [
                                {
                                  path: "user",
                                  select:
                                    "name contact_no username email account_info ",
                                },
                                {
                                  path: "car",
                                  select:
                                    "title variant registration_no _automaker _model",
                                },
                                { path: "address" },
                              ],
                            })
                            .exec();

                          var items = await OrderLine.find({
                            order: order.order._id,
                            business: business,
                          }).exec();

                          // await VendorOrders.findOneAndUpdate({ _id: vendorOrderId }, { $set: { order: o._id } }, { new: true }, async function (err, doc) {
                          //     if (err) {
                          //         res.status(422).json({
                          //             responseCode: 422,
                          //             responseMessage: "Server Errro",
                          //             responseData: err
                          //         });
                          //     }
                          //     else { }
                          // })

                          await VendorOrders.findOneAndUpdate(
                            { _id: vendorOrderId },
                            {
                              $set: {
                                order: o._id,
                                isOrder: true,
                                orderSent: true,
                              },
                            },
                            { new: true },
                            async function (err, doc) {
                              if (err) {
                                res.status(422).json({
                                  responseCode: 422,
                                  responseMessage: "Server Errro",
                                  responseData: err,
                                });
                              } else {
                                var activity = {
                                  business: business,
                                  activity_by: loggedInDetails.name,
                                  activity:
                                    "Order sent to the Seller -> " +
                                    seller.name,
                                  remark: "Order Sent",
                                  created_at: new Date(),
                                };
                                businessFunctions.vendorOrderLogs(
                                  vendorOrderId,
                                  activity
                                );

                                var activity = {
                                  business: business,
                                  activity_by: loggedInDetails.name,
                                  activity:
                                    "Order Received from ' " +
                                    loggedInDetails.name +
                                    " '",
                                  remark: "Order Received",
                                  created_at: new Date(),
                                };
                                businessFunctions.salesOrderLogs(
                                  o._id,
                                  activity
                                );
                              }
                            }
                          );

                          res.status(200).json({
                            responseCode: 200,
                            responseMessage: "Successfully Created",
                            responseData: {
                              _id: order._id,
                              id: order._id,
                              order_no: order.order_no,
                              order: order.order._id,
                              _order: order._order,
                              convenience: order.order.convenience,
                              car: order.order.car,
                              user: order.order.user,
                              address: order.order.address,
                              items: items,
                            },
                          });
                          if (
                            Log_Level == 3 ||
                            Log_Level == 7 ||
                            Log_Level == 9 ||
                            Log_Level == 10 ||
                            Log_Level == 0
                          ) {
                            businessFunctions.logs(
                              "INFO: New Order Created Successfully, Order_no:" +
                                order.order_no +
                                ", " +
                                "User:" +
                                loggedInDetails.name
                            );
                          }
                        }
                      );
                    }
                  );
                }
              }
            );
          });
        } else {
          if (
            Log_Level == 1 ||
            Log_Level == 5 ||
            Log_Level == 6 ||
            Log_Level == 7 ||
            Log_Level == 0
          ) {
            businessFunctions.logs(
              "ERROR: User not found with the given businessId:" +
                vendors[i].business
            );
          }
          res.status(400).json({
            responseCode: 400,
            responseMessage: "User not found",
            responseData: {},
          });
        }
      }
    }
  }
);

router.put("/cancel/quotation", xAccessToken.token, async (req, res, next) => {
  var token = req.headers["x-access-token"];
  var business = req.headers["business"];
  var secret = config.secret;
  var decoded = jwt.verify(token, secret);
  var user = decoded.user;
  // var quotation = req.body.quotationId;
  var partIndex = req.body.partIndex;
  var loggedInDetails = await User.findById(decoded.user).exec();
  // console.log("quotationId", quotation)
  // console.log("partIndex", partIndex)
  var quotation = await QuotationOrders.findOne({
    _id: req.body.quotationId,
  }).exec();
  if (quotation) {
    var order = await VendorOrders.findOne({ quotation: quotation._id }).exec();
    quotation.status = "Cancelled";
    await quotation.save();
    var activity = {
      business: business,
      activity: "Quotation Cancelled",
      activity_by: loggedInDetails.name,
      remark: "",
      created_at: new Date(),
    };
    businessFunctions.QuotationItemAddLog(quotation._id, activity);
    await VendorOrders.find({ quotation: quotation._id })
      .cursor()
      .eachAsync(async (v) => {
        // console.log("partslength  ", v.parts.length)
        v.status = "Cancelled";
        v.order_status = "Cancelled";
        // console.log("partslength  ", v.parts.length)
        await v.save();
      });

    // console.log("Order= ", order.parts[partIndex]);

    res.status(200).json({
      responseCode: 200,
      responseMessage: "Cancelled Successfully",
      responseData: {},
    });
  } else {
    res.status(400).json({
      responseCode: 400,
      responseMessage: "Quotation Not Found",
      responseData: {},
    });
  }
});

router.get(
  "/open/order/list/get",
  xAccessToken.token,
  async function (req, res, next) {
    businessFunctions.logs(
      "INFO: /open/order/list/get Api Called from 3.0.js," +
        " " +
        "Request Headers:" +
        JSON.stringify(req.headers) +
        ", " +
        "Request Query:" +
        JSON.stringify(req.query)
    );

    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var business = req.headers["business"];
    var user = await User.findById(decoded.user).exec();

    var orders = [];
    if (req.query.page == undefined) {
      var page = 0;
    } else {
      var page = req.query.page;
    }

    if (req.query.limit) {
      var limit = parseInt(req.query.limit);
    } else {
      var limit = 20;
    }
    if (
      Log_Level == 4 ||
      Log_Level == 6 ||
      Log_Level == 8 ||
      Log_Level == 10 ||
      Log_Level == 0
    ) {
      businessFunctions.logs(
        "DEBUG: Fatching Open Orders List, User:" + user.name
      );
    }
    await VendorOrders.find({
      business: business,
      order_status: { $in: ["Open"] },
    })
      .populate({ path: "vendor", select: "name contact_no" })
      .populate("quotation")
      .sort({ created_at: -1 })
      .skip(limit * page)
      .limit(limit)
      .cursor()
      .eachAsync(async (order) => {
        orders.push({
          _id: order._id,
          id: order._id,
          vendor: order.vendor,
          booking: order.booking,
          car: order.car,
          isVerified: order.isVerified,
          request_date: order.request_date,
          order_no: order.order_no,
          status: order.status,
          order_status: order.order_status,
          partsLength: order.parts.length,
          total_amount: order.total_amount,
          created_at: order.created_at,
          updated_at: order.updated_at,
        });
      });
    if (
      Log_Level == 4 ||
      Log_Level == 6 ||
      Log_Level == 8 ||
      Log_Level == 10 ||
      Log_Level == 0
    ) {
      businessFunctions.logs(
        "DEBUG: Sending Open Orders List In Response, User:" + user.name
      );
    }
    // console.log("Length  = " + orders.length)
    res.status(200).json({
      responseCode: 200,
      responseMessage: "Sucesss",
      responseInfo: {
        totalResult: await VendorOrders.find({
          business: business,
          order_status: { $in: ["Open"] },
        })
          .count()
          .exec(),
      },
      responseData: {
        orders: orders,
      },
    });
    if (
      Log_Level == 3 ||
      Log_Level == 7 ||
      Log_Level == 9 ||
      Log_Level == 10 ||
      Log_Level == 0
    ) {
      businessFunctions.logs(
        "INFO: Open Orders List send in Response successfully, User:" +
          user.name
      );
    }
  }
);

router.get(
  "/received/order/list/get",
  xAccessToken.token,
  async function (req, res, next) {
    businessFunctions.logs(
      "INFO: /received/order/list/get Api Called from 3.0.js," +
        " " +
        "Request Headers:" +
        JSON.stringify(req.headers) +
        ", " +
        "Request Query:" +
        JSON.stringify(req.query)
    );

    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var business = req.headers["business"];
    var user = await User.findById(decoded.user).exec();
    var orders = [];
    if (req.query.page == undefined) {
      var page = 0;
    } else {
      var page = req.query.page;
    }

    if (req.query.limit) {
      var limit = parseInt(req.query.limit);
    } else {
      var limit = 10;
    }
    // console.log("Page = " + page)
    if (
      Log_Level == 4 ||
      Log_Level == 6 ||
      Log_Level == 8 ||
      Log_Level == 10 ||
      Log_Level == 0
    ) {
      businessFunctions.logs(
        "DEBUG: Fatching Received Orders List, User:" + user.name
      );
    }
    await VendorOrders.find({ business: business, order_status: "Received" })
      .populate({ path: "vendor", select: "name contact_no" })
      .populate("quotation")
      .sort({ created_at: -1 })
      .skip(limit * page)
      .limit(limit)
      .cursor()
      .eachAsync(async (order) => {
        orders.push({
          _id: order._id,
          id: order._id,
          vendor: order.vendor,
          booking: order.booking,
          car: order.car,
          isVerified: order.isVerified,
          request_date: order.request_date,
          order_no: order.order_no,
          status: order.status,
          order_status: order.order_status,
          partsLength: order.parts.length,
          total_amount: order.total_amount,
          created_at: order.created_at,
          updated_at: order.updated_at,
        });
      });
    if (
      Log_Level == 4 ||
      Log_Level == 6 ||
      Log_Level == 8 ||
      Log_Level == 10 ||
      Log_Level == 0
    ) {
      businessFunctions.logs(
        "DEBUG: Sending Received Orders List In Response, User:" + user.name
      );
    }
    // console.log("Length  = " + orders.length)
    res.status(200).json({
      responseCode: 200,
      responseMessage: "Sucesss",
      responseInfo: {
        totalResult: await VendorOrders.find({
          business: business,
          order_status: "Received",
        })
          .count()
          .exec(),
      },
      responseData: {
        orders: orders,
      },
    });
    if (
      Log_Level == 3 ||
      Log_Level == 7 ||
      Log_Level == 9 ||
      Log_Level == 10 ||
      Log_Level == 0
    ) {
      businessFunctions.logs(
        "INFO: Received Orders List send in Response successfully, User:" +
          user.name
      );
    }
  }
);
router.get(
  "/cancelled/order/list/get",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var business = req.headers["business"];
    var orders = [];
    if (req.query.page == undefined) {
      var page = 0;
    } else {
      var page = req.query.page;
    }

    if (req.query.limit) {
      var limit = parseInt(req.query.limit);
    } else {
      var limit = 10;
    }
    // console.log("Page = " + page)
    await VendorOrders.find({ business: business, order_status: "Cancelled" })
      .populate({ path: "vendor", select: "name contact_no" })
      .populate("quotation")
      .sort({ created_at: -1 })
      .skip(limit * page)
      .limit(limit)
      .cursor()
      .eachAsync(async (order) => {
        orders.push({
          _id: order._id,
          id: order._id,
          vendor: order.vendor,
          booking: order.booking,
          car: order.car,
          isVerified: order.isVerified,
          request_date: order.request_date,
          order_no: order.order_no,
          status: order.status,
          order_status: order.order_status,
          partsLength: order.parts.length,
          total_amount: order.total_amount,
          created_at: order.created_at,
          updated_at: order.updated_at,
        });
      });
    // console.log("Length  = " + orders.length)
    res.status(200).json({
      responseCode: 200,
      responseMessage: "Sucesss",
      responseInfo: {
        totalResult: await VendorOrders.find({
          business: business,
          order_status: "Cancelled",
        })
          .count()
          .exec(),
      },
      responseData: {
        orders: orders,
      },
    });
  }
);

router.get(
  "/purchase/order/get",
  xAccessToken.token,
  async function (req, res, next) {
    businessFunctions.logs(
      "INFO: /purchase/order/get Api Called from 3.0.js," +
        " " +
        "Request Headers:" +
        JSON.stringify(req.headers) +
        ", " +
        "Request Query:" +
        JSON.stringify(req.query)
    );

    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var business = req.headers["business"];
    var user = await User.findById(decoded.user).exec();
    // order_status: { $in: ['Open']
    if (
      Log_Level == 4 ||
      Log_Level == 6 ||
      Log_Level == 8 ||
      Log_Level == 10 ||
      Log_Level == 0
    ) {
      businessFunctions.logs(
        "DEBUG: Fatching Order Details, OrderId:" +
          req.query.id +
          ", " +
          "User:" +
          user.name
      );
    }
    var order = await VendorOrders.findOne({ _id: req.query.id })
      .populate({ path: "business", select: "name contact_no address" })
      .populate({ path: "vendor", select: "name contact_no address" })
      .populate("car")
      .populate("address")
      .exec();
    if (order) {
      var itemsTotal = [];
      var tax = [];
      var map_quantity = _.filter(order.parts, (x) => x.status == "confirmed");
      var total_quantity = _.sumBy(map_quantity, "quantity");
      var total_amount = _.sumBy(map_quantity, "amount");
      for (var i = 0; i < order.parts.length; i++) {
        if (order.parts[i].status == "confirmed") {
          for (var j = 0; j < order.parts[i].tax_info.length; j++) {
            var splits = order.parts[i].tax_info[j].tax.split(" ");
            tax.push({
              tax: splits[1],
              amount: order.parts[i].tax_info[j].amount,
            });
            itemsTotal = _(tax)
              .groupBy("tax")
              .map((v, tax) => ({
                slab: tax,
                tax_amount: currencyFormatter.format(
                  _.sum(_.map(v, "amount")).toFixed(2),
                  { code: "INR" }
                ),
              }))
              .value();
          }
        }
      }

      var orders = {
        id: order.id,
        name: order.vendor.name,
        user: order.vendor._id,
        contact_no: order.vendor.contact_no,
        address: order.address,
        booking: order.booking,
        car: order.car,
        order_status: order.order_status,
        remark: order.remark,
        orderSent: order.orderSent,
        isBill: order.isBill,
        total_amount: currencyFormatter.format(total_amount.toFixed(2), {
          code: "INR",
        }),
        parts: order.parts,
        tax: itemsTotal,
        created_at: moment(order.created_at).tz(req.headers["tz"]).format("ll"),
        total_quantity: total_quantity,
      };

      var salesOrder = await BusinessOrder.findOne({
        order: order.order,
      }).exec();
      var salesitems = [];
      var due = 0;
      var order_discount = 0;
      var item_cost = 0;
      var created_at = "";
      var order = "";
      if (salesOrder) {
        order = salesOrder.order;
        due = salesOrder.due.due;
        order_discount = salesOrder.payment.order_discount;
        item_cost = salesOrder.payment.total;
        created_at = moment(salesOrder.created_at)
          .tz(req.headers["tz"])
          .format("ll");
        var total = (
          salesOrder.payment.total -
          salesOrder.payment.order_discount -
          salesOrder.payment.convenience_charges
        ).toFixed(2);

        if (
          Log_Level == 4 ||
          Log_Level == 6 ||
          Log_Level == 8 ||
          Log_Level == 10 ||
          Log_Level == 0
        ) {
          businessFunctions.logs(
            "DEBUG: fun.getBusinessOrderItems(salesOrder.order, salesOrder.business, req.headers['tz']) function called from function.js for fatching sales items details."
          );
        }

        salesitems = await q.all(
          fun.getBusinessOrderItems(
            salesOrder.order,
            salesOrder.business,
            req.headers["tz"]
          )
        );
      }

      var saleitems = [];
      var sale_tax = [];
      var taxs = [];
      for (var i = 0; i < salesitems.length; i++) {
        for (var j = 0; j < salesitems[i].tax_info.length; j++) {
          var splits = salesitems[i].tax_info[j].tax.split(" ");
          taxs.push({
            tax: splits[1],
            amount: salesitems[i].tax_info[j].amount,
          });
          sale_tax = _(tax)
            .groupBy("tax")
            .map((v, tax) => ({
              slab: tax,
              tax_amount: currencyFormatter.format(
                _.sum(_.map(v, "amount")).toFixed(2),
                { code: "INR" }
              ),
            }))
            .value();
        }

        saleitems.push({
          id: salesitems[i]._id,
          title: salesitems[i].title,
          part_no: salesitems[i].part_no,
          quantity: salesitems[i].quantity,
          amount: currencyFormatter.format(salesitems[i].amount.toFixed(2), {
            code: "INR",
          }),
          selling_price: currencyFormatter.format(
            salesitems[i].selling_price.toFixed(2),
            { code: "INR" }
          ),
          tax_amount: currencyFormatter.format(
            salesitems[i].tax_amount.toFixed(2),
            { code: "INR" }
          ),
          isMarked: salesitems[i].isMarked,
          created_at: salesitems[i].created_at,
        });
      }

      if (
        Log_Level == 4 ||
        Log_Level == 6 ||
        Log_Level == 8 ||
        Log_Level == 10 ||
        Log_Level == 0
      ) {
        businessFunctions.logs(
          "DEBUG: Sending Order Details in Response, OrderId:" +
            req.query.id +
            ", " +
            "User:" +
            user.name
        );
      }

      res.status(200).json({
        responseCode: 200,
        responseMessage: "Sucesss",
        responseData: {
          // order: order,
          orders: orders,
          saleOrder: {
            order: order,
            due: currencyFormatter.format(due.toFixed(2), { code: "INR" }),
            item_cost: currencyFormatter.format(item_cost.toFixed(2), {
              code: "INR",
            }),
            discount: currencyFormatter.format(order_discount.toFixed(2), {
              code: "INR",
            }),
            total: currencyFormatter.format(total, { code: "INR" }),
            created_at: created_at,
            sale_tax: sale_tax,
            saleitems: saleitems,
            // items: salesitems,
          },
        },
      });
    } else {
      if (
        Log_Level == 2 ||
        Log_Level == 5 ||
        Log_Level == 8 ||
        Log_Level == 9 ||
        Log_Level == 0
      ) {
        businessFunctions.logs(
          "WARNING: Order not found with the given orderId:" +
            req.query.id +
            ", " +
            "User:" +
            user.name
        );
      }
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Order not found",
        responseData: {},
      });
    }
  }
);

router.put(
  "/purchase/order/address/update",
  xAccessToken.token,
  async function (req, res, next) {
    businessFunctions.logs(
      "INFO: /purchase/order/address/update Api Called from 3.0.js," +
        " " +
        "Request Headers:" +
        JSON.stringify(req.headers) +
        ", " +
        "Request Body:" +
        JSON.stringify(req.body)
    );

    var rules = {
      order: "required",
      address: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      if (
        Log_Level == 1 ||
        Log_Level == 5 ||
        Log_Level == 6 ||
        Log_Level == 7 ||
        Log_Level == 0
      ) {
        businessFunctions.logs(
          "ERROR: Validation failed, order and address is required to update purchase address."
        );
      }
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Due Date required",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var business = req.headers["business"];
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var loggedInDetails = await User.findById(decoded.user).exec();
      var date = new Date();

      var items = [];
      var data = [];

      var item_total = 0;
      var discount = 0;
      var item_total = 0;
      var total = 0;

      if (
        Log_Level == 4 ||
        Log_Level == 6 ||
        Log_Level == 8 ||
        Log_Level == 10 ||
        Log_Level == 0
      ) {
        businessFunctions.logs(
          "DEBUG: Fatching Order details, OrderId:" +
            req.body.order +
            ", User:" +
            loggedInDetails.name
        );
      }
      var order = await VendorOrders.findById(req.body.order).exec();
      var loggedInDetails = await User.findById(decoded.user).exec();
      if (order) {
        var address = await Address.findOne({
          _id: req.body.address,
          user: order.vendor,
        }).exec();
        if (address) {
          VendorOrders.findOneAndUpdate(
            { _id: order._id },
            { $set: { address: address._id } },
            { new: false },
            async function (err, doc) {
              if (err) {
                if (
                  Log_Level == 1 ||
                  Log_Level == 5 ||
                  Log_Level == 6 ||
                  Log_Level == 7 ||
                  Log_Level == 0
                ) {
                  businessFunctions.logs(
                    "ERROR: Error Occured while Updating the purcahse order address for the orderId:" +
                      req.body.order +
                      ", User:" +
                      loggedInDetails.name
                  );
                }
                res.status(422).json({
                  responseCode: 422,
                  responseMessage: "Server Error",
                  responseData: err,
                });
              } else {
                var activity = {
                  business: business,
                  activity_by: loggedInDetails.name,
                  activity: "Address Updated",
                  // time: new Date().getTime.toLocaleTimeString(),
                  remark: "",
                  created_at: new Date(),
                };
                // console.log("Activity")
                businessFunctions.vendorOrderLogs(order._id, activity);

                res.status(200).json({
                  responseCode: 200,
                  responseMessage: "Saved",
                  responseData: {
                    address: address,
                  },
                });
                if (
                  Log_Level == 3 ||
                  Log_Level == 7 ||
                  Log_Level == 9 ||
                  Log_Level == 10 ||
                  Log_Level == 0
                ) {
                  businessFunctions.logs(
                    "INFO: Address Updated Successfully for the order, OrderId:" +
                      req.body.order +
                      ", User:" +
                      loggedInDetails.name
                  );
                }
              }
            }
          );
        } else {
          res.status(400).json({
            responseCode: 400,
            responseMessage: "Address not found",
            responseData: {},
          });
        }
      } else {
        if (
          Log_Level == 2 ||
          Log_Level == 5 ||
          Log_Level == 8 ||
          Log_Level == 9 ||
          Log_Level == 0
        ) {
          businessFunctions.logs(
            "WARNING: Order not found for the orderId:" +
              req.body.order +
              ", User:" +
              loggedInDetails.name
          );
        }
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Order not found",
          responseData: {},
        });
      }
    }
  }
);

router.post("/purchase/items/add", async (req, res, next) => {
  businessFunctions.logs(
    "INFO: /purchase/items/add Api Called from 3.0.js," +
      " " +
      "Request Headers:" +
      JSON.stringify(req.headers) +
      ", " +
      "Request Body:" +
      JSON.stringify(req.body)
  );
  var token = req.headers["x-access-token"];
  var secret = config.secret;
  var decoded = jwt.verify(token, secret);
  var user = decoded.user;
  var business = req.headers["business"];
  var loggedInDetails = await User.findById(decoded.user).exec();
  var part = req.body.item;
  var orderId = req.body.order;
  // var status = req.body.status
  // console.log("parts  ", parts)
  if (
    Log_Level == 4 ||
    Log_Level == 6 ||
    Log_Level == 8 ||
    Log_Level == 10 ||
    Log_Level == 0
  ) {
    businessFunctions.logs(
      "DEBUG: Fatching order details for the given orderId:" +
        orderId +
        ", " +
        "User:" +
        loggedInDetails.name
    );
  }
  var order = await VendorOrders.findById(orderId).exec();
  if (order) {
    var items = order.parts;
    var tax = [];
    var total = 0;
    // console.log("parts ", parts)
    if (part) {
      // for (var p = 0; p < parts.length; p++) {

      if (part.quantity != null) {
        var tax_info = await Tax.findOne({ tax: part.tax }).exec();
        if (tax_info) {
          // console.log("Product ")
          var tax_rate = tax_info.detail;
          var base =
            parseFloat(part.unit_base_price) * parseFloat(part.quantity);
          // console.log("Base  = " + unit_base_price)
          var discount = part.discount;
          var amount =
            parseFloat(part.unit_base_price) * parseFloat(part.quantity);
          if (discount.indexOf("%") >= 0) {
            discount = parseFloat(discount);
            if (!isNaN(discount) && discount > 0) {
              var discount_total = amount * (discount / 100);
              amount = amount - parseFloat(discount_total.toFixed(2));
            }
          } else {
            discount = parseFloat(discount);
            if (!isNaN(discount) && discount > 0) {
              base = base - parseFloat(discount.toFixed(2));
            }
          }

          if (part.amount_is_tax == "exclusive") {
            if (
              Log_Level == 4 ||
              Log_Level == 6 ||
              Log_Level == 8 ||
              Log_Level == 10 ||
              Log_Level == 0
            ) {
              businessFunctions.logs("DEBUG: Calculate Tax amount for parts");
            }

            var tax_on_amount = amount;

            if (tax_rate.length > 0) {
              for (var r = 0; r < tax_rate.length; r++) {
                if (tax_rate[r].rate != tax_info.rate) {
                  var t = tax_on_amount * (tax_rate[r].rate / 100);
                  amount = amount + t;
                  // console.log("Tax AMO=" + t)
                  tax.push({
                    tax: tax_rate[r].tax,
                    rate: tax_rate[r].rate,
                    amount: parseFloat(t.toFixed(2)),
                  });
                } else {
                  var t = tax_on_amount * (tax_info.rate / 100);
                  amount = amount + t;
                  // console.log("Tax AMO=" + t)

                  tax.push({
                    tax: tax_info.tax,
                    tax_rate: tax_info.rate,
                    rate: tax_info.rate,
                    amount: parseFloat(t.toFixed(2)),
                  });
                }
              }
            }
            total = total + amount;

            // console.log("Amount  = " + amount)
          }

          if (part.amount_is_tax == "inclusive") {
            var x = (100 + tax_info.rate) / 100;
            var tax_on_amount = amount / x;
            if (tax_rate.length > 0) {
              for (var r = 0; r < tax_rate.length; r++) {
                if (tax_rate[r].rate != tax_info.rate) {
                  var t = tax_on_amount * (tax_rate[r].rate / 100);
                  base = base - t;
                  tax.push({
                    tax: tax_rate[r].tax,
                    rate: tax_rate[r].rate,
                    amount: parseFloat(t.toFixed(2)),
                  });
                } else {
                  var t = amount - tax_on_amount;
                  base = base - t;
                  tax.push({
                    tax: tax_info.tax,
                    rate: tax_info.rate,
                    amount: parseFloat(t.toFixed(2)),
                  });
                }
              }
            }
            total = total + amount;
          }

          var tax_details = {
            tax: tax_info.tax,
            rate: tax_info.rate,
            amount: total,
            detail: tax,
          };

          items.push({
            part_no: part.part_no,
            hsn_sac: part.hsn_sac,
            item: part.title,
            quantity: part.quantity,
            stock: part.quantity * part.lot,
            sku: part.sku,
            unit: part.unit,
            lot: part.lot,
            mrp: part.unit_price,
            amount: amount,
            base: base,
            unit_base_price: parseFloat(part.unit_base_price),
            tax_amount: _.sumBy(tax, (x) => x.amount),
            unit_price: amount / parseFloat(part.quantity),
            amount_is_tax: part.amount_is_tax,
            margin: parseFloat(part.margin),
            sell_price:
              parseFloat(part.unit_base_price) + parseFloat(part.margin),
            rate: parseFloat(part.unit_base_price) + parseFloat(part.margin),
            discount: part.discount,
            discount_type: part.discount_type,
            discount_total: discount_total,
            tax: tax_info.tax,
            tax_rate: tax_info.rate,
            tax_info: tax,
            isChecked: part.false,
            remark: part.remark,
            sentDate: new Date(),
            status: "confirmed",
          });
          if (
            Log_Level == 4 ||
            Log_Level == 6 ||
            Log_Level == 8 ||
            Log_Level == 10 ||
            Log_Level == 0
          ) {
            businessFunctions.logs(
              "DEBUG: Push items details in the items array after calculating the tax for the parts."
            );
          }

          tax = [];
          // }
        } else {
          res.status(422).json({
            responseCode: 422,
            responseMessage: "Please check tax",
            responseData: {},
          });
        }
      } else {
        if (
          Log_Level == 2 ||
          Log_Level == 5 ||
          Log_Level == 8 ||
          Log_Level == 9 ||
          Log_Level == 0
        ) {
          businessFunctions.logs(
            "WARNING: Invalid Quantity, Tax Type , Base Amount " +
              part.item +
              ", OrderId:" +
              orderId +
              ", " +
              "User:" +
              loggedInDetails.name
          );
        }
        res.status(422).json({
          responseCode: 422,
          responseMessage:
            "Invalid Quantity, Tax Type , Base Amount " + part.item,
          responseData: {},
        });
      }

      // }
      // && order.order_status != 'Open'
      if (order.status == "Requested") {
        // console.log("Adede Quota")
        var quotation = await QuotationOrders.findOne({
          _id: order.quotation,
        }).exec();
        quotation.quotation_received = quotation.quotation_received + 1;
        await quotation.save();
      }

      var total_amount = _.sumBy(items, (x) => x.amount);
      // order_status: 'Open',
      // order_status: "Open",
      // status: 'confirmed',
      if (
        Log_Level == 4 ||
        Log_Level == 6 ||
        Log_Level == 8 ||
        Log_Level == 10 ||
        Log_Level == 0
      ) {
        businessFunctions.logs(
          "DEBUG: Add Part details in the order, orderId:" +
            orderId +
            ", " +
            "User:" +
            loggedInDetails.name
        );
      }

      await VendorOrders.findOneAndUpdate(
        { _id: orderId },
        {
          $set: {
            parts: items,
            total_amount: total_amount,
            updated_at: new Date(),
          },
        },
        { new: false },
        async function (err, doc) {
          if (err) {
            if (
              Log_Level == 1 ||
              Log_Level == 5 ||
              Log_Level == 6 ||
              Log_Level == 7 ||
              Log_Level == 0
            ) {
              businessFunctions.logs(
                "ERROR: Error Occured while adding parts in the Order, OrderId:" +
                  orderId +
                  ", " +
                  "User:" +
                  loggedInDetails.name
              );
            }
            res.status(422).json({
              responseCode: 422,
              responseMessage: "Server Error...",
              responseData: err,
            });
          } else {
            var activity = {
              business: business,
              activity_by: loggedInDetails.name,
              activity:
                "Title: ' " +
                part.title +
                " ' , Qty: " +
                part.quantity +
                " , Amt: " +
                part.amount +
                " (Added)  ",
              // time: new Date().getTime.toLocaleTimeString(),
              remark: "New Part Added",
              created_at: new Date(),
            };
            // console.log("Activity")
            businessFunctions.vendorOrderLogs(order._id, activity);
            // await QuotationOrders.findByOneAndUpdate({_id:order.quotation},{$set:{quotation_submitted:}})
          }
        }
      );
      res.status(200).json({
        responseCode: 200,
        responseMessage: "Successfully Saved",
        responseData: await VendorOrders.findById(orderId).exec(),
      });
      if (
        Log_Level == 3 ||
        Log_Level == 7 ||
        Log_Level == 9 ||
        Log_Level == 10 ||
        Log_Level == 0
      ) {
        businessFunctions.logs(
          "INFO: Part Saved Successfully in the Order, OrderId:" +
            orderId +
            ", " +
            "User:" +
            loggedInDetails.name
        );
      }
    }
  } else {
    if (
      Log_Level == 2 ||
      Log_Level == 5 ||
      Log_Level == 8 ||
      Log_Level == 9 ||
      Log_Level == 0
    ) {
      businessFunctions.logs(
        "WARNING: Order Not Found for the given orderId:" +
          orderId +
          ", " +
          "User:" +
          loggedInDetails.name
      );
    }
    res.status(422).json({
      responseCode: 422,
      responseMessage: "Order Not Found ",
      responseData: {},
    });
  }
});

router.put("/vendorOrder/item/remove", async (req, res, next) => {
  businessFunctions.logs(
    "INFO: /vendorOrder/item/remove Api Called from 3.0.js," +
      " " +
      "Request Headers:" +
      JSON.stringify(req.headers) +
      ", " +
      "Request Body:" +
      JSON.stringify(req.body)
  );

  var token = req.headers["x-access-token"];
  var business = req.headers["business"];
  var secret = config.secret;
  var decoded = jwt.verify(token, secret);
  var user = decoded.user;
  var order = req.body.order;
  var partIndex = req.body.index;
  var item = req.body.item;
  // console.log("order = ", order)
  // console.log("quotationId", partIndex)
  var loggedInDetails = await User.findById(user).exec();
  if (
    Log_Level == 4 ||
    Log_Level == 6 ||
    Log_Level == 8 ||
    Log_Level == 10 ||
    Log_Level == 0
  ) {
    businessFunctions.logs(
      "DEBUG: Fatching Vendor Order details for the orderId:" +
        req.body.order +
        ", User:" +
        loggedInDetails.name
    );
  }
  var vendorOrder = await VendorOrders.findOne({ _id: order }).exec();
  if (vendorOrder) {
    var activity = {
      business: business,
      activity_by: loggedInDetails.name,
      activity:
        "Title: ' " +
        vendorOrder.parts[partIndex].item +
        " ' , Qty: " +
        vendorOrder.parts[partIndex].quantity +
        " , Amt: " +
        vendorOrder.parts[partIndex].amount +
        " ( Removed )  ",
      remark: "New Part Added",
      created_at: new Date(),
    };
    if (
      Log_Level == 4 ||
      Log_Level == 6 ||
      Log_Level == 8 ||
      Log_Level == 10 ||
      Log_Level == 0
    ) {
      businessFunctions.logs(
        "DEBUG: Removing Item from the Vendor Order for the orderId:" +
          req.body.order +
          ", Item:" +
          vendorOrder.parts[partIndex].item +
          ", User:" +
          loggedInDetails.name
      );
    }
    vendorOrder.parts.splice(partIndex, 1);
    vendorOrder.markModified("parts");
    await vendorOrder.save();
    businessFunctions.vendorOrderLogs(vendorOrder._id, activity);
    res.status(200).json({
      responseCode: 200,
      responseMessage: "Removed Successfully",
      responseData: {},
    });
    if (
      Log_Level == 3 ||
      Log_Level == 7 ||
      Log_Level == 9 ||
      Log_Level == 10 ||
      Log_Level == 0
    ) {
      businessFunctions.logs(
        "INFO: Item Removed from the vendor order Successfully, Item:" +
          vendorOrder.parts[partIndex].item +
          ", User:" +
          loggedInDetails.name
      );
    }
  } else {
    if (
      Log_Level == 2 ||
      Log_Level == 5 ||
      Log_Level == 8 ||
      Log_Level == 9 ||
      Log_Level == 0
    ) {
      businessFunctions.logs(
        "WARNING: Order not found for the orderId:" +
          req.body.order +
          ", User:" +
          loggedInDetails.name
      );
    }
    res.status(400).json({
      responseCode: 400,
      responseMessage: "Order Not Found",
      responseData: {},
    });
  }
});

router.put("/vendorOrder/item/edit", async (req, res, next) => {
  businessFunctions.logs(
    "INFO: /vendorOrder/item/edit Api Called from 3.0.js," +
      " " +
      "Request Headers:" +
      JSON.stringify(req.headers) +
      ", " +
      "Request Body:" +
      JSON.stringify(req.body)
  );

  var token = req.headers["x-access-token"];
  var business = req.headers["business"];
  var secret = config.secret;
  var decoded = jwt.verify(token, secret);
  var user = decoded.user;
  var order = req.body.order;
  var index = req.body.index;
  var part = req.body.item;
  var tax = [];
  var total = 0;
  // console.log("order = ", order)
  // console.log("quotationId", index)
  var loggedInDetails = await User.findById(user).exec();
  var vendorOrder = await VendorOrders.findOne({ _id: order }).exec();
  if (vendorOrder) {
    if (part) {
      if (part.quantity != null) {
        var tax_info = await Tax.findOne({ tax: part.tax }).exec();
        if (tax_info) {
          // console.log("Product ")
          var tax_rate = tax_info.detail;
          var base =
            parseFloat(part.unit_base_price) * parseFloat(part.quantity);
          // console.log("Base  = " + unit_base_price)
          var discount = part.discount;
          var amount =
            parseFloat(part.unit_base_price) * parseFloat(part.quantity);
          var discount_total = 0;
          // if (discount.indexOf("%") >= 0) {
          //     discount = parseFloat(discount);
          //     if (!isNaN(discount) && discount > 0) {
          //         var discount_total = amount * (discount / 100);
          //         amount = amount - parseFloat(discount_total.toFixed(2))
          //     }
          // }
          // else {
          //     discount = parseFloat(discount);
          //     if (!isNaN(discount) && discount > 0) {
          //         base = base - parseFloat(discount.toFixed(2))
          //     }
          // }
          if (part.amount_is_tax == "exclusive") {
            if (
              Log_Level == 4 ||
              Log_Level == 6 ||
              Log_Level == 8 ||
              Log_Level == 10 ||
              Log_Level == 0
            ) {
              businessFunctions.logs(
                "DEBUG: Calculate Tax amount for Exclusive Tax."
              );
            }
            var tax_on_amount = amount;
            if (tax_rate.length > 0) {
              for (var r = 0; r < tax_rate.length; r++) {
                if (tax_rate[r].rate != tax_info.rate) {
                  var t = tax_on_amount * (tax_rate[r].rate / 100);
                  amount = amount + t;
                  // console.log("Tax AMO=" + t)
                  tax.push({
                    tax: tax_rate[r].tax,
                    rate: tax_rate[r].rate,
                    amount: parseFloat(t.toFixed(2)),
                  });
                } else {
                  var t = tax_on_amount * (tax_info.rate / 100);
                  amount = amount + t;
                  // console.log("Tax AMO=" + t)

                  tax.push({
                    tax: tax_info.tax,
                    tax_rate: tax_info.rate,
                    rate: tax_info.rate,
                    amount: parseFloat(t.toFixed(2)),
                  });
                }
              }
            }
            total = total + amount;

            // console.log("Amount  = " + amount)
          }

          if (part.amount_is_tax == "inclusive") {
            var x = (100 + tax_info.rate) / 100;
            var tax_on_amount = amount / x;
            if (tax_rate.length > 0) {
              for (var r = 0; r < tax_rate.length; r++) {
                if (tax_rate[r].rate != tax_info.rate) {
                  var t = tax_on_amount * (tax_rate[r].rate / 100);
                  base = base - t;
                  tax.push({
                    tax: tax_rate[r].tax,
                    rate: tax_rate[r].rate,
                    amount: parseFloat(t.toFixed(2)),
                  });
                } else {
                  var t = amount - tax_on_amount;
                  base = base - t;
                  tax.push({
                    tax: tax_info.tax,
                    rate: tax_info.rate,
                    amount: parseFloat(t.toFixed(2)),
                  });
                }
              }
            }
            total = total + amount;
          }

          var tax_details = {
            tax: tax_info.tax,
            rate: tax_info.rate,
            amount: total.toFixed(2),
            detail: tax,
          };
          vendorOrder.parts[index].part_no = part.part_no;
          vendorOrder.parts[index].item = part.title;
          vendorOrder.parts[index].quantity = part.quantity;
          vendorOrder.parts[index].stock = part.quantity * part.lot;
          vendorOrder.parts[index].mrp = parseFloat(part.unit_price);
          vendorOrder.parts[index].amount = amount.toFixed(2);
          vendorOrder.parts[index].base = base.toFixed(2);
          vendorOrder.parts[index].unit_base_price = parseFloat(
            part.unit_base_price
          );
          vendorOrder.parts[index].tax_amount = _.sumBy(tax, (x) => x.amount);
          vendorOrder.parts[index].unit_price = (
            amount / parseFloat(part.quantity)
          ).toFixed(2);
          vendorOrder.parts[index].amount_is_tax = part.amount_is_tax;
          vendorOrder.parts[index].margin = parseFloat(part.margin);
          vendorOrder.parts[index].sell_price =
            parseFloat(part.unit_base_price) + parseFloat(part.margin);
          vendorOrder.parts[index].rate =
            parseFloat(part.unit_base_price) + parseFloat(part.margin);
          vendorOrder.parts[index].tax = tax_info.tax;
          vendorOrder.parts[index].tax_rate = tax_info.rate;
          vendorOrder.parts[index].tax_info = tax;
          // }
          vendorOrder.markModified("parts");
          vendorOrder.save();
        } else {
          res.status(422).json({
            responseCode: 422,
            responseMessage: "Please check tax",
            responseData: {},
          });
        }
      } else {
        res.status(422).json({
          responseCode: 422,
          responseMessage:
            "Invalid Quantity, Tax Type , Base Amount " + part.item,
          responseData: {},
        });
      }
      var total_amount = _.sumBy(vendorOrder.parts, (x) => x.amount);
      await VendorOrders.findOneAndUpdate(
        { _id: vendorOrder._id },
        { $set: { total_amount: total_amount, updated_at: new Date() } },
        { new: true },
        async function (err, doc) {
          if (err) {
            if (
              Log_Level == 1 ||
              Log_Level == 5 ||
              Log_Level == 6 ||
              Log_Level == 7 ||
              Log_Level == 0
            ) {
              businessFunctions.logs(
                "ERROR: Server Error occured while updating the part details, VendorOrderId:" +
                  vendorOrder._id +
                  ", User:" +
                  loggedInDetails.name
              );
            }
            res.status(422).json({
              responseCode: 422,
              responseMessage: "Server Error...",
              responseData: err,
            });
          } else {
            var activity = {
              business: business,
              activity_by: loggedInDetails.name,
              activity:
                "Title: ' " +
                part.title +
                " ' , Qty: " +
                part.quantity +
                " , Amt: " +
                part.amount +
                " (Updated)  ",
              // time: new Date().getTime.toLocaleTimeString(),
              remark: "Part Updated",
              created_at: new Date(),
            };
            // console.log("Activity")
            businessFunctions.vendorOrderLogs(vendorOrder._id, activity);
            // await QuotationOrders.findByOneAndUpdate({_id:order.quotation},{$set:{quotation_submitted:}})
          }
        }
      );
      res.status(200).json({
        responseCode: 200,
        responseMessage: "Successfully Updated",
        responseData: await VendorOrders.findById(vendorOrder._id).exec(),
      });
      if (
        Log_Level == 3 ||
        Log_Level == 7 ||
        Log_Level == 9 ||
        Log_Level == 10 ||
        Log_Level == 0
      ) {
        businessFunctions.logs(
          "INFO: Successfully Updated Parts Details for the vendor Order, OrderId:" +
            vendorOrder._id +
            ", User:" +
            loggedInDetails.name
        );
      }
    }
  } else {
    res.status(400).json({
      responseCode: 400,
      responseMessage: "Order Not Found",
      responseData: {},
    });
  }
});

router.put(
  "/purchase/order/status/update",
  xAccessToken.token,
  async function (req, res, next) {
    businessFunctions.logs(
      "INFO: /purchase/order/status/update Api Called from 3.0.js," +
        " " +
        "Request Headers:" +
        JSON.stringify(req.headers) +
        ", " +
        "Request Body:" +
        JSON.stringify(req.body)
    );
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var business = req.headers["business"];
    var status = req.body.status;
    // console.log("Status = " + status)
    var loggedInDetails = await User.findById(decoded.user).exec();
    if (
      Log_Level == 4 ||
      Log_Level == 6 ||
      Log_Level == 8 ||
      Log_Level == 10 ||
      Log_Level == 0
    ) {
      businessFunctions.logs(
        "DEBUG: Fatching Order Details, OrderId:" +
          req.body.order +
          ", " +
          "User:" +
          loggedInDetails.name
      );
    }
    var order = await VendorOrders.findOne({
      _id: req.body.order,
      business: business,
      order_status: { $nin: ["Cancelled"] },
    }).exec();
    if (order) {
      if (
        Log_Level == 4 ||
        Log_Level == 6 ||
        Log_Level == 8 ||
        Log_Level == 10 ||
        Log_Level == 0
      ) {
        businessFunctions.logs(
          "DEBUG: Updating Order Status,Status:" +
            req.body.status +
            ", " +
            "OrderId:" +
            req.body.order +
            ", " +
            "User:" +
            loggedInDetails.name
        );
      }
      await VendorOrders.findOneAndUpdate(
        { _id: order._id },
        {
          $set: {
            status: status,
            order_status: status,
            updated_at: new Date(),
          },
        },
        { new: true },
        async function (err, doc) {
          if (err) {
            res.status(422).json({
              responseCode: 422,
              responseMessage: "Server Errro",
              responseData: err,
            });
          } else {
            var isSalesOrder = await Order.findOne({
              vendorOrder: order._id,
              status: { $nin: ["Cancelled"] },
            }).exec();
            if (isSalesOrder) {
              await Order.findOneAndUpdate(
                { vendorOrder: order._id, status: { $nin: ["Cancelled"] } },
                { $set: { status: "Delivered", updated_at: new Date() } },
                { new: true },
                async function (err, salesOrder) {
                  if (err) {
                    res.status(422).json({
                      responseCode: 422,
                      responseMessage: "Server Errro",
                      responseData: err,
                    });
                  } else {
                    await BusinessOrder.findOneAndUpdate(
                      { vendorOrder: order._id },
                      { $set: { status: "Delivered", updated_at: new Date() } },
                      { new: false },
                      async function (err, doc) {
                        if (err) {
                          return res.status(422).json({
                            responseCode: 422,
                            responseMessage: "Server Error",
                            responseData: err,
                          });
                        } else {
                          var activity = {
                            business: business,
                            activity_by: loggedInDetails.name,
                            activity: "Order " + status,
                            remark: "Orderm Received by Purchaser",
                            created_at: new Date(),
                          };
                          businessFunctions.salesOrderLogs(doc.order, activity);
                        }
                      }
                    );
                  }
                }
              );
            }

            if (status == "Received") {
              var activity = "Order Received";
              fun.webNotification(activity, doc);
              whatsAppEvent.orderDeliverd(
                doc.business,
                doc.order_no,
                doc.vendor
              );

              //whatsAppEvent.orderCancel(doc.business, doc.vendor, doc.order_no)
            }

            if (status == "Cancelled") {
              var activity = "Order Cancelled";
              fun.webNotification(activity, doc);

              whatsAppEvent.orderCancel(doc.business, doc.vendor, doc.order_no);
            }

            var activity = {
              business: business,
              activity_by: loggedInDetails.name,
              activity: "Order " + status,
              // time: new Date().getTime.toLocaleTimeString(),
              remark: "Order " + status,
              created_at: new Date(),
            };
            businessFunctions.vendorOrderLogs(order._id, activity);
            res.status(200).json({
              responseCode: 200,
              responseMessage: "Order Status Updated",
              responseData: {},
            });
            if (
              Log_Level == 3 ||
              Log_Level == 7 ||
              Log_Level == 9 ||
              Log_Level == 10 ||
              Log_Level == 0
            ) {
              businessFunctions.logs(
                "INFO: Order Status Updated Successfully, OrderId:" +
                  req.body.order +
                  ", " +
                  "User:" +
                  loggedInDetails.name
              );
            }
          }
        }
      );
    } else {
      if (
        Log_Level == 2 ||
        Log_Level == 5 ||
        Log_Level == 8 ||
        Log_Level == 9 ||
        Log_Level == 0
      ) {
        businessFunctions.logs(
          "WARNING: Order not found for the given orderId:" +
            req.body.order +
            ", " +
            "User:" +
            loggedInDetails.name
        );
      }
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Order not found",
        responseData: {},
      });
    }
  }
);

router.put("/bill/remove", xAccessToken.token, async function (req, res, next) {
  businessFunctions.logs(
    "INFO: /bill/remove Api Called from 3.0.js," +
      " " +
      "Request Headers:" +
      JSON.stringify(req.headers) +
      ", " +
      "Request Query:" +
      JSON.stringify(req.query)
  );

  var token = req.headers["x-access-token"];
  var business = req.headers["business"];
  var secret = config.secret;
  var decoded = jwt.verify(token, secret);
  let regex = req.body.tax_slab;
  var loggedInDetails = await User.findById(decoded.user).exec();
  // console.log("Tax Rate = " + regex)
  // let regex = req.query.query.replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1");
  var purchase = await Purchase.findById(req.query.bill).exec();
  if (purchase) {
    if (
      Log_Level == 4 ||
      Log_Level == 6 ||
      Log_Level == 8 ||
      Log_Level == 10 ||
      Log_Level == 0
    ) {
      businessFunctions.logs(
        "DEBUG: Deleting the bill, BillId:" +
          purchase._id +
          ", User:" +
          loggedInDetails.name
      );
    }
    await Purchase.findOneAndDelete(
      { _id: purchase._id },
      async function (err, doc) {
        if (err) {
          res.status(422).json({
            responseCode: 422,
            responseMessage: "Server Error...",
            responseData: err,
          });
        } else {
          res.status(200).json({
            responseCode: 200,
            responseMessage: "Successfully Canclled",
            responseData: {},
          });
          if (
            Log_Level == 3 ||
            Log_Level == 7 ||
            Log_Level == 9 ||
            Log_Level == 10 ||
            Log_Level == 0
          ) {
            businessFunctions.logs(
              "INFO: Bill Successfully Cancelled, BillId:" +
                purchase._id +
                ", User:" +
                loggedInDetails.name
            );
          }
        }
      }
    );
  } else {
    if (
      Log_Level == 2 ||
      Log_Level == 5 ||
      Log_Level == 8 ||
      Log_Level == 9 ||
      Log_Level == 0
    ) {
      businessFunctions.logs(
        "WARNING: Bill not found, BillId:" +
          req.body.bill +
          ", User:" +
          loggedInDetails.name
      );
    }
    res.status(400).json({
      responseCode: 400,
      responseMessage: "Bill not found",
      responseData: {},
    });
  }
});

router.post(
  "/seller/order/convert/bill",
  xAccessToken.token,
  async function (req, res, next) {
    let reference_no = req.body.reference_no;
    var rules = {
      bill: "required",
    };
    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Bill is required",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var user = decoded.user;
      var business = req.headers["business"];
      var loggedInDetails = await User.findById(decoded.user).exec();
      var product = new Object();
      var result = [];
      var tax = [];
      var total = 0;
      var purchase = await Purchase.findById(req.body.bill).exec();
      if (purchase) {
        // console.log("VendorOrder Id  = " + purchase.vendorOrder)
        var vendorOrder = await VendorOrders.findById(
          purchase.vendorOrder
        ).exec();
        var order = await Order.findById(vendorOrder.order).exec();
        // console.log("Order  = " + order._id)
        // var count = await VendorOrders.findById(purchase.vendorOrder).count().exec();
        // console.log("VendorOrder Id  = " + vendorOrder._id + " Count = " + count)
        // return res.json(vendorOrder)
        if (order) {
          if (vendorOrder) {
            if (req.body.due) {
              var due = new Date(req.body.due).toISOString();
            } else {
              var due = null;
            }
            var vendor = await User.findById(vendorOrder.vendor).exec();
            var newDate = new Date();
            if (vendor) {
              var items = [];
              //
              var salesItem = await OrderLine.find({ order: order._id }).exec();
              console.log("Sales Length = " + salesItem.length);
              if (salesItem.length > 0) {
                // console.log("1057 products length = " + products.length)
                for (var p = 0; p < salesItem.length; p++) {
                  if (salesItem[p].status == "Confirmed") {
                    if (salesItem[p].quantity != null) {
                      // console.log("Come inside business product finding condition....")
                      var product = await BusinessProduct.findOne({
                        $or: [
                          {
                            part_no: salesItem[p].part_no,
                          },
                          { title: salesItem[p].title },
                        ],
                        business: business,
                      }).exec();
                      var tax_info = await Tax.findOne({
                        tax: salesItem[p].tax,
                      }).exec();
                      if (tax_info) {
                        var tax_rate = tax_info.detail;
                        if (product) {
                          // console.log("IF Is Product = " + product._id)
                          var quantity = parseInt(salesItem[p].quantity);
                          var unit_base_price = parseFloat(salesItem[p].rate);
                          var base = parseFloat(salesItem[p].base);
                          var amount_is_tax = salesItem[p].amount_is_tax;

                          var discount = salesItem[p].discount_total;
                          // console.log("Discount prints here...", discount)
                          /*  if (discount.indexOf("%") >= 0) {
                                                      // console.log("602 - Discount If Condition = " + discount)
                                                      discount = parseFloat(discount);
                                                      if (!isNaN(discount) && discount > 0) {
                                                          var discount_total = amount * (discount / 100);
                                                          amount = amount - parseFloat(discount_total.toFixed(2))
                        
                                                      }
                                                  }
                                                  else {
                                                      // console.log("610 - Discount ELSE Condition= " + discount)
                        
                        
                                                      discount = parseFloat(discount);
                                                      if (!isNaN(discount) && discount > 0) {
                                                          amount = amount - parseFloat(discount.toFixed(2))
                        
                                                      }
                                                  }
                        */

                          // console.log("Ammount after discount= " + amount)
                          var amount_is_tax = "exclusive";
                          if (amount_is_tax == "exclusive") {
                            var amount = base;
                            var tax_on_amount = amount;
                            if (tax_rate.length > 0) {
                              for (var r = 0; r < tax_rate.length; r++) {
                                if (tax_rate[r].rate != tax_info.rate) {
                                  var t =
                                    tax_on_amount * (tax_rate[r].rate / 100);
                                  amount = amount + t;
                                  tax.push({
                                    tax: tax_rate[r].tax,
                                    rate: tax_rate[r].rate,
                                    amount: parseFloat(t.toFixed(2)),
                                  });
                                } else {
                                  var t = tax_on_amount * (tax_info.rate / 100);
                                  amount = amount + t;
                                  tax.push({
                                    tax: tax_info.tax,
                                    tax_rate: tax_info.rate,
                                    rate: tax_info.rate,
                                    amount: parseFloat(t.toFixed(2)),
                                  });
                                }
                              }
                            }
                            total = total + amount;
                          }
                          // console.log("Ammount after Tax= " + amount)

                          // if (salesItem[p].amount_is_tax == "inclusive") {
                          //     var x = (100 + tax_info.rate) / 100;
                          //     var tax_on_amount = amount / x;
                          //     if (tax_rate.length > 0) {
                          //         for (var r = 0; r < tax_rate.length; r++) {
                          //             if (tax_rate[r].rate != tax_info.rate) {
                          //                 var t = tax_on_amount * (tax_rate[r].rate / 100);
                          //                 base = base - t;
                          //                 tax.push({
                          //                     tax: tax_rate[r].tax,
                          //                     rate: tax_rate[r].rate,
                          //                     amount: parseFloat(t.toFixed(2))
                          //                 });
                          //             }
                          //             else {
                          //                 var t = amount - tax_on_amount;
                          //                 base = base - t;
                          //                 tax.push({
                          //                     tax: tax_info.tax,
                          //                     rate: tax_info.rate,
                          //                     amount: parseFloat(t.toFixed(2))
                          //                 });
                          //             }
                          //         }
                          //     }
                          //     total = total + amount;
                          // }

                          var tax_details = {
                            tax: tax_info.tax,
                            rate: tax_info.rate,
                            amount: total,
                            // amount: amount,
                            detail: tax,
                          };

                          // console.log("product.unit....", product.unit)
                          // console.log("Product " + product.product)
                          var lot = 1;
                          items.push({
                            item_status: "InComplete",
                            product: product._id,
                            part_no: salesItem[p].part_no,
                            hsn_sac: product.hsn_sac,
                            part_category: product.part_category, //OEM OR OES
                            // title: salesItem[p].item,
                            title: salesItem[p].title,
                            quantity: quantity,
                            stock: quantity * lot,
                            sku: product.sku,
                            unit_base_price: salesItem[p].rate,
                            unit_price: amount / quantity,
                            // purchase_price: purchase_price,
                            unit: salesItem[p].unit,
                            lot: lot,
                            mrp: salesItem[p].mrp,
                            rate: salesItem[p].rate,
                            base: base,
                            tax_amount: _.sumBy(tax, (x) => x.amount),
                            // tax_amount: tax_amount,
                            amount: amount,
                            // models: salesItem[p].models,
                            amount_is_tax: amount_is_tax,
                            sell_price: salesItem[p].rate,
                            margin: 0,
                            discount: salesItem[p].discount,
                            discount_type: "",
                            discount_total: salesItem[p].discount_total,
                            tax: tax_info.tax,
                            tax_rate: tax_info.rate,
                            tax_info: tax,
                            isProduct: true,
                            isOrderItem: true,
                          });

                          tax = [];
                        } else {
                          // console.log("ELSE Is Product ???")
                          var quantity = parseInt(salesItem[p].quantity);
                          var unit_base_price = parseFloat(
                            salesItem[p].unit_base_price
                          );
                          var base = parseFloat(salesItem[p].base);
                          var amount_is_tax = salesItem[p].amount_is_tax;
                          var discount = salesItem[p].discount;
                          // console.log("Discount prints here...", discount)
                          /*  if (discount.indexOf("%") >= 0) {
                                                      // console.log("602 - Discount If Condition = " + discount)
                                                      discount = parseFloat(discount);
                                                      if (!isNaN(discount) && discount > 0) {
                                                          var discount_total = amount * (discount / 100);
                                                          amount = amount - parseFloat(discount_total.toFixed(2))
                        
                                                      }
                                                  }
                                                  else {
                                                      // console.log("610 - Discount ELSE Condition= " + discount)
                        
                        
                                                      discount = parseFloat(discount);
                                                      if (!isNaN(discount) && discount > 0) {
                                                          amount = amount - parseFloat(discount.toFixed(2))
                        
                                                      }
                                                  }
                        */

                          // console.log("Ammount after discount= " + amount)
                          var amount_is_tax = "exclusive";

                          if (amount_is_tax == "exclusive") {
                            var amount = base;
                            var tax_on_amount = amount;
                            if (tax_rate.length > 0) {
                              for (var r = 0; r < tax_rate.length; r++) {
                                if (tax_rate[r].rate != tax_info.rate) {
                                  var t =
                                    tax_on_amount * (tax_rate[r].rate / 100);
                                  amount = amount + t;
                                  tax.push({
                                    tax: tax_rate[r].tax,
                                    rate: tax_rate[r].rate,
                                    amount: parseFloat(t.toFixed(2)),
                                  });
                                } else {
                                  var t = tax_on_amount * (tax_info.rate / 100);
                                  amount = amount + t;
                                  tax.push({
                                    tax: tax_info.tax,
                                    tax_rate: tax_info.rate,
                                    rate: tax_info.rate,
                                    amount: parseFloat(t.toFixed(2)),
                                  });
                                }
                              }
                            }
                            total = total + amount;
                          }
                          // console.log("Ammount after Tax= " + amount)

                          // if (salesItem[p].amount_is_tax == "inclusive") {
                          //     var x = (100 + tax_info.rate) / 100;
                          //     var tax_on_amount = amount / x;
                          //     if (tax_rate.length > 0) {
                          //         for (var r = 0; r < tax_rate.length; r++) {
                          //             if (tax_rate[r].rate != tax_info.rate) {
                          //                 var t = tax_on_amount * (tax_rate[r].rate / 100);
                          //                 base = base - t;
                          //                 tax.push({
                          //                     tax: tax_rate[r].tax,
                          //                     rate: tax_rate[r].rate,
                          //                     amount: parseFloat(t.toFixed(2))
                          //                 });
                          //             }
                          //             else {
                          //                 var t = amount - tax_on_amount;
                          //                 base = base - t;
                          //                 tax.push({
                          //                     tax: tax_info.tax,
                          //                     rate: tax_info.rate,
                          //                     amount: parseFloat(t.toFixed(2))
                          //                 });
                          //             }
                          //         }
                          //     }
                          //     total = total + amount;
                          // }

                          var tax_details = {
                            tax: tax_info.tax,
                            rate: tax_info.rate,
                            amount: total,
                            // amount: amount,
                            detail: tax,
                          };
                          var lot = 1;
                          // console.log("Unit Base  Price  = " + (base / quantity))
                          items.push({
                            item_status: "InComplete",
                            product: null,
                            part_no: salesItem[p].part_no,
                            hsn_sac: salesItem[p].hsn_sac,
                            part_category: salesItem[p].part_category, //OEM OR OES
                            title: salesItem[p].title,
                            quantity: quantity,
                            stock: quantity * lot,
                            // sku: salesItem[p].sku,
                            unit_base_price: base / quantity,
                            unit_price: amount / quantity,
                            unit: salesItem[p].unit,
                            lot: lot,
                            mrp: salesItem[p].mrp,
                            rate: salesItem[p].rate,
                            base: base,
                            tax_amount: _.sumBy(tax, (x) => x.amount),
                            amount: amount,
                            models: [],
                            amount_is_tax: amount_is_tax,
                            sell_price: salesItem[p].rate,
                            margin: 0,
                            discount: discount,
                            discount_type: "",
                            discount_total: salesItem[p].discount_total,
                            tax: tax_info.tax,
                            tax_rate: tax_info.rate,
                            tax_info: tax,
                            isProduct: false,
                            isOrderItem: true,
                          });

                          tax = [];
                        }
                      } else {
                        res.status(422).json({
                          responseCode: 422,
                          responseMessage: "Please check tax",
                          responseData: {},
                        });
                      }
                    }
                  }
                }

                var address = null;
                if (req.body.address) {
                  address = req.body.address;
                }
                var log_details = {
                  business: business,
                  activity_by: loggedInDetails.name,
                  activity: "Update",
                  remark: "Order To Bill Conversion",
                  created_at: new Date(),
                };
                var logs = [];
                if (purchase.logs) {
                  logs = purchase.logs;
                } else {
                  logs.push(log_details);
                }
                var total = _.sumBy(items, (x) => x.amount);
                var discount_total = 0;
                var discount = 0;
                var paid_total = total.toFixed(2);
                if (req.body.bill_discount > 0) {
                  // console.log(" bILL Discount = " + req.body.bill_discount)
                  discount = parseFloat(req.body.bill_discount);
                  paid_total = total.toFixed(2);

                  if (!isNaN(discount) && discount > 0) {
                    discount_total = total * (discount / 100);
                    paid_total =
                      paid_total - parseFloat(discount_total.toFixed(2));
                  }
                }
                var bill = {
                  due_date: due,
                  vendor: vendor._id,
                  items: items,
                  bill_discount: discount,
                  paid_total: paid_total,
                  total_discount: discount_total,
                  business: business,
                  total: paid_total,
                  subTotal: total.toFixed(2),
                  logs: logs,
                  // vendorOrder: vendorOrder._id,
                  updated_at: new Date(),
                };
                await Purchase.findOneAndUpdate(
                  { _id: purchase._id },
                  { $set: bill },
                  { new: false },
                  async function (err, doc) {
                    if (err) {
                      res.status(422).json({
                        responseCode: 422,
                        responseMessage: "Server Error...",
                        responseData: err,
                      });
                    } else {
                      res.status(200).json({
                        responseCode: 200,
                        responseMessage: "Successfully Saved",
                        responseData: await Purchase.findById(
                          req.body.bill
                        ).exec(),
                      });
                    }
                  }
                );
              }
              ///
              /*
                                            var products = vendorOrder.parts;
                                            if (products.length > 0) {
                                                // console.log("1057 products length = " + products.length)
                                                for (var p = 0; p < products.length; p++) {
                                                    if (products[p].status == 'confirmed') {
                                                        if (products[p].quantity != null) {
                                                            // console.log("Come inside business product finding condition....")
                                                            var product = await BusinessProduct.findOne({
                                                                $or: [{
                                                                    part_no: products[p].part_no
                                                                }, { title: products[p].title }],
                                                                business: business
                                                            }).exec();
                                                            var tax_info = await Tax.findOne({ tax: products[p].tax }).exec();
                                                            if (tax_info) {
                                                                var tax_rate = tax_info.detail;
                                                                if (product) {
                                                                    // console.log("IF Is Product = " + product._id)
                                                                    var quantity = parseInt(products[p].quantity);
                                                                    var unit_base_price = parseFloat(products[p].unit_base_price);
                                                                    var base = parseFloat(products[p].unit_base_price) * quantity;
                                                                    var amount_is_tax = products[p].amount_is_tax
                        
                        
                                                                    var discount = products[p].discount;
                                                                    // console.log("Discount prints here...", discount)
                                                                    //   if (discount.indexOf("%") >= 0) {
                                                                    //       // console.log("602 - Discount If Condition = " + discount)
                                                                    //       discount = parseFloat(discount);
                                                                    //       if (!isNaN(discount) && discount > 0) {
                                                                    //           var discount_total = amount * (discount / 100);
                                                                    //           amount = amount - parseFloat(discount_total.toFixed(2))
                        
                                                                    //       }
                                                                    //   }
                                                                    //   else {
                                                                    //       // console.log("610 - Discount ELSE Condition= " + discount)
                        
                        
                                                                    //       discount = parseFloat(discount);
                                                                    //       if (!isNaN(discount) && discount > 0) {
                                                                    //           amount = amount - parseFloat(discount.toFixed(2))
                        
                                                                    //       }
                                                                    //   }
                        
                        
                                                                    // console.log("Ammount after discount= " + amount)
                                                                    var amount_is_tax = "exclusive";
                                                                    if (amount_is_tax == "exclusive") {
                                                                        var amount = base
                                                                        var tax_on_amount = amount;
                                                                        if (tax_rate.length > 0) {
                                                                            for (var r = 0; r < tax_rate.length; r++) {
                                                                                if (tax_rate[r].rate != tax_info.rate) {
                                                                                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                                                                                    amount = amount + t;
                                                                                    tax.push({
                                                                                        tax: tax_rate[r].tax,
                                                                                        rate: tax_rate[r].rate,
                                                                                        amount: parseFloat(t.toFixed(2))
                                                                                    })
                                                                                }
                                                                                else {
                                                                                    var t = tax_on_amount * (tax_info.rate / 100);
                                                                                    amount = amount + t;
                                                                                    tax.push({
                                                                                        tax: tax_info.tax, tax_rate: tax_info.rate,
                                                                                        rate: tax_info.rate,
                                                                                        amount: parseFloat(t.toFixed(2))
                                                                                    })
                                                                                }
                                                                            }
                                                                        }
                                                                        total = total + amount;
                                                                    }
                                                                    // console.log("Ammount after Tax= " + amount)
                        
                        
                                                                    // if (products[p].amount_is_tax == "inclusive") {
                                                                    //     var x = (100 + tax_info.rate) / 100;
                                                                    //     var tax_on_amount = amount / x;
                                                                    //     if (tax_rate.length > 0) {
                                                                    //         for (var r = 0; r < tax_rate.length; r++) {
                                                                    //             if (tax_rate[r].rate != tax_info.rate) {
                                                                    //                 var t = tax_on_amount * (tax_rate[r].rate / 100);
                                                                    //                 base = base - t;
                                                                    //                 tax.push({
                                                                    //                     tax: tax_rate[r].tax,
                                                                    //                     rate: tax_rate[r].rate,
                                                                    //                     amount: parseFloat(t.toFixed(2))
                                                                    //                 });
                                                                    //             }
                                                                    //             else {
                                                                    //                 var t = amount - tax_on_amount;
                                                                    //                 base = base - t;
                                                                    //                 tax.push({
                                                                    //                     tax: tax_info.tax,
                                                                    //                     rate: tax_info.rate,
                                                                    //                     amount: parseFloat(t.toFixed(2))
                                                                    //                 });
                                                                    //             }
                                                                    //         }
                                                                    //     }
                                                                    //     total = total + amount;
                                                                    // }
                        
                                                                    var tax_details = {
                                                                        tax: tax_info.tax,
                                                                        rate: tax_info.rate,
                                                                        amount: total,
                                                                        // amount: amount,
                                                                        detail: tax
                                                                    }
                        
                                                                    // console.log("product.unit....", product.unit)
                                                                    // console.log("Product " + product.product)
                                                                    var lot = 1
                                                                    items.push({
                                                                        item_status: 'InComplete',
                                                                        product: product._id,
                                                                        part_no: products[p].part_no,
                                                                        hsn_sac: product.hsn_sac,
                                                                        part_category: product.part_category,    //OEM OR OES
                                                                        title: products[p].item,
                                                                        quantity: quantity,
                                                                        stock: quantity * lot,
                                                                        sku: product.sku,
                                                                        unit_base_price: products[p].unit_base_price,
                                                                        unit_price: amount / quantity,
                                                                        // purchase_price: purchase_price,
                                                                        unit: product.unit,
                                                                        lot: lot,
                                                                        mrp: products[p].mrp,
                                                                        rate: unit_base_price + products[p].margin,
                                                                        base: base,
                                                                        tax_amount: _.sumBy(tax, x => x.amount),
                                                                        // tax_amount: tax_amount,
                                                                        amount: amount,
                                                                        models: products[p].models,
                                                                        amount_is_tax: amount_is_tax,
                                                                        sell_price: unit_base_price + products[p].margin,
                                                                        margin: products[p].margin,
                                                                        discount: discount,
                                                                        discount_type: products[p].discount_type,
                                                                        discount_total: products[p].discount_total,
                                                                        tax: tax_info.tax,
                                                                        tax_rate: tax_info.rate,
                                                                        tax_info: tax,
                                                                        isProduct: true,
                                                                        isOrderItem: true,
                                                                    });
                        
                                                                    tax = [];
                                                                }
                                                                else {
                                                                    // console.log("ELSE Is Product ???")
                                                                    var quantity = parseInt(products[p].quantity);
                                                                    var unit_base_price = parseFloat(products[p].unit_base_price);
                                                                    var base = parseFloat(products[p].unit_base_price) * quantity;
                                                                    var amount_is_tax = products[p].amount_is_tax
                                                                    var discount = products[p].discount;
                                                                    // console.log("Discount prints here...", discount)
                                                                    //   if (discount.indexOf("%") >= 0) {
                                                                    //       // console.log("602 - Discount If Condition = " + discount)
                                                                    //       discount = parseFloat(discount);
                                                                    //       if (!isNaN(discount) && discount > 0) {
                                                                    //           var discount_total = amount * (discount / 100);
                                                                    //           amount = amount - parseFloat(discount_total.toFixed(2))
                        
                                                                    //       }
                                                                    //   }
                                                                    //   else {
                                                                    //       // console.log("610 - Discount ELSE Condition= " + discount)
                        
                        
                                                                    //       discount = parseFloat(discount);
                                                                    //       if (!isNaN(discount) && discount > 0) {
                                                                    //           amount = amount - parseFloat(discount.toFixed(2))
                        
                                                                    //       }
                                                                    //   }
                        
                        
                                                                    // console.log("Ammount after discount= " + amount)
                                                                    var amount_is_tax = "exclusive";
                        
                                                                    if (amount_is_tax == "exclusive") {
                                                                        var amount = base
                                                                        var tax_on_amount = amount;
                                                                        if (tax_rate.length > 0) {
                                                                            for (var r = 0; r < tax_rate.length; r++) {
                                                                                if (tax_rate[r].rate != tax_info.rate) {
                                                                                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                                                                                    amount = amount + t;
                                                                                    tax.push({
                                                                                        tax: tax_rate[r].tax,
                                                                                        rate: tax_rate[r].rate,
                                                                                        amount: parseFloat(t.toFixed(2))
                                                                                    })
                                                                                }
                                                                                else {
                                                                                    var t = tax_on_amount * (tax_info.rate / 100);
                                                                                    amount = amount + t;
                                                                                    tax.push({
                                                                                        tax: tax_info.tax, tax_rate: tax_info.rate,
                                                                                        rate: tax_info.rate,
                                                                                        amount: parseFloat(t.toFixed(2))
                                                                                    })
                                                                                }
                                                                            }
                                                                        }
                                                                        total = total + amount;
                                                                    }
                                                                    // console.log("Ammount after Tax= " + amount)
                        
                                                                    // if (products[p].amount_is_tax == "inclusive") {
                                                                    //     var x = (100 + tax_info.rate) / 100;
                                                                    //     var tax_on_amount = amount / x;
                                                                    //     if (tax_rate.length > 0) {
                                                                    //         for (var r = 0; r < tax_rate.length; r++) {
                                                                    //             if (tax_rate[r].rate != tax_info.rate) {
                                                                    //                 var t = tax_on_amount * (tax_rate[r].rate / 100);
                                                                    //                 base = base - t;
                                                                    //                 tax.push({
                                                                    //                     tax: tax_rate[r].tax,
                                                                    //                     rate: tax_rate[r].rate,
                                                                    //                     amount: parseFloat(t.toFixed(2))
                                                                    //                 });
                                                                    //             }
                                                                    //             else {
                                                                    //                 var t = amount - tax_on_amount;
                                                                    //                 base = base - t;
                                                                    //                 tax.push({
                                                                    //                     tax: tax_info.tax,
                                                                    //                     rate: tax_info.rate,
                                                                    //                     amount: parseFloat(t.toFixed(2))
                                                                    //                 });
                                                                    //             }
                                                                    //         }
                                                                    //     }
                                                                    //     total = total + amount;
                                                                    // }
                        
                                                                    var tax_details = {
                                                                        tax: tax_info.tax,
                                                                        rate: tax_info.rate,
                                                                        amount: total,
                                                                        // amount: amount,
                                                                        detail: tax
                                                                    }
                                                                    var lot = 1
                                                                    // console.log("Unit Base  Price  = " + (base / quantity))
                                                                    items.push({
                                                                        item_status: 'InComplete',
                                                                        product: null,
                                                                        part_no: products[p].part_no,
                                                                        hsn_sac: products[p].hsn_sac,
                                                                        part_category: products[p].part_category,    //OEM OR OES
                                                                        title: products[p].item,
                                                                        quantity: quantity,
                                                                        stock: quantity * lot,
                                                                        sku: products[p].sku,
                                                                        unit_base_price: base / quantity,
                                                                        unit_price: amount / quantity,
                                                                        unit: products[p].unit,
                                                                        lot: lot,
                                                                        mrp: products[p].mrp,
                                                                        rate: unit_base_price + products[p].margin,
                                                                        base: base,
                                                                        tax_amount: _.sumBy(tax, x => x.amount),
                                                                        amount: amount,
                                                                        models: products[p].models,
                                                                        amount_is_tax: amount_is_tax,
                                                                        sell_price: unit_base_price + products[p].margin,
                                                                        margin: products[p].margin,
                                                                        discount: discount,
                                                                        discount_type: products[p].discount_type,
                                                                        discount_total: products[p].discount_total,
                                                                        tax: tax_info.tax,
                                                                        tax_rate: tax_info.rate,
                                                                        tax_info: tax,
                                                                        isProduct: false,
                                                                        isOrderItem: true,
                        
                                                                    });
                        
                                                                    tax = [];
                                                                }
                                                            }
                                                            else {
                                                                res.status(422).json({
                                                                    responseCode: 422,
                                                                    responseMessage: "Please check tax",
                                                                    responseData: {}
                                                                });
                                                            }
                                                        }
                                                    }
                                                }
                        
                        
                                                var address = null;
                                                if (req.body.address) {
                                                    address = req.body.address;
                                                }
                                                var log_details = {
                                                    business: business,
                                                    activity_by: loggedInDetails.name,
                                                    activity: "Update",
                                                    remark: "Order To Bill Conversion",
                                                    created_at: new Date(),
                                                }
                                                var logs = []
                                                if (purchase.logs) {
                                                    logs = purchase.logs
                        
                                                } else {
                                                    logs.push(log_details)
                                                }
                                                var total = _.sumBy(items, x => x.amount);
                                                var discount_total = 0;
                                                var discount = 0
                                                var paid_total = total.toFixed(2)
                                                if (req.body.bill_discount > 0) {
                        
                                                    // console.log(" bILL Discount = " + req.body.bill_discount)
                                                    discount = parseFloat(req.body.bill_discount);
                                                    paid_total = total.toFixed(2)
                        
                                                    if (!isNaN(discount) && discount > 0) {
                                                        discount_total = total * (discount / 100);
                                                        paid_total = paid_total - parseFloat(discount_total.toFixed(2))
                                                    }
                        
                                                }
                                                var bill = {
                                                    due_date: due,
                                                    vendor: vendor._id,
                                                    items: items,
                                                    bill_discount: discount,
                                                    paid_total: paid_total,
                                                    total_discount: discount_total,
                                                    business: business,
                                                    total: paid_total,
                                                    subTotal: total.toFixed(2),
                                                    logs: logs,
                                                    // vendorOrder: vendorOrder._id,
                                                    updated_at: new Date(),
                                                };
                                                await Purchase.findOneAndUpdate({ _id: purchase._id }, { $set: bill }, { new: false }, async function (err, doc) {
                                                    if (err) {
                                                        res.status(422).json({
                                                            responseCode: 422,
                                                            responseMessage: "Server Error...",
                                                            responseData: err
                                                        });
                                                    }
                                                    else {
                                                        res.status(200).json({
                                                            responseCode: 200,
                                                            responseMessage: "Successfully Saved",
                                                            responseData: await Purchase.findById(req.body.bill).exec()
                                                        });
                                                    }
                                                });
                                            }
                                            else {
                                                res.status(400).json({
                                                    responseCode: 400,
                                                    responseMessage: "Items not found",
                                                    responseData: {}
                                                });
                                            }
                        */
            } else {
              res.status(400).json({
                responseCode: 400,
                responseMessage: "Vendor not found",
                responseData: {},
              });
            }
          } else {
            res.status(400).json({
              responseCode: 400,
              responseMessage: "Vendor Order not found",
              responseData: {},
            });
          }
        } else {
          res.status(400).json({
            responseCode: 400,
            responseMessage: "Send to seller Before Convert",
            responseData: {},
          });
        }
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Purchase not found",
          responseData: {},
        });
      }
    }
  }
);
router.post(
  "/purchaser/order/convert/bill/",
  xAccessToken.token,
  async function (req, res, next) {
    let reference_no = req.body.reference_no;
    var rules = {
      bill: "required",
    };
    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Bill is required",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var user = decoded.user;
      var business = req.headers["business"];
      var loggedInDetails = await User.findById(decoded.user).exec();
      var product = new Object();
      var result = [];
      var tax = [];
      var total = 0;
      var purchase = await Purchase.findById(req.body.bill).exec();
      if (purchase) {
        // console.log("VendorOrder Id  = " + purchase.vendorOrder)
        var vendorOrder = await VendorOrders.findById(
          purchase.vendorOrder
        ).exec();
        // var count = await VendorOrders.findById(purchase.vendorOrder).count().exec();
        // console.log("VendorOrder Id  = " + vendorOrder._id + " Count = " + count)
        // return res.json(vendorOrder)
        if (vendorOrder) {
          if (req.body.due) {
            var due = new Date(req.body.due).toISOString();
          } else {
            var due = null;
          }
          var vendor = await User.findById(vendorOrder.vendor).exec();
          var newDate = new Date();
          if (vendor) {
            var items = [];
            var products = vendorOrder.parts;
            if (products.length > 0) {
              // console.log("1057 products length = " + products.length)
              for (var p = 0; p < products.length; p++) {
                if (products[p].status == "confirmed") {
                  if (products[p].quantity != null) {
                    // console.log("Come inside business product finding condition....")
                    var product = await BusinessProduct.findOne({
                      $or: [
                        {
                          part_no: products[p].part_no,
                        },
                        { title: products[p].title },
                      ],
                      business: business,
                    }).exec();
                    var tax_info = await Tax.findOne({
                      tax: products[p].tax,
                    }).exec();
                    if (tax_info) {
                      var tax_rate = tax_info.detail;
                      if (product) {
                        // console.log("IF Is Product = " + product._id)
                        var quantity = parseInt(products[p].quantity);
                        var unit_base_price = parseFloat(
                          products[p].unit_base_price
                        );
                        var base =
                          parseFloat(products[p].unit_base_price) * quantity;
                        var amount_is_tax = products[p].amount_is_tax;

                        var discount = products[p].discount;
                        // console.log("Discount prints here...", discount)
                        /*  if (discount.indexOf("%") >= 0) {
                                                  // console.log("602 - Discount If Condition = " + discount)
                                                  discount = parseFloat(discount);
                                                  if (!isNaN(discount) && discount > 0) {
                                                      var discount_total = amount * (discount / 100);
                                                      amount = amount - parseFloat(discount_total.toFixed(2))
          
                                                  }
                                              }
                                              else {
                                                  // console.log("610 - Discount ELSE Condition= " + discount)
          
          
                                                  discount = parseFloat(discount);
                                                  if (!isNaN(discount) && discount > 0) {
                                                      amount = amount - parseFloat(discount.toFixed(2))
          
                                                  }
                                              }
          */

                        // console.log("Ammount after discount= " + amount)
                        var amount_is_tax = "exclusive";
                        if (amount_is_tax == "exclusive") {
                          var amount = base;
                          var tax_on_amount = amount;
                          if (tax_rate.length > 0) {
                            for (var r = 0; r < tax_rate.length; r++) {
                              if (tax_rate[r].rate != tax_info.rate) {
                                var t =
                                  tax_on_amount * (tax_rate[r].rate / 100);
                                amount = amount + t;
                                tax.push({
                                  tax: tax_rate[r].tax,
                                  rate: tax_rate[r].rate,
                                  amount: parseFloat(t.toFixed(2)),
                                });
                              } else {
                                var t = tax_on_amount * (tax_info.rate / 100);
                                amount = amount + t;
                                tax.push({
                                  tax: tax_info.tax,
                                  tax_rate: tax_info.rate,
                                  rate: tax_info.rate,
                                  amount: parseFloat(t.toFixed(2)),
                                });
                              }
                            }
                          }
                          total = total + amount;
                        }
                        // console.log("Ammount after Tax= " + amount)

                        // if (products[p].amount_is_tax == "inclusive") {
                        //     var x = (100 + tax_info.rate) / 100;
                        //     var tax_on_amount = amount / x;
                        //     if (tax_rate.length > 0) {
                        //         for (var r = 0; r < tax_rate.length; r++) {
                        //             if (tax_rate[r].rate != tax_info.rate) {
                        //                 var t = tax_on_amount * (tax_rate[r].rate / 100);
                        //                 base = base - t;
                        //                 tax.push({
                        //                     tax: tax_rate[r].tax,
                        //                     rate: tax_rate[r].rate,
                        //                     amount: parseFloat(t.toFixed(2))
                        //                 });
                        //             }
                        //             else {
                        //                 var t = amount - tax_on_amount;
                        //                 base = base - t;
                        //                 tax.push({
                        //                     tax: tax_info.tax,
                        //                     rate: tax_info.rate,
                        //                     amount: parseFloat(t.toFixed(2))
                        //                 });
                        //             }
                        //         }
                        //     }
                        //     total = total + amount;
                        // }

                        var tax_details = {
                          tax: tax_info.tax,
                          rate: tax_info.rate,
                          amount: total,
                          // amount: amount,
                          detail: tax,
                        };

                        // console.log("product.unit....", product.unit)
                        // console.log("Product " + product.product)
                        var lot = 1;
                        items.push({
                          item_status: "InComplete",
                          product: product._id,
                          part_no: products[p].part_no,
                          hsn_sac: product.hsn_sac,
                          part_category: product.part_category, //OEM OR OES
                          title: products[p].item,
                          quantity: quantity,
                          stock: quantity * lot,
                          sku: product.sku,
                          unit_base_price: products[p].unit_base_price,
                          unit_price: amount / quantity,
                          // purchase_price: purchase_price,
                          unit: product.unit,
                          lot: lot,
                          mrp: products[p].mrp,
                          rate: unit_base_price + products[p].margin,
                          base: base,
                          tax_amount: _.sumBy(tax, (x) => x.amount),
                          // tax_amount: tax_amount,
                          amount: amount,
                          models: products[p].models,
                          amount_is_tax: amount_is_tax,
                          sell_price: unit_base_price + products[p].margin,
                          margin: products[p].margin,
                          discount: discount,
                          discount_type: products[p].discount_type,
                          discount_total: products[p].discount_total,
                          tax: tax_info.tax,
                          tax_rate: tax_info.rate,
                          tax_info: tax,
                          isProduct: true,
                          isOrderItem: true,
                        });

                        tax = [];
                      } else {
                        // console.log("ELSE Is Product ???")
                        var quantity = parseInt(products[p].quantity);
                        var unit_base_price = parseFloat(
                          products[p].unit_base_price
                        );
                        var base =
                          parseFloat(products[p].unit_base_price) * quantity;
                        var amount_is_tax = products[p].amount_is_tax;
                        var discount = products[p].discount;
                        // console.log("Discount prints here...", discount)
                        /*  if (discount.indexOf("%") >= 0) {
                                                  // console.log("602 - Discount If Condition = " + discount)
                                                  discount = parseFloat(discount);
                                                  if (!isNaN(discount) && discount > 0) {
                                                      var discount_total = amount * (discount / 100);
                                                      amount = amount - parseFloat(discount_total.toFixed(2))
          
                                                  }
                                              }
                                              else {
                                                  // console.log("610 - Discount ELSE Condition= " + discount)
          
          
                                                  discount = parseFloat(discount);
                                                  if (!isNaN(discount) && discount > 0) {
                                                      amount = amount - parseFloat(discount.toFixed(2))
          
                                                  }
                                              }
          */

                        // console.log("Ammount after discount= " + amount)
                        var amount_is_tax = "exclusive";

                        if (amount_is_tax == "exclusive") {
                          var amount = base;
                          var tax_on_amount = amount;
                          if (tax_rate.length > 0) {
                            for (var r = 0; r < tax_rate.length; r++) {
                              if (tax_rate[r].rate != tax_info.rate) {
                                var t =
                                  tax_on_amount * (tax_rate[r].rate / 100);
                                amount = amount + t;
                                tax.push({
                                  tax: tax_rate[r].tax,
                                  rate: tax_rate[r].rate,
                                  amount: parseFloat(t.toFixed(2)),
                                });
                              } else {
                                var t = tax_on_amount * (tax_info.rate / 100);
                                amount = amount + t;
                                tax.push({
                                  tax: tax_info.tax,
                                  tax_rate: tax_info.rate,
                                  rate: tax_info.rate,
                                  amount: parseFloat(t.toFixed(2)),
                                });
                              }
                            }
                          }
                          total = total + amount;
                        }
                        // console.log("Ammount after Tax= " + amount)

                        // if (products[p].amount_is_tax == "inclusive") {
                        //     var x = (100 + tax_info.rate) / 100;
                        //     var tax_on_amount = amount / x;
                        //     if (tax_rate.length > 0) {
                        //         for (var r = 0; r < tax_rate.length; r++) {
                        //             if (tax_rate[r].rate != tax_info.rate) {
                        //                 var t = tax_on_amount * (tax_rate[r].rate / 100);
                        //                 base = base - t;
                        //                 tax.push({
                        //                     tax: tax_rate[r].tax,
                        //                     rate: tax_rate[r].rate,
                        //                     amount: parseFloat(t.toFixed(2))
                        //                 });
                        //             }
                        //             else {
                        //                 var t = amount - tax_on_amount;
                        //                 base = base - t;
                        //                 tax.push({
                        //                     tax: tax_info.tax,
                        //                     rate: tax_info.rate,
                        //                     amount: parseFloat(t.toFixed(2))
                        //                 });
                        //             }
                        //         }
                        //     }
                        //     total = total + amount;
                        // }

                        var tax_details = {
                          tax: tax_info.tax,
                          rate: tax_info.rate,
                          amount: total,
                          // amount: amount,
                          detail: tax,
                        };
                        var lot = 1;
                        // console.log("Unit Base  Price  = " + (base / quantity))
                        items.push({
                          item_status: "InComplete",
                          product: null,
                          part_no: products[p].part_no,
                          hsn_sac: products[p].hsn_sac,
                          part_category: products[p].part_category, //OEM OR OES
                          title: products[p].item,
                          quantity: quantity,
                          stock: quantity * lot,
                          sku: products[p].sku,
                          unit_base_price: base / quantity,
                          unit_price: amount / quantity,
                          unit: products[p].unit,
                          lot: lot,
                          mrp: products[p].mrp,
                          rate: unit_base_price + products[p].margin,
                          base: base,
                          tax_amount: _.sumBy(tax, (x) => x.amount),
                          amount: amount,
                          models: products[p].models,
                          amount_is_tax: amount_is_tax,
                          sell_price: unit_base_price + products[p].margin,
                          margin: products[p].margin,
                          discount: discount,
                          discount_type: products[p].discount_type,
                          discount_total: products[p].discount_total,
                          tax: tax_info.tax,
                          tax_rate: tax_info.rate,
                          tax_info: tax,
                          isProduct: false,
                          isOrderItem: true,
                        });

                        tax = [];
                      }
                    } else {
                      res.status(422).json({
                        responseCode: 422,
                        responseMessage: "Please check tax",
                        responseData: {},
                      });
                    }
                  }
                }
              }

              var address = null;
              if (req.body.address) {
                address = req.body.address;
              }
              var log_details = {
                business: business,
                activity_by: loggedInDetails.name,
                activity: "Update",
                remark: "Order To Bill Conversion",
                created_at: new Date(),
              };
              var logs = [];
              if (purchase.logs) {
                logs = purchase.logs;
              } else {
                logs.push(log_details);
              }
              var total = _.sumBy(items, (x) => x.amount);
              var discount_total = 0;
              var discount = 0;
              var paid_total = total.toFixed(2);
              if (req.body.bill_discount > 0) {
                // console.log(" bILL Discount = " + req.body.bill_discount)
                discount = parseFloat(req.body.bill_discount);
                paid_total = total.toFixed(2);

                if (!isNaN(discount) && discount > 0) {
                  discount_total = total * (discount / 100);
                  paid_total =
                    paid_total - parseFloat(discount_total.toFixed(2));
                }
              }
              var bill = {
                due_date: due,
                vendor: vendor._id,
                items: items,
                bill_discount: discount,
                paid_total: paid_total,
                total_discount: discount_total,
                business: business,
                total: paid_total,
                subTotal: total.toFixed(2),
                logs: logs,
                // vendorOrder: vendorOrder._id,
                updated_at: new Date(),
              };
              await Purchase.findOneAndUpdate(
                { _id: purchase._id },
                { $set: bill },
                { new: false },
                async function (err, doc) {
                  if (err) {
                    res.status(422).json({
                      responseCode: 422,
                      responseMessage: "Server Error...",
                      responseData: err,
                    });
                  } else {
                    res.status(200).json({
                      responseCode: 200,
                      responseMessage: "Successfully Saved",
                      responseData: await Purchase.findById(
                        req.body.bill
                      ).exec(),
                    });
                  }
                }
              );
            } else {
              res.status(400).json({
                responseCode: 400,
                responseMessage: "Items not found",
                responseData: {},
              });
            }
          } else {
            res.status(400).json({
              responseCode: 400,
              responseMessage: "Vendor not found",
              responseData: {},
            });
          }
        } else {
          res.status(400).json({
            responseCode: 400,
            responseMessage: "Vendor Order not found",
            responseData: {},
          });
        }
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Purchase not found",
          responseData: {},
        });
      }
    }
  }
);

router.put(
  "/purchase/bill/attach",
  xAccessToken.token,
  async function (req, res, next) {
    businessFunctions.logs(
      "INFO: /purchase/bill/attach Api Called from 3.0.js," +
        " " +
        "Request Headers:" +
        JSON.stringify(req.headers) +
        ", " +
        "Request Query:" +
        JSON.stringify(req.query)
    );

    var token = req.headers["x-access-token"];
    var business = req.headers["business"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var loggedInDetails = await User.findById(decoded.user).exec();

    var file_type = "";
    // console.log("Bill Id = " + req.body.purchase)
    if (
      Log_Level == 4 ||
      Log_Level == 6 ||
      Log_Level == 8 ||
      Log_Level == 10 ||
      Log_Level == 0
    ) {
      businessFunctions.logs("DEBUG: Storing the file on the S3 Bucket");
    }
    var upload = multer({
      storage: multerS3({
        s3: s3,
        bucket: config.BUCKET_NAME + "/PurchaseBills",
        acl: "public-read",
        contentType: multerS3.AUTO_CONTENT_TYPE,
        // contentDisposition: 'attachment',
        key: function (req, file, cb) {
          let extArray = file.mimetype.split("/");
          let extension = extArray[extArray.length - 1];

          var filename = uuidv1() + "." + extension;
          if (
            extension == "png" ||
            extension == "jpg" ||
            extension == "jpeg" ||
            extension == "gif" ||
            extension == "pdf"
          ) {
            cb(null, filename);
          } else {
            var params = {
              Bucket: config.BUCKET_NAME + "/PurchaseBills",
              Key: filename,
            };
            s3.deleteObject(params, async function (err, data) {
              var json = {
                responseCode: 422,
                responseMessage: "Invalid extension",
                responseData: {},
              };
              res.status(422).json(json);
            });
          }
        },
      }),
    }).array("media", 1);

    upload(req, res, async function (error) {
      if (error) {
        console.log("Error 3204");
        var json = {
          responseCode: 400,
          responseMessage: "Error occured",
          responseData: {},
        };
        res.status(400).json(json);
      }

      if (req.files.length == 0) {
        console.log("req.files.length = " + req.files.length);

        var json = {
          responseCode: 400,
          responseMessage: "Media is required",
          responseData: {},
        };
        res.status(400).json(json);
      } else {
        var rules = {
          purchase: "required",
        };

        var validation = new Validator(req.body, rules);

        if (validation.fails()) {
          res.status(422).json({
            responseCode: 422,
            responseMessage: "Purchase is required",
            responseData: {
              res: validation.errors.all(),
            },
          });
        } else {
          // originalName
          var purchase = await Purchase.findById(req.body.purchase).exec();
          if (purchase) {
            var log_details = {
              business: business,
              activity_by: loggedInDetails.name,
              activity: "Bill Copy Attach",
              // time: new Date().getTime.toLocaleTimeString(),
              remark: "Bill Copy Attached",
              created_at: new Date(),
            };
            var logs = [];
            if (purchase.logs) {
              logs = purchase.logs;
              logs.push(log_details);
            } else {
              logs.push(log_details);
            }
            // console.log("File Name = " + req.body.originalName)
            var data = {
              attachment:
                "https://s3.ap-south-1.amazonaws.com/" +
                config.BUCKET_NAME +
                "/PurchaseBills/" +
                req.files[0].key,
              file_name: req.body.originalName,
              logs: logs,
              updated_at: new Date(),
            };
            // console.log("Bill Id Update  = " + req.body.purchase)
            await Purchase.findOneAndUpdate(
              { _id: req.body.purchase },
              { $set: data },
              { new: false },
              async function (err, doc) {
                if (err) {
                  res.status(422).json({
                    responseCode: 422,
                    responseMessage: "Server Error",
                    responseData: err,
                  });
                } else {
                  // var updated = await User.findOne({ _id: business }).exec();
                  res.status(200).json({
                    responseCode: 200,
                    responseMessage: "Bill Attached",
                    responseData: { name: doc.file_name },
                  });
                  if (
                    Log_Level == 3 ||
                    Log_Level == 7 ||
                    Log_Level == 9 ||
                    Log_Level == 10 ||
                    Log_Level == 0
                  ) {
                    businessFunctions.logs(
                      "INFO: Bill Attached Successfully, PurchaseId:" +
                        req.body.purchase +
                        ", Bill Attach Name:" +
                        doc.file_name
                    );
                  }
                }
              }
            );
          }
        }
      }
    });
  }
);
router.put(
  "/bill/item/return",
  xAccessToken.token,
  async function (req, res, next) {

    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var loggedInDetails = await User.findById(decoded.user).exec();

    var business = req.headers["business"];
    var product = new Object();
    var result = [];
    var tax = [];
    var total = 0;
    var item_index = req.body.item_index;
    // console.log("Bill = " + req.body.bill)
    // console.log("item_index = " + item_index)
    // console.log("Business Id = " + business)
    var purchase = await Purchase.findById(req.body.bill).exec();
    let vendor = await User.findOne({ _id: purchase.vendor }).exec();

    var loggedInDetails = await User.findById(user).exec();
    if (purchase) {
      // var checkStock = await q.all(businessFunctions.checkStock(purchase._id, purchase.items, business));
      // console.log("checkStock= " + checkStock)
      // if (checkStock) {
      var products = purchase.items;
      // console.log("products[item_index] = " + products[item_index])
      var items = products[item_index];
      var quantity = parseFloat(req.body.quantity);
      if (quantity > 0) {
        // var quantity = 7
        // return res.json({ "Items ": items })
        var removed = false;
        if (items.item_status != "InCompleted") {
          removed = await q.all(
            businessFunctions.stockRemoveSingleItem(
              purchase._id,
              items,
              quantity,
              business,
              vendor,
              loggedInDetails
            )
          );
        }

        // return res.status(200).json({
        //     responseCode: 400,
        //     responseMessage: "SKU Stockd ",
        //     responseData: removed
        // });
        // var removed = true
        // console.log("Removed = " + removed)

        if (removed) {
          // products[item_index].item_status = "InCompleted"
          // console.log("Remove Quantity = ", quantity)
          // console.log("Stock Previus = " + products[item_index].stock)
          var stock = parseFloat(products[item_index].stock);
          // var final = stock - quantity;
          var finalStock = stock - quantity;
          // console.log("Final  = ", finalStock)
          // console.log("Final Stock = ", parseFloat(products[item_index].stock) - parseFloat(quantity))
          var status = "Complete";
          if (finalStock == 0) {
            products[item_index].item_status = "InCompleted";
            // products[item_index].unit_base_price
            status = "Incomplete";
          }
          var unit_tax =
            products[item_index].unit_price -
            products[item_index].unit_base_price;
          var tax_amount = unit_tax * finalStock;
          var base_amount = products[item_index].unit_base_price * finalStock;
          products[item_index].stock = finalStock;
          products[item_index].quantity = finalStock;
          products[item_index].amount =
            products[item_index].unit_price * finalStock;
          products[item_index].base = base_amount;
          products[item_index].tax_amount = tax_amount;

          var total_amount = base_amount;

          var tax_info = await Tax.findOne({
            tax: products[item_index].tax,
          }).exec();
          // return res.json(tax_info)
          if (tax_info) {
            if (products[item_index].amount_is_tax == "exclusive") {
              var t = 0;
              var tax_on_amount = base_amount;
              var tax_rate = tax_info.detail;
              if (tax_rate.length > 0) {
                for (var r = 0; r < tax_rate.length; r++) {
                  if (tax_rate[r].rate != tax_info.rate) {
                    t = tax_on_amount * (tax_rate[r].rate / 100);
                    total_amount = total_amount + t;
                    tax.push({
                      tax: tax_rate[r].tax,
                      rate: tax_rate[r].rate,
                      amount: parseFloat(t.toFixed(2)),
                    });
                  } else {
                    t = tax_on_amount * (tax_info.rate / 100);
                    total_amount = total_amount + t;
                    tax.push({
                      tax: tax_info.tax,
                      tax_rate: tax_info.rate,
                      rate: tax_info.rate,
                      amount: parseFloat(t.toFixed(2)),
                    });
                  }
                }
              }
            }
            var tax_details = {
              // tax: tax_info.tax,
              // rate: tax_info.rate,
              // amount: total,
              // amount: total_amount,
              detail: tax,
            };
          }
          products[item_index].tax_info = tax;
          await purchase.markModified("items");
          purchase.total =
            purchase.total - products[item_index].unit_price * quantity;
          await purchase.markModified("total");
          await purchase
            .save()
            .then(async function (ress) {
              // console.log("Item Saved = " + p)
              // await businessFunctions.stockRemove(purchase._id, items, business);
              // console.log("Data saved...")
            })
            .catch((err) => {
              // console.log("Error...", err)
            });

          // var loggedInDetails = await User.findById(decoded.user).exec();
          var log_details = {
            business: business,
            activity_by: loggedInDetails.name,
            activity: "Bill Item  Returned",
            // time: new Date().getTime.toLocaleTimeString(),
            remark: req.body.remark,
            // remark: products[item_index].title + " returned of Amount = " + products[item_index].amount,
            created_at: new Date(),
          };
          var logs = [];
          if (purchase.logs) {
            logs = purchase.logs;
            logs.push(log_details);
          } else {
            logs.push(log_details);
          }

          await Purchase.findOneAndUpdate(
            { _id: purchase._id },
            { $set: { status: status, logs: logs, updated_at: new Date() } },
            { new: true },
            async function (err, doc) {
              //Signel item returnd entry
              var transactionData = {
                user: doc.vendor,
                business: doc.business,
                status: "Purchase",
                type: "Purchase",
                paid_by: "-",
                activity: "Purchase",
                source: doc._id,
                bill_id: doc.reference_no,
                bill_amount: doc.total,
                transaction_amount: doc.total,
                balance: doc.total,
                total: doc.total,
                paid_total: doc.total,
                due: 0,
                payment_status: "Pending",
                payment_mode: "-",
                received_by: loggedInDetails.name,
                transaction_id: "-",
                transaction_date: new Date(),
                transaction_status: "Success",
                transaction_response: "-",
                transaction_type: "Purchase Returned",
              };
              q.all(businessFunctions.addTransaction(transactionData));

              res.status(200).json({
                responseCode: 200,
                responseMessage: "Updated...",
                responseData: doc,
              });
              if (
                Log_Level == 3 ||
                Log_Level == 7 ||
                Log_Level == 9 ||
                Log_Level == 10 ||
                Log_Level == 0
              ) {
                businessFunctions.logs(
                  "INFO: Item Successfully Returned, User:" +
                    loggedInDetails.name
                );
              }
            }
          );
        } else {
          if (
            Log_Level == 2 ||
            Log_Level == 5 ||
            Log_Level == 8 ||
            Log_Level == 9 ||
            Log_Level == 0
          ) {
            businessFunctions.logs(
              "WARNING:Insufficient Qantity in stock to retrun, BillId:" +
                req.body.bill
            );
          }
          res.status(200).json({
            responseCode: 400,
            responseMessage: "Insufficient Qantity in stock to retrun",
            responseData: {},
          });
        }
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Quantity not to be Zero",
          responseData: {},
        });
      }
      // }
      // else {
      //     res.status(200).json({
      //         responseCode: 400,
      //         responseMessage: "Insufficient items in stock ",
      //         responseData: {}
      //     });
      // }
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Purchase not found",
        responseData: {},
      });
    }
  }
);

//Delete Bill & return all items
router.put("/bill/delete", xAccessToken.token, async function (req, res, next) {
  businessFunctions.logs(
    "INFO: /bill/delete Api Called from 3.0.js," +
      " " +
      "Request Headers:" +
      JSON.stringify(req.headers) +
      ", " +
      "Request Query:" +
      JSON.stringify(req.query)
  );

  var rules = {
    query: "required",
  };

  var validation = new Validator(req.query, rules);

  if (validation.fails()) {
    if (
      Log_Level == 1 ||
      Log_Level == 5 ||
      Log_Level == 6 ||
      Log_Level == 7 ||
      Log_Level == 0
    ) {
      businessFunctions.logs(
        "ERROR: Validation failed, BillId is required to Delete Bill."
      );
    }
    res.status(422).json({
      responseCode: 422,
      responseMessage: "Error",
      responseData: {
        res: validation.errors.all(),
      },
    });
  } else {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers["business"];
    var product = new Object();
    var result = [];
    var tax = [];
    var total = 0;
    // var purchase = await Purchase.findOne({ _id: req.query.query, status: "Incomplete" }).exec();
    var purchase = await Purchase.findOne({ _id: req.query.query }).exec();
    let vendor = await User.findOne({ _id: purchase.vendor }).exec();
    var loggedInDetails = await User.findById(user).exec();
    if (purchase) {
      var checkStock = await q.all(
        businessFunctions.checkStock(purchase._id, purchase.items, business)
      );
      // console.log("checkStock= " + checkStock)
      if (checkStock) {
        var products = purchase.items;
        for (var p = 0; p < products.length; p++) {
          // var removed =
          if (products[p].item_status == "Completed") {
            var removed = await q.all(
              businessFunctions.purchaseStockRemove(
                purchase._id,
                products[p],
                business,
                vendor,
                loggedInDetails
              )
            );
            if (removed) {
              products[p].item_status = "InCompleted";
              await purchase.markModified("items");
              await purchase
                .save()
                .then(async function (ress) {
                  // console.log("Item Saved = " + p)
                  // await businessFunctions.stockRemove(purchase._id, items, business);
                  // console.log("Data saved...")
                })
                .catch((err) => {
                  // console.log("Error...", err)
                });
            } else {
              // console.log("This item is not availale = " + products.part_no)
            }
            // console.log("Incompte Item Not need to Remove from Stock" + products[p].part_no)
          }
        }
        // var loggedInDetails = await User.findById(decoded.user).exec();
        var log_details = {
          business: business,
          activity_by: loggedInDetails.name,
          activity: "Deleted",
          // time: new Date().getTime.toLocaleTimeString(),
          remark: "",
          created_at: new Date(),
        };
        var logs = [];
        if (purchase.logs) {
          logs = purchase.logs;
          logs.push(log_details);
        } else {
          logs.push(log_details);
        }
        if (
          Log_Level == 4 ||
          Log_Level == 6 ||
          Log_Level == 8 ||
          Log_Level == 10 ||
          Log_Level == 0
        ) {
          businessFunctions.logs(
            "DEBUG: Updating the bill status as Deleted, BillId:" +
              purchase._id +
              ", User:" +
              loggedInDetails
          );
        }
        await Purchase.findOneAndUpdate(
          { _id: purchase._id },
          { $set: { status: "Deleted", logs: logs, updated_at: new Date() } },
          { new: true },
          async function (err, doc) {
            var transactionData = {
              user: doc.vendor,
              business: doc.business,
              status: "Purchase Deleted",
              type: "Purchase Cancelled",
              paid_by: "-",
              activity: "Purchase Deleted",
              source: doc._id,
              bill_id: doc.reference_no,
              bill_amount: doc.total.toFixed(2),
              transaction_amount: doc.total.toFixed(2),
              balance: doc.total.toFixed(2),
              total: doc.total.toFixed(2),
              paid_total: doc.total.toFixed(2),
              due: 0,
              payment_status: "Pending",
              payment_mode: "-",
              received_by: loggedInDetails.name,
              transaction_id: "-",
              transaction_date: new Date(),
              transaction_status: "Success",
              transaction_response: "-",
              transaction_type: "Purchase Cancelled",
            };
            q.all(businessFunctions.addTransaction(transactionData));
            res.status(200).json({
              responseCode: 200,
              responseMessage: "Successfully Deleted...",
              responseData: {},
            });
            if (
              Log_Level == 3 ||
              Log_Level == 7 ||
              Log_Level == 9 ||
              Log_Level == 10 ||
              Log_Level == 0
            ) {
              businessFunctions.logs(
                "INFO: Bill Successfully Deleted, BillId:" +
                  req.query.query +
                  ", User:" +
                  loggedInDetails.name
              );
            }
          }
        );
      } else {
        if (
          Log_Level == 2 ||
          Log_Level == 5 ||
          Log_Level == 8 ||
          Log_Level == 9 ||
          Log_Level == 0
        ) {
          businessFunctions.logs(
            "WARNING: Insufficient Qantity in stock for deleting the Bill, BillId:" +
              req.query.query +
              ", User:" +
              loggedInDetails.name
          );
        }
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Insufficient Qantity in stock ",
          responseData: {},
        });
      }
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Purchase not found",
        responseData: {},
      });
    }
    // if (purchase) {
    //     Purchase.findOneAndUpdate({ _id: purchase._id }, { $set: { status: "Deleted" } }, { new: false }, async function (err, doc) {
    //         if (err) {
    //             res.status(422).json({
    //                 responseCode: 422,
    //                 responseMessage: "Server Error...",
    //                 responseData: err
    //             });
    //         }
    //         else {
    //             res.status(200).json({
    //                 responseCode: 200,
    //                 responseMessage: "Removed Successfully",
    //                 responseData: {}
    //             });
    //         }
    //     });
    // }
    // else {
    //     res.status(400).json({
    //         responseCode: 400,
    //         responseMessage: "Purchase not found",
    //         responseData: {}
    //     });
    // }
  }
});

router.put(
  "/purcahse/convert/bill",
  xAccessToken.token,
  async function (req, res, next) {
    businessFunctions.logs(
      "INFO: /purcahse/convert/bill Api Called from 3.0.js," +
        " " +
        "Request Headers:" +
        JSON.stringify(req.headers) +
        ", " +
        "Request Body:" +
        JSON.stringify(req.body)
    );

    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers["business"];
    var product = new Object();
    var result = [];
    var tax = [];
    var total = 0;
    // console.log("Bill No To Complete = " + req.body.bill)
    if (
      Log_Level == 4 ||
      Log_Level == 6 ||
      Log_Level == 8 ||
      Log_Level == 10 ||
      Log_Level == 0
    ) {
      businessFunctions.logs(
        "DEBUG: Fatching Purchase Details, BillId:" + req.body.bill
      );
    }
    var purchase = await Purchase.findOne({
      _id: req.body.bill,
      status: "Completed",
    }).exec();
    var loggedInDetails = await User.findById(user).exec();
    if (purchase) {
      var transactionData = {
        user: purchase.vendor,
        business: purchase.business,
        status: "Purchase",
        type: "Purchase",
        paid_by: "-",
        activity: "Purchase",
        source: purchase._id,
        bill_id: purchase.reference_no,
        bill_amount: purchase.total,
        transaction_amount: purchase.total,
        balance: purchase.total,
        total: purchase.total,
        paid_total: purchase.total,
        due: 0,
        payment_status: "Pending",
        payment_mode: "-",
        received_by: loggedInDetails.name,
        transaction_id: "-",
        transaction_date: new Date(),
        transaction_status: "Success",
        transaction_response: "-",
        transaction_type: "Purchase",
      };
      if (
        Log_Level == 4 ||
        Log_Level == 6 ||
        Log_Level == 8 ||
        Log_Level == 10 ||
        Log_Level == 0
      ) {
        businessFunctions.logs(
          "DEBUG: businessFunctions.addTransaction(transactionData) function Called."
        );
      }
      var vaild = q.all(businessFunctions.addTransaction(transactionData));
      // console.log("Return = " + vaild)
      res.status(200).json({
        responseCode: 200,
        responseMessage: "Bill Successfully converted.",
        responseData: {},
      });
      if (
        Log_Level == 3 ||
        Log_Level == 7 ||
        Log_Level == 9 ||
        Log_Level == 10 ||
        Log_Level == 0
      ) {
        businessFunctions.logs(
          "INFO: Bill Details Updated Successfully, PurchaseId:" +
            req.body.bill +
            ", User:" +
            loggedInDetails.name
        );
      }
      // });
    } else {
      if (
        Log_Level == 2 ||
        Log_Level == 5 ||
        Log_Level == 8 ||
        Log_Level == 9 ||
        Log_Level == 0
      ) {
        businessFunctions.logs(
          "WARNING: Purchase not found for the billId:" +
            req.body.bill +
            ", User:" +
            loggedInDetails.name
        );
      }
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Purchase not found",
        responseData: {},
      });
    }
  }
);

router.put(
  "/bill/to/salesOrder/items/add",
  xAccessToken.token,
  async function (req, res, next) {
    var business = req.headers["business"];
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var date = new Date();
    var loggedInDetails = decoded.user;
    var items = [];
    var data = [];
    var convenience_charges = 0;
    var discount = 0;
    var total = 0;
    var orderItem = {};
    var order = await Order.findById(req.body.order).exec();
    var purchase = await Purchase.findById(req.body.bill).exec();
    var loggedInDetails = await User.findById(decoded.user).exec();

    if (order && purchase) {
      var user = await User.findById(order.user).exec();

      // purchase.items[p].item_status != "Completed"
      var items = purchase.items;
      // console.log("4300 Purchase Item Length = " + items.length)
      for (var p = 0; p < items.length; p++) {
        // purchase.items[p].item_status != "Completed"
        // console.log("4303 items[p].item_status = " + items[p].item_status + " ,Iteration = " + p)
        if (items[p].item_status == "Completed") {
          var products = items[p];
          // console.log("4308 items[p].part_no = " + items[p].part_no)
          if (products.part_no != "") {
            var businessOrder = await BusinessOrder.findOne({
              order: order._id,
            }).exec();
            var log = {
              status: "Confirmed",
              type: "Counter",
              activity: "Confirmed",
              user: loggedInDetails._id,
              name: loggedInDetails.name,
              created_at: date,
              updated_at: date,
            };
            var id = mongoose.Types.ObjectId();
            if (products.id != null) {
              id = products.id;
            }

            // console.log("4325  Iteration= " + p)

            if (products) {
              // console.log("Products.products = " + products.product)
              var tax_info = await Tax.findOne({ tax: products.tax }).exec();
              var floor = Math.floor(products.unit_price);
              var ceil = Math.ceil(products.unit_price);
              console.log("Floor " + floor);
              console.log("ceil " + ceil);
              console.log("ceil " + ceil);

              // Math.round(5.95)
              // console.log("purchase_price " + req.body.purchase_price)
              // 'price.purchase_price': { $gte: floor, $lte: ceil },

              // .sort({ updated_at: -1 })
              var part_no = products.part_no;
              part_no = part_no.replace(/,/g, ", ");
              part_no = part_no.toUpperCase();
              var checkProducut = await BusinessProduct.findOne({
                purchases: purchase._id,
                part_no: part_no,
                "price.purchase_price": { $gte: floor, $lte: ceil },
                business: business,
              })
                .sort({ updated_at: -1 })
                .exec();
              // if (businessProduct.price.rate == product.rate) {
              if (checkProducut) {
                // console.log("checkProducut" + checkProducut.part_no)
                var tax = [];
                products.product = checkProducut._id;
                var rate = products.rate;
                var amount = products.rate * products.quantity;
                var tax_rate = tax_info.detail;
                var discount_total = 0;
                var base = amount;

                var discount = products.discount;

                // if (discount.indexOf("%") >= 0) {
                //     discount = parseFloat(discount);
                //     if (!isNaN(discount) && discount > 0) {
                //         discount_total = amount * (discount / 100);
                //         amount = amount - parseFloat(discount_total.toFixed(2))
                //     }
                // }
                // else {
                //     if (discount == "") {
                //         discount = "0"
                //     }

                //     discount_total = parseFloat(discount);

                //     if (!isNaN(discount_total) && discount_total > 0) {
                //         amount = amount - parseFloat(discount_total.toFixed(2))
                //     }
                // }
                var discount = "0";
                var discount_total = parseFloat(discount);
                if (products.amount_is_tax == "exclusive") {
                  var tax_on_amount = amount;
                  if (tax_rate.length > 0) {
                    for (var r = 0; r < tax_rate.length; r++) {
                      if (tax_rate[r].rate != tax_info.rate) {
                        var t = tax_on_amount * (tax_rate[r].rate / 100);
                        amount = amount + t;
                        tax.push({
                          tax: tax_rate[r].tax,
                          rate: tax_rate[r].rate,
                          amount: parseFloat(t.toFixed(2)),
                        });
                      } else {
                        var t = tax_on_amount * (tax_info.rate / 100);
                        amount = amount + t;
                        tax.push({
                          tax: tax_info.tax,
                          tax_rate: tax_info.rate,
                          rate: tax_info.rate,
                          amount: parseFloat(t.toFixed(2)),
                        });
                      }
                    }
                  }
                }

                if (products.amount_is_tax == "inclusive") {
                  var x = (100 + tax_info.rate) / 100;
                  var tax_on_amount = amount / x;
                  if (tax_rate.length > 0) {
                    for (var r = 0; r < tax_rate.length; r++) {
                      if (tax_rate[r].rate != tax_info.rate) {
                        var t = tax_on_amount * (tax_rate[r].rate / 100);
                        base = base - t;
                        tax.push({
                          tax: tax_rate[r].tax,
                          rate: tax_rate[r].rate,
                          amount: parseFloat(t.toFixed(2)),
                        });
                      } else {
                        var t = amount - tax_on_amount;
                        base = base - t;
                        tax.push({
                          tax: tax_info.tax,
                          rate: tax_info.rate,
                          amount: parseFloat(t.toFixed(2)),
                        });
                      }
                    }
                  }
                  //base = base - discount_total;
                }

                var tax_details = {
                  tax: tax_info.tax,
                  rate: tax_info.rate,
                  amount: total,
                  detail: tax,
                };

                var orderItem = {
                  _id: id,
                  order: order._id,
                  product: checkProducut._id,
                  category: checkProducut.category,
                  _category: checkProducut._category,
                  subcategory: checkProducut.subcategory,
                  _subcategory: checkProducut._subcategory,
                  product_brand: checkProducut.product_brand,
                  _brand: checkProducut.product_brand,
                  // _brand: "",
                  product_model: null,
                  _model: checkProducut.product_model,
                  source: checkProducut.source,
                  part_no: products.part_no,
                  hsn_sac: products.hsn_sac,
                  unit: products.unit,
                  title: products.title,
                  quantity: products.quantity,
                  unit: products.unit,
                  sku: products.sku,
                  mrp: products.selling_price,
                  selling_price: products.sell_price,
                  rate: products.rate,
                  base: parseFloat(base.toFixed(2)),
                  discount: products.discount,
                  discount_total: parseFloat(discount_total.toFixed(2)),
                  amount_is_tax: products.amount_is_tax,
                  tax_amount: parseFloat(
                    _.sumBy(tax, (x) => x.amount).toFixed(2)
                  ),
                  amount: parseFloat(amount.toFixed(2)),
                  tax: tax_info.tax,
                  tax_rate: tax_info.rate,
                  tax_info: tax,
                  issued: false,
                  added_by_customer: false,
                  delivery_date: businessOrder.delivery_date,
                  tracking_no:
                    Math.round(+new Date() / 1000) +
                    "-" +
                    Math.ceil(Math.random() * 90000 + 10000),
                  business: business,
                  created_at: new Date(),
                  updated_at: new Date(),
                };

                await OrderLine.create(orderItem).then(async function (ol) {
                  var issued = await q.all(
                    businessFunctions.salesPartIssue(
                      ol,
                      business,
                      user,
                      loggedInDetails
                    )
                  );
                  if (issued) {
                    console.log("Issuesd True...");
                    await OrderLine.findOneAndUpdate(
                      { _id: ol._id },
                      { $set: { issued: issued, updated_at: new Date() } },
                      { new: false },
                      async function (err, doc) {}
                    );
                  }
                });
              } else {
                console.log("CheckProduct Not Found");
              }
            } else {
              console.log("Product Not Found");
            }
          } else {
            console.log("Incomplete Item  Detatils");
            // res.status(200).json({
            //     responseCode: 200,
            //     responseMessage: "Add New Item",
            //     responseData: {}
            // });
          }
        } else {
          console.log("Incomplete Item");
        }
      }

      // console.log("Value of P = " + p)
      var orderItems = await OrderLine.find({
        order: order._id,
        issued: true,
        business: business,
        status: { $nin: ["Cancelled"] },
      }).exec();
      if (businessOrder.payment.convenience_charges) {
        convenience_charges = Math.ceil(
          businessOrder.payment.convenience_charges
        );
      }
      var discount = parseFloat(
        _.sumBy(orderItems, (x) => x.discount_total).toFixed(2)
      );
      var amount = parseFloat(_.sumBy(orderItems, (x) => x.amount).toFixed(2));
      var total = amount + discount + convenience_charges;

      var transaction_log = await q.all(
        fun.getOrderTransaction(order._id, business)
      );
      var paid_total = transaction_log.paid_total;

      var data = {
        updated_at: new Date(),
        "payment.paid_total": paid_total,
        "payment.amount": parseFloat(amount.toFixed(2)),
        "payment.discount_total": parseFloat(discount.toFixed(2)),
        "payment.total": parseFloat(total.toFixed(2)),
        "payment.order_discount": parseFloat(order.payment.order_discount),
        due: {
          due:
            Math.ceil(amount) +
            convenience_charges -
            paid_total -
            parseFloat(order.payment.order_discount),
        },
      };

      // console.log("Issued = " + issued)

      await Order.findOneAndUpdate(
        { _id: order._id },
        { $set: data },
        { new: false },
        async function (err, doc) {
          if (err) {
            // res.status(422).json({
            //     responseCode: 422,
            //     responseMessage: "Server Error",
            //     responseData: err
            // });
            console.log("Server Error");
          } else {
            await BusinessOrder.findOneAndUpdate(
              { order: order._id, business: business },
              { $set: data },
              { new: false },
              async function (err, doc) {
                if (err) {
                  // res.status(422).json({
                  //     responseCode: 422,
                  //     responseMessage: "Server Error",
                  //     responseData: err
                  // });
                  console.log("Server Error");
                } else {
                  await BusinessOrder.find({
                    order: businessOrder.order,
                    business: business,
                  })
                    .populate({
                      path: "order",
                      populate: [
                        {
                          path: "user",
                          select:
                            "name contact_no username email account_info ",
                        },
                        {
                          path: "car",
                          select:
                            "title variant registration_no _automaker _model",
                        },
                        { path: "address" },
                      ],
                    })
                    .cursor()
                    .eachAsync(async (p) => {
                      var has_invoice = false;
                      var invoices = await OrderInvoice.find({
                        order: p.order._id,
                        business: business,
                      })
                        .select("status invoice_no")
                        .exec();

                      if (invoices.length > 0) {
                        has_invoice = true;
                      }
                      var activity = {
                        business: business,
                        activity_by: loggedInDetails.name,
                        activity:
                          "Items added from Purchase Bill ( " +
                          purchase.reference_no +
                          " )",
                        remark: "Sales Order",
                        created_at: new Date(),
                      };
                      businessFunctions.salesOrderLogs(order._id, activity);
                      // console.log("Item Added Successfully")
                      res.status(200).json({
                        responseCode: 200,
                        responseMessage: "success",
                        responseData: {},
                      });
                      // res.status(200).json({
                      //     responseCode: 200,
                      //     responseMessage: "success",
                      //     responseData:{}
                      // });
                    });
                }
              }
            );
          }
        }
      );
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Order/Bill not found",
        responseData: {},
      });
    }
  }
);

router.put(
  "/bill/revert/",
  xAccessToken.token,
  async function (req, res, next) {
    businessFunctions.logs(
      "INFO: /bill/revert/ Api Called from 3.0.js," +
        " " +
        "Request Headers:" +
        JSON.stringify(req.headers) +
        ", " +
        "Request Body:" +
        JSON.stringify(req.body)
    );

    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var loggedInDetails = await User.findById(decoded.user).exec();

    var business = req.headers["business"];
    var product = new Object();
    var result = [];
    var tax = [];
    var total = 0;
    if (
      Log_Level == 4 ||
      Log_Level == 6 ||
      Log_Level == 8 ||
      Log_Level == 10 ||
      Log_Level == 0
    ) {
      businessFunctions.logs(
        "DEBUG: Fatching Purchase Bill Details, PurchaseId:" +
          req.body.bill +
          ", User:" +
          loggedInDetails.name
      );
    }
    var purchase = await Purchase.findById(req.body.bill).exec();
    let vendor = await User.findOne({
      _id: mongoose.Types.ObjectId(purchase.vendor),
    }).exec();
    var loggedInDetails = await User.findById(user).exec();

    if (purchase) {
      if (
        Log_Level == 4 ||
        Log_Level == 6 ||
        Log_Level == 8 ||
        Log_Level == 10 ||
        Log_Level == 0
      ) {
        businessFunctions.logs(
          "DEBUG:(businessFunctions.checkStock(purchase._id, purchase.items, business) function called."
        );
      }
      var checkStock = await q.all(
        businessFunctions.checkStock(purchase._id, purchase.items, business)
      );
      // console.log("checkStock= " + checkStock)
      if (checkStock) {
        var products = purchase.items;
        for (var p = 0; p < products.length; p++) {
          // var removed =
          if (products[p].item_status == "Completed") {
            var removed = await q.all(
              businessFunctions.purchaseStockRemove(
                purchase._id,
                products[p],
                business,
                vendor,
                loggedInDetails
              )
            );
            if (removed) {
              products[p].item_status = "InCompleted";
              await purchase.markModified("items");
              await purchase
                .save()
                .then(async function (ress) {
                  // console.log("Item Saved = " + p)
                  // await businessFunctions.stockRemove(purchase._id, items, business);
                  // console.log("Data saved...")
                })
                .catch((err) => {
                  // console.log("Error...", err)
                });
            } else {
              // console.log("This item is not availale = " + products.part_no)
            }
            // console.log("Incompte Item Not need to Remove from Stock" + products[p].part_no)
          }
        }
        // var loggedInDetails = await User.findById(decoded.user).exec();
        var log_details = {
          business: business,
          activity_by: loggedInDetails.name,
          activity: "Bill Returned",
          // time: new Date().getTime.toLocaleTimeString(),
          remark: "",
          created_at: new Date(),
        };
        var logs = [];
        if (purchase.logs) {
          logs = purchase.logs;
          logs.push(log_details);
        } else {
          logs.push(log_details);
        }
        if (
          Log_Level == 4 ||
          Log_Level == 6 ||
          Log_Level == 8 ||
          Log_Level == 10 ||
          Log_Level == 0
        ) {
          businessFunctions.logs(
            "DEBUG: Updating Bill Status As Incomplete, PurchaseId:" +
              purchase._id
          );
        }
        await Purchase.findOneAndUpdate(
          { _id: purchase._id },
          {
            $set: { status: "Incomplete", logs: logs, updated_at: new Date() },
          },
          { new: true },
          async function (err, doc) {
            var purchaseReturn = q.all(
              businessFunctions.addPurchaseReturn(doc._id, business)
            );
            var transactionData = {
              user: doc.vendor,
              business: doc.business,
              status: "Purchase Returned",
              type: "Purchase Returned",
              paid_by: "-",
              activity: "Purchase Returned",
              source: doc._id,
              bill_id: doc.reference_no,
              bill_amount: parseFloat(doc.total),
              transaction_amount: parseFloat(doc.total),
              balance: parseFloat(doc.total),
              total: parseFloat(doc.total),
              paid_total: parseFloat(doc.total),
              due: 0,
              payment_status: "Pending",
              payment_mode: "-",
              received_by: loggedInDetails.name,
              transaction_id: "-",
              transaction_date: new Date(),
              transaction_status: "Success",
              transaction_response: "-",
              transaction_type: "Purchase Returned",
            };
            if (
              Log_Level == 4 ||
              Log_Level == 6 ||
              Log_Level == 8 ||
              Log_Level == 10 ||
              Log_Level == 0
            ) {
              businessFunctions.logs(
                "DEBUG: businessFunctions.addTransaction(transactionData) function called."
              );
            }
            q.all(businessFunctions.addTransaction(transactionData));

            res.status(200).json({
              responseCode: 200,
              responseMessage: "Bill Returned Successfully",
              responseData: {},
            });
            if (
              Log_Level == 3 ||
              Log_Level == 7 ||
              Log_Level == 9 ||
              Log_Level == 10 ||
              Log_Level == 0
            ) {
              businessFunctions.logs(
                "INFO: Bill Updated Successfully, PurchaseId:" +
                  purchase._id +
                  ", User:" +
                  loggedInDetails.name
              );
            }
          }
        );
      } else {
        if (
          Log_Level == 2 ||
          Log_Level == 5 ||
          Log_Level == 8 ||
          Log_Level == 9 ||
          Log_Level == 0
        ) {
          businessFunctions.logs(
            "WARNING: Insufficient Qantity in stock, User:" +
              loggedInDetails.name
          );
        }
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Insufficient Qantity in stock ",
          responseData: {},
        });
      }
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Purchase not found",
        responseData: {},
      });
    }
  }
);

router.get(
  "/vendor/details/get",
  xAccessToken.token,
  async function (req, res, next) {
    businessFunctions.logs(
      "INFO: /vendor/details/get Api Called from 3.0.js," +
        " " +
        "Request Headers:" +
        JSON.stringify(req.headers) +
        ", " +
        "Request Query:" +
        JSON.stringify(req.query)
    );

    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var business = req.headers["business"];
    var loggedInDetails = await User.findById(decoded.user).exec();
    var product = new Object();
    var result = [];

    if (
      Log_Level == 4 ||
      Log_Level == 6 ||
      Log_Level == 8 ||
      Log_Level == 10 ||
      Log_Level == 0
    ) {
      businessFunctions.logs(
        "DEBUG: Fatching Vendor Details, VendorId:" + req.query.user
      );
    }
    var user = await User.findById(req.query.user).exec();
    if (user) {
      var address = await Address.find({ user: user._id }).exec();
      var info = {
        _id: user.id,
        id: user.id,
        name: user.name,
        username: user.username,
        email: user.email,
        contact_no: user.contact_no,
        avatar: user.avatar,
        avatar_address: user.avatar_address,
        business_info: user.business_info,
        bank_details: user.bank_details,
        account_info: user.account_info,
        address: address,
      };

      res.status(200).json({
        responseCode: 200,
        responseMessage: "success",
        responseData: info,
      });
      if (
        Log_Level == 3 ||
        Log_Level == 7 ||
        Log_Level == 9 ||
        Log_Level == 10 ||
        Log_Level == 0
      ) {
        businessFunctions.logs(
          "INFO: Vendor Details Send in Response Successfully, Vendor_Name:" +
            user.name +
            ", User:" +
            loggedInDetails.name
        );
      }
    } else {
      if (
        Log_Level == 2 ||
        Log_Level == 5 ||
        Log_Level == 8 ||
        Log_Level == 9 ||
        Log_Level == 0
      ) {
        businessFunctions.logs(
          "WARNING: Vendor not found for the vendorId:" +
            req.query.user +
            ", User:" +
            loggedInDetails.name
        );
      }
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Vendor not found",
        responseData: {},
      });
    }
  }
);

router.post("/purchase/order/create", async (req, res, next) => {
  businessFunctions.logs(
    "INFO: /purchase/order/create Api Called from 3.0.js," +
      " " +
      "Request Headers:" +
      JSON.stringify(req.headers) +
      ", " +
      "Request Body:" +
      JSON.stringify(req.body)
  );

  var token = req.headers["x-access-token"];
  var business = req.headers["business"];
  var secret = config.secret;
  var decoded = jwt.verify(token, secret);
  var user = decoded.user;
  var loggedInDetails = await User.findById(decoded.user).exec();
  var parts = [];
  var loggedInDetails = await User.findById(user).exec();
  if (
    Log_Level == 4 ||
    Log_Level == 6 ||
    Log_Level == 8 ||
    Log_Level == 10 ||
    Log_Level == 0
  ) {
    businessFunctions.logs(
      "DEBUG: Fatching Vendor details, VendorId:" +
        req.body.vendor +
        ", " +
        "User:" +
        loggedInDetails.name
    );
  }
  var vendor = await User.findById(req.body.vendor).exec();
  if (vendor) {
    var car = null;
    var booking = null;
    if (req.body.booking) {
      car = booking.car;
      booking = req.body.booking;
    }
    var orderNo = await VendorOrders.find({ business: business }).count();
    var data = {
      vendor: vendor._id,
      business: business,
      car: car,
      booking: booking,
      parts: parts,
      // parts: quotationsPart,
      order_link: "http://localhost:4200/vendors/orders?id=",
      shop_name: vendor.name,
      contact_no: vendor.contact_no,
      email: vendor.email,
      totalQuotations: 0,
      status: "Confirmed",
      order_status: "Open",
      quotation: null,
      order_no: orderNo + 1,
      created_at: new Date(),
      updated_at: new Date(),
    };
    if (
      Log_Level == 4 ||
      Log_Level == 6 ||
      Log_Level == 8 ||
      Log_Level == 10 ||
      Log_Level == 0
    ) {
      businessFunctions.logs(
        "DEBUG: Creating New Purchase Order, Vendor Name:" +
          vendor.name +
          ", " +
          "User:" +
          loggedInDetails.name
      );
    }
    await VendorOrders.create(data).then(async function (order) {
      var activity = {
        business: business,
        activity_by: loggedInDetails.name,
        activity: "Order Created",
        // time: new Date().getTime.toLocaleTimeString(),
        remark: "",
        created_at: new Date(),
      };
      // console.log("Activity")
      businessFunctions.vendorOrderLogs(order._id, activity);
      res.status(200).json({
        responseCode: 200,
        responseMessage: "Purchase Order Created",
        responseData: {
          order: order,
          user: user,
        },
      });
      if (
        Log_Level == 3 ||
        Log_Level == 7 ||
        Log_Level == 9 ||
        Log_Level == 10 ||
        Log_Level == 0
      ) {
        businessFunctions.logs(
          "INFO: Purchase Order Created Successfully, User:" +
            loggedInDetails.name
        );
      }
    });
  } else {
    if (
      Log_Level == 2 ||
      Log_Level == 5 ||
      Log_Level == 8 ||
      Log_Level == 9 ||
      Log_Level == 0
    ) {
      businessFunctions.logs(
        "WARNING: Vendor Not Found for the given vendorId:" +
          req.body.vendor +
          ", " +
          "User:" +
          loggedInDetails.name
      );
    }
    res.status(400).json({
      responseCode: 400,
      responseMessage: "Vendor Not Found",
      responseData: {},
    });
  }
});
// purchase/order/get

router.post(
  "/send/sales-order",
  xAccessToken.token,
  async function (req, res, next) {
    businessFunctions.logs(
      "INFO: /send/sales-order Api Called from 3.0.js," +
        " " +
        "Request Headers:" +
        JSON.stringify(req.headers) +
        ", " +
        "Request Body:" +
        JSON.stringify(req.body)
    );

    var business = req.headers["business"];
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var date = new Date();
    var car = null;
    var address = null;
    var items = [];
    var discount = 0;
    var total = 0;
    var due = {
      due: 0,
    };
    var vendor = req.body.vendor;
    var vendorOrderId = req.body.order;
    var user = await User.findById(business).exec();
    var loggedInDetails = await User.findById(decoded.user).exec();
    if (user) {
      if (
        Log_Level == 4 ||
        Log_Level == 6 ||
        Log_Level == 8 ||
        Log_Level == 10 ||
        Log_Level == 0
      ) {
        businessFunctions.logs(
          "DEBUG: Fatching Vendor Order details for the vendor orderId:" +
            vendorOrderId +
            ", User:" +
            loggedInDetails.name
        );
      }

      var vendorOrder = await VendorOrders.findById(vendorOrderId)
        .populate("vendor")
        .exec();
      // console.log("Vendor Order = " + vendorOrder.vendor)
      // return res.json(vendorOrder)
      if (vendorOrder) {
        if (req.body.address) {
          var checkAddress = await Address.findOne({
            _id: req.body.address,
            user: user._id,
          }).exec();
          if (checkAddress) {
            address = checkAddress._id;
          } else {
            return res.status(400).json({
              responseCode: 400,
              responseMessage: "Address not found",
              responseData: {},
            });
          }
        }
        /*else
            {
                return res.status(400).json({
                    responseCode: 400,
                    responseMessage: "Address not found",
                    responseData: {}
                });
            }*/

        if (req.body.car) {
          var checkCar = await Car.findOne({
            _id: req.body.car,
            user: user._id,
          }).exec();
          if (checkCar) {
            car = checkCar._id;
          } else {
            return res.status(400).json({
              responseCode: 400,
              responseMessage: "Car not found",
              responseData: {},
            });
          }
        }

        var date = new Date();
        var payment = {
          payment_mode: "",
          payment_status: "",
          extra_charges_limit: 0,
          convenience_charges: 0,
          discount_type: "",
          coupon_type: "",
          coupon: "",
          discount_applied: false,
          transaction_id: "",
          transaction_date: "",
          transaction_status: "",
          transaction_response: "",
          total: total,
          discount_total: discount,
          paid_total: 0,
        };
        var req_no = Math.round(+new Date() / 1000);
        if (
          Log_Level == 4 ||
          Log_Level == 6 ||
          Log_Level == 8 ||
          Log_Level == 10 ||
          Log_Level == 0
        ) {
          businessFunctions.logs("DEBUG: Creating New Sales Order.");
        }

        await Order.create({
          convenience: req.body.convenience,
          time_slot: req.body.time_slot,
          user: user._id,
          car: car,
          address: address,
          items: items,
          business: vendorOrder.vendor,
          payment: payment,
          due: due,

          status: "Ordered",
          isPurchaseOrder: true,
          vendorOrder: vendorOrder._id,
          request_no: req_no,
          created_at: date,
          updated_at: date,
        }).then(async function (o) {
          var count = await Order.find({
            _id: { $lt: o._id },
            business: vendorOrder.vendor,
          }).count();

          var order_no =
            Math.round(+new Date() / 1000) +
            "-" +
            Math.ceil(Math.random() * 90000 + 10000) +
            "-" +
            Math.ceil(count + 1);
          // console.log("Order NO + " + order_no)
          await Order.findOneAndUpdate(
            { _id: o._id },
            { $set: { order_no: order_no } },
            { new: true },
            async function (err, doc) {
              if (err) {
                if (
                  Log_Level == 1 ||
                  Log_Level == 5 ||
                  Log_Level == 6 ||
                  Log_Level == 7 ||
                  Log_Level == 0
                ) {
                  businessFunctions.logs(
                    "ERROR: Error Occured while updating the order details, orderId:" +
                      o._id
                  );
                }
                res.status(422).json({
                  responseCode: 422,
                  responseMessage: "Server Errro",
                  responseData: err,
                });
              } else {
                var businessOrder = {
                  order: o._id,
                  _order: order_no,
                  due_date: null,
                  delivery_date: null,
                  convenience: req.body.convenience,
                  time_slot: req.body.time_slot,
                  user: user._id,
                  items: items,
                  business: vendorOrder.vendor,
                  payment: payment,
                  status: "Confirmed",
                  isPurchaseOrder: true,
                  vendorOrder: vendorOrder._id,
                  created_at: date,
                  updated_at: date,
                  due: due,
                };
                if (
                  Log_Level == 4 ||
                  Log_Level == 6 ||
                  Log_Level == 8 ||
                  Log_Level == 10 ||
                  Log_Level == 0
                ) {
                  businessFunctions.logs("DEBUG: Creating New Business Order.");
                }
                await BusinessOrder.create(businessOrder).then(async function (
                  bo
                ) {
                  var count = await BusinessOrder.find({
                    _id: { $lt: bo._id },
                    business: vendorOrder.vendor,
                  }).count();
                  var order_no = count + 1;

                  await BusinessOrder.findOneAndUpdate(
                    { _id: bo._id },
                    { $set: { order_no: order_no } },
                    { new: true },
                    async function (err, doc) {
                      var order = await BusinessOrder.findById(bo._id)
                        .populate({
                          path: "order",
                          populate: [
                            {
                              path: "user",
                              select:
                                "name contact_no username email account_info ",
                            },
                            {
                              path: "car",
                              select:
                                "title variant registration_no _automaker _model",
                            },
                            { path: "address" },
                          ],
                        })
                        .exec();

                      var items = await OrderLine.find({
                        order: order.order._id,
                        business: vendor,
                      }).exec();

                      // var req_no = Math.round(+new Date() / 1000);
                      // $set: { order: o._id, isOrder: true, orderSent: true, request_no: req_no }
                      await VendorOrders.findOneAndUpdate(
                        { _id: vendorOrder._id },
                        {
                          $set: {
                            order: o._id,
                            isOrder: true,
                            orderSent: true,
                            request_no: req_no,
                          },
                        },
                        { new: true },
                        async function (err, doc) {
                          if (err) {
                            if (
                              Log_Level == 1 ||
                              Log_Level == 5 ||
                              Log_Level == 6 ||
                              Log_Level == 7 ||
                              Log_Level == 0
                            ) {
                              businessFunctions.logs(
                                "ERROR: Error Occured while updating the Vendor order details, orderId:" +
                                  vendorOrder._id +
                                  ", User:" +
                                  loggedInDetails.name
                              );
                            }
                            res.status(422).json({
                              responseCode: 422,
                              responseMessage: "Server Errro",
                              responseData: err,
                            });
                          } else {
                            var activity = {
                              business: business,
                              activity_by: loggedInDetails.name,
                              activity:
                                "Order sent to the Seller -> " +
                                vendorOrder.vendor.name,

                              remark: "Order Sent",
                              created_at: new Date(),
                            };
                            businessFunctions.vendorOrderLogs(
                              vendorOrder._id,
                              activity
                            );

                            var activity = {
                              business: business,
                              activity_by: loggedInDetails.name,
                              activity:
                                "Order Received from ' " +
                                loggedInDetails.name +
                                " '",
                              remark: "Order Received",
                              created_at: new Date(),
                            };
                            businessFunctions.salesOrderLogs(o._id, activity);
                          }
                          if (
                            Log_Level == 4 ||
                            Log_Level == 6 ||
                            Log_Level == 8 ||
                            Log_Level == 10 ||
                            Log_Level == 0
                          ) {
                            businessFunctions.logs(
                              "DEBUG:  whatsAppEvent.orderPurchase(doc._id) function called."
                            );
                          }
                          whatsAppEvent.orderPurchase(doc._id);
                          var activity = "Purchase Order";
                          fun.webNotification(activity, doc);
                        }
                      );
                      if (
                        Log_Level == 4 ||
                        Log_Level == 6 ||
                        Log_Level == 8 ||
                        Log_Level == 10 ||
                        Log_Level == 0
                      ) {
                        businessFunctions.logs("DEBUG: ");
                      }

                      res.status(200).json({
                        responseCode: 200,
                        responseMessage: "",
                        responseData: {
                          _id: order._id,
                          id: order._id,
                          order_no: order.order_no,
                          order: order.order._id,
                          _order: order._order,
                          convenience: order.order.convenience,
                          car: order.order.car,
                          user: order.order.user,
                          address: order.order.address,
                          items: items,
                        },
                      });
                      if (
                        Log_Level == 3 ||
                        Log_Level == 7 ||
                        Log_Level == 9 ||
                        Log_Level == 10 ||
                        Log_Level == 0
                      ) {
                        businessFunctions.logs(
                          "INFO: Order sent to the Seller Successfully, Seller Name:" +
                            vendorOrder.vendor.name +
                            ", " +
                            "User:" +
                            loggedInDetails.name
                        );
                      }
                    }
                  );
                });
              }
            }
          );
        });
      } else {
        if (
          Log_Level == 2 ||
          Log_Level == 5 ||
          Log_Level == 8 ||
          Log_Level == 9 ||
          Log_Level == 0
        ) {
          businessFunctions.logs(
            "WARNING: Purchase Order not found with the given vendor orderId:" +
              vendorOrderId +
              ", User:" +
              loggedInDetails.name
          );
        }
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Purchase Order not found",
          responseData: {},
        });
      }
    } else {
      if (
        Log_Level == 1 ||
        Log_Level == 5 ||
        Log_Level == 6 ||
        Log_Level == 7 ||
        Log_Level == 0
      ) {
        businessFunctions.logs(
          "ERROR: User not found for the given businessId:" + business
        );
      }
      res.status(400).json({
        responseCode: 400,
        responseMessage: "User not found",
        responseData: {},
      });
    }
  }
);

router.get("/bills/get", xAccessToken.token, async function (req, res, next) {
  businessFunctions.logs(
    "INFO: /bills/get Api Called from 3.0.js," +
      " " +
      "Request Headers:" +
      JSON.stringify(req.headers) +
      ", " +
      "Request Query:" +
      JSON.stringify(req.query)
  );

  var token = req.headers["x-access-token"];
  var secret = config.secret;
  var decoded = jwt.verify(token, secret);
  var user = decoded.user;
  var business = req.headers["business"];
  var user = await User.findById(decoded.user).exec();
  var bills = [];
  var filters = [];
  var totalResult = 0;

  var role = await Management.findOne({
    user: user,
    business: business,
  }).exec();
  if (req.query.page == undefined) {
    var page = 0;
  } else {
    var page = req.query.page;
  }

  var limit = 10;
  // if (req.query.limit) {
  //     limit = parseInt(req.query.limit)
  // }

  var page = Math.max(0, parseInt(page));
  var queries = new Object();
  var sortBy = new Object();

  var thumbnail = [];

  var specification = {};
  specification["$lookup"] = {
    from: "User",
    localField: "vendor",
    foreignField: "_id",
    as: "vendor",
  };
  filters.push(specification);

  var specification = {};
  specification["$unwind"] = {
    path: "$vendor",
    preserveNullAndEmptyArrays: false,
  };
  filters.push(specification);
  if (req.query.query) {
    req.query.query = req.query.query.replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1");

    var specification = {};
    specification["$match"] = {
      business: mongoose.Types.ObjectId(business),
      status: { $ne: "Deleted" },
      $or: [
        { "vendor.name": { $regex: req.query.query, $options: "i" } },
        { "vendor.contact_no": { $regex: req.query.query, $options: "i" } },
        {
          "vendor.business_info.gstin": {
            $regex: req.query.query,
            $options: "i",
          },
        },
        {
          items: {
            $elemMatch: {
              title: { $regex: req.query.query, $options: "i" },
            },
          },
        },
        {
          bill_no: { $regex: req.query.query, $options: "i" },
        },
        {
          reference_no: { $regex: req.query.query, $options: "i" },
        },
        {
          items: {
            $elemMatch: {
              part_no: { $regex: req.query.query, $options: "i" },
            },
          },
        },
        {
          items: {
            $elemMatch: {
              sku: { $regex: req.query.query, $options: "i" },
            },
          },
        },
      ],
    };
    filters.push(specification);

    if (req.query.date) {
      var date = new Date();
      //from 10-05-21to13-07-21
      if (req.query.dateType == "range") {
        var query = req.query.date;
        var ret = query.split("to");
        var from = new Date(ret[0]);
        var to = new Date(ret[1]);
      }

      // 70 Days
      else if (req.query.dateType == "period") {
        if (parseInt(req.query.date) > 1) {
          var days = parseInt(req.query.date);
          var from = new Date(
            date.getFullYear(),
            date.getMonth(),
            date.getDate() - days
          );
          var to = new Date(
            date.getFullYear(),
            date.getMonth(),
            date.getDate() + 1
          );
        } else if (parseInt(req.query.date) == 0) {
          var query = parseInt(req.query.date);
          var from = new Date(
            date.getFullYear(),
            date.getMonth(),
            date.getDate()
          );
          var to = new Date(
            date.getFullYear(),
            date.getMonth(),
            date.getDate() + 1
          );
        } else if (parseInt(req.query.date) == 1) {
          var query = parseInt(req.query.date);
          var from = new Date(
            date.getFullYear(),
            date.getMonth(),
            date.getDate() - 1
          );
          var to = new Date(
            date.getFullYear(),
            date.getMonth(),
            date.getDate()
          );
        }
      } else {
        var from = new Date(
          date.getFullYear(),
          date.getMonth(),
          date.getDate()
        );
        var to = new Date(
          date.getFullYear(),
          date.getMonth(),
          date.getDate() + 1
        );
      }
      var specification = {};
      specification["$match"] = {
        created_at: { $gte: from, $lte: to },
      };
      filters.push(specification);
    }
  } else {
    var specification = {};
    specification["$match"] = {
      business: mongoose.Types.ObjectId(business),
      status: { $ne: "Deleted" },
    };
    filters.push(specification);

    if (req.query.date) {
      var date = new Date();
      //from 10-05-21to13-07-21
      if (req.query.dateType == "range") {
        var query = req.query.date;
        var ret = query.split("to");
        var from = new Date(ret[0]);
        var to = new Date(ret[1]);
      }

      // 70 Days
      else if (req.query.dateType == "period") {
        if (parseInt(req.query.date) > 1) {
          var days = parseInt(req.query.date);
          var from = new Date(
            date.getFullYear(),
            date.getMonth(),
            date.getDate() - days
          );
          var to = new Date(
            date.getFullYear(),
            date.getMonth(),
            date.getDate() + 1
          );
        } else if (parseInt(req.query.date) == 0) {
          var query = parseInt(req.query.date);
          var from = new Date(
            date.getFullYear(),
            date.getMonth(),
            date.getDate()
          );
          var to = new Date(
            date.getFullYear(),
            date.getMonth(),
            date.getDate() + 1
          );
        } else if (parseInt(req.query.date) == 1) {
          var query = parseInt(req.query.date);
          var from = new Date(
            date.getFullYear(),
            date.getMonth(),
            date.getDate() - 1
          );
          var to = new Date(
            date.getFullYear(),
            date.getMonth(),
            date.getDate()
          );
        }
      } else {
        var from = new Date(
          date.getFullYear(),
          date.getMonth(),
          date.getDate()
        );
        var to = new Date(
          date.getFullYear(),
          date.getMonth(),
          date.getDate() + 1
        );
      }
      var specification = {};
      specification["$match"] = {
        created_at: { $gte: from, $lte: to },
      };
      filters.push(specification);
    }
  }

  if (
    Log_Level == 4 ||
    Log_Level == 6 ||
    Log_Level == 8 ||
    Log_Level == 10 ||
    Log_Level == 0
  ) {
    businessFunctions.logs(
      "DEBUG: Fatching Total Bill Count, User:" + user.name
    );
  }
  // var totalResult = await Purchase.aggregate(filters);

  // var all = _.filter(totalResult, x => x.status == "Completed");
  // var due = parseFloat(_.sumBy(all, x => x.total).toFixed(2));

  var specification = {};
  specification["$sort"] = {
    updated_at: -1,
  };
  filters.push(specification);

  var specification = {};
  specification["$skip"] = config.perPage * page;
  filters.push(specification);

  var specification = {};
  specification["$limit"] = limit;
  filters.push(specification);

  if (
    Log_Level == 4 ||
    Log_Level == 6 ||
    Log_Level == 8 ||
    Log_Level == 10 ||
    Log_Level == 0
  ) {
    businessFunctions.logs("DEBUG: Fatching Bill list, User:" + user.name);
  }
  await Purchase.aggregate(filters)
    .allowDiskUse(true)
    .cursor({ batchSize: 10 })
    .exec()
    .eachAsync(async function (p) {
      var vendor_order = await VendorOrders.findById(p.vendorOrder).exec();
      var order_no = "N/A";
      var status = "";
      var due = 0;
      if (p.status == "Completed") {
        status = "Active";
      } else {
        status = p.status;
      }
      if (vendor_order) {
        order_no = vendor_order.order_no;
      }
      if (p.due) {
        due = p.due.toFixed(2);
      }
      bills.push({
        _id: p._id,
        // id: p._id,
        // bill_no: p.bill_no,
        reference_no: p.reference_no,
        date: moment(p.date).tz(req.headers["tz"]).format("YYYY-MM-DD"),
        // due_date: moment(p.due_date).tz(req.headers['tz']).format('YYYY-MM-DD'),
        // vendor: {
        //     name: p.vendor.name,
        //     _id: p.vendor._id,
        //     id: p.vendor.id,
        //     name: p.vendor.name,
        //     contact_no: p.vendor.contact_no,
        //     email: p.vendor.email,
        //     business_info: p.vendor.business_info,
        //     account_info: p.vendor.account_info,
        // },
        vendor_name: p.vendor.name,
        contact_no: p.vendor.contact_no,
        // business: p.business,
        total: p.total.toFixed(2),
        status: status,
        // paid_total: p.paid_total,
        due: due,
        order_no: order_no,
        created_at: moment(p.created_at).tz(req.headers["tz"]).format("lll"),
        updated_at: moment(p.updated_at).tz(req.headers["tz"]).format("lll"),
      });
    });

  if (
    Log_Level == 4 ||
    Log_Level == 6 ||
    Log_Level == 8 ||
    Log_Level == 10 ||
    Log_Level == 0
  ) {
    businessFunctions.logs(
      "DEBUG: Sending Bill List in Response, User:" + user.name
    );
  }
  res.status(200).json({
    responseCode: 200,
    responseMessage: "Success",
    responseData: bills,
  });
  if (
    Log_Level == 3 ||
    Log_Level == 7 ||
    Log_Level == 9 ||
    Log_Level == 10 ||
    Log_Level == 0
  ) {
    businessFunctions.logs(
      "INFO: Send Bill List in Response successfully, User:" + user.name
    );
  }
});

router.get(
  "/bills/total/get",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers["business"];
    var user = await User.findById(decoded.user).exec();
    var filters = [];

    var specification = {};
    specification["$match"] = {
      business: mongoose.Types.ObjectId(business),
      status: { $ne: "Deleted" },
    };
    filters.push(specification);

    if (req.query.date) {
      var date = new Date();
      //from 10-05-21to13-07-21
      if (req.query.dateType == "range") {
        var query = req.query.date;
        var ret = query.split("to");
        var from = new Date(ret[0]);
        var to = new Date(ret[1]);
      }

      // 70 Days
      else if (req.query.dateType == "period") {
        if (parseInt(req.query.date) > 1) {
          var days = parseInt(req.query.date);
          var from = new Date(
            date.getFullYear(),
            date.getMonth(),
            date.getDate() - days
          );
          var to = new Date(
            date.getFullYear(),
            date.getMonth(),
            date.getDate() + 1
          );
        } else if (parseInt(req.query.date) == 0) {
          var query = parseInt(req.query.date);
          var from = new Date(
            date.getFullYear(),
            date.getMonth(),
            date.getDate()
          );
          var to = new Date(
            date.getFullYear(),
            date.getMonth(),
            date.getDate() + 1
          );
        } else if (parseInt(req.query.date) == 1) {
          var query = parseInt(req.query.date);
          var from = new Date(
            date.getFullYear(),
            date.getMonth(),
            date.getDate() - 1
          );
          var to = new Date(
            date.getFullYear(),
            date.getMonth(),
            date.getDate()
          );
        }
      } else {
        var from = new Date(
          date.getFullYear(),
          date.getMonth(),
          date.getDate()
        );
        var to = new Date(
          date.getFullYear(),
          date.getMonth(),
          date.getDate() + 1
        );
      }
      var specification = {};
      specification["$match"] = {
        created_at: { $gte: from, $lte: to },
      };
      filters.push(specification);
    }
    var totalResult = await Purchase.aggregate(filters);
    // var due_total = 0
    var all = _.filter(totalResult, (x) => x.status !== "Deleted");
    var due_total = parseFloat(_.sumBy(all, (x) => x.due).toFixed(2));
    total_amount = parseFloat(_.sumBy(all, (x) => x.total).toFixed(2));
    var due = await businessFunctions.numberConversion(due_total);
    var total = await businessFunctions.numberConversion(total_amount);

    res.status(200).json({
      responseCode: 200,
      responseMessage: "Success",
      responseData: {
        total_results: totalResult.length,
        total: total,
        total_due: due,
      },
    });
  }
);

router.get(
  "/purchase-return/get",
  xAccessToken.token,
  async function (req, res, next) {
    businessFunctions.logs(
      "INFO: /purchase-return/get Api Called from 3.0.js," +
        " " +
        "Request Headers:" +
        JSON.stringify(req.headers) +
        ", " +
        "Request Query:" +
        JSON.stringify(req.query)
    );

    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers["business"];
    var loggedInDetails = await User.findById(decoded.user).exec();
    var bills = [];

    if (req.query.page == undefined) {
      var page = 0;
    } else {
      var page = req.query.page;
    }
    if (
      Log_Level == 4 ||
      Log_Level == 6 ||
      Log_Level == 8 ||
      Log_Level == 10 ||
      Log_Level == 0
    ) {
      businessFunctions.logs(
        "DEBUG: Fatching Purchase Return List with their detail, User:" +
          loggedInDetails.name
      );
    }
    await PurchaseReturn.find({ business: business })
      .populate({
        path: "vendor_address",
        select: "name username avatar avatar_address address contact_no",
      })
      .populate({
        path: "vendor",
        select: "name username avatar avatar_address address contact_no",
      })
      .sort({ updated_at: -1 })
      .skip(config.perPage * page)
      .limit(config.perPage)
      .cursor()
      .eachAsync(async (p) => {
        bills.push({
          _id: p._id,
          id: p._id,
          bill_no: p.bill_no,
          return_no: p.return_no,
          reference_no: p.reference_no,
          vendor_address: p.vendor_address,
          date: moment(p.date).tz(req.headers["tz"]).format("YYYY-MM-DD"),
          due_date: moment(p.due_date)
            .tz(req.headers["tz"])
            .format("YYYY-MM-DD"),
          vendor: p.vendor,
          business: p.business,
          total: p.total,
          status: p.status,
          created_at: moment(p.created_at).tz(req.headers["tz"]).format("lll"),
          updated_at: moment(p.updated_at).tz(req.headers["tz"]).format("lll"),
        });
      });

    if (
      Log_Level == 4 ||
      Log_Level == 6 ||
      Log_Level == 8 ||
      Log_Level == 10 ||
      Log_Level == 0
    ) {
      businessFunctions.logs(
        "DEBUG: Sending Purchase Return List in Response, User:" +
          loggedInDetails.name
      );
    }

    res.status(200).json({
      responseCode: 200,
      responseMessage: "Sucess",
      responseInfo: {
        totalResult: await PurchaseReturn.find({ business: business })
          .count()
          .exec(),
      },
      responseData: bills,
    });
    if (
      Log_Level == 3 ||
      Log_Level == 7 ||
      Log_Level == 9 ||
      Log_Level == 10 ||
      Log_Level == 0
    ) {
      businessFunctions.logs(
        "INFO: Purchase Return List send in Response Successfully, User:" +
          loggedInDetails.name
      );
    }
  }
);

router.get(
  "/purchase-return/details/get",
  xAccessToken.token,
  async function (req, res, next) {
    businessFunctions.logs(
      "INFO: /purchase-return/details/get Api Called from 3.0.js," +
        " " +
        "Request Headers:" +
        JSON.stringify(req.headers) +
        ", " +
        "Request Query:" +
        JSON.stringify(req.query)
    );

    var rules = {
      purchase: "required",
    };

    var validation = new Validator(req.query, rules);

    if (validation.fails()) {
      if (
        Log_Level == 1 ||
        Log_Level == 5 ||
        Log_Level == 6 ||
        Log_Level == 7 ||
        Log_Level == 0
      ) {
        businessFunctions.logs(
          "ERROR: Validation failed, PurcahseId is Required to get purchase return details."
        );
      }
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Error",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var user = decoded.user;
      var business = req.headers["business"];

      if (
        Log_Level == 4 ||
        Log_Level == 6 ||
        Log_Level == 8 ||
        Log_Level == 10 ||
        Log_Level == 0
      ) {
        businessFunctions.logs(
          "DEBUG: Fatching Purchase Return details, PurchaseId:" +
            req.query.purchase +
            ", User:" +
            loggedInDetails.name
        );
      }
      var p = await PurchaseReturn.findById({ _id: req.query.purchase })
        .populate({ path: "vendor_address" })
        .populate({
          path: "vendor",
          select:
            "name username avatar avatar_address address contact_no business_info",
        })
        .exec();

      if (p) {
        if (
          Log_Level == 4 ||
          Log_Level == 6 ||
          Log_Level == 8 ||
          Log_Level == 10 ||
          Log_Level == 0
        ) {
          businessFunctions.logs(
            "DEBUG: Sending Purchase return details in response, Vendor_Name:" +
              p.vendor.name +
              ", User:" +
              loggedInDetails.name
          );
        }
        var bill = {
          _id: p._id,
          id: p._id,
          return_no: p.return_no,
          bill_no: p.bill_no,
          reference_no: p.reference_no,
          date: moment(p.date).tz(req.headers["tz"]).format("YYYY-MM-DD"),
          due_date: moment(p.due_date)
            .tz(req.headers["tz"])
            .format("YYYY-MM-DD"),
          vendor_address: p.vendor_address,
          vendor: p.vendor,
          items: p.items,
          business: p.business,
          purchase: p.purchase,
          total: p.total,
          status: p.status,
          created_at: moment(p.created_at).tz(req.headers["tz"]).format("lll"),
          updated_at: moment(p.updated_at).tz(req.headers["tz"]).format("lll"),
        };

        res.status(200).json({
          responseCode: 200,
          responseMessage: "Sucess",
          responseData: bill,
        });
        if (
          Log_Level == 3 ||
          Log_Level == 7 ||
          Log_Level == 9 ||
          Log_Level == 10 ||
          Log_Level == 0
        ) {
          businessFunctions.logs(
            "INFO: Purchase return details send in response successfully, Vendor_Name:" +
              bill.vendor.name +
              ", User:" +
              loggedInDetails.name
          );
        }
      } else {
        if (
          Log_Level == 2 ||
          Log_Level == 5 ||
          Log_Level == 8 ||
          Log_Level == 9 ||
          Log_Level == 0
        ) {
          businessFunctions.logs(
            "WARNING: Purchase not found, PurchaseId:" +
              req.body.purchase +
              ", User:" +
              loggedInDetails.name
          );
        }
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Purchase not found",
          responseData: {},
        });
      }
    }
  }
);

router.put(
  "/purchase-return/update",
  xAccessToken.token,
  async function (req, res, next) {
    businessFunctions.logs(
      "INFO: /purchase-return/update Api Called from 3.0.js," +
        " " +
        "Request Headers:" +
        JSON.stringify(req.headers) +
        ", " +
        "Request Body:" +
        JSON.stringify(req.body)
    );

    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers["business"];
    var loggedInDetails = await User.findById(decoded.user).exec();
    var product = new Object();
    var result = [];
    var tax = [];
    var total = 0;

    var date = new Date(req.body.date).toISOString();
    if (req.body.due) {
      var due = new Date(req.body.due).toISOString();
    } else {
      var due = null;
    }
    if (
      Log_Level == 4 ||
      Log_Level == 6 ||
      Log_Level == 8 ||
      Log_Level == 10 ||
      Log_Level == 0
    ) {
      businessFunctions.logs(
        "DEBUG: Fatching Purchase Details, PurchaseId:" +
          req.body.purchase +
          ", User:" +
          loggedInDetails.name
      );
    }
    var purchase = await PurchaseReturn.findById(req.body.purchase).exec();
    var newDate = new Date();
    if (purchase) {
      var items = [];
      var products = req.body.items;

      if (products.length > 0) {
        for (var p = 0; p < products.length; p++) {
          if (products[p].lot != null && products[p].quantity != null) {
            var tax_info = await Tax.findOne({ tax: products[p].tax }).exec();
            if (tax_info) {
              var rate = products[p].mrp;
              var amount = products[p].mrp;
              var tax_rate = tax_info.detail;
              var base = amount;
              var discount = products[p].discount;

              if (discount.indexOf("%") >= 0) {
                discount = parseFloat(discount);
                if (!isNaN(discount) && discount > 0) {
                  var discount_total = amount * (discount / 100);
                  amount = amount - parseFloat(discount_total.toFixed(2));
                }
              } else {
                discount = parseFloat(discount);
                if (!isNaN(discount) && discount > 0) {
                  amount = amount - parseFloat(discount.toFixed(2));
                }
              }

              if (products[p].amount_is_tax == "exclusive") {
                if (
                  Log_Level == 4 ||
                  Log_Level == 6 ||
                  Log_Level == 8 ||
                  Log_Level == 10 ||
                  Log_Level == 0
                ) {
                  businessFunctions.logs(
                    "DEBUG: Calculating Tax Amount for tax type Exclusive."
                  );
                }
                var tax_on_amount = amount;
                if (tax_rate.length > 0) {
                  for (var r = 0; r < tax_rate.length; r++) {
                    if (tax_rate[r].rate != tax_info.rate) {
                      var t = tax_on_amount * (tax_rate[r].rate / 100);
                      amount = amount + t;
                      tax.push({
                        tax: tax_rate[r].tax,
                        rate: tax_rate[r].rate,
                        amount: parseFloat(t.toFixed(2)),
                      });
                    } else {
                      var t = tax_on_amount * (tax_info.rate / 100);
                      amount = amount + t;
                      tax.push({
                        tax: tax_info.tax,
                        tax_rate: tax_info.rate,
                        rate: tax_info.rate,
                        amount: parseFloat(t.toFixed(2)),
                      });
                    }
                  }
                }

                total = total + amount;
              }

              if (products[p].amount_is_tax == "inclusive") {
                amount = amount;
                var x = (100 + tax_info.rate) / 100;
                var tax_on_amount = amount / x;
                if (tax_rate.length > 0) {
                  for (var r = 0; r < tax_rate.length; r++) {
                    if (tax_rate[r].rate != tax_info.rate) {
                      var t = tax_on_amount * (tax_rate[r].rate / 100);
                      base = base - t;
                      tax.push({
                        tax: tax_rate[r].tax,
                        rate: tax_rate[r].rate,
                        amount: parseFloat(t.toFixed(2)),
                      });
                    } else {
                      var t = amount - tax_on_amount;
                      base = base - t;
                      tax.push({
                        tax: tax_info.tax,
                        rate: tax_info.rate,
                        amount: parseFloat(t.toFixed(2)),
                      });
                    }
                  }
                }
                //amount = products[p].mrp;
                total = total + amount;
              }

              var tax_details = {
                tax: tax_info.tax,
                rate: tax_info.rate,
                amount: total,
                detail: tax,
              };

              items.push({
                product: products[p].product,
                part_no: products[p].part_no,
                hsn_sac: products[p].hsn_sac,
                title: products[p].title,
                quantity: products[p].quantity,
                stock: products[p].quantity * products[p].lot,
                lot: products[p].lot,
                unit: products[p].unit,
                sku: products[p].sku,
                mrp: products[p].mrp,
                rate: products[p].rate,
                base: base,
                amount: amount,
                tax_amount: _.sumBy(tax, (x) => x.amount),
                models: products[p].models,
                amount_is_tax: products[p].amount_is_tax,
                unit_price: products[p].unit_price,
                sell_price: products[p].rate,
                margin: products[p].margin,
                discount: products[p].discount,
                discount_total: discount_total,
                tax: tax_info.tax,
                tax_rate: tax_info.rate,
                tax_info: tax,
                status: products[p].status,
              });

              tax = [];
            } else {
              res.status(422).json({
                responseCode: 422,
                responseMessage: "Please check tax rate",
                responseData: {},
              });
            }
          }
        }

        var returnItems = _.filter(items, (status) => status.status == true);
        var total = _.sumBy(returnItems, (x) => x.amount);

        var bill = {
          reference_no: req.body.reference_no,
          date: date,
          due_date: due,
          items: items,
          total: total,
          vendor_address: req.body.address,
          updated_at: new Date(),
        };

        PurchaseReturn.findOneAndUpdate(
          { _id: purchase._id },
          { $set: bill },
          { new: false },
          async function (err, doc) {
            if (err) {
              if (
                Log_Level == 1 ||
                Log_Level == 5 ||
                Log_Level == 6 ||
                Log_Level == 7 ||
                Log_Level == 0
              ) {
                businessFunctions.logs(
                  "ERROR: Error Occured  while Updating Purchase Return details, PurchaseId:" +
                    purchase._id +
                    ", User:" +
                    loggedInDetails.name
                );
              }
              res.status(422).json({
                responseCode: 422,
                responseMessage: "Server Error...",
                responseData: {},
              });
            } else {
              res.status(200).json({
                responseCode: 200,
                responseMessage: "Successfully Saved",
                responseData: await PurchaseReturn.findById(
                  purchase._id
                ).exec(),
              });
              if (
                Log_Level == 3 ||
                Log_Level == 7 ||
                Log_Level == 9 ||
                Log_Level == 10 ||
                Log_Level == 0
              ) {
                businessFunctions.logs(
                  "INFO: Successfully Saved purchase return details, PurchaseId:" +
                    purchase._id +
                    ", User:" +
                    loggedInDetails.name
                );
              }
            }
          }
        );
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Items not found",
          responseData: {},
        });
      }
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Purchase not found",
        responseData: {},
      });
    }
  }
);

router.post(
  "/send/eParchi/pdf",
  xAccessToken.token,
  async function (req, res, next) {
    // var rules = {
    //     business: 'required',
    // };

    //var validation = new Validator(req.body, rules);

    // if (validation.fails()) {
    //     res.status(422).json({
    //         responseCode: 422,
    //         responseMessage: "Validation Error",
    //         responseData: {
    //             res: validation.errors.all()
    //         }
    //     })
    // }
    // else {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers["business"];
    var type = req.body.type;
    var parchi = await Parchi.findOne({
      _id: mongoose.Types.ObjectId(req.body.parchi),
      status: "Open",
    }).exec();
    var loggedInDetails = await User.findById(decoded.user).exec();
    if (parchi) {
      if (parchi.parchi_url) {
        if (type == "email") {
          event.sendParchiMail(parchi._id, business);
        }
        if (type == "whatsapp") {
          var result = await whatsAppEvent.parchiSendWhatsapp(
            parchi._id,
            business
          );
        }
        res.status(200).json({
          responseCode: 200,
          responseMessage: "Parchi has been sent",
          responseData: result,
        });
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: " Parchi not found",
          responseData: {},
        });
      }
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Business not found",
        responseData: {},
      });
    }
    // }
  }
);

router.post(
  "/send/salesInvoice/pdf",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      invoice: "required",
    };
    var validation = new Validator(req.body, rules);
    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Validation Error",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var user = decoded.user;
      var business = req.headers["business"];
      var type = req.body.type;
      var stage = req.body.stage;
      var loggedInDetails = await User.findById(user).exec();
      var invoice = {};
      if (stage == "order") {
        // console.log("ord");
        invoice = await OrderInvoice.findOne({
          order: req.body.invoice,
          status: "Active",
        }).exec();
      } else if (stage == "sale") {
        // console.log('sle');

        invoice = await OrderInvoice.findOne({
          sale: req.body.invoice,
          status: "Active",
        }).exec();
      }

      if (invoice) {
        if (type == "email") {
          event.sendSalesInvoice(invoice);
        }
        if (type == "whatsapp") {
          whatsAppEvent.SalesInvoiceWhatsapp(invoice);
        }
        res.status(200).json({
          responseCode: 200,
          responseMessage: "Sales Invoice has been sent",
          responseData: {},
        });
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Invoice not found Please Generate Invoice",
          responseData: {},
        });
      }
    }
  }
);

router.post("/send/payment/code/sales", async function (req, res, next) {
  var token = req.headers["x-access-token"];
  var secret = config.secret;
  var decoded = jwt.verify(token, secret);
  var user = decoded.user;
  var business = req.headers["business"];
  // console.log(business);
  var userInfo = await User.findOne({
    _id: mongoose.Types.ObjectId(req.body.user),
  })
    // .populate({ path: 'user', select: 'name contact_no address _id' })
    .exec();
  var loggedInDetails = await User.findById(decoded.user).exec();

  if (userInfo) {
    //console.log(orderInfo.user);

    whatsAppEvent.paymetRequestSales(userInfo, business);

    res.status(200).json({
      responseCode: 200,
      responseMessage: "Request has been sent",
      responseData: { userInfo },
    });
  } else {
    res.status(400).json({
      responseCode: 400,
      responseMessage: " User not found",
      responseData: {},
    });
  }
});

router.get("/parchi/print/pdf", async function (req, res, next) {
  var token = req.headers["x-access-token"];
  var secret = config.secret;
  var decoded = jwt.verify(token, secret);
  var user = decoded.user;
  var business = req.headers["business"];
  type = req.query.type;

  var result_url = "";
  if (type == "parchi") {
    var parchi = await Parchi.findOne({
      business: business,
      _id: req.query.id,
    }).exec();
    if (parchi) {
      result_url = parchi.parchi_url;
    }
  }
  if (type == "order") {
    var invoice = await OrderInvoice.findOne({
      order: req.query.id,
      status: "Active",
    }).exec();
    if (invoice) {
      result_url = parchi.parchi_url;
    }
  } else if (type == "sale") {
    var invoice = await OrderInvoice.findOne({
      sale: req.query.id,
      status: "Active",
    }).exec();
    if (invoice) {
      result_url = parchi.parchi_url;
    }
    // result_url = invoice.invoice_url
  }
  if (result_url !== "") {
    res.status(200).json({
      responseCode: 200,
      responseMessage: "url has been sent",
      responseData: result_url,
    });
  } else {
    res.status(400).json({
      responseCode: 400,
      responseMessage: " url not found",
      responseData: {},
    });
  }
});

router.put(
  "/booking/invoice/cancel/sales/invoices/jobs",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      invoice: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Invoice is required",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var business = req.headers["business"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var user = decoded.user;
      var data = new Object();

      var loggedInDetails = await User.findById(user).exec();

      var invoice = await Invoice.findOne({
        _id: req.body.invoice,
        status: "Active",
      }).exec();
      if (invoice) {
        Invoice.findOneAndUpdate(
          { _id: invoice._id },
          { $set: { status: "Cancelled" } },
          { new: true },
          async function (err, doc) {
            if (err) {
              res.status(422).json({
                responseCode: 422,
                responseMessage: "Server Error",
                responseData: err,
              });
            } else {
              Booking.findOneAndUpdate(
                { _id: invoice.booking },
                { $set: { status: "Ready" } },
                { new: true },
                async function (err, doc) {
                  if (err) {
                    res.status(422).json({
                      responseCode: 422,
                      responseMessage: "Server Error",
                      responseData: err,
                    });
                  } else {
                    var activity = {
                      user: loggedInDetails._id,
                      name: loggedInDetails.name,
                      stage: "Invoice",
                      activity:
                        "Invoice Cancelled #(" + invoice.invoice_no + ")",
                    };

                    fun.bookingLog(invoice.booking, activity);

                    res.status(200).json({
                      responseCode: 200,
                      responseMessage: "Invoice Cancelled",
                      responseData: {},
                    });
                  }
                }
              );
            }
          }
        );
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Invoice Already Cancelled!",
          responseData: {},
        });
      }
    }
  }
);

router.put(
  "/bill/item/remove",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var business = req.headers["business"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var partIndex = req.body.index;
    var loggedInDetails = await User.findById(decoded.user).exec();

    var purchase = await Purchase.findById(req.body.bill).exec();
    if (purchase) {
      // var activity = {
      //     business: business,
      //     activity: "Item Removed- " + "Item: " + parchi.parts[partIndex].title + " " + "Part_No: " + parchi.parts[partIndex].part_no + " " + "Quantity: " + parchi.parts[partIndex].quantity,
      //     activity_by: loggedInDetails.name,
      //     remark: "",
      //     created_at: new Date(),
      // }
      // businessFunctions.parchiLogs(parchi._id, activity);

      purchase.items.splice(partIndex, 1);
      purchase.markModified("items");
      await purchase.save();

      var purchase = await Purchase.findById(req.body.bill).exec();
      var total = _.sumBy(purchase.items, (x) => x.amount);

      var discount_total = 0;
      var discount = 0;
      var total_amount = total.toFixed(2);
      if (purchase.bill_discount > 0) {
        discount = parseFloat(purchase.bill_discount);
        total_amount = total.toFixed(2);

        if (!isNaN(discount) && discount > 0) {
          discount_total = total * (discount / 100);
          total_amount = total_amount - parseFloat(discount_total.toFixed(2));
        }
      }

      var transaction_log = await TransactionLog.find({
        source: purchase._id,
        payment_status: "Success",
      }).exec();
      var paid_total = _.sumBy(transaction_log, (x) => x.paid_total);
      var due_amount = Math.ceil(total_amount) - paid_total;

      await Purchase.findOneAndUpdate(
        { _id: purchase._id },
        {
          $set: {
            due: due_amount,
            // paid_total: paid_total,
            total_discount: discount_total,
            total: total_amount,
            subTotal: total.toFixed(2),
            updated_at: new Date(),
          },
        },
        { new: false },
        async function (err, doc) {
          if (err) {
            res.status(422).json({
              responseCode: 422,
              responseMessage: "Server Error...",
              responseData: err,
            });
          } else {
          }
        }
      );

      res.status(200).json({
        responseCode: 200,
        responseMessage: "Removed Successfully",
        responseData: {},
      });
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Bill Not Found",
        responseData: {},
      });
    }
  }
);

router.put("/bill/items/add", xAccessToken.token, async function (req, res, next) {
  var purchase = req.body.bill;
  var rules = {
    bill: "required",
  };

  var validation = new Validator(req.body, rules);

  if (validation.fails()) {
    res.status(422).json({
      responseCode: 422,
      responseMessage: "Bill is required",
      responseData: {
        res: validation.errors.all(),
      },
    });
  } else {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers["business"];
    var loggedInDetails = await User.findById(decoded.user).exec();
    var product = new Object();
    var items = [];
    var tax = [];
    var total = 0;
    var purchase = await Purchase.findById(req.body.bill).exec();
    if (purchase) {
      var products = req.body.items;
      items = purchase.items;
      if (products) {
        var product = await BusinessProduct.findOne({
          part_no: products.part_no,
          business: business,
        }).exec();
        var tax_info = await Tax.findOne({ tax: products.tax }).exec();
        if (tax_info) {
          if (product) {
            var quantity = parseInt(products.quantity);
            var unit_base_price = parseFloat(products.unit_base_price);
            var base = parseFloat(products.base);
            var tax_slab = parseFloat(products.tax);
            var amount_is_tax = products.amount_is_tax;
            var amount = parseFloat(products.base);
            var tax_amount = parseFloat(amount) - parseFloat(base);
            var rate =
              parseFloat(unit_base_price) + parseFloat(products.margin);
            var unit_price = parseFloat(products.unit_price);
            var discount = parseFloat(products.discount);
            var tax_rate = tax_info.detail;
            var amount_is_tax = "exclusive";
            var lot = 1;

            if (products.amount_is_tax == "exclusive") {
              var tax_on_amount = amount;
              if (tax_rate.length > 0) {
                for (var r = 0; r < tax_rate.length; r++) {
                  if (tax_rate[r].rate != tax_info.rate) {
                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                    amount = parseFloat(amount + t);
                    tax.push({
                      tax: tax_rate[r].tax,
                      rate: tax_rate[r].rate,
                      amount: parseFloat(t.toFixed(2)),
                    });
                  } else {
                    var t = tax_on_amount * (tax_info.rate / 100);
                    amount = parseFloat(amount + t);
                    tax.push({
                      tax: tax_info.tax,
                      tax_rate: tax_info.rate,
                      rate: tax_info.rate,
                      amount: parseFloat(t.toFixed(2)),
                    });
                  }
                }
              }
            }
            var models = [];
            if (products.models != null) {
              models = products.models;
            }

            items.push({
              item_status: products.item_status,
              product: product.product,
              part_no: products.part_no,
              hsn_sac: products.hsn_sac,
              part_category: products.part_category,
              title: products.title,
              quantity: quantity,
              stock: products.quantity * lot,
              sku: products.sku,
              unit_base_price: unit_base_price,
              unit_price: unit_price,
              unit: products.unit,
              lot: lot,
              mrp: products.mrp,
              rate: rate,
              base: base,
              tax_amount: tax_amount,
              amount: parseFloat(products.amount),
              models: models,
              amount_is_tax: amount_is_tax,
              sell_price: rate,
              margin: products.margin,
              discount: discount,
              discount_type: products.discount_type,
              discount_total: products.discount_total,
              tax: tax_info.tax,
              tax_rate: tax_info.rate,
              tax_info: tax,
              isProduct: true,
              isOrderItem: products.isOrderItem,
            });

            // tax = [];
          } else {
            var quantity = parseInt(products.quantity);
            var unit_base_price = parseFloat(products.unit_base_price);
            var base = parseFloat(products.base);
            var tax_slab = parseFloat(products.tax);
            var amount_is_tax = products.amount_is_tax;
            var amount = parseFloat(products.base);
            var tax_amount = parseFloat(amount) - parseFloat(base);
            var rate =
              parseFloat(unit_base_price) + parseFloat(products.margin);
            var unit_price = parseFloat(products.unit_price);
            var discount = parseFloat(products.discount);
            var tax_rate = tax_info.detail;
            var lot = 1;

            if (products.amount_is_tax == "exclusive") {
              var tax_on_amount = amount;
              if (tax_rate.length > 0) {
                for (var r = 0; r < tax_rate.length; r++) {
                  if (tax_rate[r].rate != tax_info.rate) {
                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                    amount = parseFloat(amount + t);
                    tax.push({
                      tax: tax_rate[r].tax,
                      rate: tax_rate[r].rate,
                      amount: parseFloat(t.toFixed(2)),
                    });
                  } else {
                    var t = tax_on_amount * (tax_info.rate / 100);
                    amount = parseFloat(amount + t);
                    tax.push({
                      tax: tax_info.tax,
                      tax_rate: tax_info.rate,
                      rate: tax_info.rate,
                      amount: parseFloat(t.toFixed(2)),
                    });
                  }
                }
              }
            }

            var models = [];
            if (products.models != null) {
              models = products.models;
            }

            items.push({
              item_status: products.item_status,
              product: null,
              part_no: products.part_no,
              hsn_sac: products.hsn_sac,
              part_category: products.part_category,
              title: products.title,
              quantity: quantity,
              stock: products.quantity * lot,
              sku: products.sku,
              unit_base_price: unit_base_price,
              unit_price: unit_price,
              // purchase_price: purchase_price,
              unit: products.unit,
              lot: lot,
              mrp: products.mrp,
              rate: rate,
              base: base,
              // tax_amount: _.sumBy(tax, x => x.amount),
              tax_amount: tax_amount,
              amount: parseFloat(products.amount),
              models: models,
              amount_is_tax: amount_is_tax,
              sell_price: rate,
              margin: products.margin,
              discount: discount,
              discount_type: products.discount_type,
              discount_total: products.discount_total,
              tax: tax_info.tax,
              tax_rate: tax_info.rate,
              tax_info: tax,
              isProduct: false,
              isOrderItem: products.isOrderItem,
            });

            // tax = [];
          }
        } else {
          res.status(422).json({
            responseCode: 422,
            responseMessage: "Please check tax",
            responseData: {},
          });
        }

        await Purchase.findOneAndUpdate(
          { _id: purchase._id },
          {
            $set: {
              items: items,
            },
          },
          { new: false },
          async function (err, doc) {
            if (err) {
              res.status(422).json({
                responseCode: 422,
                responseMessage: "Server Error...",
                responseData: err,
              });
            } else {
              var purchase = await Purchase.findById(req.body.bill).exec();

              var total = _.sumBy(purchase.items, (x) => x.amount);

              var discount_total = 0;
              var discount = 0;
              var total_amount = total.toFixed(2);
              if (purchase.bill_discount > 0) {
                discount = parseFloat(purchase.bill_discount);
                total_amount = total.toFixed(2);

                if (!isNaN(discount) && discount > 0) {
                  discount_total = total * (discount / 100);
                  total_amount =
                    total_amount - parseFloat(discount_total.toFixed(2));
                }
              }
              var transaction_log = await TransactionLog.find({
                source: purchase._id,
                payment_status: "Success",
              }).exec();
              var paid_total = _.sumBy(transaction_log, (x) => x.paid_total);
              var due_amount = Math.ceil(total_amount) - paid_total;

              await Purchase.findOneAndUpdate(
                { _id: purchase._id },
                {
                  $set: {
                    due: due_amount,
                    total_discount: discount_total,
                    total: total_amount,
                    subTotal: total.toFixed(2),
                    updated_at: new Date(),
                  },
                },
                { new: false },
                async function (err, doc) {
                  if (err) {
                    res.status(422).json({
                      responseCode: 422,
                      responseMessage: "Server Error...",
                      responseData: err,
                    });
                  } else {
                  }
                }
              );
            }
          }
        );

        res.status(200).json({
          responseCode: 200,
          responseMessage: "Item Added Successfully",
          responseData: {},
        });
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Please Add Items Details.",
          responseData: {},
        });
      }
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Purchase not found",
        responseData: {},
      });
    }
  }
});

router.post(
  "/quotation/create",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      vendors: "required",
    };

    var validation = new Validator(req.body, rules);
    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "vendors is required",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var user = decoded.user;
      var business = req.headers["business"];
      var loggedInDetails = await User.findById(decoded.user).exec();

      var vendors = req.body.vendors;
      var count = await QuotationOrders.find({ business: business }).count();
      var activity = {
        business: business,
        activity: "Quotation Created",
        activity_by: loggedInDetails.name,
        remark: "",
        created_at: new Date(),
      };

      var quotationOrder = {
        business: business,
        car: null,
        booking: null,
        vendors: vendors,
        created_at: new Date(),
        updated_at: new Date(),
        order_no: count,
        status: "created",
        logs: activity,
      };

      await QuotationOrders.create(quotationOrder).then(async function (
        quotation
      ) {
        var last_order = "";
        var count = await QuotationOrders.find({
          _id: { $lt: quotation._id },
          business: business,
        }).count();
        if (count == 0) {
          var last_order = "";
          var position = 1;
        } else {
          var lq = await QuotationOrders.findOne({
            _id: { $lt: quotation._id },
            business: business,
          })
            .sort({ _id: -1 })
            .exec();
          var last_order = lq.quotation_no;
          position = count + 1;
        }
        var fy = {
          with_tax: false,
          last_order: last_order,
          position: position,
          type: "quotation",
        };
        if (
          Log_Level == 4 ||
          Log_Level == 6 ||
          Log_Level == 8 ||
          Log_Level == 10 ||
          Log_Level == 0
        ) {
          businessFunctions.logs(
            "DEBUG: fun.fiscalyear(fy) function called from function.js."
          );
        }
        var assigned_quotation_no = await q.all(fun.fiscalyear(fy));
        if (assigned_quotation_no) {
          if (assigned_quotation_no.invoice) {
            // console.log("Invoice no: " + assigned_invoice_no.invoice)
            if (
              Log_Level == 4 ||
              Log_Level == 6 ||
              Log_Level == 8 ||
              Log_Level == 10 ||
              Log_Level == 0
            ) {
              businessFunctions.logs(
                "DEBUG: Update Quotation Request Details, User:" +
                  loggedInDetails.name
              );
            }
            await QuotationOrders.findOneAndUpdate(
              { _id: quotation._id },
              { $set: { quotation_no: assigned_quotation_no.invoice } },
              { new: true },
              async function (err, doc) {
                if (err) {
                  if (
                    Log_Level == 1 ||
                    Log_Level == 5 ||
                    Log_Level == 6 ||
                    Log_Level == 7 ||
                    Log_Level == 0
                  ) {
                    businessFunctions.logs(
                      "ERROR: Error Occured while updating the quotation order details, QuotationId:" +
                        quotation._id +
                        ", " +
                        "User:" +
                        loggedInDetails.name
                    );
                  }
                  res.status(422).json({
                    responseCode: 422,
                    responseMessage: "Server Error",
                    responseData: err,
                  });
                } else {
                  // console.log("NO Assigned  = " + doc.quotation_no)
                }
              }
            );
          }
        }
        var orderNo = await VendorOrders.find({ business: business }).count();

        let vendorQuery = { _id: { $in: quotation.vendors } };
        var counter = 0;
        await User.find(vendorQuery)
          .populate({ path: "car", select: "vin title manufacture_year" })
          .cursor()
          .eachAsync(async (v) => {
            var car = null;
            var booking = null;
            if (req.body.booking) {
              car = booking.car;
              booking = req.body.booking;
            }
            var parts = [];
            var data = {
              vendor: v._id,
              business: business,
              car: car,
              booking: booking,
              parts: parts,
              // parts: quotationsPart,
              order_link: "http://localhost:4200/vendors/orders?id=",
              shop_name: v.name,
              contact_no: v.contact_no,
              email: v.email,
              totalQuotations: 0,
              status: "Created",
              quotation: quotation._id,
              order_no: orderNo + 1,
              created_at: new Date(),
              updated_at: new Date(),
            };
            if (
              Log_Level == 4 ||
              Log_Level == 6 ||
              Log_Level == 8 ||
              Log_Level == 10 ||
              Log_Level == 0
            ) {
              businessFunctions.logs(
                "DEBUG: Creating Vendor Orders, User:" + loggedInDetails.name
              );
            }

            await VendorOrders.create(data).then(async function (order) {
              await VendorOrders.findOneAndUpdate(
                { _id: order._id },
                {
                  $set: {
                    order_link:
                      "http://localhost:4200/vendors/orders?id=" + order._id,
                  },
                },
                { new: true },
                async function (err, doc) {}
              );
            });
          });
        var result = await VendorOrders.find({ quotation: quotation._id })
          .populate({ path: "quotation", select: "created_at order_no" })
          .populate({ path: "vendor" })
          .exec();
        res.status(200).json({
          responseCode: 200,
          responseMessage: "Quotation Created Successfully",
          responseData: quotation._id,
        });
        if (
          Log_Level == 3 ||
          Log_Level == 7 ||
          Log_Level == 9 ||
          Log_Level == 10 ||
          Log_Level == 0
        ) {
          businessFunctions.logs(
            "INFO: Quotation Created Successfully, QuotationId:" +
              quotation._id +
              ", " +
              "User:" +
              loggedInDetails.name
          );
        }
      });
    }
  }
);

router.get(
  "/purchaseOrders/total/get",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers["business"];
    var user = await User.findById(decoded.user).exec();
    var filters = [];

    var specification = {};
    specification["$match"] = {
      business: mongoose.Types.ObjectId(business),
      order_status: { $in: ["Open", "Received", "Cancelled"] },
    };
    filters.push(specification);

    if (req.query.date) {
      var date = new Date();
      //from 10-05-21to13-07-21
      if (req.query.dateType == "range") {
        var query = req.query.date;
        var ret = query.split("to");
        var from = new Date(ret[0]);
        var to = new Date(ret[1]);
      }

      // 70 Days
      else if (req.query.dateType == "period") {
        if (parseInt(req.query.date) > 1) {
          var days = parseInt(req.query.date);
          var from = new Date(
            date.getFullYear(),
            date.getMonth(),
            date.getDate() - days
          );
          var to = new Date(
            date.getFullYear(),
            date.getMonth(),
            date.getDate() + 1
          );
        } else if (parseInt(req.query.date) == 0) {
          var query = parseInt(req.query.date);
          var from = new Date(
            date.getFullYear(),
            date.getMonth(),
            date.getDate()
          );
          var to = new Date(
            date.getFullYear(),
            date.getMonth(),
            date.getDate() + 1
          );
        } else if (parseInt(req.query.date) == 1) {
          var query = parseInt(req.query.date);
          var from = new Date(
            date.getFullYear(),
            date.getMonth(),
            date.getDate() - 1
          );
          var to = new Date(
            date.getFullYear(),
            date.getMonth(),
            date.getDate()
          );
        }
      } else {
        var from = new Date(
          date.getFullYear(),
          date.getMonth(),
          date.getDate()
        );
        var to = new Date(
          date.getFullYear(),
          date.getMonth(),
          date.getDate() + 1
        );
      }
      var specification = {};
      specification["$match"] = {
        created_at: { $gte: from, $lte: to },
      };
      filters.push(specification);
    }
    var totalResult = await VendorOrders.aggregate(filters);
    var open = _.filter(totalResult, (x) => x.order_status == "Open");
    var received = _.filter(totalResult, (x) => x.order_status == "Received");
    var cancelled = _.filter(totalResult, (x) => x.order_status == "Cancelled");

    // var due_total = parseFloat(_.sumBy(all, x => x.due).toFixed(2));
    // total_amount = parseFloat(_.sumBy(all, x => x.total).toFixed(2));
    // var due = await businessFunctions.numberConversion(due_total)
    // var total = await businessFunctions.numberConversion(total_amount)

    res.status(200).json({
      responseCode: 200,
      responseMessage: "Success",
      responseData: {
        open: open.length,
        received: received.length,
        cancelled: cancelled.length,
      },
    });
  }
);

router.get(
  "/purchaseOrders/list/get",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers["business"];
    var user = await User.findById(decoded.user).exec();
    var filters = [];
    var match = [];
    var queries = {};

    if (req.query.page == undefined) {
      var page = 0;
    } else {
      var page = req.query.page;
    }

    if (req.query.limit) {
      var limit = parseInt(req.query.limit);
    } else {
      var limit = 10;
    }
    var status = "Open";
    if (req.query.status) {
      status = req.query.status;
    }

    if (req.query.query) {
      var specification = {};
      specification["$lookup"] = {
        from: "User",
        localField: "vendor",
        foreignField: "_id",
        as: "vendor",
      };
      filters.push(specification);
      var specification = {};
      specification["$unwind"] = {
        path: "$vendor",
        preserveNullAndEmptyArrays: false,
      };
      filters.push(specification);

      // console.log("query= ", req.query.query)
      req.query.query = req.query.query.replace(
        /([.?*+^$[\]\\(){}|-])/g,
        "\\$1"
      );
      var specification = {};
      specification["$match"] = {
        business: mongoose.Types.ObjectId(business),
        $or: [
          { "vendor.name": { $regex: req.query.query, $options: "i" } },
          { "vendor.contact_no": { $regex: req.query.query, $options: "i" } },
          // { 'car.title': { $regex: req.query.query, $options: 'i' } },
          // { 'car.registration_no': { $regex: req.query.query, $options: 'i' } },
          { order_no: { $regex: req.query.query, $options: "i" } },

          // { 'car.insurance_info.insurance_company': { $regex: req.query.query, $options: 'i' } },
          // { 'car.insurance_info.insurance_company': { $regex: req.query.query, $options: 'i' } },
        ],
      };
      filters.push(specification);

      var specification = {};
      specification["$match"] = {
        order_status: { $in: [status] },
      };
      filters.push(specification);

      var specification = {};
      specification["$sort"] = {
        updated_at: -1,
      };
      filters.push(specification);

      var specification = {};
      specification["$skip"] = config.perPage * page;
      filters.push(specification);

      var specification = {};
      specification["$limit"] = limit;
      filters.push(specification);

      if (req.query.date) {
        var date = new Date();
        //from 10-05-21to13-07-21
        if (req.query.dateType == "range") {
          var query = req.query.date;
          var ret = query.split("to");
          var from = new Date(ret[0]);
          var to = new Date(ret[1]);
        }

        // 70 Days
        else if (req.query.dateType == "period") {
          if (parseInt(req.query.date) > 1) {
            var days = parseInt(req.query.date);
            var from = new Date(
              date.getFullYear(),
              date.getMonth(),
              date.getDate() - days
            );
            var to = new Date(
              date.getFullYear(),
              date.getMonth(),
              date.getDate() + 1
            );
          } else if (parseInt(req.query.date) == 0) {
            var query = parseInt(req.query.date);
            var from = new Date(
              date.getFullYear(),
              date.getMonth(),
              date.getDate()
            );
            var to = new Date(
              date.getFullYear(),
              date.getMonth(),
              date.getDate() + 1
            );
          } else if (parseInt(req.query.date) == 1) {
            var query = parseInt(req.query.date);
            var from = new Date(
              date.getFullYear(),
              date.getMonth(),
              date.getDate() - 1
            );
            var to = new Date(
              date.getFullYear(),
              date.getMonth(),
              date.getDate()
            );
          }
        } else {
          var from = new Date(
            date.getFullYear(),
            date.getMonth(),
            date.getDate()
          );
          var to = new Date(
            date.getFullYear(),
            date.getMonth(),
            date.getDate() + 1
          );
        }
        var specification = {};
        specification["$match"] = {
          created_at: { $gte: from, $lte: to },
        };
        filters.push(specification);
      }
    } else {
      var specification = {};
      specification["$match"] = {
        order_status: { $in: [status] },
      };
      filters.push(specification);

      var specification = {};
      specification["$match"] = {
        business: mongoose.Types.ObjectId(business),
      };
      filters.push(specification);

      var specification = {};
      specification["$sort"] = {
        updated_at: -1,
      };
      filters.push(specification);

      var specification = {};
      specification["$skip"] = config.perPage * page;
      filters.push(specification);

      var specification = {};
      specification["$limit"] = limit;
      filters.push(specification);

      if (req.query.date) {
        var date = new Date();
        //from 10-05-21to13-07-21
        if (req.query.dateType == "range") {
          var query = req.query.date;
          var ret = query.split("to");
          var from = new Date(ret[0]);
          var to = new Date(ret[1]);
        }

        // 70 Days
        else if (req.query.dateType == "period") {
          if (parseInt(req.query.date) > 1) {
            var days = parseInt(req.query.date);
            var from = new Date(
              date.getFullYear(),
              date.getMonth(),
              date.getDate() - days
            );
            var to = new Date(
              date.getFullYear(),
              date.getMonth(),
              date.getDate() + 1
            );
          } else if (parseInt(req.query.date) == 0) {
            var query = parseInt(req.query.date);
            var from = new Date(
              date.getFullYear(),
              date.getMonth(),
              date.getDate()
            );
            var to = new Date(
              date.getFullYear(),
              date.getMonth(),
              date.getDate() + 1
            );
          } else if (parseInt(req.query.date) == 1) {
            var query = parseInt(req.query.date);
            var from = new Date(
              date.getFullYear(),
              date.getMonth(),
              date.getDate() - 1
            );
            var to = new Date(
              date.getFullYear(),
              date.getMonth(),
              date.getDate()
            );
          }
        } else {
          var from = new Date(
            date.getFullYear(),
            date.getMonth(),
            date.getDate()
          );
          var to = new Date(
            date.getFullYear(),
            date.getMonth(),
            date.getDate() + 1
          );
        }
        var specification = {};
        specification["$match"] = {
          created_at: { $gte: from, $lte: to },
        };
        filters.push(specification);
      }
    }
    var query = filters;
    var orders = [];
    await VendorOrders.aggregate(query)
      .allowDiskUse(true)
      .cursor({ batchSize: 10 })
      .exec()
      .eachAsync(async (p) => {
        var order = await VendorOrders.findOne({
          _id: p._id,
          order_status: { $in: req.query.status },
          business: business,
        })
          .populate({ path: "vendor", select: "name contact_no id" })
          .populate("quotation")
          .exec();
        if (order) {
          orders.push({
            _id: order._id,
            vendor: order.vendor,
            booking: order.booking,
            car: order.car,
            isVerified: order.isVerified,
            request_date: order.request_date,
            order_no: order.order_no,
            status: order.status,
            order_status: order.order_status,
            partsLength: order.parts.length,
            total_amount: currencyFormatter.format(
              order.total_amount.toFixed(2),
              { code: "INR" }
            ),
            created_at: order.created_at,
            updated_at: order.updated_at,
          });
        }
      });

    res.status(200).json({
      responseCode: 200,
      responseMessage: "Success",
      responseData: orders,
    });
  }
);

router.put(
  "/convert/custom/to/standard",
  xAccessToken.token,
  async function (req, res, next) {
    console.log("Body= ", JSON.stringify(req.body));
    var rules = {
      _id: "required",
      type: "required",
      // status: 'required',   //To maintain status for search query use in future
    };
    var status = req.body.status;
    var type = req.body.type;
    // console.log(status)
    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Validation Error",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var remark = "";
      var decoded = jwt.verify(token, secret);
      var loggedInDetails = await User.findById(decoded.user).exec();
      // if (status == "Approved") {
      if (req.body.type == "services") {
        // console.log("Inside services")
        await Service.findOneAndUpdate(
          { _id: req.body._id },
          {
            $set: {
              approved: true,
              publish: true,
              admin_status: "Approved",
              admin_verified: true,
              custom: false,
              status: "Standard",
              updated_at: new Date(),
            },
          },
          { new: true },
          function (err, doc) {
            if (err) {
              res.status(422).json({
                responseCode: 422,
                responseMessage: "Error Occurred",
                responseData: err,
              });
            } else {
              // console.log("Updatedd...... " + req.query._id + " Type= " + req.query.type)
              // event.adminServiceApproval(type, req.query._id, req.body.remark, req.headers['tz'])
              res.status(200).json({
                responseCode: 200,
                responseMessage: "Successfully Converted",
                responseData: {},
              });
            }
          }
        );
      } else if (req.body.type == "collision") {
        // console.log("Inside Collision")
        await Collision.findOneAndUpdate(
          { _id: req.body._id },
          {
            $set: {
              approved: true,
              publish: true,
              admin_status: "Approved",
              admin_verified: true,
              custom: false,
              status: "Standard",
              // status:req.query.status,
              updated_at: new Date(),
            },
          },
          { new: false },
          function (err, doc) {
            if (err) {
              res.status(422).json({
                responseCode: 422,
                responseMessage: "Error Occurred",
                responseData: err,
              });
            } else {
              // console.log("Updatedd..collision.... " + req.query._id + " Type= " + req.query.type)
              // event.adminServiceApproval(type, req.query._id, req.body.remark, req.headers['tz'])
              res.status(200).json({
                responseCode: 200,
                responseMessage: "Successfully Converted",
                responseData: {},
              });
            }
          }
        );
      } else if (req.body.type == "detailing") {
        // console.log("Inside Detailing")
        await Detailing.findOneAndUpdate(
          { _id: req.body._id },
          {
            $set: {
              approved: true,
              publish: true,
              custom: false,
              admin_status: "Approved",
              admin_verified: true,
              status: "Standard",
              // status:req.query.status,
              updated_at: new Date(),
            },
          },
          { new: true },
          function (err, doc) {
            if (err) {
              res.status(422).json({
                responseCode: 422,
                responseMessage: "Error Occurred",
                responseData: err,
              });
            } else {
              // console.log("Updatedd..detailing.... " + req.query._id + " Type= " + req.query.type)
              // event.adminServiceApproval(type, req.query._id, req.body.remark, req.headers['tz'])
              res.status(200).json({
                responseCode: 200,
                responseMessage: "Successfully Converted",
                responseData: {},
              });
            }
          }
        );
      } else if (req.body.type == "customization") {
        // console.log("Inside Customization")
        await Customization.findOneAndUpdate(
          { _id: req.body._id },
          {
            $set: {
              approved: true,
              publish: true,
              custom: false,
              admin_status: "Approved",
              admin_verified: true,
              status: "Standard",
              // status:req.query.status,
              updated_at: new Date(),
            },
          },
          { new: true },
          function (err, doc) {
            if (err) {
              res.status(422).json({
                responseCode: 422,
                responseMessage: "Error Occurred",
                responseData: err,
              });
            } else {
              // console.log("Updatedd..customization.... " + req.query._id + " Type= " + req.query.type)
              // event.adminServiceApproval(type, req.query._id, req.body.remark, req.headers['tz'])
              res.status(200).json({
                responseCode: 200,
                responseMessage: "Successfully Converted",
                responseData: {},
              });
            }
          }
        );
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Service not Found",
          responseData: {},
        });
      }
      // }
      // else {
      //     res.status(400).json({
      //         responseCode: 400,
      //         responseMessage: "Status not Matched",
      //         responseData: {}
      //     })

      // }
    }
  }
);

router.put(
  "/remove/custom/services",
  xAccessToken.token,
  async function (req, res, next) {
    console.log("Query= ", JSON.stringify(req.query));
    var rules = {
      _id: "required",
      type: "required",
      // status: 'required',   //To maintain status for search query use in future
    };
    var status = req.query.status;
    var type = req.query.type;
    // console.log(status)
    var validation = new Validator(req.query, rules);

    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Validation Error",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var remark = "";
      var decoded = jwt.verify(token, secret);
      var loggedInDetails = await User.findById(decoded.user).exec();
      // if (status == "Approved") {
      if (req.query.type == "services") {
        // console.log("Inside services")
        await Service.findByIdAndDelete({ _id: req.query._id }).exec();
        res.status(200).json({
          responseCode: 200,
          responseMessage: "Successfully deleted",
          responseData: {},
        });
      } else if (req.query.type == "collision") {
        // console.log("Inside Collision")
        await Collision.findByIdAndDelete({ _id: req.query._id }).exec();
        res.status(200).json({
          responseCode: 200,
          responseMessage: "Successfully deleted",
          responseData: {},
        });
      } else if (req.query.type == "detailing") {
        // console.log("Inside Detailing")
        await Detailing.findByIdAndDelete({ _id: req.query._id }).exec();
        res.status(200).json({
          responseCode: 200,
          responseMessage: "Successfully deleted",
          responseData: {},
        });
      } else if (req.query.type == "customization") {
        // console.log("Inside Customization")
        await Customization.findByIdAndDelete({ _id: req.query._id }).exec();
        res.status(200).json({
          responseCode: 200,
          responseMessage: "Successfully deleted",
          responseData: {},
        });
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "Service not Found",
          responseData: {},
        });
      }
      // }
      // else {
      //     res.status(400).json({
      //         responseCode: 400,
      //         responseMessage: "Service not Matched",
      //         responseData: {}
      //     })

      // }
    }
  }
);

router.get(
  "/generate/payment-receipt",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var business = req.headers["business"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var loggedInDetails = await User.findById(decoded.user).exec();

    // var userData = req.body.userData
    var transactionId = req.query.transactionId;
    var id = req.query.id;
    // var business = '5bfec47ef651033d1c99fbca'
    let status = "Received";
    // if (req.query.status == 'Payment-In') {
    //     status = 'Received'
    //     // var business = '5bfec47ef651033d1c99fbca'
    // }
    if (req.query.status == "Payment-Out") {
      status = "Sent";
    }

    var userDetails = await User.findOne({
      _id: mongoose.Types.ObjectId(id),
    }).exec();
    var paymentDetails = await TransactionLog.findOne({
      _id: mongoose.Types.ObjectId(transactionId),
    }).exec();
    var statement = await Statements.findOne({
      _id: mongoose.Types.ObjectId(transactionId),
    }).exec();

    if (userDetails) {
      if (paymentDetails) {
        var pdf = await fun.paymentPdf(
          userDetails,
          paymentDetails,
          business,
          status
        );

        var paymentDetails = {
          business_name: loggedInDetails.name,
          business_contact: loggedInDetails.contact_no,
          business_email: loggedInDetails.email,
          _id: paymentDetails._id,
          name: userDetails.name,
          contact_no: userDetails.contact_no,
          paid_total:
            numWords(paymentDetails.paid_total).toUpperCase() + " " + "RUPEES",
          paid_amount: paymentDetails.paid_total,
          transaction_url: paymentDetails.transaction_url,
          transaction_id: paymentDetails.transaction_id,
          type: paymentDetails.type,
          updated_at: moment(paymentDetails.updated_at)
            .tz(req.headers["tz"])
            .format("lll"),
        };

        res.status(200).json({
          responseCode: 200,
          responseMessage: "File generated Successfully",
          responseData: paymentDetails,
        });
      } else if (statement) {
        statementDetails = {
          _id: statement._id,
          paid_total: statement.transaction_amount,
          transaction_id: statement.transaction_id,
          created_at: statement.transaction_date,
        };
        await fun.payment_InPdf(
          userDetails,
          statementDetails,
          business,
          status
        );
        var statementDetails = {
          business_name: loggedInDetails.name,
          business_contact: loggedInDetails.contact_no,
          business_email: loggedInDetails.email,
          _id: statement._id,
          name: userDetails.name,
          contact_no: userDetails.contact_no,
          paid_total:
            numWords(statement.transaction_amount).toUpperCase() +
            " " +
            "RUPEES",
          paid_amount: statement.transaction_amount,
          transaction_url: statement.transaction_url,
          transaction_id: statement.transaction_id,
          type: statement.payment_mode,
          updated_at: moment(statement.updated_at)
            .tz(req.headers["tz"])
            .format("lll"),
        };

        res.status(200).json({
          responseCode: 200,
          responseMessage: "File generated Successfully",
          responseData: statementDetails,
        });
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: " Transaction not found",
          responseData: {},
        });
      }
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Business not found",
        responseData: {},
      });
    }
  }
);

router.get("/generate/party/statments", async function (req, res, next) {
  var token = req.headers["x-access-token"];
  var secret = config.secret;
  var decoded = jwt.verify(token, secret);
  var user = decoded.user;
  var business = req.headers["business"];
  var userId = req.query.user;
  // var transactions = req.body.transactions
  // var type = req.body.type
  // var duration = req.body.duration
  var transactions = [];
  var duration = {};
  if (req.query.date) {
    var date = new Date();
    //from 10-05-21to13-07-21
    if (req.query.dateType == "range") {
      var query = req.query.date;
      var ret = query.split("to");
      var from = new Date(ret[0]);
      var to = new Date(ret[1]);
    }

    // 70 Days
    else if (req.query.dateType == "period") {
      if (parseInt(req.query.date) > 1) {
        var days = parseInt(req.query.date);
        var from = new Date(
          date.getFullYear(),
          date.getMonth(),
          date.getDate() - days
        );
        var to = new Date(
          date.getFullYear(),
          date.getMonth(),
          date.getDate() + 1
        );
      } else if (parseInt(req.query.date) == 0) {
        var query = parseInt(req.query.date);
        var from = new Date(
          date.getFullYear(),
          date.getMonth(),
          date.getDate()
        );
        var to = new Date(
          date.getFullYear(),
          date.getMonth(),
          date.getDate() + 1
        );
      } else if (parseInt(req.query.date) == 1) {
        var query = parseInt(req.query.date);
        var from = new Date(
          date.getFullYear(),
          date.getMonth(),
          date.getDate() - 1
        );
        var to = new Date(date.getFullYear(), date.getMonth(), date.getDate());
      }
    } else {
      var from = new Date(date.getFullYear(), date.getMonth(), date.getDate());
      var to = new Date(
        date.getFullYear(),
        date.getMonth(),
        date.getDate() + 1
      );
    }

    // console.log("From = " + from + " TO " + to)
    duration = {
      from: from,
      to: to,
    };

    query = {
      user: req.query.user,
      payment_status: { $ne: "Failure" },
      business: business,
      transaction_date: { $gte: from, $lte: to },
    };
    await Statements.find(query)
      .populate({ path: "user", select: "name contact_no" })
      .populate({ path: "business", select: "name contact_no" })
      .sort({ Updated_at: 1 })
      .cursor()
      .eachAsync(async (statements) => {
        transactions.push({
          user: statements.user,
          business: statements.business,
          status: statements.status,
          type: statements.type,
          paid_by: statements.paid_by,
          activity: statements.activity,
          source: statements.source,
          bill_id: statements.bill_id,
          bill_amount: statements.bill_amount,
          transaction_amount: statements.transaction_amount,
          balance: statements.balance,
          total: statements.total,
          paid_total: statements.paid_total,
          // due: parseFloat(statements.bill_amount) - parseFloat(statements.paid_total),
          payment_status: statements.payment_status,
          payment_mode: statements.payment_mode,
          received_by: statements.received_by,
          transaction_id: statements.transaction_id,
          transaction_date: statements.transaction_date,
          transaction_status: statements.transaction_status,
          transaction_response: statements.transaction_response,
          // transaction_type: statements.transaction_type,
        });
      });
  }
  await fun.partyStatement(userId, duration, transactions);
  var user = await User.find({ _id: mongoose.Types.ObjectId(userId) });

  res.status(200).json({
    responseCode: 200,
    responseMessage: "Generated success",
    responseData: user[0].business_info.party_statements,
  });
});

router.get("/send/party/statments", async function (req, res, next) {
  var token = req.headers["x-access-token"];
  var secret = config.secret;
  var decoded = jwt.verify(token, secret);
  var user = decoded.user;
  var business = req.headers["business"];
  var type = req.query.type;

  var partyDetails = req.query.partyDetails;
  //var   partyDetails = details.party._id;

  var userInfo = await User.findOne({
    _id: mongoose.Types.ObjectId(partyDetails),
  }).exec();
  var url = userInfo.business_info.party_statements;
  if (url) {
    if (type == "email") {
      event.sendStatement(userInfo._id);
    }
    if (type == "whatsapp") {
      whatsAppEvent.statmentSend(userInfo._id, business);
    }
    return res.status(200).json({
      responseCode: 200,
      responseMessage: "Sent success",
      responseData: partyDetails,
    });
  }
  return res.status(400).json({
    responseCode: 400,
    responseMessage: "Invoice not found,please generate .",
    responseData: {},
  });
});

// router.get('/send/whatsapp-payment-reciept', xAccessToken.token, async function (req, res, next) {

//     var token = req.headers['x-access-token'];
//     var secret = config.secret;
//     var decoded = jwt.verify(token, secret);
//     var user = decoded.user;
//     var business = req.headers['business'];

//     var id = req.query.id
//     // console.log("iddd" + id);
//     var transactionId = req.query.transactionId
//     var user = await User.findOne({ _id: mongoose.Types.ObjectId(id) }).exec();
//     var paymentDetails = await TransactionLog.findOne({ _id: mongoose.Types.ObjectId(transactionId) }).exec();
//     if (user) {
//         if (paymentDetails.transaction_url) {
//             //console.log('done');

//             whatsAppEvent.paymentRecieptWhatsApp(user, paymentDetails);

//             res.status(200).json({
//                 responseCode: 200,
//                 responseMessage: "File has been sent",
//                 responseData: { paymentDetails }
//             });

//         }
//         res.status(400).json({
//             responseCode: 400,
//             responseMessage: "File not Found, File can't share",
//             responseData: {}
//         });

//     }
//     else {

//         res.status(400).json({
//             responseCode: 400,
//             responseMessage: "User not found, File can't share",
//             responseData: {}
//         });
//     }

// });

router.get(
  "/send/whatsapp-payment-reciept",
  xAccessToken.token,
  async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers["business"];

    var id = req.query.id;
    // console.log("iddd" + id);
    var transactionId = req.query.transactionId;
    var user = await User.findOne({ _id: mongoose.Types.ObjectId(id) }).exec();
    var paymentDetails = await TransactionLog.findOne({
      _id: mongoose.Types.ObjectId(transactionId),
    }).exec();
    var statement = await Statements.findOne({
      _id: mongoose.Types.ObjectId(transactionId),
    }).exec();
    if (user) {
      if (paymentDetails) {
        //console.log('done');
        if (paymentDetails.transaction_url) {
          if (req.query.type == "email") {
            event.paymentReceipt(user, paymentDetails);
          } else {
            whatsAppEvent.paymentRecieptWhatsApp(user, paymentDetails);
          }
          res.status(200).json({
            responseCode: 200,
            responseMessage: "File has been sent",
            responseData: {},
          });
        } else {
          res.status(200).json({
            responseCode: 200,
            responseMessage: "File not Found, File can't share",
            responseData: {},
          });
        }
      } else if (statement) {
        if (statement.transaction_url) {
          if (req.query.type == "email") {
            event.paymentReceipt(user, statement);
          } else {
            whatsAppEvent.paymentRecieptWhatsApp(user, statement);
          }
          res.status(200).json({
            responseCode: 200,
            responseMessage: "File has been sent",
            responseData: {},
          });
        } else {
          res.status(200).json({
            responseCode: 200,
            responseMessage: "File not Found, File can't share",
            responseData: {},
          });
        }
      }

      // else{
      //     res.status(400).json({
      //         responseCode: 400,
      //         responseMessage: "File not Found, File can't share",
      //         responseData: {}
      //     });

      // }
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "User not found, File can't share",
        responseData: {},
      });
    }
  }
);

router.get(
  "/send/payment/request",
  xAccessToken.token,
  async function (req, res, next) {
    var rules = {
      user: "required",
    };
    var validation = new Validator(req.query, rules);
    if (validation.fails()) {
      res.status(422).json({
        responseCode: 422,
        responseMessage: "Validation Error",
        responseData: {
          res: validation.errors.all(),
        },
      });
    } else {
      var token = req.headers["x-access-token"];
      var secret = config.secret;
      var decoded = jwt.verify(token, secret);
      var user = decoded.user;
      var business = req.headers["business"];
      // console.log(business);
      let user_id = req.query.user;
      let amount = req.query.amount;
      let activity = req.query.activity;
      let user_info = await User.findById(user_id).exec();
      // var loggedInDetails = await User.findById(decoded.user).exec();
      if (user_info) {
        if (activity == "email") {
          await event.paymentLink(user_info, amount, business);
        } else if (activity == "whatsapp") {
          whatsAppEvent.paymetRequest(amount, user_info, business);
        }

        res.status(200).json({
          responseCode: 200,
          responseMessage: "Payment Request has been sent",
          responseData: {},
        });
      } else {
        res.status(400).json({
          responseCode: 400,
          responseMessage: "User not found",
          responseData: {},
        });
      }
    }
  }
);

router.get("/leads/bookings/get",xAccessToken.token,async function (req, res, next) {
    // console.log("body= ", JSON.stringify(req.query))
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers["business"];

    var filters = [];
    var leads = [];
    var bookingss = [];
    var role = await Management.findOne({
      user: user,
      business: business,
    }).exec();
    if (req.query.page == undefined) {
      var page = 0;
    } else {
      var page = req.query.page;
    }
    var limit = 10;
    var page = Math.max(0, parseInt(page));

    if (req.query.list == "Leads") {
      if (role.role == "CRE") {
        var specification = {};
        specification["$match"] = {
          assignee: mongoose.Types.ObjectId(role.user),
        };
        filters.push(specification);
        var specification = {};
        specification["$match"] = {
          business: mongoose.Types.ObjectId(business),
        };
        filters.push(specification);
      } else if (role.role == "Admin" || role.role == "Manager") {
        var specification = {};
        specification["$match"] = {
          business: mongoose.Types.ObjectId(business),
        };
        filters.push(specification);
      } else {
        var specification = {};
        specification["$match"] = {
          assignee: mongoose.Types.ObjectId(role.user),
        };
        filters.push(specification);
        var specification = {};
        specification["$match"] = {
          business: mongoose.Types.ObjectId(business),
        };
        filters.push(specification);
      }

      if (req.query.query) {
        var specification = {};
        specification["$lookup"] = {
          from: "LeadRemark",
          localField: "remarks",
          foreignField: "_id",
          as: "remarks",
        };
        filters.push(specification);

        req.query.query = req.query.query.replace( /([.?*+^$[\]\\(){}|-])/g, "\\$1");

        var specification = {};
        specification["$match"] = {
          business: mongoose.Types.ObjectId(business),
          $or: [
            { name: { $regex: req.query.query, $options: "i" } },
            { contact_no: { $regex: req.query.query, $options: "i" } },
            {
              remarks: {
                $elemMatch: {
                  status: { $regex: req.query.query, $options: "i" },
                },
              },
            },
            {
              remarks: {
                $elemMatch: {
                  customer_remark: { $regex: req.query.query, $options: "i" },
                },
              },
            },
            {
              remarks: {
                $elemMatch: {
                  assignee_remark: { $regex: req.query.query, $options: "i" },
                },
              },
            },
          ],
        };

        filters.push(specification);
      }

      if (req.query.priority) {
        var priority = parseInt(req.query.priority);
        if (priority == 0) {
          var specification = {};
          specification["$match"] = {
            priority: { $in: [1, 2, 3] },
          };
          filters.push(specification);
        } else {
          var specification = {};
          specification["$match"] = {
            priority: priority,
          };
          filters.push(specification);
        }
      }

      var specification = {};
      if (req.query.status == "All") {
        var date = new Date();
        var specification = {};
        specification["$match"] = {
          created_at: { $lte: date },
        };
        filters.push(specification);
      } else {
        var specification = {};
        specification["$match"] = {
          "remark.status": { $in: [req.query.status] },
        };
        if (req.query.status == "Follow-Up" || req.query.status == "PSF") {
          var specification = {};
          specification["$match"] = {
            "follow_up.date": { $lte: new Date() },
          };
        }
        filters.push(specification);
      }

      if (req.query.source) {
        var specification = {};
        specification["$match"] = {
          source: { $eq: req.query.source },
        };
        filters.push(specification);
      }

      if (req.query.date && req.query.endDate) {
        var date = new Date(req.query.date);
        var endDate = new Date(req.query.endDate);
        var specification = {};
        specification["$match"] = {
          "follow_up.date": { $gte: new Date(date), $lte: new Date(endDate) },
        };
        filters.push(specification);
      }

      var specification = {};
      specification["$sort"] = {
        created_at: -1,
      };
      filters.push(specification);

      var specification = {};
      specification["$skip"] = config.perPage * page;
      filters.push(specification);

      var specification = {};
      specification["$limit"] = limit;
      filters.push(specification);

      var query = filters;

      await Lead.aggregate(query)
        .allowDiskUse(true)
        .cursor({ batchSize: 20 })
        .exec()
        .eachAsync(async function (lead) {
          var remark = await LeadRemark.findOne({ lead: lead._id })
            .sort({ created_at: -1 })
            .exec();
          var assignee = await User.findById(lead.assignee).exec();
          // console.log("70863")

          if (assignee) {
            var a = {
              name: assignee.name,
              email: assignee.email,
              contact_no: assignee.contact_no,
              _id: assignee._id,
              _id: assignee._id,
            };
          } else {
            var a = {
              name: "",
              email: "",
              contact_no: "",
              _id: null,
              _id: null,
            };
          }

          if (lead.follow_up == null) {
            var follow_up = {};
          } else {
            follow_up = lead.follow_up;
          }

          var l = lead.remark;

          if (l) {
            if (l.assignee_remark == "") {
              l.assignee_remark = l.customer_remark;
            }
            var remark = {
              source: l.source,
              type: l.type,
              reason: l.reason,
              status: l.status,
              customer_remark: l.customer_remark,
              assignee_remark: l.assignee_remark,
              assignee: a,
              color_code: l.color_code,
              created_at: moment(l.created_at)
                .tz(req.headers["tz"])
                .format("lll"),
              updated_at: moment(l.updated_at)
                .tz(req.headers["tz"])
                .format("lll"),
            };
          }

          var b = await Booking.findOne({ lead: lead._id }).exec();

          var booking = null;
          var isOutbound = false;
          if (b) {
            booking = b._id;
            isOutbound = b.isOutbound;
          }

          var category = "";
          if (lead.category) {
            category = lead.category;
          }
          var isStared = false;
          if (lead.isStared) {
            isStared = lead.isStared;
          } else {
            isStared = false;
          }

          var source = lead.source;
          if (source == "Booking") {
            source = "Walk-in";
          }
          // isStared : isStared,

          // var outbound = await Booking.find({ isOutbound: true, status: "EstimateRequested" }).count().exec();
          // totalCounts = total.length - outbound
          var date = "";
          if (follow_up.date != null) {
            date = moment(follow_up.date)
              .tz(req.headers["tz"])
              .format("DD-MM-YYYY");
          }
          leads.push({
            _id: lead._id,
            // booking: booking,
            // user: lead.user,
            name: lead.name,
            contact_no: lead.contact_no,
            // email: lead.email,
            // id: lead.id,
            priority: lead.priority,
            // contacted: lead.contacted,
            // type: lead.type,
            lead_id: lead.lead_id,
            // geometry: lead.geometry,
            // date: moment(lead.updated_at).tz(req.headers['tz']).format('lll'),
            status: remark.status,
            source: source,
            manager: a.name,
            // important: lead.important,
            // follow_up: date + " " + follow_up.time,
            follow_up_date: date,
            // follow_up_time: follow_up.time,
            // remark: remark,
            // assignee: a,
            // time: time,
            // isStared: isStared,
            // category: category,
            isOutbound: isOutbound,
            created_at: moment(lead.created_at)
              .tz(req.headers["tz"])
              .format("DD-MM-YYYY"),
            // updated_at: moment(lead.updated_at).tz(req.headers['tz']).format('lll'),
          });
        });

      leads = _.filter(leads, (x) => !x.isOutbound && x.status != "PSF");
      res.status(200).json({
        responseCode: 200,
        responseMessage: role.role + " Leads",
        responseData: leads,
      });
    } else {
      var user = null;
      if (role.role == "Admin" || role.role == "Manager") {
        user = { $ne: null };
      } else {
        user = role.user;
      }

      if (req.query.status !== "Missed" || req.query.status !== "Confirmed") {
        if (role.role == "Admin" || role.role == "Manager") {
          var specification = {};
          specification["$match"] = {
            business: mongoose.Types.ObjectId(business),
          };
          filters.push(specification);
        } else {
          var specification = {};
          specification["$match"] = {
            manager: mongoose.Types.ObjectId(user),
          };
          specification["$match"] = {
            business: mongoose.Types.ObjectId(business),
          };
          filters.push(specification);
        }
      } else if (req.query.status == "Missed" ||req.query.status == "Confirmed" ||req.query.status == "EstimateRequested" ||req.query.status == "Approval"
      ) {
        if (role.role == "Admin" || role.role == "Manager") {
          var specification = {};
          specification["$match"] = {
            business: mongoose.Types.ObjectId(business),
          };
          filters.push(specification);
        } else {
          var specification = {};
          specification["$match"] = {
            manager: mongoose.Types.ObjectId(user),
          };
        }
      }

      // if (req.query.status == "Converted" || req.query.status == "Missed" || req.query.status == "Confirmed") {
      //     var specification = {};
      //     specification['$match'] = {
      //         isOutbound: { $eq: false }
      //     };
      //     filters.push(specification);
      // }

      if (req.query.status == "Converted") {
        var specification = {};
        specification["$match"] = {
          $and: [
            {
              status: {
                $nin: [
                  "Rejected",
                  "Cancelled",
                  "Inactive",
                  "EstimateRequested",
                  "Confirmed",
                ],
              },
            },
            { isOutbound: { $eq: false } },
            { converted: true },
          ],
        };
        filters.push(specification);
      } else if (req.query.status == "Missed") {
        var specification = {};
        specification["$match"] = {
          $and: [
            { status: { $in: ["Confirmed"] } },
            { date: { $lt: new Date() } },
            {isOutbound: { $eq: false }}
          ],
        };
        filters.push(specification);
      } else if (req.query.status == "Confirmed") {
        var specification = {};
        specification["$match"] = {
          $and: [
            { status: { $eq: ["Confirmed"] } },
            { isOutbound: { $eq: false } },
            { date: { $gte: new Date() } },
          ],
        };
        filters.push(specification);
      } else if (req.query.status == "EstimateRequested") {
        var specification = {};
        specification["$match"] = {
          status: { $in: ["EstimateRequested"] },
        };
        filters.push(specification);
      } else if (req.query.status == "Approval") {
        var specification = {};
        specification["$match"] = {
          $and: [
            { converted: { $eq: true } },
              {status: { $nin: ["Approval"] }},
          ],
        };
        filters.push(specification);
      }
      // if (req.query.source) {
      //     var specification = {};
      //     specification['$match'] = {
      //         source: { $eq: req.query.source }
      //     };
      //     filters.push(specification);
      // }
      if (req.query.query) {
        var specification = {};
        specification["$lookup"] = {
          from: "User",
          localField: "user",
          foreignField: "_id",
          as: "user",
        };
        filters.push(specification);

        req.query.query = req.query.query.replace(
          /([.?*+^$[\]\\(){}|-])/g,
          "\\$1"
        );

        var specification = {};
        specification["$match"] = {
          business: mongoose.Types.ObjectId(business),
          $or: [
            { "user.name": { $regex: req.query.query, $options: "i" } },
            { "user.contact_no": { $regex: req.query.query, $options: "i" } },
            // {
            //     "remarks": {
            //         $elemMatch: {
            //             "status": { $regex: req.query.query, $options: 'i' }
            //         }
            //     }
            // },
            // {
            //     "remarks": {
            //         $elemMatch: {
            //             "customer_remark": { $regex: req.query.query, $options: 'i' }
            //         }
            //     }
            // },
            // {
            //     "remarks": {
            //         $elemMatch: {
            //             "assignee_remark": { $regex: req.query.query, $options: 'i' }
            //         }
            //     }
            // },
          ],
        };

        filters.push(specification);
      }

      if (req.query.date) {
        var specification = {};
        specification["$match"] = {
          created_at: {
            $gte: new Date(req.query.date),
            $lte: new Date(req.query.endDate),
          },
        };
        filters.push(specification);
      }

      var specification = {};
      specification["$sort"] = {
        updated_at: -1,
      };
      filters.push(specification);

      var specification = {};
      specification["$skip"] = config.perPage * page;
      filters.push(specification);

      var specification = {};
      specification["$limit"] = limit;
      filters.push(specification);

      var query = filters;

      await Booking.aggregate(query)
        .allowDiskUse(true)
        .cursor({ batchSize: 20 })
        .exec()
        .eachAsync(async function (bookings) {
          var booking = await Booking.findOne({ _id: bookings._id })
            .populate({
              path: "user",
              populate: {
                path: "user",
                select: "_id id name contact_no email business_info",
              },
            })
            .populate({
              path: "manager",
              populate: {
                path: "user",
                select: "_id id name contact_no email",
              },
            })
            .populate({
              path: "lead",
              populate: {
                path: "lead",
                select: "_id id name contact_no email",
              },
            })
            .populate({
              path: "car",
              select: "_id id title registration_no ic rc",
              populate: { path: "thumbnails" },
            })
            .exec();
          if (booking.address) {
            var address = await Address.findOne({
              _id: booking.address,
            }).exec();
          } else {
            var address = {};
          }

          if (booking.car) {
            var car = {
              title: booking.car.title,
              _id: booking.car._id,
              id: booking.car.id,
              rc_address: booking.car.rc_address,
              ic_address: booking.car.ic_address,
              ic: booking.car.ic,
              rc: booking.car.rc,
              registration_no: booking.car.registration_no,
            };
          } else {
            var car = {
              title: "",
              _id: null,
              id: null,
              rc_address: "",
              ic_address: "",
              ic: "",
              rc: "",
              registration_no: "",
            };
          }
          var manager = null;
          var manager_name = "";
          if (booking.manager) {
            manager_name = booking.manager.name;
            manager = {
              name: booking.manager.name,
              _id: booking.manager._id,
              id: booking.manager.id,
              contact_no: booking.manager.contact_no,
              email: booking.manager.email,
            };
          }
          var status = booking.status;
          var source = "";
          var _id = booking._id;
          if (booking.lead) {
            source = booking.lead.source;
            if (source == "Booking") {
              source = "Walk-in";
            }
            _id = booking.lead._id;
            lead = {
              name: booking.lead.name,
              _id: booking.lead._id,
              id: booking.lead.id,
              contact_no: booking.lead.contact_no,
              source: booking.lead.source,
              email: booking.lead.email,
            };
            status = booking.lead.remark.status;
          }
          if (req.query.status == "Confirmed" || req.query.status == "Missed") {
            status = req.query.status;
          }
          var name = "";
          var contact_no = "";

          if (booking.user) {
            name = booking.user.name;
            contact_no = booking.user.contact_no;
          }

          bookingss.push({
            _id: lead._id,
            // id: booking._id,
            // car: car,
            name: name,
            contact_no: contact_no,
            // user: {
            //     name: booking.user.name,
            //     _id: booking.user._id,
            //     id: booking.user.id,
            //     contact_no: booking.user.contact_no,
            //     email: booking.user.email,
            //     business_info: booking.user.business_info
            // },
            manager: manager_name,
            lead_id: "",
            source: source,
            priority: "",
            // services: booking.services,
            // convenience: booking.convenience,
            // date: moment(booking.date).tz(req.headers['tz']).format('ll'),
            // time_slot: booking.time_slot,
            status: status,
            isOutbound: false,
            follow_up_date: "",
            // // status: req.query.status,
            // booking_no: booking.booking_no,
            // job_no: booking.job_no,
            // estimation_requested: booking.estimation_requested,
            // address: address,
            // remarks: booking.remarks,
            // customer_requirements: booking.customer_requirements,
            // payment: booking.payment,
            // txnid: booking.txnid,
            // __v: booking.__v,
            created_at: moment(booking.created_at)
              .tz(req.headers["tz"])
              .format("DD-MM-YYYY"),
            // updated_at: moment(booking.updated_at).tz(req.headers['tz']).format('lll'),
          });
        });
      res.status(200).json({
        responseCode: 200,
        responseMessage: "Success",
        responseData: bookingss,
      });
    }
  }
);

router.post("/sale/labour/add",xAccessToken.token,async function (req, res, next) {
    var business = req.headers["business"];
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var date = new Date();
    var loggedInDetails = decoded.user;
    var items = [];
    var convenience_charges = 0;
    var discount = 0;
    // var item_total = 0;
    var sale = await Sales.findById(req.body.sale).exec();
    var labours = sale.labours;
    var loggedInDetails = await User.findById(decoded.user).exec();
    if (sale) {
      var products = req.body.items;
      if (products) {
        var tax_info = await Tax.findOne({ tax: products.tax }).exec();

        // var product = await BusinessProduct.findOne({ _id: products.product, business: business }).exec();
        var tax = [];
        var rate = products.rate;
        var amount = products.rate * products.quantity;
        var tax_rate = tax_info.detail;
        var discount_total = 0;
        var base = amount;
        var discount = products.discount;
        if (discount.indexOf("%") >= 0) {
          discount = parseFloat(discount);
          if (!isNaN(discount) && discount > 0) {
            discount_total = amount * (discount / 100);
            amount = amount - parseFloat(discount_total.toFixed(2));
          }
        } else {
          if (discount == "") {
            discount = "0";
          }

          discount_total = parseFloat(discount);

          if (!isNaN(discount_total) && discount_total > 0) {
            amount = amount - parseFloat(discount_total.toFixed(2));
          }
        }

        if (products.amount_is_tax == "exclusive") {
          var tax_on_amount = amount;
          if (tax_rate.length > 0) {
            for (var r = 0; r < tax_rate.length; r++) {
              if (tax_rate[r].rate != tax_info.rate) {
                var t = tax_on_amount * (tax_rate[r].rate / 100);
                amount = amount + t;
                tax.push({
                  tax: tax_rate[r].tax,
                  rate: tax_rate[r].rate,
                  amount: parseFloat(t.toFixed(2)),
                });
              } else {
                var t = tax_on_amount * (tax_info.rate / 100);
                amount = amount + t;
                tax.push({
                  tax: tax_info.tax,
                  tax_rate: tax_info.rate,
                  rate: tax_info.rate,
                  amount: parseFloat(t.toFixed(2)),
                });
              }
            }
          }
        }

        if (products.amount_is_tax == "inclusive") {
          var x = (100 + tax_info.rate) / 100;
          var tax_on_amount = amount / x;
          if (tax_rate.length > 0) {
            for (var r = 0; r < tax_rate.length; r++) {
              if (tax_rate[r].rate != tax_info.rate) {
                var t = tax_on_amount * (tax_rate[r].rate / 100);
                base = base - t;
                tax.push({
                  tax: tax_rate[r].tax,
                  rate: tax_rate[r].rate,
                  amount: parseFloat(t.toFixed(2)),
                });
              } else {
                var t = amount - tax_on_amount;
                base = base - t;
                tax.push({
                  tax: tax_info.tax,
                  rate: tax_info.rate,
                  amount: parseFloat(t.toFixed(2)),
                });
              }
            }
          }
          //base = base - discount_total;
        }

        var tax_details = {
          tax: tax_info.tax,
          rate: tax_info.rate,
          amount: total,
          detail: tax,
        };
        // var issued = await q.all(businessFunctions.salesPartIssue(products, business, user, loggedInDetails));
        // if (issued) {

        // }
        var user = await User.findById(sale.user).exec();
        labours.push({
          part_no: products.part_no,
          hsn_sac: products.hsn_sac,
          unit: products.unit,
          title: products.title,
          mrp: products.mrp,
          selling_price: products.selling_price,
          rate: products.rate,
          quantity: products.quantity,
          base: parseFloat(base.toFixed(2)),
          amount: amount,
          discount: products.discount,
          discount_total: parseFloat(discount_total.toFixed(2)),
          amount_is_tax: products.amount_is_tax,
          tax_amount: parseFloat(_.sumBy(tax, (x) => x.amount).toFixed(2)),
          amount: parseFloat(amount.toFixed(2)),
          tax: tax_info.tax,
          tax_rate: tax_info.rate,
          tax_info: tax,
          created_at: new Date(),
          updated_at: new Date(),
        });
      }
      if (sale.payment.convenience_charges) {
        convenience_charges = Math.ceil(sale.payment.convenience_charges);
      }
      var discount =
        parseFloat(_.sumBy(labours, (x) => x.discount_total).toFixed(2)) +
        parseFloat(_.sumBy(sale.parts, (x) => x.discount_total).toFixed(2));
      var amount =
        parseFloat(_.sumBy(labours, (x) => x.amount).toFixed(2)) +
        parseFloat(_.sumBy(sale.parts, (x) => x.amount).toFixed(2));
      var total = amount + discount + convenience_charges;
      var transaction_log = await q.all(
        fun.getSalesTransaction(sale._id, business)
      );
      var paid_total = transaction_log.paid_total;
      var data = {
        "payment.paid_total": paid_total,
        "payment.amount": parseFloat(amount.toFixed(2)),
        "payment.discount_total": parseFloat(discount.toFixed(2)),
        "payment.total": parseFloat(total.toFixed(2)),
        "payment.order_discount": parseFloat(sale.payment.order_discount),
        due: {
          due:
            Math.ceil(amount) +
            convenience_charges -
            paid_total -
            (parseFloat(sale.payment.order_discount) +
              parseFloat(sale.payment.discount_total)),
        },
        labours: labours,
        updated_at: new Date(),
      };

      await Sales.findOneAndUpdate(
        { _id: sale._id, business: business },
        { $set: data },
        { new: false },
        async function (err, doc) {
          if (err) {
            res.status(422).json({
              responseCode: 422,
              responseMessage: "Server Error",
              responseData: err,
            });
          } else {
            var has_invoice = false;
            var invoices = await OrderInvoice.find({
              sale: sale._id,
              business: business,
            })
              .select("status invoice_no")
              .exec();
            if (invoices.length > 0) {
              has_invoice = true;
            }
            var orders = {
              _id: sale._id,
              id: sale._id,
              items: sale.parts,
              labours: sale.labours,
              user: sale.user,
              car: sale.car,
              address: sale.address,
              due_date: moment(sale.due_date)
                .tz(req.headers["tz"])
                .format("lll"),
              delivery_date: moment(sale.delivery_date)
                .tz(req.headers["tz"])
                .format("lll"),
              time_slot: sale.time_slot,
              convenience: sale.convenience,
              order_no: sale.order_no,
              address: sale.address,
              payment: sale.payment,
              due: sale.due,
              logs: sale.logs,
              status: sale.status,
              has_invoice: has_invoice,
              invoices: invoices,
              created_at: moment(sale.created_at)
                .tz(req.headers["tz"])
                .format("lll"),
              updated_at: moment(sale.updated_at)
                .tz(req.headers["tz"])
                .format("lll"),
            };
            var activity = {
              business: business,
              activity_by: loggedInDetails.name,
              activity: "'" + products.title + "'  -Added to Order",
              remark: "Labour Added",
              created_at: new Date(),
            };
            businessFunctions.salesLogs(sale._id, activity);

            res.status(200).json({
              responseCode: 200,
              responseMessage: "success",
              responseData: orders,
            });
          }
        }
      );
    } else {
      res.status(400).json({
        responseCode: 400,
        responseMessage: "Sale not found",
        responseData: {},
      });
    }
  }
);

router.get("/psf/lead/stats",xAccessToken.token,async function (req, res, next) {
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers["business"];
    var role = await Management.findOne({
      user: user,
      business: business,
    }).exec();
    if (role) {
      var assignee = null;
      if (role.role == "CRE") {
        assignee = mongoose.Types.ObjectId(role.user);
      } else if (role.role == "Admin" || role.role == "Manager") {
        assignee = { $ne: null };
      } else {
        assignee = mongoose.Types.ObjectId(role.user);
      }
      // assignee = { $ne: null }
      var open = await Lead.find({
        "remark.status": { $in: ["PSF"] },
        "follow_up.date": { $lt: new Date() },
        business: business,
        assignee: assignee,
      })
        .count()
        .exec();
      var rework = await Lead.find({
        "remark.status": { $in: ["Rework"] },
        business: business,
        assignee: assignee,
      })
        .count()
        .exec();
      var satisfied = await Lead.find({
        "remark.status": { $in: ["Closed"] },
        "remark.reason": { $in: ["Satisfied"] },
        business: business,
        assignee: assignee,
      })
        .count()
        .exec();
      var dissatisfied = await Lead.find({
        "remark.status": { $in: ["Closed"] },
        "remark.reason": { $in: ["Dissatisfied"] },
        business: business,
        assignee: assignee,
      })
        .count()
        .exec();
      res.status(200).json({
        responseCode: 200,
        responseMessage: "PSF Stats Counts",
        responseData: {
          open: open,
          rework: rework,
          satisfied: satisfied,
          dissatisfied: dissatisfied,
        },
      });
    }
  }
);

router.get("/psf/leads/get",xAccessToken.token,async function (req, res, next) {
    console.log('Route is called...', JSON.stringify(req.query));
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers["business"];
    // console.log('User = ', user, business);
    var bookings = [];
    var totalResult = 0;
    var role = await Management.findOne({
      user: user,
      business: business,
    }).exec();
    if (req.query.page == undefined) {
      var page = 0;
    } else {
      var page = req.query.page;
    }
    var page = Math.max(0, parseInt(page));
    var leads = [];
    var filters = [];
    var queries = {};

    
    // filters = [];
    if (role.role == "CRE") {
      var specification = {};
      specification['$match'] = {
        $and: [{ assignee: mongoose.Types.ObjectId(role.user) },{business:mongoose.Types.ObjectId(business)}],
      };
      filters.push(specification);
    } else if (role.role == "Admin" || role.role == "Manager") {
      var specification = {};
      specification['$match'] = { business: mongoose.Types.ObjectId(business)};
      filters.push(specification);
    } else {
     var specification = {};
     specification['$match'] = { business: mongoose.Types.ObjectId(business) };
     filters.push(specification);
    }

    if (req.query.status == "Rework") {
      var specification = {};
      specification['$match'] = {
        "remark.status": { $eq: req.query.status },
      };
      filters.push(specification);
    } else if (req.query.status == "PSF") {
      var specification = {};
      specification['$match'] = {
        $and: [
          { "remark.status": { $eq: req.query.status } },
          { "follow_up.date": { $lte: new Date() } },
        ],
      };
      filters.push(specification);
    } else if (req.query.status == "Dissatisfied") {
      var specification = {};
      specification["$match"] = {
        $and: [
          { "remark.reason": { $eq:req.query.status } },
          { "remark.status": { $eq: "Closed" } },
        ],
      };
      filters.push(specification);
    } else if (req.query.status == "Satisfied") {
      var specification = {};
      specification["$match"] = {
        $and: [
          { "remark.reason": { $eq: req.query.status } },
          { "remark.status": { $eq: "Closed" } },
        ],
      };
      filters.push(specification);
  }
  if (req.query.query) {
    var specification = {};
    specification["$lookup"] = {
      from: "LeadRemark",
      localField: "remarks",
      foreignField: "_id",
      as: "remarks",
    };
    filters.push(specification);

    req.query.query = req.query.query.replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1");
    req.query.query.replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1");

    var specification = {};
    specification["$match"] = {
      business: mongoose.Types.ObjectId(business),
      "remark.status": { $in: ["PSF", "Closed", "Rework"] },
      $or: [
        { name: { $regex: req.query.query, $options: "i" } },
        { contact_no: { $regex: req.query.query, $options: "i" } },
        { "remark.reason": { $regex: req.query.query, $options: "i" } },
        {
          remarks: {
            $elemMatch: {
              status: { $regex: req.query.query, $options: "i" },
            },
          },
        },
        {
          remarks: {
            $elemMatch: {
              customer_remark: { $regex: req.query.query, $options: "i" },
            },
          },
        },
        {
          remarks: {
            $elemMatch: {
              assignee_remark: { $regex: req.query.query, $options: "i" },
            },
          },
        },
      ],
    };

    filters.push(specification);
  }
  var specification = {};
  specification["$sort"] = {
    updated_at: -1,
  };
  filters.push(specification);

  var specification = {};
  specification["$skip"] = 10 * page;
  filters.push(specification);

  var specification = {};
  specification["$limit"] = 10;
  filters.push(specification);

    var query=filters
    // console.log('Filters', filters);

    var total = await Lead.aggregate(query).exec();
    var sortQuery = { $sort: { updated_at: -1 } };

    await Lead.aggregate(query)
      .allowDiskUse(true)
      .cursor({ batchSize: 20 })
      .exec()
      .eachAsync(async function (lead) {
        var remark = await LeadRemark.findOne({ lead: lead._id })
          .sort({ created_at: -1 })
          .exec();
        var assignee = await User.findById(lead.assignee).exec();

        if (assignee) {
          var a = {
            name: assignee.name,
            email: assignee.email,
            contact_no: assignee.contact_no,
            _id: assignee._id,
            _id: assignee._id,
          };
        } else {
          var a = {
            name: "",
            email: "",
            contact_no: "",
            _id: null,
            _id: null,
          };
        }
        var follow_up = {};
        if (lead.follow_up) {
          follow_up = lead.follow_up;
        }

        var b = await Booking.findOne({ lead: lead._id })
          .populate({ path: "car", select: "title registration_no" })
          .populate({ path: "advisor", select: "name contact_no email" })
          .exec();
        var booking = null;
        var car = null;
        var advisor = null;
        if (b) {
          booking = {
            _id: b._id,
            id: b._id,
            last_job: moment(b.date).tz(req.headers["tz"]).format("lll"),
          };
          // car = {
          //   title: b.car.title,
          //   registration_no: b.car.registration_no,
          //   // insurance_info :b.car.insurance_info
          // };
          advisor = {
            name: b.advisor.name,
            contact_no: b.advisor.contact_no,
            email: b.advisor.email,
          };
        }
        var isStared = false;
        if (lead.isStared) {
          isStared = lead.isStared;
        } else {
          isStared = false;
        }
        leads.push({
          booking: booking,
          // car: car,
          name: lead.name,
          contact_no: lead.contact_no,
          email: lead.email,
          _id: lead._id,
          id: lead.id,
          status: lead.status,
          follow_up: follow_up,
          assignee: a,
          advisor: advisor,
          isStared: isStared,
          created_at: moment(lead.created_at)
            .tz(req.headers["tz"])
            .format("lll"),
          updated_at: moment(lead.updated_at)
            .tz(req.headers["tz"])
            .format("lll"),
        });
      });
      // console.log("Data",JSON.stringify(leads))

    res.status(200).json({
      responseCode: 200,
      responseInfo: {
        // filters: filters,
        totalResult: total.length,
      },
      responseMessage: role.role + " Leads",
      totalLeads: leads.length,
      responseData: leads,
    });
  }
);

router.get("/psf/leads/get/new",xAccessToken.token,async function (req, res, next) {
    console.log("Route is called...", JSON.stringify(req.query));
    var token = req.headers["x-access-token"];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers["business"];
    // console.log('User = ', user, business);
    var bookings = [];
    var totalResult = 0;
    var role = await Management.findOne({
      user: user,
      business: business,
    }).exec();
    if (req.query.page == undefined) {
      var page = 0;
    } else {
      var page = req.query.page;
    }
    var page = Math.max(0, parseInt(page));
    var leads = [];
    var filters = [];
    var queries = {};

    if (req.query.query) {
      var specification = {};
      specification["$lookup"] = {
        from: "LeadRemark",
        localField: "remarks",
        foreignField: "_id",
        as: "remarks",
      };
      filters.push(specification);

      req.query.query = req.query.query.replace(
        /([.?*+^$[\]\\(){}|-])/g,
        "\\$1"
      );
      req.query.query.replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1");

      var specification = {};
      specification["$match"] = {
        business: mongoose.Types.ObjectId(business),
        "remark.status": { $in: ["PSF", "Closed", "Rework"] },
        $or: [
          { name: { $regex: req.query.query, $options: "i" } },
          { contact_no: { $regex: req.query.query, $options: "i" } },
          { "remark.reason": { $regex: req.query.query, $options: "i" } },
          {
            remarks: {
              $elemMatch: {
                status: { $regex: req.query.query, $options: "i" },
              },
            },
          },
          {
            remarks: {
              $elemMatch: {
                customer_remark: { $regex: req.query.query, $options: "i" },
              },
            },
          },
          {
            remarks: {
              $elemMatch: {
                assignee_remark: { $regex: req.query.query, $options: "i" },
              },
            },
          },
        ],
      };

      filters.push(specification);

      await Lead.aggregate(filters)
        .allowDiskUse(true)
        .cursor({ batchSize: 20 })
        .exec()
        .eachAsync(async function (lead) {
          var remark = await LeadRemark.findOne({ lead: lead._id })
            .sort({ created_at: -1 })
            .exec();
          var assignee = await User.findById(lead.assignee).exec();

          if (assignee) {
            var a = {
              name: assignee.name,
              email: assignee.email,
              contact_no: assignee.contact_no,
              _id: assignee._id,
              _id: assignee._id,
            };
          } else {
            var a = {
              name: "",
              email: "",
              contact_no: "",
              _id: null,
              _id: null,
            };
          }
          var follow_up = {};
          if (lead.follow_up) {
            follow_up = lead.follow_up;
          }

          var b = await Booking.findOne({ lead: lead._id })
            .populate({ path: "car", select: "title registration_no" })
            .populate({ path: "advisor", select: "name contact_no email" })
            .exec();
          var booking = null;
          var car = null;
          var advisor = null;
          if (b) {
            booking = {
              _id: b._id,
              id: b._id,
              last_job: moment(b.date).tz(req.headers["tz"]).format("lll"),
            };
            // var title = ""
            // var registration_no=""
            // if (b.car) {
            //   title = b.car.title
            //   registration_no=b.car.registration_no
            // }
            // car = {
            //   title: title,
            //   registration_no: registration_no,
            //   // insurance_info :b.car.insurance_info
            // };

            var name = "";
            var contact = "";
            var email = "";
            if (b.advisor) {
              name = b.advisor.name;
              contact = b.advisor.contact_no;
              email = b.advisor.email;
            }
            advisor = {
              name: name,
              contact_no: contact,
              email: email,
            };
          }
          var isStared = false;
          if (lead.isStared) {
            isStared = lead.isStared;
          } else {
            isStared = false;
          }
          leads.push({
            booking: booking,
            // car: car,
            name: lead.name,
            contact_no: lead.contact_no,
            email: lead.email,
            _id: lead._id,
            id: lead.id,
            status: lead.status,
            follow_up: follow_up,
            assignee: a,
            advisor: advisor,
            isStared: isStared,
            created_at: moment(lead.created_at)
              .tz(req.headers["tz"])
              .format("lll"),
            updated_at: moment(lead.updated_at)
              .tz(req.headers["tz"])
              .format("lll"),
          });
        });
      // console.log("Data", JSON.stringify(leads));

      return res.status(200).json({
        responseCode: 200,
        responseInfo: {
          // filters: filters,
          msg: "Filter Leads",
          totalResult: leads.length,
        },
        responseMessage: "",
        totalLeads: leads.length,
        responseData: leads,
      });
    }
    filters = [];
    if (role.role == "CRE") {
      var specification = {};
      specification["assignee"] = mongoose.Types.ObjectId(role.user);
      filters.push(specification);
      var specification = {};
      specification["business"] = mongoose.Types.ObjectId(business);
      filters.push(specification);
    } else if (role.role == "Admin" || role.role == "Manager") {
      var specification = {};
      specification["business"] = mongoose.Types.ObjectId(business);
      filters.push(specification);
    } else {
      var specification = {};
      specification["business"] = mongoose.Types.ObjectId(role.user);
      filters.push(specification);
    }

    if (req.query.status == "Rework") {
      var specification = {};
      specification["remark.status"] = req.query.status;
      filters.push(specification);
    } else if (req.query.status == "PSF") {
      var specification = {};
      specification["remark.status"] = req.query.status;
      specification["follow_up.date"] = { $lte: new Date() };
      filters.push(specification);
    } else if (req.query.status == "Dissatisfied") {
      var specification = {};
      specification["remark.reason"] = req.query.status;
      specification["remark.status"] = "Closed";
      filters.push(specification);
    } else if (req.query.status == "Satisfied") {
      var specification = {};
      specification["remark.reason"] = req.query.status;
      specification["remark.status"] = "Closed";
      filters.push(specification);
    }

    var query = {
      $match: {
        $and: filters,
      },
    };
    // console.log('Filters', filters);

    var total = await Lead.aggregate([query]).exec();
    var sortQuery = { $sort: { updated_at: -1 } };

    await Lead.aggregate([
      query,
      sortQuery,
      { $skip: 10 * page },
      { $limit: 10 },
    ])
      .allowDiskUse(true)
      .cursor({ batchSize: 20 })
      .exec()
      .eachAsync(async function (lead) {
        var remark = await LeadRemark.findOne({ lead: lead._id })
          .sort({ created_at: -1 })
          .exec();
        var assignee = await User.findById(lead.assignee).exec();

        if (assignee) {
          var a = {
            name: assignee.name,
            email: assignee.email,
            contact_no: assignee.contact_no,
            _id: assignee._id,
            _id: assignee._id,
          };
        } else {
          var a = {
            name: "",
            email: "",
            contact_no: "",
            _id: null,
            _id: null,
          };
        }
        var follow_up = {};
        if (lead.follow_up) {
          follow_up = lead.follow_up;
        }

        var b = await Booking.findOne({ lead: lead._id })
          .populate({ path: "car", select: "title registration_no" })
          .populate({ path: "advisor", select: "name contact_no email" })
          .exec();
        var booking = null;
        var car = null;
        var advisor = null;
        if (b) {
          booking = {
            _id: b._id,
            id: b._id,
            last_job: moment(b.date).tz(req.headers["tz"]).format("lll"),
          };
          // car = {
          //   title: b.car.title,
          //   registration_no: b.car.registration_no,
          //   // insurance_info :b.car.insurance_info
          // };
          advisor = {
            name: b.advisor.name,
            contact_no: b.advisor.contact_no,
            email: b.advisor.email,
          };
        }
        var isStared = false;
        if (lead.isStared) {
          isStared = lead.isStared;
        } else {
          isStared = false;
        }
        leads.push({
          booking: booking,
          // car: car,
          name: lead.name,
          contact_no: lead.contact_no,
          email: lead.email,
          _id: lead._id,
          id: lead.id,
          status: lead.status,
          follow_up: follow_up,
          assignee: a,
          advisor: advisor,
          isStared: isStared,
          created_at: moment(lead.created_at)
            .tz(req.headers["tz"])
            .format("lll"),
          updated_at: moment(lead.updated_at)
            .tz(req.headers["tz"])
            .format("lll"),
        });
      });
    // console.log("Data",JSON.stringify(leads))

    res.status(200).json({
      responseCode: 200,
      responseInfo: {
        // filters: filters,
        totalResult: total.length,
      },
      responseMessage: role.role + " Leads",
      totalLeads: leads.length,
      responseData: leads,
    });
  }
);

module.exports = router;
