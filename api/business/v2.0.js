var mongoose = require('mongoose'),
    express = require('express'),
    router = express.Router(),
    config = require('../../config'),
    bcrypt = require('bcrypt-nodejs'),
    assert = require('assert'),
    jwt = require('jsonwebtoken'),
    aws = require('aws-sdk'),
    multerS3 = require('multer-s3'),
    uuidv1 = require('uuid/v1'),
    Validator = require('validatorjs'),
    multer = require('multer'),
    moment = require('moment-timezone'),
    redis = require('redis'),
    FCM = require('fcm-node'),
    q = require('q'),
    xlsxtojson = require("xlsx-to-json-lc"),
    request = require('request');
//webpush = require('web-push');

var s3 = new aws.S3({
    accessKeyId: config.IAM_USER_KEY,
    secretAccessKey: config.IAM_USER_SECRET,
    Bucket: config.BUCKET_NAME
});


var client = redis.createClient({ host: 'localhost', port: 6379 });

const xAccessToken = require('../../middlewares/xAccessTokenBusiness');
const fun = require('../../api/function');
const event = require('../../api/event');

var paytm_config = require('../../paytm/paytm_config').paytm_config;
var paytm_checksum = require('../../paytm/checksum');

var salt = bcrypt.genSaltSync(10);
const User = require('../../models/user');
const BusinessTiming = require('../../models/businessTiming');
const BusinessConvenience = require('../../models/businessConvenience');
const BookingTiming = require('../../models/bookingTiming');
const Type = require('../../models/type');
const BusinessType = require('../../models/businessType');
const Category = require('../../models/category');
const Automaker = require('../../models/automaker');
const Model = require('../../models/model');
const State = require('../../models/state');
const BookingCategory = require('../../models/bookingCategory');
const ProductImage = require('../../models/productImage');
const Country = require('../../models/country');
const BusinessOffer = require('../../models/businessOffer');
const BusinessUser = require('../../models/businessUser');
const ProductOffer = require('../../models/productOffer');
const Order = require('../../models/order');
const BusinessOrder = require('../../models/businessOrder');
const OrderLine = require('../../models/orderLine');
const OrderConvenience = require('../../models/orderConvenience');
const OrderInvoice = require('../../models/orderInvoice');
const BookmarkProduct = require('../../models/bookmarkProduct');
const BookmarkOffer = require('../../models/bookmarkOffer');
const Car = require('../../models/car');
const CarSell = require('../../models/carSell');
const Asset = require('../../models/asset');
const CarImage = require('../../models/carImage');
const CarDocument = require('../../models/carDocument');
const BookmarkCar = require('../../models/bookmarkCar');
const BodyStyle = require('../../models/bodyStyle');
const FuelType = require('../../models/fuelType');
const Transmission = require('../../models/transmission');
const Color = require('../../models/color');
const Owner = require('../../models/owner');
const BusinessGallery = require('../../models/businessGallery');
const Variant = require('../../models/variant');
const ClaimBusiness = require('../../models/claimBusiness');
const Review = require('../../models/review');
const Battery = require('../../models/battery');
const BatteryBrand = require('../../models/batteryBrand');
const TyreSize = require('../../models/tyreSize');
const Booking = require('../../models/booking');
const Lead = require('../../models/lead');
const Service = require('../../models/service');
const Customization = require('../../models/customization');
const Collision = require('../../models/collision');
const Washing = require('../../models/washing');
const ProductCategory = require('../../models/productCategory');
const Product = require('../../models/product');
const ProductBrand = require('../../models/productBrand');
const ProductModel = require('../../models/productModel');
const BusinessProduct = require('../../models/businessProduct');
const LeadRemark = require('../../models/leadRemark');
const LeadStatus = require('../../models/leadStatus');
const Package = require('../../models/package');
const UserPackage = require('../../models/userPackage');
const PackageUsed = require('../../models/packageUsed');
const Management = require('../../models/management');
const LeadManagement = require('../../models/leadManagement');
const Address = require('../../models/address');
const Gallery = require('../../models/gallery');
const Coupon = require('../../models/coupon');
const Detailing = require('../../models/detailing');
const CouponUsed = require('../../models/couponUsed');
const Purchase = require('../../models/purchase');
const PurchaseReturn = require('../../models/purchaseReturn');
const PurchaseOrder = require('../../models/purchaseOrder');
const Tax = require('../../models/tax');
const BusinessVendor = require('../../models/businessVendor');
const JobInspection = require('../../models/jobInspection');
const ClubMember = require('../../models/clubMember');
const InsuranceCompany = require('../../models/insuranceCompany');
const LabourRate = require('../../models/labourRate');
const Point = require('../../models/point');
const QualityCheck = require('../../models/qualityCheck');
const Invoice = require('../../models/invoice');
const Expense = require('../../models/expense');
const Estimate = require('../../models/estimate');
const TransactionLog = require('../../models/transactionLog');
const RFQ = require('../../models/rfq');
const Quotation = require('../../models/quotation');
const BusinessPlan = require('../../models/businessPlan');
const Referral = require('../../models/referral');
const ManagementRole = require('../../models/managementRole');
const Location = require('../../models/location');
const BusinessSetting = require('../../models/businessSetting');
const ExpenseCategory = require('../../models/expenseCategory');
const ReviewPoint = require('../../models/reviewPoint');

var secret = config.secret;

router.post('/short-codes', async function (req, res, next) {
    var last_invoice = "2019-20/787";
    var lst = last_invoice.split('/');
    var fiscalyear = "";
    var today = new Date();

    var thisFullYear = today.getFullYear().toString();
    thisFullYear = thisFullYear.toString();
    var nextFullYear = today.getFullYear() + 1;
    nextFullYear = nextFullYear.toString();

    if ((today.getMonth() + 1) <= 3) {
        fiscalyear = (today.getFullYear() - 1) + "-" + thisFullYear.slice(-2);
    }
    else {
        fiscalyear = today.getFullYear() + "-" + nextFullYear.slice(-2);
    }

    var date = new Date(today.getFullYear() + "-04-01");

    if (lst.length > 0) {
        if (lst[0] == fiscalyear) {
            var match = true;
            var invoice = invNum.next(lst[0] + "/" + lst[1])
        }
        else {
            var match = false;
            var invoice = fiscalyear + "/001"
        }
    }
    else {
        var invoice = invNum.next(fiscalyear + "/000")
    }

    res.json({
        lst: lst[0],
        last_invoice: last_invoice,
        match: match,
        date: date,
        today: today,
        fiscalyear: fiscalyear,
        invoice: invoice
    });
});

router.post('/signup', async function (req, res, next) {
    var rules = {
        contact_no: 'required',
        username: 'required',
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Mobile No. and Username is required",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        if (req.body.email) {
            var checkEmail = await User.find({ email: req.body.email }).count().exec();
        }
        else {
            var checkEmail = 0;
        }

        if (checkEmail) {
            res.status(422).json({
                responseCode: 422,
                responseMessage: "Email already in use.",
                responseData: {},
            });
        }
        else {
            var checkUsername = await User.find({ username: req.body.username }).collation({ locale: 'en', strength: 2 }).exec();
            if (checkUsername.length == 0) {
                var regexp = /^[a-zA-Z0-9._]+$/;
                var check = req.body.username;
                if (check.search(regexp) == -1) {
                    res.status(422).json({
                        responseCode: 422,
                        responseMessage: "Use Only Alphabet, Numbers and dot & underscore",
                        responseData: {},
                    });
                }
                else {
                    var checkPhone = await User.find({ contact_no: req.body.contact_no }).count().exec();
                    if (checkPhone == 0) {

                        var otp = Math.floor(Math.random() * 90000) + 10000;

                        req.body.socialite = {};
                        req.body.optional_info = {};

                        var country = await Country.findOne({ _id: req.body.country }).exec();
                        req.body.address = {
                            country: country.countryName,
                            timezone: req.headers['tz'],
                            location: req.body.location,
                        };

                        req.body.account_info = {
                            type: "business",
                            status: "Complete",
                            phone_verified: false,
                            verified_account: false,
                            approved_by_admin: false,
                        };

                        req.body.geometry = [parseFloat(req.body.longitude), parseFloat(req.body.latitude)];
                        req.body.uuid = uuidv1();
                        req.body.device = [];
                        req.body.otp = otp;

                        req.body.business_info = {
                            business_category: req.body.business_category,
                            company: req.body.company
                        };

                        var firstPart = (Math.random() * 46656) | 0;
                        var secondPart = (Math.random() * 46656) | 0;
                        firstPart = ("000" + firstPart.toString(36)).slice(-3);
                        secondPart = ("000" + secondPart.toString(36)).slice(-3);
                        req.body.referral_code = firstPart.toUpperCase() + secondPart.toUpperCase();


                        User.create(req.body).then(async function (user) {
                            var days = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];

                            for (var i = 0; i < 7; i++) {
                                var timing = new BusinessTiming({
                                    business: user._id,
                                    day: days[i],
                                    open: '09:30 AM',
                                    close: '06:30 PM',
                                    is_closed: false,
                                    created_at: new Date(),
                                    updated_at: new Date(),
                                });
                                timing.save();
                            }

                            Type.find({}).then(function (BT) {
                                BT.forEach(function (u) {
                                    var businessType = new BusinessType({
                                        business: user._id,
                                        business_type: u._id,
                                        is_added: false,
                                    });
                                    businessType.save();
                                });
                            });

                            event.signupSMS(user);
                            //event.otpSms(user);

                            res.status(200).json({
                                responseCode: 200,
                                responseMessage: "success",
                                responseData: {
                                    user: user
                                },
                            });
                        });
                    }
                    else {
                        res.status(400).json({
                            responseCode: 400,
                            responseMessage: "Phone number already in use.",
                            responseData: {},
                        });
                    }
                }
            }
            else {
                res.status(422).json({
                    responseCode: 422,
                    responseMessage: "Username already in use.",
                    responseData: {},
                });
            }
        }
    }
});

router.post('/owner/add', async function (req, res, next) {
    if (req.body.user) {
        var user = await User.findOne({ _id: req.body.user }).exec();
        if (user) {
            res.status(200).json({
                responseCode: 200,
                responseMessage: "success",
                responseData: {
                    _id: user._id,
                    id: user._id,
                    name: user.name,
                    email: user.email,
                    user: user._id,
                    contact_no: user.contact_no
                },
            });
        }
    }
    else {
        var rules = {
            contact_no: 'required',
            name: 'required',
        };

        var validation = new Validator(req.body, rules);

        if (validation.fails()) {
            res.status(422).json({
                responseCode: 422,
                responseMessage: "Mobile No. and name is required",
                responseData: {
                    res: validation.errors.all()
                }
            })
        }
        else {
            var checkPhone = await User.find({ contact_no: req.body.contact_no, "account_info.type": "user" }).count().exec();
            if (checkPhone == 0) {
                var otp = Math.floor(Math.random() * 90000) + 10000;
                req.body.username = shortid.generate();
                req.body.socialite = {};
                req.body.business_info = {};
                req.body.optional_info = {};

                var country = await Country.findOne({ timezone: { $in: req.headers['tz'] } }).exec();
                req.body.address = {
                    country: country.countryName,
                    timezone: req.headers['tz'],
                    location: req.body.location,
                };

                req.body.account_info = {
                    type: "user",
                    status: "Complete",
                    phone_verified: false,
                    verified_account: false,
                    approved_by_admin: false,
                };

                req.body.geometry = [0, 0];

                req.body.device = [];
                req.body.otp = otp;
                req.body.uuid = uuidv1();
                req.body.business_info = {};

                var firstPart = (Math.random() * 46656) | 0;
                var secondPart = (Math.random() * 46656) | 0;
                firstPart = ("000" + firstPart.toString(36)).slice(-3);
                secondPart = ("000" + secondPart.toString(36)).slice(-3);
                req.body.referral_code = firstPart.toUpperCase() + secondPart.toUpperCase();


                User.create(req.body).then(async function (user) {
                    event.signupSMS(user);
                    //event.otpSms(user);

                    res.status(200).json({
                        responseCode: 200,
                        responseMessage: "success",
                        responseData: {
                            _id: user._id,
                            id: user._id,
                            name: user.name,
                            email: user.email,
                            user: user._id,
                            contact_no: user.contact_no
                        },
                    });
                });
            }
            else {
                res.status(422).json({
                    responseCode: 422,
                    responseMessage: "Contact no already exist",
                    responseData: {}
                })
            }
        }
    }
});

router.get('/side-menu/get', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var business = req.headers['business'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var chat = false;
    var loggedInDetails = await User.findById(decoded.user).exec();

    var role = await Management.findOne({ user: decoded.user, business: business })
        .populate({ path: 'business', select: 'name avatar avatar_address contact_no isCarEager uuid business_info' })
        .populate({ path: 'user', select: 'name avatar avatar_address contact_no' })
        .exec();

    if (role) {
        var def = [];
        var main = [];
        var multi = false;

        var plans = await BusinessPlan.find({ business: business }).populate('suite').exec();
        var suite = _.map(plans, 'suite');

        for (var i = 0; i < suite.length; i++) {
            var defaults = suite[i].default;
            for (var j = 0; j < defaults.length; j++) {
                var foundIndex = def.findIndex(x => x.action == defaults[j].action);
                if (foundIndex == -1) {
                    def.push({
                        tag: defaults[j].tag,
                        module: defaults[j].module,
                        action: defaults[j].action,
                        enable: defaults[j].enable,
                        activityTab: defaults[j].activityTab,
                        icon: "https://careager-staging.s3.ap-south-1.amazonaws.com/icon/" + defaults[j].tag + ".svg",
                    })
                }
            }

            var serverTime = moment.tz(new Date(), req.headers['tz']);
            var bar = plans[i].created_at;
            bar.setDate(bar.getDate() + plans[i].validity);
            var e = bar;
            bar = moment.tz(bar, req.headers['tz'])

            var baz = bar.diff(serverTime);

            if (baz > 0) {
                var mains = suite[i].main;
                for (var k = 0; k < mains.length; k++) {
                    var foundIndex = main.findIndex(x => x.action == mains[k].action);
                    if (foundIndex >= 0) {
                        main[foundIndex] = {
                            tag: mains[k].tag,
                            module: mains[k].action,
                            action: mains[k].action,
                            enable: mains[k].enable,
                            activityTab: mains[k].activityTab,
                            icon: "https://careager-staging.s3.ap-south-1.amazonaws.com/icon/" + mains[k].tag + ".svg",
                        }
                    }
                    else {
                        main.push({
                            tag: mains[k].tag,
                            module: mains[k].module,
                            action: mains[k].action,
                            enable: mains[k].enable,
                            activityTab: mains[k].activityTab,
                            icon: "https://careager-staging.s3.ap-south-1.amazonaws.com/icon/" + mains[k].tag + ".svg",
                        })
                    }
                }
            }

            if (suite[i].chat == true) {
                chat = true;
            }
        }

        def = _(def).groupBy(x => x.module).map((value, key) => ({ module: key, group: value })).value();
        def = _.orderBy(def, ['plan'], ['asc']);

        main = _(main).groupBy(x => x.module).map((value, key) => ({ module: key, group: value })).value();
        main = _.orderBy(main, ['plan'], ['asc']);

        var business_info = role.business.business_info;

        var manifest = await BusinessSetting.findOne({ business: business }).exec();
        if (manifest == null) {
            manifest = {
                discount_on: "Labour",
                job_inspection_pics_limit: 13,
                skip_insurance_info: false,
                skip_store_approval: true,
                skip_qc: true,
                gst_invoice: true,
            };
        }

        res.status(200).json({
            responseCode: 200,
            responseMessage: "navigation",
            responseData: {
                business: role.business,
                user: role.user,
                navigation: main.concat(def),
                chat: chat,
                manifest: manifest,
                management: {
                    _id: role._id,
                    id: role.id,
                    role: role.role,
                }
            }
        });
    }
    else {
        res.status(400).json({
            responseCode: 400,
            responseMessage: "Unauthorized",
            responseData: {}
        });
    }
});

router.get('/management/roles/get', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var business = req.headers['business'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    res.status(200).json({
        responseCode: 200,
        responseMessage: "Role",
        responseData: await ManagementRole.find({}).exec()
    })
});

router.post('/management/add', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var business = req.headers['business'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    var rules = {
        name: 'required',
        contact_no: 'required',
        role: 'required',
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Mobile No. is required",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var checkPhone = await User.find({ contact_no: req.body.contact_no, "account_info.type": "business" }).count().exec();
        if (checkPhone == 0) {
            var otp = Math.floor(Math.random() * 90000) + 10000;
            var password = Math.floor(Math.random() * 90000) + 10000;

            req.body.username = shortid.generate();
            req.body.socialite = {};
            req.body.optional_info = {};

            var country = await Country.findOne({ timezone: req.headers['tz'] }).exec();
            req.body.address = {
                country: country.countryName,
                timezone: req.headers['tz'],
                location: req.body.location,
            };

            req.body.account_info = {
                type: "business",
                status: "Complete",
                phone_verified: false,
                verified_account: false,
                approved_by_admin: false,
            };

            req.body.geometry = [0, 0];
            req.body.password = password;
            req.body.device = [];
            req.body.otp = otp;
            req.body.visibility = false
            req.body.uuid = uuidv1();

            req.body.business_info = {
                business_category: '',
                company: ''
            };

            var firstPart = (Math.random() * 46656) | 0;
            var secondPart = (Math.random() * 46656) | 0;
            firstPart = ("000" + firstPart.toString(36)).slice(-3);
            secondPart = ("000" + secondPart.toString(36)).slice(-3);
            req.body.referral_code = firstPart.toUpperCase() + secondPart.toUpperCase();

            User.create(req.body).then(async function (user) {
                Management.create({
                    business: business,
                    user: user._id,
                    department: req.body.department,
                    role: req.body.role,
                    created_at: new Date(),
                    updated_at: new Date()
                });

                event.signupSMS(user);

                res.status(200).json({
                    responseCode: 200,
                    responseMessage: "success",
                    responseData: {
                        user: user
                    },
                });
            });
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Phone number already in use.",
                responseData: {},
            });
        }
    }
});

router.put('/management-info/update', xAccessToken.token, async function (req, res, next) {
    var rules = {
        user: 'required',
        name: 'required',
        contact_no: 'required',
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "All field required",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var token = req.headers['x-access-token'];
        var business = req.headers['business'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var user = await User.findById(req.body.user).exec();
        if (user) {
            var check = await User.findOne({ contact_no: req.body.contact_no, _id: { $ne: user._id }, "account_info.type": user.account_info.type, }).exec();

            if (check) {
                res.status(400).json({
                    responseCode: 400,
                    responseMessage: "Contact no already exist",
                    responseData: {}
                });
            }
            else {
                User.findOneAndUpdate({ _id: user._id }, {
                    $set: {
                        name: req.body.name,
                        contact_no: req.body.contact_no,
                        email: req.body.email,
                        updated_at: new Date()
                    }
                }, { new: false }, function (err, doc) {
                    if (err) {
                        res.status(422).json({
                            responseCode: 422,
                            responseMessage: "Error Occurred",
                            responseData: err,
                        });
                    }
                    else {

                        Management.findOneAndUpdate({ user: user._id, business: business }, {
                            $set: {
                                department: req.body.department,
                                role: req.body.role,
                                updated_at: new Date()
                            }
                        }, { new: false }, function (err, doc) {
                            if (err) {
                                res.status(422).json({
                                    responseCode: 422,
                                    responseMessage: "Error Occurred",
                                    responseData: err,
                                });
                            }
                            else {
                                res.status(200).json({
                                    responseCode: 200,
                                    responseMessage: "User details updated...",
                                    responseData: {},
                                })
                            }

                        });
                    }

                });
            }
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "User not found",
                responseData: {},
            })
        }
    }
});

router.delete('/management/remove', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var business = req.headers['business'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    var rules = {
        user: 'required',
    };

    var validation = new Validator(req.query, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Employee Required",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var role = await Management.findOne({ user: req.query.user, business: business }).exec();
        if (role) {
            if (!role.business.equals(req.query.user)) {
                return res.status(422).json({
                    responseCode: 422,
                    responseMessage: "Server Error",
                    responseData: {}
                });

                User.findOneAndUpdate({ _id: req.query.user }, { $set: { "account_info.type": "deleted", "account_info.status": "Deleted" } }, { new: true }, async function (err, doc) {
                    if (err) {
                        res.status(422).json({
                            responseCode: 422,
                            responseMessage: "Server Error",
                            responseData: err
                        })
                    }
                    else {
                        await Management.remove({ user: req.query.user, business: business }).exec();
                        res.status(200).json({
                            responseCode: 200,
                            responseMessage: "Removed Successfully",
                            responseData: {}
                        })
                    }
                });
            }
            else {
                res.status(400).json({
                    responseCode: 400,
                    responseMessage: "User not found",
                    responseData: {},
                });
            }
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "User not found",
                responseData: {},
            });
        }
    }
});

router.get('/managements/get/', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    var business = req.headers['business'];

    var managements = [];

    if (req.query.page == undefined) {
        var page = 0;
    } else {
        var page = req.query.page;
    }

    var page = Math.max(0, parseInt(page));

    await Management.find({ business: business, user: { $ne: business } })
        .populate({ path: 'user', select: '_id id name contact_no avatar avatar_address email' })
        .sort({ created_at: -1 }).skip(config.perPage * page).limit(config.perPage)
        .cursor().eachAsync(async (management) => {

            managements.push({
                id: management.user._id,
                name: management.user.name,
                role: management.role,
                department: management.department,
                username: management.user.username,
                email: management.user.email,
                contact_no: management.user.contact_no,
                avatar: management.user.avatar,
                avatar_address: management.user.avatar_address,
            });

        });

    res.status(200).json({
        responseCode: 200,
        responseMessage: "Analytics",
        responseData: managements
    });
});

router.get('/chat/leads/add', async function (req, res, next) {
    var business = req.headers['business'];
    var user = await User.findById(req.query.id).exec();
    if (user) {
        var checklead = await Lead.findOne({ contact_no: user.contact_no, business: business, "remark.status": { $in: ["Open", "Follow-Up"] } }).sort({ updated_at: -1 }).exec();

        if (checklead) {
            Lead.findOneAndUpdate({ _id: checklead._id }, {
                $set: {
                    "remark.status": "Open",
                    "type": "Booking",
                    "source": "Chat",
                    "remark.source": "Chat",
                    updated_at: new Date(),
                }
            }, { new: false }, async function (err, doc) {
            });
        }
        else {
            var data = {}
            var manager = business;

            var status = await LeadStatus.findOne({ status: "Open" }).exec();

            var managers = [];
            await Management.find({ business: business, role: "CRE" })
                .cursor().eachAsync(async (a) => {
                    var d = await Lead.find({ business: business, assignee: a.user }).count().exec();
                    managers.push({
                        user: a.user,
                        count: d
                    })
                });

            if (managers.length != 0) {
                managers.sort(function (a, b) {
                    return a.count > b.count;
                });

                manager = managers[0].user;
            }

            data.user = user._id;
            data.business = business;
            data.name = user.name;
            data.contact_no = user.contact_no;
            data.email = user.email;
            data.assignee = manager;
            data.type = "Chat";
            data.geometry = [0, 0];
            data.follow_up = null;
            data.source = "Chat",
                data.remark = {
                    status: req.body.status,
                    customer_remark: "",
                    assignee_remark: "",
                    assignee: manager,
                    color_code: "",
                    created_at: new Date(),
                    updated_at: new Date()
                };
            data.created_at = new Date();
            data.updated_at = new Date();

            Lead.create(data).then(async function (lead) {
                var count = await Lead.find({ _id: { $lt: l._id }, business: business }).count();
                var lead_id = count + 10000;

                Lead.findOneAndUpdate({ _id: l._id }, { $set: { lead_id: lead_id } }, { new: true }, async function (err, doc) {
                })
                var status = await LeadStatus.findOne({ status: "Open" }).exec();
                LeadRemark.create({
                    lead: lead._id,
                    type: "Chat",
                    source: req.headers['devicetype'],
                    status: req.body.status,
                    customer_remark: "",
                    assignee_remark: "",
                    assignee: manager,
                    color_code: "",
                    created_at: new Date(),
                    updated_at: new Date()
                }).then(function (newRemark) {
                    Lead.findOneAndUpdate({ _id: lead._id }, { $push: { remarks: newRemark._id } }, { new: true }, async function (err, doc) {
                    })
                });

                event.assistance(lead, req.headers['tz'])

                res.status(200).json({
                    responseCode: 200,
                    responseMessage: "",
                    responseData: {}
                })
            });
        }
    }
    else {
        var json = ({
            responseCode: 400,
            responseMessage: "Invalid user",
            responseData: {}
        });

        res.status(400).json(json)
    }
});

router.get('/lead/status/get', xAccessToken.token, async function (req, res, next) {
    var leads = [];
    var status = await LeadStatus.findOne({ stage: req.query.stage }).exec();
    if (status) {
        res.status(200).json({
            responseCode: 200,
            responseMessage: "success",
            responseData: status.status
        });
    }
    else {
        res.status(200).json({
            responseCode: 200,
            responseMessage: "success",
            responseData: []
        });
    }
});

router.get('/lead/category/get', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var business = req.headers['business'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    var loggedInDetails = await User.findById(decoded.user).exec();
    var plans = await BusinessPlan.find({ business: business }).populate('suite').exec();
    var suite = _.map(plans, 'suite');
    var def = [];
    for (var i = 0; i < suite.length; i++) {
        var serverTime = moment.tz(new Date(), req.headers['tz']);
        var bar = plans[i].created_at;
        bar.setDate(bar.getDate() + plans[i].validity);
        var e = bar;
        bar = moment.tz(bar, req.headers['tz'])

        var baz = bar.diff(serverTime);
        if (baz > 0) {
            var defaults = suite[i].default;
            for (var j = 0; j < defaults.length; j++) {
                if (defaults[j].action == "Leads") {
                    var newArr = defaults[j].category;
                    def = _.concat(def, newArr);
                }
            }
        }
    }

    res.status(200).json({
        responseCode: 200,
        responseMessage: "navigation",
        responseData: _.uniq(def)
    });
});

router.get('/lead/tabs/get', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var business = req.headers['business'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    var loggedInDetails = await User.findById(decoded.user).exec();
    var plans = await BusinessPlan.find({ business: business }).populate('suite').exec();
    var suite = _.map(plans, 'suite');
    var def = [];
    for (var i = 0; i < plans.length; i++) {
        var serverTime = moment.tz(new Date(), req.headers['tz']);
        var bar = plans[i].created_at;
        bar.setDate(bar.getDate() + plans[i].validity);
        var e = bar;
        bar = moment.tz(bar, req.headers['tz'])

        var baz = bar.diff(serverTime);
        if (baz > 0) {
            var defaults = suite[i].default;
            for (var j = 0; j < defaults.length; j++) {
                if (defaults[j].action == "Leads") {
                    var newArr = defaults[j].activityTab;
                    def = _.concat(def, newArr);
                }
            }
        }
    }

    var def = _.uniqBy(def, function (o) {
        return o.activity;
    });

    res.status(200).json({
        responseCode: 200,
        responseMessage: "navigation",
        responseData: def
    });
});

router.post('/lead/add', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var business = req.headers['business'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    var loggedInDetails = await User.findById(decoded.user).exec();
    var role = await Management.findOne({ user: decoded.user, business: business }).exec();

    if (req.body.contact_no) {
        var last = await Lead.findOne({ contact_no: req.body.contact_no, business: business, "remark.status": { $in: ["Open", "Follow-Up"] } }).sort({ updated_at: -1 }).exec();
    }
    else {
        var last = null
    }

    var assignee = await q.all(getAssignee(decoded.user, business));

    if (last) {
        return res.status(422).json({
            responseCode: 422,
            responseMessage: "Lead already exist #" + last.lead_id + " [" + last.remark.status + "]",
            responseData: {}
        });
    }
    else {
        var data = {}
        var status = await LeadStatus.findOne({ status: req.body.status }).exec();
        var follow_up = {};
        var advisor = null;


        if (req.body.status == "Follow-Up") {
            if (req.body.date) {
                var follow_up = {
                    date: new Date(req.body.date).toISOString(),
                    time: req.body.time,
                    created_at: new Date(),
                    updated_at: new Date()
                }
            }
        }

        var contacted = false;

        if (req.body.contacted) {
            contacted = true;
        }

        var priority = 2;

        if (req.body.priority) {
            if (parseInt(req.body.priority)) {
                priority = req.body.priority;
            }
            else {
                priority = 2;
            }
        }

        var checkUser = await User.findOne({ contact_no: req.body.contact_no, "account_info.type": "user" }).exec();
        if (checkUser) {
            var user = checkUser._id;
            var name = checkUser.name;
            var contact_no = checkUser.contact_no;
            var email = checkUser.email;
        }
        else {
            var user = null;
            var name = req.body.name;
            var contact_no = req.body.contact_no;
            var email = req.body.email;
        }

        var remark = {
            assignee: assignee,
            status: req.body.status,
            reason: req.body.reason,
            customer_remark: req.body.remark,
            assignee_remark: req.body.remark,
            color_code: "",
            created_at: new Date(),
            updated_at: new Date()
        }

        var category = "Booking";
        if (req.body.category) {
            category = req.body.category;
        }


        var lead = {
            user: user,
            name: name,
            contact_no: contact_no,
            email: email,
            type: req.body.type,
            follow_up: follow_up,
            business: req.headers['business'],
            assignee: assignee,
            source: req.body.source,
            model: req.body.model,
            remark: remark,
            priority: priority,
            category: category,
            created_at: new Date(),
            updated_at: new Date()
        };


        Lead.create(lead).then(async function (l) {
            var count = await Lead.find({ _id: { $lt: l._id }, business: business }).count();
            var lead_id = count + 10000;

            Lead.findOneAndUpdate({ _id: l._id }, { $set: { lead_id: lead_id } }, { new: true }, async function (err, doc) {
            })

            LeadRemark.create({
                lead: l._id,
                source: l.source,
                type: l.type,
                status: l.remark.status,
                reason: req.body.reason,
                customer_remark: req.body.remark,
                assignee_remark: req.body.remark,
                assignee: assignee,
                color_code: "",
                created_at: new Date(),
                updated_at: new Date()
            }).then(function (newRemark) {
                Lead.findOneAndUpdate({ _id: l._id }, { $push: { remarks: newRemark._id } }, { new: true }, async function (err, doc) {
                })
            });

            var lead = await Lead.findById(l._id).populate('assignee').exec();

            var logs = [];
            await LeadRemark.find({ lead: lead._id })
                .populate('assignee')
                .sort({ created_at: -1 })
                .cursor()
                .eachAsync(async (l) => {
                    var assignee = {}
                    if (l.assignee) {
                        assignee = {
                            _id: l.assignee._id,
                            id: l.assignee._id,
                            name: l.assignee.name,
                            email: l.assignee.email,
                            contact_no: l.assignee.contact_no
                        }
                    }


                    logs.push({
                        source: l.source,
                        type: l.type,
                        reason: l.reason,
                        status: l.status,
                        customer_remark: l.customer_remark,
                        assignee_remark: l.assignee_remark,
                        assignee: assignee,
                        color_code: l.color_code,
                        created_at: moment(l.created_at).tz(req.headers['tz']).format('lll'),
                        updated_at: moment(l.updated_at).tz(req.headers['tz']).format('lll'),
                    });
                });


            var push = {
                user: lead.user,
                name: lead.name,
                contact_no: lead.contact_no,
                email: lead.email,
                _id: lead._id,
                id: lead.id,
                priority: lead.priority,
                contacted: lead.contacted,
                type: lead.type,
                lead_id: lead.lead_id,
                date: moment(lead.updated_at).tz(req.headers['tz']).format('lll'),
                source: lead.source,
                status: lead.status,
                important: lead.important,
                follow_up: lead.follow_up,
                remark: lead.remark,
                assignee: {
                    _id: lead.assignee._id,
                    name: lead.assignee.name,
                    contact_no: lead.assignee.contact_no,
                    email: lead.assignee.email,
                    id: lead.assignee.id,
                },
                logs: logs,
                created_at: moment(lead.created_at).tz(req.headers['tz']).format('lll'),
                updated_at: moment(lead.updated_at).tz(req.headers['tz']).format('lll'),
            }


            if (role.role != "CRE") {
                var notify = {
                    receiver: [lead.assignee._id],
                    activity: "lead",
                    tag: "assigned",
                    source: lead._id,
                    sender: loggedInDetails._id,
                    points: 0
                }

                fun.newNotification(notify);
            }


            res.status(200).json({
                responseCode: 200,
                responseMessage: "Lead Added ",
                responseData: push
            });

        });
    }
});

router.put('/lead/edit', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers['business'];
    var bookings = [];
    var totalResult = 0;
    var check = await Lead.findById(req.body.lead).exec();
    if (check) {
        var last = await Lead.findOne({ contact_no: req.body.contact_no, _id: { $ne: req.body.lead }, business: business, "remark.status": { $in: ["Open", "Follow-Up"] } }).sort({ updated_at: -1 }).exec();

        if (last) {
            return res.status(422).json({
                responseCode: 422,
                responseMessage: "Lead already exist #" + last.lead_id + " [" + last.remark.status + "]",
                responseData: {}
            });
        }
        else {
            var token = req.headers['x-access-token'];
            var secret = config.secret;
            var decoded = jwt.verify(token, secret);

            var checkUser = await User.findOne({ contact_no: req.body.contact_no, "account_info.type": "user" }).exec();
            if (checkUser) {
                var user = checkUser._id;
                var name = checkUser.name;
                var contact_no = checkUser.contact_no;
                var email = req.body.email;
            }
            else {
                var user = null;
                var name = req.body.name;
                var contact_no = req.body.contact_no;
                var email = req.body.email;
            }

            var leads = {};

            var data = {
                user: user,
                name: name,
                contact_no: contact_no,
                email: email,
                updated_at: new Date()
            }

            Lead.findOneAndUpdate({ _id: check._id }, { $set: data }, { new: true }, async function (err, doc) {
                var lead = await Lead.findById(req.body.lead).populate('assignee').exec();

                var a = await User.findById(lead.advisor).exec();
                var remark = await LeadRemark.findOne({ lead: lead._id }).sort({ created_at: -1 }).exec();
                var assignee = {
                    name: lead.assignee.name,
                    email: lead.assignee.email,
                    contact_no: lead.assignee.contact_no,
                    _id: lead.assignee._id,
                    _id: lead.assignee._id,
                }

                if (a) {
                    var advisor = {
                        name: a.name,
                        email: a.email,
                        contact_no: a.contact_no,
                        _id: a._id,
                        _id: a._id,
                    }
                }
                else {
                    var advisor = null;
                }

                var push = {
                    _id: lead._id,
                    id: lead.id,
                    user: lead.user,
                    name: lead.name,
                    contact_no: lead.contact_no,
                    email: lead.email,
                    _id: lead._id,
                    id: lead.id,
                    priority: lead.priority,
                    contacted: lead.contacted,
                    type: lead.type,
                    lead_id: lead.lead_id,
                    date: moment(lead.updated_at).tz(req.headers['tz']).format('lll'),
                    source: lead.source,
                    status: lead.status,
                    important: lead.important,
                    follow_up: lead.follow_up,
                    remark: lead.remark,
                    assignee: assignee,
                    advisor: advisor,
                    created_at: moment(lead.created_at).tz(req.headers['tz']).format('lll'),
                    updated_at: moment(lead.updated_at).tz(req.headers['tz']).format('lll'),
                }

                res.status(200).json({
                    responseCode: 200,
                    responseMessage: "Lead Added ",
                    responseData: push
                });

            });
        }
    }
    else {
        res.status(400).json({
            responseCode: 400,
            responseMessage: "Lead not found",
            responseData: {}
        });
    }
});

router.put('/lead/assignee/update', xAccessToken.token, async function (req, res, next) {
    var rules = {
        lead: 'required',
        assignee: 'required'
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Label required",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var user = decoded.user;
        var business = req.headers['business'];
        var bookings = [];
        var totalResult = 0;
        var loggedInDetails = await User.findById(decoded.user).exec();
        var check = await Lead.findById(req.body.lead).exec();
        if (check) {
            var management = await Management.findOne({ user: req.body.assignee, business: business }).populate('user').exec();
            if (management) {
                var leads = {};

                var data = {
                    assignee: management.user._id,
                    updated_at: new Date()
                }

                Lead.findOneAndUpdate({ _id: check._id }, { $set: data }, { new: false }, async function (err, doc) {
                    if (err) {
                        res.status(422).json({
                            responseCode: 422,
                            responseMessage: "Server Error",
                            responseData: err
                        });
                    }
                    else {
                        var booking = await Booking.findOne({ lead: check._id }).populate('manager').exec();
                        if (booking) {
                            Booking.findOneAndUpdate({ _id: booking._id }, {
                                $set: {
                                    manager: management.user._id,
                                    updated_at: new Date()
                                }
                            }, { new: false }, async function (err, doc) {
                                if (err) {
                                    return res.status(422).json({
                                        responseCode: 422,
                                        responseMessage: "Server Error",
                                        responseData: err
                                    });
                                }
                                else {
                                    var activity = management.user.name + " has been assigned";
                                    if (booking.manager) {
                                        activity = booking.manager.name + " has been replaced by " + management.user.name;
                                    }

                                    var activity = {
                                        user: loggedInDetails._id,
                                        name: loggedInDetails.name,
                                        stage: "Updates",
                                        activity: activity,
                                    };

                                    fun.bookingLog(booking._id, activity);
                                }
                            });
                        }

                        LeadRemark.create({
                            lead: check._id,
                            status: check.remark.status,
                            assignee: loggedInDetails._id,
                            customer_remark: "Lead assigned to - " + management.user.name,
                            assignee_remark: "Lead assigned to - " + management.user.name,
                            created_at: new Date(),
                            updated_at: new Date(),
                        }).then(function (newRemark) {
                            Lead.findOneAndUpdate({ _id: check._id }, { $push: { remarks: newRemark._id } }, { new: true }, async function (err, doc) {
                            })
                        });

                        var lead = await Lead.findById(req.body.lead).populate('assignee').exec();
                        var a = await User.findById(lead.advisor).exec();
                        var remark = await LeadRemark.findOne({ lead: lead._id }).sort({ created_at: -1 }).exec();
                        var assignee = {
                            name: lead.assignee.name,
                            email: lead.assignee.email,
                            contact_no: lead.assignee.contact_no,
                            _id: lead.assignee._id,
                            _id: lead.assignee._id,
                        }

                        if (a) {
                            var advisor = {
                                name: a.name,
                                email: a.email,
                                contact_no: a.contact_no,
                                _id: a._id,
                                _id: a._id,
                            }
                        }
                        else {
                            var advisor = null;
                        }

                        var push = {
                            _id: lead._id,
                            id: lead.id,
                            user: lead.user,
                            name: lead.name,
                            contact_no: lead.contact_no,
                            email: lead.email,
                            _id: lead._id,
                            id: lead.id,
                            priority: lead.priority,
                            contacted: lead.contacted,
                            type: lead.type,
                            lead_id: lead.lead_id,
                            date: moment(lead.updated_at).tz(req.headers['tz']).format('lll'),
                            source: lead.source,
                            status: lead.status,
                            important: lead.important,
                            follow_up: lead.follow_up,
                            remark: lead.remark,
                            assignee: assignee,
                            advisor: advisor,
                            created_at: moment(lead.created_at).tz(req.headers['tz']).format('lll'),
                            updated_at: moment(lead.updated_at).tz(req.headers['tz']).format('lll'),
                        }

                        res.status(200).json({
                            responseCode: 200,
                            responseMessage: "Lead Added ",
                            responseData: push
                        });
                    }
                });
            }
            else {
                res.status(400).json({
                    responseCode: 400,
                    responseMessage: "User not found",
                    responseData: {}
                });
            }
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Lead not found",
                responseData: {}
            });
        }
    }
});

router.put('/lead/remark/update', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers['business'];
    var bookings = [];
    var totalResult = 0;
    var rules = {
        lead: 'required'
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Label required",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var role = await Management.findOne({ user: user, business: business }).exec();

        var lead = await Lead.findOne({ business: business, _id: req.body.lead }).exec();
        var loggedInDetails = await User.findById(decoded.user).exec();
        if (lead) {
            var advisor = null;
            if (lead.advisor) {
                advisor = lead.advisor;
            }
            var data = {};
            var follow_up = {};
            var status = await LeadStatus.findOne({ status: req.body.status }).exec();

            if (req.body.reason) {
                var reason = req.body.reason;
            }
            else {
                if (req.body.status == "Closed") {
                    var reason = "Info Only";
                }
                else {
                    var reason = "";
                }
            }

            if (req.body.status == "Follow-Up" || req.body.status == "PSF") {
                if (req.body.date) {
                    var follow_up = {
                        date: new Date(req.body.date).toISOString(),
                        time: req.body.time,
                        created_at: new Date(),
                        updated_at: new Date()
                    }
                }
            }

            if (req.body.status == "Follow-Up") {
                if (req.body.date) {
                    var follow_up = {
                        date: new Date(req.body.date).toISOString(),
                        time: req.body.time,
                        created_at: new Date(),
                        updated_at: new Date()
                    }
                }
            }


            if (req.body.advisor) {
                var checkAdvisor = await Management.findOne({ user: req.body.advisor, business: business }).exec();
                if (checkAdvisor) {
                    var advisor = checkAdvisor.user;
                }
                else {
                    return res.status(400).json({
                        responseCode: 400,
                        responseMessage: "Unauthorized",
                        responseData: {}
                    });
                }
            }

            data = {
                updated_at: new Date(),
                remark: {
                    lead: lead._id,
                    status: req.body.status,
                    reason: reason,
                    color_code: "",
                    assignee: user,
                    customer_remark: req.body.remark,
                    assignee_remark: req.body.remark,
                    created_at: new Date(),
                    updated_at: new Date(),
                },
                advisor: advisor,
                follow_up: follow_up,
            };

            Lead.findOneAndUpdate({ _id: req.body.lead }, { $set: data }, { new: false }, async function (err, doc) {
                if (err) {
                    res.status(422).json({
                        responseCode: 422,
                        responseMessage: "Server Error",
                        responseData: err
                    });
                }
                else {
                    data.remark.lead = req.body.lead;
                    data.created_at = new Date();

                    LeadRemark.create(data.remark).then(function (newRemark) {
                        Lead.findOneAndUpdate({ _id: req.body.lead }, { $push: { remarks: newRemark._id } }, { new: true }, async function (err, doc) {
                        })
                    });

                    /*if(!loggedInDetails._id.equals(lead.assignee))
                    {
                        var notify = {
                            receiver: [lead.assignee],
                            activity: "lead",
                            tag: "RemarkUpdate",
                            source: req.body.lead,
                            sender: loggedInDetails._id,
                            points: 0
                        }

                        fun.newNotification(notify);
                    }*/


                    var lead = await Lead.findById(req.body.lead).populate('assignee').exec();
                    var a = await User.findById(lead.advisor).exec();

                    var assignee = {
                        name: lead.assignee.name,
                        email: lead.assignee.email,
                        contact_no: lead.assignee.contact_no,
                        _id: lead.assignee._id,
                        _id: lead.assignee._id,
                    }

                    if (a) {
                        var advisor = {
                            name: a.name,
                            email: a.email,
                            contact_no: a.contact_no,
                            _id: a._id,
                            _id: a._id,
                        }

                    }
                    else {
                        var advisor = null;
                    }

                    var push = {
                        user: lead.user,
                        name: lead.name,
                        contact_no: lead.contact_no,
                        email: lead.email,
                        _id: lead._id,
                        id: lead.id,
                        priority: lead.priority,
                        contacted: lead.contacted,
                        type: lead.type,
                        lead_id: lead.lead_id,
                        date: moment(lead.updated_at).tz(req.headers['tz']).format('lll'),
                        source: lead.source,
                        status: lead.status,
                        important: lead.important,
                        follow_up: lead.follow_up,
                        remark: lead.remark,
                        assignee: assignee,
                        advisor: advisor,
                        created_at: moment(lead.created_at).tz(req.headers['tz']).format('lll'),
                        updated_at: moment(lead.updated_at).tz(req.headers['tz']).format('lll'),
                    }

                    res.status(200).json({
                        responseCode: 200,
                        responseMessage: "Lead Updated",
                        responseData: push
                    });
                }
            });
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Lead not found",
                responseData: {
                }
            })
        }
    }
});

router.put('/lead/priority/update', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers['business'];
    var bookings = [];
    var totalResult = 0;
    var rules = {
        lead: 'required'
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Label required",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var check = await Lead.findOne({ business: business, _id: req.body.lead }).exec();
        if (check) {
            var data = {
                updated_at: new Date(),
                priority: parseInt(req.body.priority)
            };



            Lead.findOneAndUpdate({ _id: req.body.lead }, { $set: data }, { new: false }, async function (err, doc) {
                if (err) {
                    res.status(422).json({
                        responseCode: 422,
                        responseMessage: "Server Error",
                        responseData: err
                    });
                }
                else {
                    if (parseInt(req.body.priority) == 1) {
                        var tag = "Low";
                    }
                    else if (parseInt(req.body.priority) == 2) {
                        var tag = "Medium";
                    }
                    else if (parseInt(req.body.priority) == 3) {
                        var tag = "High";
                    }

                    LeadRemark.create({
                        lead: check._id,
                        reason: check.remark.reason,
                        status: check.remark.status,
                        color_code: check.remark.color_code,
                        assignee: user,
                        customer_remark: "Priority changes to - " + tag,
                        assignee_remark: "Priority changes to - " + tag,
                        created_at: new Date(),
                        updated_at: new Date(),
                    }).then(function (newRemark) {
                        Lead.findOneAndUpdate({ _id: check._id }, { $push: { remarks: newRemark._id } }, { new: true }, async function (err, doc) {
                        })
                    });

                    res.status(200).json({
                        responseCode: 200,
                        responseMessage: "Lead Updated",
                        responseData: {}
                    });
                }
            });
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Lead not found",
                responseData: {
                }
            })
        }
    }
});

router.put('/lead/category/update', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers['business'];
    var bookings = [];
    var totalResult = 0;
    var rules = {
        lead: 'required'
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Label required",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var check = await Lead.findOne({ business: business, _id: req.body.lead }).exec();
        if (check) {
            var data = {
                updated_at: new Date(),
                category: req.body.category
            };


            Lead.findOneAndUpdate({ _id: req.body.lead }, { $set: data }, { new: false }, async function (err, doc) {
                if (err) {
                    res.status(422).json({
                        responseCode: 422,
                        responseMessage: "Server Error",
                        responseData: err
                    });
                }
                else {
                    LeadRemark.create({
                        lead: check._id,
                        reason: check.remark.reason,
                        status: check.remark.status,
                        color_code: check.remark.color_code,
                        assignee: user,
                        customer_remark: "Category changes to - " + req.body.category,
                        assignee_remark: "Category changes to - " + req.body.category,
                        created_at: new Date(),
                        updated_at: new Date(),
                    }).then(function (newRemark) {
                        Lead.findOneAndUpdate({ _id: check._id }, { $push: { remarks: newRemark._id } }, { new: true }, async function (err, doc) {
                        })
                    });

                    res.status(200).json({
                        responseCode: 200,
                        responseMessage: "Lead Updated",
                        responseData: {}
                    });
                }
            });
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Lead not found",
                responseData: {
                }
            })
        }
    }
});

router.put('/lead/contacted/update', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers['business'];
    var bookings = [];
    var totalResult = 0;
    var rules = {
        lead: 'required',
        contacted: 'required',
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Label required",
            responseData: {
                res: validation.errors.all()
            }
        });
    }
    else {
        var check = await Lead.findOne({ business: business, _id: req.body.lead }).exec();
        if (check) {
            var data = {
                updated_at: new Date(),
                contacted: JSON.parse(req.body.contacted)
            };

            Lead.findOneAndUpdate({ _id: req.body.lead }, { $set: data }, { new: false }, async function (err, doc) {
                if (err) {
                    res.status(422).json({
                        responseCode: 422,
                        responseMessage: "Server Error",
                        responseData: err
                    });
                }
                else {
                    if (req.body.contacted == true) {
                        var tag = "Contacted";
                    }
                    else {
                        var tag = "Not Contacted";
                    }


                    LeadRemark.create({
                        lead: check._id,
                        reason: check.remark.reason,
                        status: check.remark.status,
                        color_code: check.remark.color_code,
                        assignee: user,
                        customer_remark: tag,
                        assignee_remark: tag,
                        created_at: new Date(),
                        updated_at: new Date(),
                    }).then(function (newRemark) {
                        Lead.findOneAndUpdate({ _id: check._id }, { $push: { remarks: newRemark._id } }, { new: true }, async function (err, doc) {
                        })
                    });

                    res.status(200).json({
                        responseCode: 200,
                        responseMessage: "Lead Updated",
                        responseData: {}
                    });
                }
            });
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Lead not found",
                responseData: {
                }
            })
        }
    }
});

router.get('/leads/get', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers['business'];
    var bookings = [];
    var totalResult = 0;

    var role = await Management.findOne({ user: user, business: business }).exec();
    if (req.query.page == undefined) {
        var page = 0;
    }
    else {
        var page = req.query.page;
    }

    var page = Math.max(0, parseInt(page));
    var leads = [];
    var filters = [];
    var queries = {};





    if (req.query.query) {
        var specification = {};
        specification['$lookup'] = {
            from: "LeadRemark",
            localField: "remarks",
            foreignField: "_id",
            as: "remarks",
        };
        filters.push(specification);


        var specification = {};
        specification['$match'] = {
            business: mongoose.Types.ObjectId(business),
            $or: [
                { 'name': { $regex: req.query.query, $options: 'i' } },
                { 'contact_no': { $regex: req.query.query, $options: 'i' } },
                {
                    "remarks": {
                        $elemMatch: {
                            "status": { $regex: req.query.query, $options: 'i' }
                        }
                    }
                },
                {
                    "remarks": {
                        $elemMatch: {
                            "customer_remark": { $regex: req.query.query, $options: 'i' }
                        }
                    }
                },
                {
                    "remarks": {
                        $elemMatch: {
                            "assignee_remark": { $regex: req.query.query, $options: 'i' }
                        }
                    }
                },
            ]
        };

        filters.push(specification)

        await Lead.aggregate(filters)
            .allowDiskUse(true)
            .cursor({ batchSize: 20 })
            .exec()
            .eachAsync(async function (lead) {
                var remark = await LeadRemark.findOne({ lead: lead._id }).sort({ created_at: -1 }).exec();
                var assignee = await User.findById(lead.assignee).exec();

                if (assignee) {
                    var a = {
                        name: assignee.name,
                        email: assignee.email,
                        contact_no: assignee.contact_no,
                        _id: assignee._id,
                        _id: assignee._id,
                    }
                }
                else {
                    var a = {
                        name: "",
                        email: "",
                        contact_no: "",
                        _id: null,
                        _id: null,
                    }
                }

                if (lead.follow_up == null) {
                    var follow_up = {}
                } else {
                    follow_up = lead.follow_up
                }

                var l = lead.remark;

                if (l) {
                    if (l.assignee_remark == "") {
                        l.assignee_remark = l.customer_remark
                    }
                    var remark = {
                        source: l.source,
                        type: l.type,
                        reason: l.reason,
                        status: l.status,
                        customer_remark: l.customer_remark,
                        assignee_remark: l.assignee_remark,
                        assignee: a,
                        color_code: l.color_code,
                        created_at: moment(l.created_at).tz(req.headers['tz']).format('lll'),
                        updated_at: moment(l.updated_at).tz(req.headers['tz']).format('lll'),
                    }
                }

                var b = await Booking.findOne({ lead: lead._id }).exec();
                var booking = null
                if (b) {
                    booking = b._id
                }

                var category = "";
                if (lead.category) {
                    category = lead.category;
                }

                leads.push({
                    booking: booking,
                    user: lead.user,
                    name: lead.name,
                    contact_no: lead.contact_no,
                    email: lead.email,
                    _id: lead._id,
                    id: lead.id,
                    priority: lead.priority,
                    contacted: lead.contacted,
                    type: lead.type,
                    lead_id: lead.lead_id,
                    geometry: lead.geometry,
                    date: moment(lead.updated_at).tz(req.headers['tz']).format('lll'),
                    status: lead.status,
                    source: lead.source,
                    important: lead.important,
                    follow_up: follow_up,
                    remark: remark,
                    assignee: a,
                    category: category,
                    created_at: moment(lead.created_at).tz(req.headers['tz']).format('lll'),
                    updated_at: moment(lead.updated_at).tz(req.headers['tz']).format('lll'),
                });
            });

        return res.status(200).json({
            responseCode: 200,
            responseInfo: {
                filters: filters,
                totalResult: leads.length
            },
            responseMessage: "",
            responseData: leads,

        });
    }

    filters = [];

    if (req.query.by == "filter") {
        if (role.role == "CRE") {
            var specification = {};
            specification["assignee"] = mongoose.Types.ObjectId(role.user)
            filters.push(specification);
        }
        else {
            var specification = {};
            specification["business"] = mongoose.Types.ObjectId(business)
            filters.push(specification);
        }

        if (req.query.status != "#") {
            if (req.query.status == "All") {
                var date = new Date();
                if (req.query.date) {
                    date = new Date(req.query.date);
                }

                /*var specification = {};
                specification['follow_up.date'] = { $lte: date };
                filters.push(specification);*/
            }

            else if (req.query.status == "Follow-Up") {
                var specification = {};
                specification["remark.status"] = req.query.status;
                if (req.query.date) {
                    var date = new Date(req.query.date);
                    var newDate = moment(date, "DD-MM-YYYY").add(1, 'days').toDate();
                    specification['follow_up.date'] = { $gte: new Date(date), $lt: new Date(newDate) };
                }


                filters.push(specification);
            }

            else if (req.query.status == "PSF") {
                var specification = {};
                specification["remark.status"] = req.query.status;
                if (req.query.date) {
                    /*var date= new Date(req.query.date);
                    var newDate = moment(date, "DD-MM-YYYY").add(1, 'days').toDate();
                    specification['follow_up.date'] = {$gte: new Date(date),$lt: new Date(newDate)};*/
                }

                filters.push(specification);
            }

            else if (req.query.status == "Closed") {
                var specification = {};
                specification["remark.status"] = req.query.status;
                if (req.query.date) {
                    var date = new Date(req.query.date);
                    var newDate = moment(date, "DD-MM-YYYY").add(1, 'days');
                    specification['updated_at'] = { $gte: new Date(date), $lt: new Date(newDate) };
                }


                if (req.query.reason) {
                    specification['remark.reason'] = req.query.reason;
                }


                filters.push(specification);
            }

            else if (req.query.status == "Lost") {
                var specification = {};
                var date = new Date();
                specification["remark.status"] = req.query.status;
                if (req.query.date) {
                    var date = new Date(req.query.date);
                    var newDate = moment(date, "DD-MM-YYYY").add(1, 'days');
                    specification['updated_at'] = { $gte: new Date(date), $lt: new Date(newDate) };
                }

                if (req.query.reason) {
                    specification['remark.reason'] = req.query.reason;
                }


                filters.push(specification);
            }
        }

        if (req.query.priority) {
            var priority = parseInt(req.query.priority);
            if (priority == 0) {
                var specification = {};
                specification['priority'] = { $in: [1, 2, 3] };
                filters.push(specification);
            }
            else {
                var specification = {};
                specification['priority'] = { $in: [1, 2, 3] };
                //specification['priority'] = priority;
                filters.push(specification);
            }
        }

        var query = {
            "$match": {
                "$and": filters
            }
        }
    }
    else {
        if (role.role == "CRE") {
            var specification = {};
            specification["assignee"] = mongoose.Types.ObjectId(role.user)
            filters.push(specification);
        }

        if (role.role == "Admin") {
            var specification = {};
            specification["business"] = mongoose.Types.ObjectId(business)
            filters.push(specification);
        }

        if (req.query.status != "#") {
            var status = req.query.status;
            if (status == "All") {
                var specification = {};
                var dateString = moment(new Date()).tz(req.headers['tz']).format('YYYY-MM-DD');
                specification['follow_up.date'] = { $lte: new Date() };
                filters.push(specification);
            }
            else if (status == "Follow-Up") {
                var specification = {};
                var dateString = moment(new Date()).tz(req.headers['tz']).format('YYYY-MM-DD');
                specification["remark.status"] = req.query.status;
                specification['follow_up.date'] = { $lte: new Date() };
                filters.push(specification);
            }
            else if (status == "PSF") {
                var specification = {};
                var dateString = moment(new Date()).tz(req.headers['tz']).format('YYYY-MM-DD');
                specification["remark.status"] = req.query.status;
                specification['follow_up.date'] = { $lte: new Date() };
                filters.push(specification);
            }
            else {
                var specification = {};
                specification["remark.status"] = status;
                filters.push(specification);
            }
        }

        var query = {
            "$match": {
                "$and": filters
            }
        }
    }

    /// console.log(query)

    var total = await Lead.aggregate([query]).exec();

    await Lead.aggregate([
        query,
        { $sort: { updated_at: -1 } },
        { $skip: 10 * page },
        { $limit: 10 }
    ])
        .allowDiskUse(true)
        .cursor({ batchSize: 20 })
        .exec()
        .eachAsync(async function (lead) {
            var remark = await LeadRemark.findOne({ lead: lead._id }).sort({ created_at: -1 }).exec();
            var assignee = await User.findById(lead.assignee).exec();

            if (assignee) {
                var a = {
                    name: assignee.name,
                    email: assignee.email,
                    contact_no: assignee.contact_no,
                    _id: assignee._id,
                    _id: assignee._id,
                }
            }
            else {
                var a = {
                    name: "",
                    email: "",
                    contact_no: "",
                    _id: null,
                    _id: null,
                }
            }

            if (lead.follow_up == null) {
                var follow_up = {}
            } else {
                follow_up = lead.follow_up
            }

            var l = lead.remark;

            if (l) {
                if (l.assignee_remark == "") {
                    l.assignee_remark = l.customer_remark
                }
                var remark = {
                    source: l.source,
                    type: l.type,
                    reason: l.reason,
                    status: l.status,
                    customer_remark: l.customer_remark,
                    assignee_remark: l.assignee_remark,
                    assignee: a,
                    color_code: l.color_code,
                    created_at: moment(l.created_at).tz(req.headers['tz']).format('lll'),
                    updated_at: moment(l.updated_at).tz(req.headers['tz']).format('lll'),
                }
            }

            var b = await Booking.findOne({ lead: lead._id }).exec();
            var booking = null
            if (b) {
                booking = b._id
            }

            var category = "";
            if (lead.category) {
                category = lead.category;
            }

            leads.push({
                booking: booking,
                user: lead.user,
                name: lead.name,
                contact_no: lead.contact_no,
                email: lead.email,
                _id: lead._id,
                id: lead.id,
                priority: lead.priority,
                contacted: lead.contacted,
                type: lead.type,
                lead_id: lead.lead_id,
                geometry: lead.geometry,
                date: moment(lead.updated_at).tz(req.headers['tz']).format('lll'),
                status: lead.status,
                source: lead.source,
                important: lead.important,
                follow_up: follow_up,
                remark: remark,
                assignee: a,
                category: category,
                created_at: moment(lead.created_at).tz(req.headers['tz']).format('lll'),
                updated_at: moment(lead.updated_at).tz(req.headers['tz']).format('lll'),
            });
        });

    res.status(200).json({
        responseCode: 200,
        responseInfo: {
            totalResult: total.length
        },
        responseMessage: role.role + " Leads",
        responseData: leads,

    });
});

router.get('/lead/details/get', xAccessToken.token, async function (req, res, next) {
    var rules = {
        lead: 'required'
    };

    var validation = new Validator(req.query, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "lead required",
            responseData: {
                res: validation.errors.all()
            }
        });
    }
    else {
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var user = decoded.user;
        var business = req.headers['business'];
        var bookings = [];
        var totalResult = 0;

        var lead = await Lead.findById(req.query.lead).populate('assignee').populate('advisor').exec();

        if (lead) {
            var a = lead.advisor;
            var logs = [];
            await LeadRemark.find({ lead: lead._id })
                .populate('assignee')
                .sort({ created_at: -1 })
                .cursor()
                .eachAsync(async (l) => {

                    if (l.assignee_remark == "") {
                        l.assignee_remark = l.customer_remark
                    }

                    if (l.assignee) {
                        var assignee = {
                            _id: l.assignee._id,
                            id: l.assignee._id,
                            name: l.assignee.name,
                            email: l.assignee.email,
                            contact_no: l.assignee.contact_no,
                        };
                    }
                    else {
                        var assignee = {
                            _id: "",
                            id: "",
                            name: "",
                            email: "",
                            contact_no: "",
                        };
                    }

                    logs.push({
                        source: l.source,
                        type: l.type,
                        status: l.status,
                        reason: l.reason,
                        customer_remark: l.customer_remark,
                        assignee_remark: l.assignee_remark,
                        assignee: assignee,
                        color_code: l.color_code,
                        created_at: moment(l.created_at).tz(req.headers['tz']).format('lll'),
                        updated_at: moment(l.updated_at).tz(req.headers['tz']).format('lll'),
                    })
                })

            if (lead.assignee) {
                var assignee = {
                    name: lead.assignee.name,
                    email: lead.assignee.email,
                    contact_no: lead.assignee.contact_no,
                    _id: lead.assignee._id,
                    id: lead.assignee._id,
                }
            }
            else {
                var assignee = {
                    name: "",
                    email: "",
                    contact_no: "",
                    _id: null,
                    id: null,
                }
            }


            if (lead.follow_up == null) {
                var follow_up = {}
            }
            else {
                follow_up = lead.follow_up
            }

            var last_active = "";
            if (lead.user) {
                var get_last_active = await User.findById(lead.user).exec();
                if (get_last_active) {
                    last_active = moment(get_last_active.updated_at).tz(req.headers['tz']).format('lll');
                }
            }

            var b = await Booking.findOne({ lead: lead._id }).sort({ updated_at: -1 }).exec();
            var booking = null
            if (b) {
                booking = b._id
            }


            var push = {
                booking: booking,
                user: lead.user,
                name: lead.name,
                contact_no: lead.contact_no,
                email: lead.email,
                _id: lead._id,
                id: lead.id,
                priority: lead.priority,
                category: lead.category,
                type: lead.type,
                lead_id: lead.lead_id,
                date: moment(lead.updated_at).tz(req.headers['tz']).format('lll'),
                source: lead.source,
                status: lead.status,
                important: lead.important,
                follow_up: follow_up,
                remark: lead.remark,
                psf: lead.psf,
                assignee: assignee,
                logs: logs,
                last_active: last_active,
                created_at: moment(lead.created_at).tz(req.headers['tz']).format('lll'),
                updated_at: moment(lead.updated_at).tz(req.headers['tz']).format('lll'),
            }

            res.status(200).json({
                responseCode: 200,
                responseMessage: "Lead Added ",
                responseData: push
            });
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Lead Not found",
                responseData: {}
            });
        }
    }
});

router.post('/lead/booking/add/', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers['business'];

    var loggedInDetails = await User.findById(decoded.user).exec();
    var role = await Management.findOne({ user: decoded.user, business: business }).exec();

    var advisor = await q.all(getAdvisor(loggedInDetails._id, business));

    var estimation_requested = false;
    if (req.body.estimation_requested == "Yes") {
        estimation_requested = true;
    }

    var date = null;
    if (req.body.date) {
        date = new Date(req.body.date).toISOString();
    }

    var time_slot = "";
    if (req.body.time_slot) {
        time_slot = req.body.time_slot;
    }

    var convenience = "";
    if (req.body.convenience) {
        convenience = req.body.convenience
    }

    var address = null;
    if (req.body.address) {
        address = req.body.address;
    }

    var role = await Management.findOne({ user: user, business: business }).exec();
    if (role.role == "CRE") {
        var lead = await Lead.findOne({ assignee: user, _id: req.body.lead }).exec();
    }
    else {
        var lead = await Lead.findOne({ business: business, _id: req.body.lead }).exec();
    }

    if (lead) {
        if (lead.contact_no) {
            var leadUser = {
                name: lead.name,
                contact_no: lead.contact_no,
                email: lead.email,
                user: lead.user,
            }
            var user = await q.all(getUser(leadUser))
            if (user) {
                var rg = req.body.registration_no;
                req.body.registration_no = rg.replace(/ /g, '');

                var leadCar = {
                    user: user,
                    car: req.body.car,
                    variant: req.body.variant,
                    registration_no: req.body.registration_no,
                }
                var car = await q.all(getCar(leadCar))
                if (car) {
                    var booking = await Booking.findOne({ car: car._id, user: user, status: { $nin: ["Completed", "CompleteWork", "QC", "Closed", "Ready", "Rejected", "Cancelled", "Inactive"] }, is_services: true }).exec();

                    if (booking) {
                        return res.status(422).json({
                            responseCode: 422,
                            responseMessage: "Booking already exists for the same registration no. [" + booking.status + "]",
                            responseData: {},
                        });
                    }
                    else {
                        var bookingService = [];
                        var customer_requirements = [];

                        if (req.body.requirement) {
                            customer_requirements.push({
                                requirement: req.body.requirement,
                            });
                        }

                        if (req.body.advisor) {
                            advisor = req.body.advisor;
                        }
                        else {
                            if (lead.advisor) {
                                advisor = lead.advisor;
                            }
                            else {
                                return res.status(422).json({
                                    responseCode: 422,
                                    responseMessage: "Advisor Needed",
                                    responseData: {},
                                });
                            }
                        }


                        var payment = {
                            payment_mode: "",
                            payment_status: "Pending",
                            discount_type: "",
                            coupon: "",
                            coupon_type: "",
                            discount: 0,
                            discount_total: 0,
                            part_cost: 0,
                            labour_cost: 0,
                            paid_total: 0,
                            total: 0,
                            discount_applied: false,
                            transaction_id: "",
                            transaction_date: "",
                            transaction_status: "",
                            transaction_response: ""
                        }

                        var bookingData = {
                            package: null,
                            car: car,
                            advisor: advisor,
                            manager: lead.assignee,
                            business: business,
                            user: user,
                            services: bookingService,
                            customer_requirements: customer_requirements,
                            booking_no: Math.round(+new Date() / 1000),
                            date: date,
                            time_slot: time_slot,
                            estimation_requested: estimation_requested,
                            convenience: convenience,
                            status: "EstimateRequested",
                            payment: payment,
                            address: address,
                            lead: lead,
                            is_services: true,
                            converted: true,
                            created_at: new Date(),
                            updated_at: new Date()
                        };

                        Booking.create(bookingData).then(async function (b) {
                            var activity = {
                                user: loggedInDetails._id,
                                name: loggedInDetails.name,
                                stage: "Approval",
                                activity: "Booking",
                            };

                            fun.bookingLog(b._id, activity);

                            if (role.role == "CRE") {
                                if (estimation_requested) {
                                    var notify = {
                                        receiver: [b.advisor],
                                        sender: loggedInDetails._id,
                                        activity: "booking",
                                        source: b._id,
                                        tag: "EstimateRequested",
                                        points: 0,
                                    }

                                    fun.newNotification(notify);
                                }
                                else {
                                    var notify = {
                                        source: b._id,
                                        receiver: [b.advisor],
                                        sender: loggedInDetails._id,
                                        activity: "booking",
                                        tag: "leadBooking",
                                        points: 0,
                                    }
                                    fun.newNotification(notify);
                                }
                            }
                            else {
                                if (estimation_requested) {
                                    var notify = {
                                        receiver: [b.manager],
                                        sender: loggedInDetails._id,
                                        activity: "booking",
                                        source: b._id,
                                        tag: "EstimateInitiated",
                                        points: 0,
                                    }

                                    fun.newNotification(notify);
                                }
                                else {
                                    var notify = {
                                        source: b._id,
                                        receiver: [b.manager],
                                        sender: loggedInDetails._id,
                                        activity: "booking",
                                        tag: "EstimateInitiated",
                                        points: 0,
                                    }
                                    fun.newNotification(notify);
                                }
                            }


                            var data = {
                                user: user,
                                follow_up: {},
                                converted: true,
                                remark: {
                                    lead: lead._id,
                                    status: "EstimateRequested",
                                    color_code: lead.remark.color_code,
                                    assignee: user,
                                    customer_remark: "Estimate requested",
                                    assignee_remark: "Estimate requested",
                                    created_at: new Date(),
                                    updated_at: new Date(),
                                },
                                created_at: new Date(),
                                updated_at: new Date(),
                            };


                            Lead.findOneAndUpdate({ _id: lead._id }, { $set: data }, { new: false }, async function (err, doc) {
                                if (err) {
                                    return res.status(422).json({
                                        responseCode: 422,
                                        responseMessage: "Server Error",
                                        responseData: err
                                    });
                                }
                                else {
                                    LeadRemark.create(data.remark).then(function (newRemark) {
                                        Lead.findOneAndUpdate({ _id: lead._id }, { $push: { remarks: newRemark._id } }, { new: true }, async function (err, doc) {
                                        })
                                    });;
                                }
                            });


                            var bookings = [];
                            var booking = await Booking.findById(b._id)
                                .populate({ path: 'user', populate: { path: 'user', select: "_id id name contact_no email business_info" } })
                                .populate({ path: 'manager', populate: { path: 'user', select: "_id id name contact_no email" } })
                                .populate({ path: 'car', select: '_id id title registration_no ic rc', populate: { path: 'thumbnails' } })
                                .exec();


                            if (booking.address) {
                                var address = await Address.findOne({ _id: booking.address }).exec();
                            }
                            else {
                                var address = {};
                            }
                            if (booking.car) {
                                var car = {
                                    title: booking.car.title,
                                    _id: booking.car._id,
                                    id: booking.car.id,
                                    rc_address: booking.car.rc_address,
                                    ic_address: booking.car.ic_address,
                                    ic: booking.car.ic,
                                    rc: booking.car.rc,
                                    registration_no: booking.car.registration_no,
                                }
                            }

                            var manager = null;
                            if (booking.manager) {
                                manager = {
                                    name: booking.manager.name,
                                    _id: booking.manager._id,
                                    id: booking.manager.id,
                                    contact_no: booking.manager.contact_no,
                                    email: booking.manager.email
                                }
                            }
                            bookings.push({
                                _id: booking._id,
                                id: booking._id,
                                car: car,
                                user: {
                                    name: booking.user.name,
                                    _id: booking.user._id,
                                    id: booking.user.id,
                                    contact_no: booking.user.contact_no,
                                    email: booking.user.email,
                                    business_info: booking.user.business_info
                                },
                                manager: manager,
                                services: booking.services,
                                convenience: booking.convenience,
                                date: moment(booking.date).tz(req.headers['tz']).format('ll'),
                                time_slot: booking.time_slot,
                                status: booking.status,
                                booking_no: booking.booking_no,
                                job_no: booking.job_no,
                                estimation_requested: booking.estimation_requested,
                                address: address,
                                remarks: booking.remarks,
                                customer_requirements: booking.customer_requirements,
                                payment: booking.payment,
                                txnid: booking.txnid,
                                __v: booking.__v,
                                created_at: moment(booking.created_at).tz(req.headers['tz']).format('lll'),
                                updated_at: moment(booking.updated_at).tz(req.headers['tz']).format('lll'),
                            });

                            Lead.findOneAndUpdate({ _id: lead._id }, { $set: { user: user, converted: true } }, { new: false }, async function (err, doc) {
                                if (err) {
                                    res.status(422).json({
                                        responseCode: 422,
                                        responseMessage: "Server Error",
                                        responseData: err
                                    });
                                }
                                else {
                                    event.zohoLead(b._id);

                                    res.status(200).json({
                                        responseCode: 200,
                                        responseMessage: "Booking",
                                        responseData: bookings
                                    });
                                }
                            });
                        });
                    }
                }
                else {
                    res.status(422).json({
                        responseCode: 400,
                        responseMessage: "Car required",
                        responseData: {}
                    });
                }
            }
            else {
                res.status(422).json({
                    responseCode: 400,
                    responseMessage: "User required",
                    responseData: {}
                });
            }
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Contact No required",
                responseData: {}
            });
        }
    }
    else {
        res.status(400).json({
            responseCode: 400,
            responseMessage: "Lead not found",
            responseData: {}
        });
    }
});

router.get('/lead/contact-history/get', xAccessToken.token, async function (req, res, next) {
    var leads = [];
    var leadId = [];

    await Lead.find({ contact_no: req.query.contact_no }).sort({ created_at: -1 })
        .cursor().eachAsync(async (l) => {
            leadId.push(l._id);
        });

    leadId = Array.from(new Set(leadId));

    await LeadRemark.find({ lead: { $in: leadId } })
        .populate({ path: 'assignee', select: 'name username avatar avatar_address' })
        .sort({ created_at: -1 })
        .cursor().eachAsync(async (lead) => {
            leads.push({
                lead: lead.lead,
                _id: lead._id,
                id: lead.id,
                type: lead.type,
                source: lead.source,
                color_code: lead.color_code,
                assignee: lead.assignee,
                assignee_remark: lead.assignee_remark,
                customer_remark: lead.customer_remark,
                status: lead.status,
                created_at: moment(lead.created_at).tz(req.headers['tz']).format('lll'),
                updated_at: moment(lead.updated_at).tz(req.headers['tz']).format('lll'),
            });
        });

    res.status(200).json({
        responseCode: 200,
        responseMessage: "success",
        responseData: leads
    });
});

router.post('/job/review/add', xAccessToken.token, async function (req, res, next) {
    var rules = {
        booking: 'required',
        rating: 'required',
        recommendation: 'required'
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Error",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var user = decoded.user;
        var businessReview = new Object();


        var booking = await Booking.findOne({ _id: req.body.booking }).exec();
        if (booking) {
            var status = req.body.status;

            req.body.status = false;
            req.body.user = booking.user;
            req.body.business = booking.business;
            req.body.created_at = new Date();
            req.body.updated_at = new Date();

            Review.create(req.body).then(async function (data) {
                if (status == "Dissatisfied") {
                    event.zohoCustomStatus(booking._id, "Dissatisfied");
                }
                else if (status == "Satisfied") {
                    event.zohoCustomStatus(booking._id, "Satisfied");
                }
                else if (status == "Rework") {
                    event.zohoCustomStatus(booking._id, "Rework");
                }

                Review.findOneAndUpdate({ booking: booking._id }, { $set: { status: false } }, { new: true }, async function (err, doc) { });
                Booking.findOneAndUpdate({ _id: booking._id }, { $set: { is_reviewed: true } }, { new: true }, async function (err, doc) { });

                var point = {
                    user: booking.user,
                    activity: "coin",
                    tag: "businessReview",
                    source: booking._id,
                    points: 25,
                    title: "",
                    body: "",
                    status: true
                }
                fun.addPoints(point);

                var notify = {
                    receiver: [data.business],
                    sender: data.user,
                    activity: "profile",
                    tag: "review",
                    source: booking._id,
                    points: data.rating,
                }

                fun.newNotification(notify);

                await Review.find({ _id: data._id })
                    .populate({ path: 'user', select: 'name username avatar avatar_address account_info' })
                    .cursor().eachAsync(async (review) => {

                        businessReview = {
                            _id: review._id,
                            id: review._id,
                            business: review.business,
                            booking: review.booking,
                            review_points: review.review_points,
                            rating: review.rating,
                            review: review.review,
                            recommendation: review.recommendation,
                            type: review.type,
                            created_at: moment(review.created_at).tz(req.headers['tz']).format('ll'),
                            updated_at: moment(review.updated_at).tz(req.headers['tz']).format('ll'),
                            user: review.user
                        }
                    });

                res.status(200).json({
                    responseCode: 200,
                    responseMessage: "Thank You For Your Review",
                    responseData: businessReview
                });
            });
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Booking not found",
                responseData: {}
            })
        }
    }
});

router.get('/user/search/', xAccessToken.token, async function (req, res, next) {
    var rules = {
        query: 'required',
    };

    var validation = new Validator(req.query, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Error",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var user = decoded.user;
        var business = req.headers['business'];
        var peoples = [];
        var filters = [];


        /*var specification = {};        
        specification['$lookup']= {
            from: "Booking",
            localField: "bookings",
            foreignField: "_id",
            as: "bookings",
        };
        filters.push(specification); */

        var specification = {};
        specification['$lookup'] = {
            from: "Car",
            localField: "cars",
            foreignField: "_id",
            as: "cars",
        };
        filters.push(specification);



        if (req.query.query) {
            var specification = {};
            specification['$match'] = {
                $or: [
                    { 'name': { $regex: req.query.query, $options: 'i' } },
                    { 'contact_no': { $regex: req.query.query, $options: 'i' } },
                    {
                        "cars": {
                            $elemMatch: {
                                "title": { $regex: req.query.query, $options: 'i' }
                            }
                        }
                    },
                    {
                        "cars": {
                            $elemMatch: {
                                "registration_no": { $regex: req.query.query, $options: 'i' }
                            }
                        }
                    },
                ]
            };
            filters.push(specification);


            var specification = {};
            specification['$sort'] = {
                updated_at: -1,
            };
            filters.push(specification);
        }


        await User.aggregate(filters)
            .allowDiskUse(true)
            .cursor({ batchSize: 10 })
            .exec()
            .eachAsync(async function (user) {
                var b = await Booking.find({ business: business, user: user._id }).count();
                var l = await Lead.find({ business: business, user: user._id }).count();
                var o = await BusinessOrder.find({ business: business, user: user._id }).count();
                if (b > 0 || l > 0 || o > 0) {
                    peoples.push({
                        _id: user._id,
                        id: user._id,
                        name: user.name,
                        username: user.username,
                        email: user.email,
                        contact_no: user.contact_no,
                        avatar: user.avatar,
                        avatar_address: "https://s3.ap-south-1.amazonaws.com/" + config.BUCKET_NAME + "/avatar/" + user.avatar,
                        account_info: user.account_info,
                        business_info: user.business_info,
                        created_at: user.created_at,
                        updated_at: user.updated_at,
                        joined: moment(user.created_at).tz(req.headers['tz']).format('ll'),
                    });
                }
            });

        res.status(200).json({
            responseCode: 200,
            responseMessage: "",
            responseInfo: {
                //filters:filters
            },
            responseData: peoples,
        });
    }
});

router.get('/user/details', xAccessToken.token, async function (req, res, next) {
    var rules = {
        query: 'required',
    };

    var validation = new Validator(req.query, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Error",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var user = decoded.user;
        var business = req.headers['business'];
        var peoples = [];

        if (req.query.page == undefined) {
            var page = 0;
        } else {
            var page = req.query.page;
        }
        var page = Math.max(0, parseInt(page));

        var query = req.query.query;


        await User.find({ '_id': req.query.query })
            .select('name username avatar avatar_address contact_no email careager_cash account_info')
            .sort({ created_at: -1 }).limit(config.perPage)
            .skip(config.perPage * page)
            .cursor().eachAsync(async (user) => {
                var date = new Date();
                date.setDate(date.getDate() - 1);
                var bookings = [];
                await Booking.find({
                    user: user._id,
                    status: { $nin: ["Cancelled", "Inactive", "EstimatePrepared"] },
                    is_services: true
                })
                    .populate({ path: 'manager', populate: { path: 'user', select: "_id id name contact_no email" } })
                    .populate({ path: 'advisor', populate: { path: 'user', select: "_id id name contact_no email" } })
                    .populate({ path: 'user', populate: { path: 'user', select: "_id id name contact_no email" } })
                    .populate({ path: 'business', populate: { path: 'user', select: "_id id name contact_no email" } })
                    .populate({ path: 'car', select: '_id id title registration_no ic rc' })
                    .sort({ date: 1 })
                    .cursor().eachAsync(async (booking) => {
                        var car = null;
                        var manager = null;
                        var advisor = null;
                        var address = null;
                        if (booking.car) {
                            car = {
                                title: booking.car.title,
                                _id: booking.car._id,
                                id: booking.car.id,
                                registration_no: booking.car.registration_no,
                                ic_address: booking.car.ic_address,
                                rc_address: booking.car.rc_address,
                            }
                        }

                        if (booking.manager) {
                            manager = {
                                name: booking.manager.name,
                                _id: booking.manager._id,
                                id: booking.manager.id,
                                contact_no: booking.manager.contact_no,
                                email: booking.manager.email
                            }
                        }

                        if (booking.advisor) {
                            advisor = {
                                name: booking.advisor.name,
                                _id: booking.advisor._id,
                                id: booking.advisor.id,
                                contact_no: booking.advisor.contact_no,
                                email: booking.advisor.email
                            }
                        }

                        if (booking.address) {
                            var address = await Address.findOne({ _id: booking.address }).exec();
                        }

                        bookings.push({
                            _id: booking._id,
                            id: booking._id,
                            car: car,
                            user: {
                                name: booking.user.name,
                                _id: booking.user._id,
                                id: booking.user.id,
                                contact_no: booking.user.contact_no,
                                email: booking.user.email
                            },
                            business: {
                                name: booking.business.name,
                                _id: booking.business._id,
                                id: booking.business.id,
                                contact_no: booking.business.contact_no,
                                email: booking.business.email
                            },
                            advisor: advisor,
                            manager: manager,
                            services: booking.services,
                            convenience: booking.convenience,
                            date: moment(booking.date).tz(req.headers['tz']).format('ll'),
                            time_slot: booking.time_slot,
                            status: _.startCase(booking.status),
                            booking_no: booking.booking_no,
                            estimation_requested: booking.estimation_requested,
                            address: address,
                            payment: booking.payment,
                            due: booking.due,
                            __v: booking.__v,
                            updated_at: booking.updated_at,
                            updated_at: booking.updated_at,
                        });
                    });

                var cars = [];
                await Car.find({ user: user._id, status: true })
                    .select('_id id title registration_no rc ic')
                    .cursor().eachAsync(async (car) => {
                        if (car) {
                            cars.push({
                                _id: car._id,
                                id: car._id,
                                title: car.title,
                                registration_no: car.registration_no,
                                rc: car.rc,
                                rc_address: car.rc_address,
                                ic: car.ic,
                                ic_address: car.ic_address,
                            });
                        }
                    });

                var leadId = [];
                var leads = [];

                await Lead.find({ contact_no: user.contact_no, business: business })
                    .populate({ path: 'assignee', select: 'id name contact_no email' })
                    .sort({ updated_at: -1 }).skip(config.perPage * page).limit(config.perPage)
                    .cursor().eachAsync(async (lead) => {
                        if (lead) {
                            var remark = await LeadRemark.findOne({ lead: lead._id }).sort({ created_at: -1 }).exec();
                            leads.push({
                                user: lead.user,
                                name: lead.name,
                                contact_no: lead.contact_no,
                                email: lead.email,
                                _id: lead._id,
                                id: lead.id,
                                type: lead.type,
                                date: moment(lead.updated_at).tz(req.headers['tz']).format('lll'),
                                status: lead.status,
                                important: lead.important,
                                follow_up: lead.follow_up,
                                remark: lead.remark,
                                assignee: lead.assignee,
                                created_at: moment(lead.created_at).tz(req.headers['tz']).format('lll'),
                                updated_at: moment(lead.updated_at).tz(req.headers['tz']).format('lll'),
                            });
                        }
                    });
                peoples = {
                    _id: user._id,
                    id: user._id,
                    name: user.name,
                    username: user.username,
                    email: user.email,
                    contact_no: user.contact_no,
                    avatar_address: "https://s3.ap-south-1.amazonaws.com/" + config.BUCKET_NAME + "/avatar/" + user.avatar,
                    account_info: user.account_info,
                    careager_cash: user.careager_cash,
                    cars: cars,
                    bookings: bookings,
                    leads: leads,
                    created_at: user.created_at,
                    updated_at: user.updated_at,
                    joined: moment(user.created_at).tz(req.headers['tz']).format('ll'),
                };
            });

        res.status(200).json({
            responseCode: 200,
            responseMessage: "",
            responseData: peoples,
        });
    }
});

router.get('/lead/user/cars/get', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers['business'];


    var lead = await Lead.findOne({ business: business, _id: req.query.lead }).exec();

    if (lead) {
        if (lead.contact_no) {
            var leadUser = {
                name: lead.name,
                contact_no: lead.contact_no,
                email: lead.email,
                user: lead.user,
            }
            var user = await q.all(getUser(leadUser))
            if (user) {
                Lead.findOneAndUpdate({ _id: lead._id }, { $set: { user: user } }, { new: false }, async function (err, doc) {
                    var car = []

                    await Car.find({ user: user, status: true })
                        .populate('bookmark')
                        .populate('thumbnails')
                        .populate({ path: 'user', select: 'name username avatar avatar_address address' })
                        .populate({ path: 'variant', populate: { path: 'model' } })
                        .sort({ created_at: -1 })
                        .cursor().eachAsync(async (doc) => {
                            car.push({
                                __v: 0,
                                _id: doc._id,
                                id: doc.id,
                                title: doc.title,
                                variant: doc.variant._id,
                                model: doc.model,
                                modelName: doc.variant.model.model,
                                price: doc.price,
                                numericPrice: doc.price,
                                accidental: doc.accidental,
                                body_style: doc.body_style,
                                description: doc.description,
                                driven: doc.driven,
                                carId: doc.carId,
                                fuel_type: doc.fuel_type,
                                insurance: doc.insurance,
                                location: doc.location,
                                manufacture_year: doc.manufacture_year,
                                mileage: doc.mileage,
                                owner: doc.owner,
                                registration_no: doc.registration_no,
                                transmission: doc.transmission,
                                vehicle_color: doc.vehicle_color,
                                vehicle_status: doc.vehicle_status,
                                geometry: doc.geometry,
                                fuel_level: doc.fuel_level,
                                engine_no: doc.engine_no,
                                vin: doc.vin,
                                ic: doc.ic,
                                rc: doc.rc,
                                ic_address: doc.ic_address,
                                rc_address: doc.rc_address,
                                publish: doc.publish,
                                status: doc.status,
                                premium: doc.premium,
                                is_bookmarked: doc.is_bookmarked,
                                thumbnails: doc.thumbnails,
                                user: doc.user,
                                insurance_info: doc.insurance_info,
                                created_at: doc.created_at,
                                updated_at: doc.updated_at
                            });
                        });

                    res.status(200).json({
                        responseCode: 200,
                        responseMessage: "User added",
                        responseData: car
                    });
                });
            }
            else {
                res.status(422).json({
                    responseCode: 400,
                    responseMessage: "User information incomplete",
                    responseData: {}
                });
            }
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Contact No required",
                responseData: {}
            });
        }
    }
    else {
        res.status(400).json({
            responseCode: 400,
            responseMessage: "Lead not found",
            responseData: {}
        });
    }
});

router.get('/insurance/due/get', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers['business'];
    var cars = [];
    var filters = [];
    var totalResult = 0;

    var role = await Management.findOne({ user: user, business: business }).exec();
    if (req.query.page == undefined) {
        var page = 0;
    }
    else {
        var page = req.query.page;
    }



    var specification = {};
    specification['$lookup'] = {
        from: "User",
        localField: "user",
        foreignField: "_id",
        as: "user",
    };
    filters.push(specification);

    var specification = {};
    specification['$unwind'] = {
        path: "$user",
        preserveNullAndEmptyArrays: false
    };
    filters.push(specification);

    var specification = {};
    specification['$lookup'] = {
        from: "Car",
        localField: "car",
        foreignField: "_id",
        as: "car",
    };
    filters.push(specification);

    var specification = {};
    specification['$unwind'] = {
        path: "$car",
        preserveNullAndEmptyArrays: true
    };

    var bar = new Date();
    bar.setDate(bar.getDate() + 20);

    if (req.query.query) {
        var specification = {};
        specification['$match'] = {
            business: mongoose.Types.ObjectId(business),
            "car.insurance_info": { $exists: true },
            "car.insurance_info.expire": { $ne: "" },
            "car.insurance_info.expire": { $ne: null },
            "car.insurance_info.expire": { $lte: bar },
            $or: [
                { 'user.name': { $regex: req.query.query, $options: 'i' } },
                { 'user.contact_no': { $regex: req.query.query, $options: 'i' } },
                { 'car.title': { $regex: req.query.query, $options: 'i' } },
                { 'car.registration_no': { $regex: req.query.query, $options: 'i' } },
                { 'car.insurance_info.policy_holder': { $regex: req.query.query, $options: 'i' } },
                { 'car.insurance_info.insurance_company': { $regex: req.query.query, $options: 'i' } },
                { 'car.insurance_info.policy_type': { $regex: req.query.query, $options: 'i' } },
                { 'car.insurance_info.policy_no': { $eq: Math.ceil(req.query.query) } },
            ]
        };
        filters.push(specification);
    }
    else {
        var specification = {};
        specification['$match'] = {
            "car.insurance_info": { $exists: true },
            "business": mongoose.Types.ObjectId(business),
            "car.insurance_info.expire": { $ne: "" },
            "car.insurance_info.expire": { $ne: null },
            "car.insurance_info.expire": { $lte: bar }
        };
        filters.push(specification);
    }

    var specification = {};
    specification['$group'] = {
        _id: { car: "$car" },
        max: { $max: "$car.insurance_info.expire" },
        item: { $push: "$$ROOT" }
    };
    filters.push(specification);

    var specification = {};
    specification['$sort'] = {
        "max": -1
    };
    filters.push(specification);

    totalResult = await Booking.aggregate(filters);

    var specification = {};
    specification['$skip'] = config.perPage * page;
    filters.push(specification);

    var specification = {};
    specification['$limit'] = config.perPage;
    filters.push(specification);

    await Booking.aggregate(filters)
        .allowDiskUse(true)
        .cursor({ batchSize: 10 })
        .exec()
        .eachAsync(async function (booking) {
            if (booking._id.car[0].insurance_info) {
                var expire = moment(booking._id.car[0].insurance_info.expire).tz(req.headers['tz']).format('YYYY-MM-DD');
                var insurance_info = {
                    policy_holder: booking._id.car[0].insurance_info.policy_holder,
                    policy_no: booking._id.car[0].insurance_info.policy_no,
                    insurance_company: booking._id.car[0].insurance_info.insurance_company,
                    policy_type: booking._id.car[0].insurance_info.policy_type,
                    premium: booking._id.car[0].insurance_info.premium,
                    expire: expire,
                };
            }

            /*Car.findOneAndUpdate({ _id: booking._id.car[0]._id  },{ $set:{
                insurance_info: {
                    policy_holder: booking.item[0].insurance_info.policy_holder,
                    policy_no: booking.item[0].insurance_info.policy_no,
                    insurance_company: booking.item[0].insurance_info.insurance_company,
                    policy_type: booking.item[0].insurance_info.policy_type,
                    premium: booking.item[0].insurance_info.premium,
                    expire: new Date(expire).toISOString(),
                }
            }
    
            },{new: false}, function(err, doc){});*/

            cars.push({
                _id: booking._id.car[0]._id,
                id: booking._id.car[0]._id,
                title: booking._id.car[0].title,
                modelName: booking._id.car[0]._automaker + " " + booking._id.car[0]._model,
                price: price(booking._id.car[0].price),
                numericPrice: booking._id.car[0].price,
                carId: booking._id.car[0].carId,
                fuel_type: booking._id.car[0].fuel_type,
                vehicle_color: booking._id.car[0].vehicle_color,
                registration_no: booking._id.car[0].registration_no,
                manufacture_year: booking._id.car[0].manufacture_year,
                user: await User.findById(booking._id.car[0].user).select('name email contact_no business_info').exec(),
                status: booking._id.car[0].status,
                insurance_info: insurance_info,
                created_at: booking._id.car[0].created_at,
                updated_at: booking._id.car[0].updated_at
            })
        });

    res.status(200).json({
        responseCode: 200,
        responseMessage: "Insurance Dues",
        responseInfo: {
            totalResult: totalResult.length
        },
        responseData: cars,
    });
});

router.get('/service-reminder/get', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers['business'];
    var bookings = [];
    var filters = [];
    var totalResult = 0;

    var role = await Management.findOne({ user: user, business: business }).exec();
    if (req.query.page == undefined) {
        var page = 0;
    }
    else {
        var page = req.query.page;
    }



    var specification = {};
    specification['$lookup'] = {
        from: "User",
        localField: "user",
        foreignField: "_id",
        as: "user",
    };
    filters.push(specification);

    var specification = {};
    specification['$unwind'] = {
        path: "$user",
        preserveNullAndEmptyArrays: false
    };
    filters.push(specification);

    var specification = {};
    specification['$lookup'] = {
        from: "Car",
        localField: "car",
        foreignField: "_id",
        as: "car",
    };
    filters.push(specification);

    var specification = {};
    specification['$unwind'] = {
        path: "$car",
        preserveNullAndEmptyArrays: true
    };

    var bar = new Date();
    bar.setDate(bar.getDate() + 20);

    if (req.query.query) {
        var specification = {};
        specification['$match'] = {
            business: mongoose.Types.ObjectId(business),
            "service_reminder": { $lte: bar },
            $or: [
                { 'user.name': { $regex: req.query.query, $options: 'i' } },
                { 'user.contact_no': { $regex: req.query.query, $options: 'i' } },
                { 'car.title': { $regex: req.query.query, $options: 'i' } },
                { 'car.registration_no': { $regex: req.query.query, $options: 'i' } },
                { 'car.insurance_info.policy_holder': { $regex: req.query.query, $options: 'i' } },
            ]
        };
        filters.push(specification);
    }
    else {
        var specification = {};
        specification['$match'] = {
            business: mongoose.Types.ObjectId(business),
            "service_reminder": { $lte: bar },
        };
        filters.push(specification);
    }

    filters.push(specification);

    totalResult = await Booking.aggregate(filters);

    var specification = {};
    specification['$sort'] = {
        service_reminder: 1,
    };
    filters.push(specification);

    var specification = {};
    specification['$skip'] = config.perPage * page;
    filters.push(specification);

    var specification = {};
    specification['$limit'] = config.perPage;
    filters.push(specification);

    await Booking.aggregate(filters)
        .allowDiskUse(true)
        .cursor({ batchSize: 10 })
        .exec()
        .eachAsync(async function (booking) {
            var remarks = booking.remarks;
            var remarksData = [];
            if (remarks) {
                for (var i = 0; i < remarks.length; i++) {
                    var added_by = await User.findById(remarks[i].added_by).exec();
                    remarksData.push({
                        added_by: remarks[i].user,
                        name: added_by.name,
                        remark: remarks[i].remark,
                        created_at: moment(remarks[i].created_at).tz(req.headers['tz']).format('lll'),
                        updated_at: moment(remarks[i].updated_at).tz(req.headers['tz']).format('lll'),
                    })
                }
            }

            bookings.push({
                _id: booking._id,
                id: booking._id,
                car: {
                    title: booking.car[0].title,
                    _id: booking.car[0]._id,
                    id: booking.car[0].id,
                    vin: booking.car[0].vin,
                    engine_no: booking.car[0].engine_no,
                    registration_no: booking.car[0].registration_no,
                    variant: booking.car[0].variant,
                    manufacture_year: booking.car[0].manufacture_year,
                    purchased_year: booking.car[0].purchased_year,
                },
                user: {
                    name: booking.user.name,
                    _id: booking.user._id,
                    id: booking.user.id,
                    contact_no: booking.user.contact_no,
                    email: booking.user.email,
                    business_info: booking.user.business_info,
                    account_info: booking.user.account_info,
                },
                insurance_info: booking.insurance_info,
                odometer: booking.odometer,
                convenience: booking.convenience,
                date: moment(booking.date).tz(req.headers['tz']).format('ll'),
                time_slot: booking.time_slot,
                status: _.startCase(booking.status),
                _status: booking.status,
                sub_status: booking.sub_status,
                booking_no: booking.booking_no,
                job_no: booking.job_no,
                remarks: remarks,
                service_reminder: moment(booking.service_reminder).tz(req.headers['tz']).format('lll'),
                created_at: moment(booking.created_at).tz(req.headers['tz']).format('lll'),
                updated_at: moment(booking.updated_at).tz(req.headers['tz']).format('lll'),
            });
        });

    res.status(200).json({
        responseCode: 200,
        responseMessage: "",
        responseInfo: {
            totalResult: totalResult.length
        },
        responseData: bookings,

    });
});

router.put('/booking/info/update', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers['business'];
    var loggedInDetails = await User.findById(decoded.user).exec();
    var booking = await Booking.findOne({ _id: req.body.booking }).exec();

    if (booking) {
        var estimation_requested = false;
        if (req.body.estimation_requested == "Yes") {
            estimation_requested = true;
        }

        var date = null;
        var status = booking.status;

        if (req.body.date) {
            status = "Confirmed";
            date = new Date(req.body.date).toISOString();
        }

        var time_slot = booking.time_slot;
        if (req.body.time_slot) {
            time_slot = req.body.time_slot;
        }

        var convenience = booking.convenience;
        if (req.body.convenience) {
            convenience = req.body.convenience
        }

        var address = null;
        if (req.body.address) {
            address = req.body.address;
        }



        var pick_up_charges = booking.payment.pick_up_charges;
        if (req.body.pick_up_charges >= 0) {
            pick_up_charges = parseFloat(req.body.pick_up_charges);
        }

        var policy_clause = booking.payment.policy_clause;
        if (req.body.policy_clause >= 0 && req.body.policy_clause != null) {
            policy_clause = parseFloat(req.body.policy_clause);
        }

        var salvage = booking.payment.salvage;
        if (req.body.salvage >= 0 && req.body.salvage != null) {
            salvage = parseFloat(req.body.salvage);
        }

        var bookingService = booking.services;

        var approved = _.filter(bookingService, customer_approval => customer_approval.customer_approval == true);


        var labour_cost = _.sumBy(bookingService, x => x.labour_cost);
        var part_cost = _.sumBy(bookingService, x => x.part_cost);
        var of_cost = _.sumBy(bookingService, x => x.of_cost);
        var discount_total = _.sumBy(bookingService, x => x.discount);
        var pick_up_charges = pick_up_charges;
        var paid_total = booking.payment.paid_total;


        var careager_cash = await q.all(fun.getBookingCarEagerCash(booking._id));


        var payment_total = labour_cost + part_cost + of_cost + discount_total + policy_clause + salvage + pick_up_charges;

        var estimate_cost = labour_cost + part_cost + of_cost + policy_clause + salvage + pick_up_charges - careager_cash;
        var due_amount = _.sumBy(approved, x => x.labour_cost) + _.sumBy(approved, x => x.part_cost) + _.sumBy(approved, x => x.of_cost) + policy_clause + salvage + pick_up_charges - (paid_total + careager_cash);

        var due = {
            due: Math.ceil(due_amount.toFixed(2))
        }

        var payment = {
            total: payment_total,
            estimate_cost: estimate_cost,
            careager_cash: careager_cash,
            of_cost: of_cost,
            labour_cost: labour_cost,
            part_cost: part_cost,
            payment_mode: booking.payment.payment_mode,
            payment_status: booking.payment.payment_status,
            coupon: booking.payment.coupon,
            coupon_type: booking.payment.coupon_type,
            discount_by: booking.payment.discount_by,
            discount_type: booking.payment.discount_type,
            discount: discount_total,
            discount_total: discount_total,
            policy_clause: policy_clause,
            salvage: salvage,
            terms: booking.payment.terms,
            pick_up_limit: booking.payment.pick_up_limit,
            pick_up_charges: pick_up_charges,
            paid_total: parseFloat(booking.payment.paid_total),
            discount_applied: booking.payment.discount_applied,
            transaction_id: booking.payment.transaction_id,
            transaction_date: booking.payment.transaction_date,
            transaction_status: booking.payment.transaction_status,
            transaction_response: booking.payment.transaction_response
        };


        Booking.findOneAndUpdate({ _id: booking._id }, { $set: { status: status, date: date, time_slot: time_slot, convenience: convenience, address: address, payment: payment, due: due, updated_at: new Date() } }, { new: false }, async function (err, doc) {
            if (err) {
                res.status(400).json({
                    responseCode: 400,
                    responseMessage: "Error Occurred Try again",
                    responseData: err
                });
            }
            else {
                if (req.body.requirements) {
                    var customer_requirement = {
                        added_by: loggedInDetails.name,
                        requirement: req.body.requirements,
                        user: loggedInDetails._id,
                        created_at: new Date(),
                        updated_at: new Date(),
                    }

                    Booking.findOneAndUpdate({ _id: booking._id }, { $push: { customer_requirements: customer_requirement } }, { new: false }, async function (err, doc) { })
                }

                if (date) {
                    var notify = {
                        receiver: [booking.user],
                        activity: "booking",
                        tag: "bookingConfirmation",
                        source: booking._id,
                        sender: booking.user,
                        points: 0
                    }
                    fun.newNotification(notify);
                }

                var updated = await Booking.findById(booking._id).exec();

                res.status(200).json({
                    responseCode: 200,
                    responseMessage: "Booking Updated",
                    responseData: updated
                });
            }
        });
    }
    else {
        res.status(400).json({
            responseCode: 400,
            responseMessage: "Booking not found",
            responseData: {}
        });
    }
});

router.post('/booking/add', xAccessToken.token, async function (req, res, next) {
    var rules = {
        registration_no: 'required',
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Error",
            responseData: {
                res: validation.errors.all()
            }
        });
    }
    else {
        var token = req.headers['x-access-token'];
        var business = req.headers['business'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var loggedInDetails = await User.findById(decoded.user).exec();
        var customer_requirements = [];
        var advisor = await q.all(getAdvisor(loggedInDetails._id, business));

        var check = await User.findOne({ _id: req.body.user }).exec();
        if (check) {
            var date = null;
            if (req.body.date) {
                date = new Date(req.body.date).toISOString();
            }

            if (req.body.requirement) {
                customer_requirements.push({
                    user: loggedInDetails._id,
                    added_by: loggedInDetails.name,
                    requirement: req.body.requirement,
                    created_at: new Date(),
                    updated_at: new Date(),
                });
            }

            var rg = req.body.registration_no;
            req.body.registration_no = rg.replace(/ /g, '');

            var insurance_info = {
                "driver": null,
                "accident_place": "",
                "accident_date": null,
                "accident_time": "",
                "accident_cause": "",
                "fir": "",
                "branch": "",
                "cashless": "true",
                "claim": "false",
                "contact_no": "",
                "claim_no": "",
                "driver_accident": "",
                "expire": null,
                "gstin": "",
                "insurance_company": "",
                "manufacture_year": "",
                "policy_holder": "",
                "policy_no": "",
                "policy_type": "",
                "premium": 0,
                "spot_survey": "",
                "state": ""
            }

            var getCar = await Car.findOne({ registration_no: req.body.registration_no, status: true }).exec();
            if (getCar) {
                /*if(!getCar.user.equals(check._id))
                {
                    res.status(422).json({
                        responseCode: 422,
                        responseMessage: "Registration no authentication error",
                        responseData: {}
                    })
                }
                else
                {*/
                var booking = await Booking.findOne({ car: getCar._id, status: { $nin: ["Completed", "CompleteWork", "QC", "Closed", "Ready", "Rejected", "Cancelled", "Inactive"] }, is_services: true }).exec();

                if (booking) {
                    res.status(422).json({
                        responseCode: 422,
                        responseMessage: "Booking already exists for the same registration no. [" + booking.status + "]",
                        responseData: {},
                    });
                }
                else {
                    var pick_up_charges = 0;
                    var bookingService = [];

                    var countBooking = await Booking.find({}).count().exec();

                    if (req.body.charges) {
                        pick_up_charges = parseFloat(req.body.charges);
                    }

                    var due = {
                        due: pick_up_charges
                    };

                    var payment = {
                        payment_mode: "",
                        payment_status: "Pending",
                        discount_type: "",
                        coupon: "",
                        coupon_type: "",
                        discount: 0,
                        discount_total: 0,
                        part_cost: 0,
                        labour_cost: 0,
                        paid_total: 0,
                        pick_up_charges: pick_up_charges,
                        total: pick_up_charges,
                        discount_applied: false,
                        transaction_id: "",
                        transaction_date: "",
                        transaction_status: "",
                        transaction_response: ""
                    }

                    var bookingData = {
                        package: null,
                        car: getCar._id,
                        advisor: advisor,
                        manager: null,
                        business: business,
                        user: check.id,
                        services: bookingService,
                        customer_requirements: customer_requirements,
                        booking_no: Math.round(+new Date() / 1000),
                        date: date,
                        time_slot: req.body.time_slot,
                        convenience: "",
                        status: "EstimateRequested",
                        payment: payment,
                        due: due,
                        address: req.body.address,
                        lead: null,
                        insurance_info: insurance_info,
                        is_services: true,
                        created_at: new Date(),
                        updated_at: new Date()
                    };

                    Booking.create(bookingData).then(async function (b) {
                        var bookings = [];
                        var booking = await Booking.findById(b._id)
                            .populate({ path: 'user', populate: { path: 'user', select: "_id id name contact_no email business_info" } })
                            .populate({ path: 'manager', populate: { path: 'user', select: "_id id name contact_no email" } })
                            .populate({ path: 'car', select: '_id id title registration_no ic rc', populate: { path: 'thumbnails' } })
                            .exec();


                        if (booking.address) {
                            var address = await Address.findOne({ _id: booking.address }).exec();
                        }
                        else {
                            var address = {};
                        }
                        if (booking.car) {
                            var car = {
                                title: booking.car.title,
                                _id: booking.car._id,
                                id: booking.car.id,
                                rc_address: booking.car.rc_address,
                                ic_address: booking.car.ic_address,
                                ic: booking.car.ic,
                                rc: booking.car.rc,
                                registration_no: booking.car.registration_no,
                            }
                        }

                        var manager = null;
                        if (booking.manager) {
                            manager = {
                                name: booking.manager.name,
                                _id: booking.manager._id,
                                id: booking.manager.id,
                                contact_no: booking.manager.contact_no,
                                email: booking.manager.email
                            }
                        }
                        bookings.push({
                            _id: booking._id,
                            id: booking._id,
                            car: car,
                            user: {
                                name: booking.user.name,
                                _id: booking.user._id,
                                id: booking.user.id,
                                contact_no: booking.user.contact_no,
                                email: booking.user.email,
                                business_info: booking.user.business_info
                            },
                            manager: manager,
                            services: booking.services,
                            convenience: booking.convenience,
                            date: moment(booking.date).tz(req.headers['tz']).format('ll'),
                            time_slot: booking.time_slot,
                            status: booking.status,
                            booking_no: booking.booking_no,
                            job_no: booking.job_no,
                            estimation_requested: booking.estimation_requested,
                            address: address,
                            remarks: booking.remarks,
                            customer_requirements: booking.customer_requirements,
                            payment: booking.payment,
                            txnid: booking.txnid,
                            __v: booking.__v,
                            created_at: moment(booking.created_at).tz(req.headers['tz']).format('lll'),
                            updated_at: moment(booking.updated_at).tz(req.headers['tz']).format('lll'),
                        });

                        event.zohoLead(b._id);

                        var activity = {
                            user: loggedInDetails._id,
                            name: loggedInDetails.name,
                            stage: "New Booking",
                            activity: "New Booking",
                        };

                        fun.bookingLog(booking._id, activity);

                        var notify = {
                            receiver: [booking.user],
                            activity: "booking",
                            tag: "newBooking",
                            source: booking._id,
                            sender: booking.business,
                            points: 0,
                            tz: req.headers['tz']
                        };
                        fun.newNotification(notify);

                        res.status(200).json({
                            responseCode: 200,
                            responseMessage: "Booking",
                            responseData: bookings
                        });
                    });
                }
                /*}*/
            }
            else {
                var variant = await Variant.findOne({ _id: req.body.variant }).populate('model').select('-service_schedule').exec();
                if (variant) {
                    var rg = req.body.registration_no;
                    req.body.registration_no = rg.replace(/ /g, '');

                    var reg = await Car.find({ registration_no: req.body.registration_no, status: true }).count().exec();
                    if (reg == 0) {
                        var automaker = await Automaker.findById(variant.model.automaker).exec();
                        var data = {
                            geometry: [
                                0,
                                0
                            ],
                            registration_no: rg.replace(/ /g, ''),
                            reg_no_copy: rg.replace(/ /g, ''),
                            created_at: new Date(),
                            updated_at: new Date(),
                            title: variant.variant,
                            variant: variant._id,
                            _variant: variant.value,
                            automaker: automaker._id,
                            _automaker: automaker.maker,
                            model: variant.model._id,
                            _model: variant.model.value,
                            segment: variant.model.segment,
                            user: check._id,
                            vin: req.body.vin,
                            engine_no: req.body.engine_no,
                            fuel_type: variant.specification.fuel_type,
                            transmission: variant.specification.type,
                            carId: Math.round(new Date() / 1000) + Math.round((Math.random() * 9999) + 1),
                        };

                        Car.create(data).then(async function (car) {



                            var bookingService = [];
                            var countBooking = await Booking.find({}).count().exec();

                            var payment = {
                                payment_mode: "",
                                payment_status: "Pending",
                                discount_type: "",
                                coupon: "",
                                coupon_type: "",
                                discount: 0,
                                discount_total: 0,
                                part_cost: 0,
                                labour_cost: 0,
                                paid_total: 0,
                                total: 0,
                                discount_applied: false,
                                transaction_id: "",
                                transaction_date: "",
                                transaction_status: "",
                                transaction_response: ""
                            }

                            var bookingData = {
                                package: null,
                                car: car,
                                advisor: advisor,
                                business: business,
                                user: check.id,
                                services: bookingService,
                                customer_requirements: customer_requirements,
                                booking_no: Math.round(+new Date() / 1000),
                                date: new Date(),
                                time_slot: "",
                                convenience: "",
                                status: "EstimateRequested",
                                payment: payment,
                                address: null,
                                lead: null,
                                insurance_info: insurance_info,
                                is_services: true,
                                created_at: new Date(),
                                updated_at: new Date()
                            };


                            Booking.create(bookingData).then(async function (b) {
                                var bookings = [];
                                var booking = await Booking.findById(b._id)
                                    .populate({ path: 'user', populate: { path: 'user', select: "_id id name contact_no email business_info" } })
                                    .populate({ path: 'manager', populate: { path: 'user', select: "_id id name contact_no email" } })
                                    .populate({ path: 'car', select: '_id id title registration_no ic rc', populate: { path: 'thumbnails' } })
                                    .exec();


                                if (booking.address) {
                                    var address = await Address.findOne({ _id: booking.address }).exec();
                                }
                                else {
                                    var address = {};
                                }
                                if (booking.car) {
                                    var car = {
                                        title: booking.car.title,
                                        _id: booking.car._id,
                                        id: booking.car.id,
                                        rc_address: booking.car.rc_address,
                                        ic_address: booking.car.ic_address,
                                        ic: booking.car.ic,
                                        rc: booking.car.rc,
                                        registration_no: booking.car.registration_no,
                                    }
                                }
                                else {
                                    var car = {
                                        title: "",
                                        _id: null,
                                        id: null,
                                        rc_address: "",
                                        ic_address: "",
                                        ic: "",
                                        rc: "",
                                        registration_no: "",
                                    }

                                }
                                var manager = null;
                                if (booking.manager) {
                                    manager = {
                                        name: booking.manager.name,
                                        _id: booking.manager._id,
                                        id: booking.manager.id,
                                        contact_no: booking.manager.contact_no,
                                        email: booking.manager.email
                                    }
                                }
                                bookings.push({
                                    _id: booking._id,
                                    id: booking._id,
                                    car: car,
                                    user: {
                                        name: booking.user.name,
                                        _id: booking.user._id,
                                        id: booking.user.id,
                                        contact_no: booking.user.contact_no,
                                        email: booking.user.email,
                                        business_info: booking.user.business_info
                                    },
                                    manager: manager,
                                    services: booking.services,
                                    convenience: booking.convenience,
                                    date: moment(booking.date).tz(req.headers['tz']).format('ll'),
                                    time_slot: booking.time_slot,
                                    status: booking.status,
                                    booking_no: booking.booking_no,
                                    job_no: booking.job_no,
                                    estimation_requested: booking.estimation_requested,
                                    address: address,
                                    remarks: booking.remarks,
                                    customer_requirements: booking.customer_requirements,
                                    payment: booking.payment,
                                    txnid: booking.txnid,
                                    __v: booking.__v,
                                    created_at: moment(booking.created_at).tz(req.headers['tz']).format('lll'),
                                    updated_at: moment(booking.updated_at).tz(req.headers['tz']).format('lll'),
                                });


                                event.zohoLead(b._id)

                                var activity = {
                                    user: loggedInDetails._id,
                                    name: loggedInDetails.name,
                                    stage: "New Booking",
                                    activity: "New Booking",
                                };

                                fun.bookingLog(booking._id, activity);

                                var notify = {
                                    receiver: [booking.user],
                                    activity: "booking",
                                    tag: "newBooking",
                                    source: booking._id,
                                    sender: booking.business,
                                    points: 0,
                                    tz: req.headers['tz']
                                };
                                fun.newNotification(notify);

                                res.status(200).json({
                                    responseCode: 200,
                                    responseMessage: "Booking",
                                    responseData: bookings
                                });
                            });
                        });
                    }
                    else {
                        res.status(422).json({
                            responseCode: 422,
                            responseMessage: "registration no already exist",
                            responseData: {}
                        });
                    }
                }
                else {
                    return res.status(400).json({
                        responseCode: 400,
                        responseMessage: "Car variant not found",
                        responseData: {}
                    })
                }
            }
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "User not found",
                responseData: {}
            });
        }
    }
});

router.post('/job/add', xAccessToken.token, async function (req, res, next) {
    var rules = {
        registration_no: 'required',
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Error",
            responseData: {
                res: validation.errors.all()
            }
        });
    }
    else {
        var token = req.headers['x-access-token'];
        var business = req.headers['business'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var loggedInDetails = await User.findById(decoded.user).exec();
        var customer_requirements = [];
        var advisor = await q.all(getAdvisor(loggedInDetails._id, business));

        var check = await User.findOne({ _id: req.body.user }).exec();
        if (check) {
            var date = null;
            if (req.body.date) {
                date = new Date(req.body.date).toISOString();
            }

            if (req.body.requirement) {
                customer_requirements.push({
                    user: loggedInDetails._id,
                    added_by: loggedInDetails.name,
                    requirement: req.body.requirement,
                    created_at: new Date(),
                    updated_at: new Date(),
                });
            }

            var insurance_info = {
                "driver": null,
                "accident_place": "",
                "accident_date": null,
                "accident_time": "",
                "accident_cause": "",
                "fir": "",
                "branch": "",
                "cashless": "true",
                "claim": "false",
                "contact_no": "",
                "claim_no": "",
                "driver_accident": "",
                "expire": null,
                "gstin": "",
                "insurance_company": "",
                "manufacture_year": "",
                "policy_holder": "",
                "policy_no": "",
                "policy_type": "",
                "premium": 0,
                "spot_survey": "",
                "state": ""
            }

            var rg = req.body.registration_no;
            req.body.registration_no = rg.replace(/ /g, '');

            var getCar = await Car.findOne({ registration_no: req.body.registration_no, status: true }).exec();
            if (getCar) {
                /*if(!getCar.user.equals(check._id))
                {
                    res.status(422).json({
                        responseCode: 422,
                        responseMessage: "Registration no authentication error",
                        responseData: {}
                    })
                }
                else
                {*/
                var booking = await Booking.findOne({ car: getCar._id, status: { $nin: ["Completed", "CompleteWork", "QC", "Closed", "Ready", "Rejected", "Cancelled", "Inactive"] }, is_services: true }).exec();

                if (booking) {
                    res.status(422).json({
                        responseCode: 422,
                        responseMessage: "Booking already exists for the same registration no. [" + booking.status + "]",
                        responseData: {},
                    });
                }
                else {
                    var pick_up_charges = 0;
                    var bookingService = [];

                    var countBooking = await Booking.find({}).count().exec();

                    if (req.body.charges) {
                        pick_up_charges = parseFloat(req.body.charges);
                    }

                    var due = {
                        due: pick_up_charges
                    };

                    var payment = {
                        payment_mode: "",
                        payment_status: "Pending",
                        discount_type: "",
                        coupon: "",
                        coupon_type: "",
                        discount: 0,
                        discount_total: 0,
                        part_cost: 0,
                        labour_cost: 0,
                        paid_total: 0,
                        pick_up_charges: pick_up_charges,
                        total: pick_up_charges,
                        discount_applied: false,
                        transaction_id: "",
                        transaction_date: "",
                        transaction_status: "",
                        transaction_response: ""
                    }

                    var bookingData = {
                        package: null,
                        car: getCar._id,
                        advisor: advisor,
                        manager: null,
                        business: business,
                        user: check.id,
                        services: bookingService,
                        customer_requirements: customer_requirements,
                        booking_no: Math.round(+new Date() / 1000),
                        date: date,
                        time_slot: req.body.time_slot,
                        convenience: "",
                        status: "EstimateRequested",
                        payment: payment,
                        due: due,
                        address: req.body.address,
                        lead: null,
                        insurance_info: insurance_info,
                        is_services: true,
                        created_at: new Date(),
                        updated_at: new Date()
                    };


                    Booking.create(bookingData).then(async function (b) {
                        var bookings = [];
                        var booking = await Booking.findById(b._id)
                            .populate({ path: 'user', populate: { path: 'user', select: "_id id name contact_no email business_info" } })
                            .populate({ path: 'manager', populate: { path: 'user', select: "_id id name contact_no email" } })
                            .populate({ path: 'car', select: '_id id title registration_no ic rc', populate: { path: 'thumbnails' } })
                            .exec();


                        if (booking.address) {
                            var address = await Address.findOne({ _id: booking.address }).exec();
                        }
                        else {
                            var address = {};
                        }
                        if (booking.car) {
                            var car = {
                                title: booking.car.title,
                                _id: booking.car._id,
                                id: booking.car.id,
                                rc_address: booking.car.rc_address,
                                ic_address: booking.car.ic_address,
                                ic: booking.car.ic,
                                rc: booking.car.rc,
                                registration_no: booking.car.registration_no,
                            }
                        }

                        var manager = null;
                        if (booking.manager) {
                            manager = {
                                name: booking.manager.name,
                                _id: booking.manager._id,
                                id: booking.manager.id,
                                contact_no: booking.manager.contact_no,
                                email: booking.manager.email
                            }
                        }
                        bookings.push({
                            _id: booking._id,
                            id: booking._id,
                            car: car,
                            user: {
                                name: booking.user.name,
                                _id: booking.user._id,
                                id: booking.user.id,
                                contact_no: booking.user.contact_no,
                                email: booking.user.email,
                                business_info: booking.user.business_info
                            },
                            manager: manager,
                            services: booking.services,
                            convenience: booking.convenience,
                            date: moment(booking.date).tz(req.headers['tz']).format('ll'),
                            time_slot: booking.time_slot,
                            status: booking.status,
                            booking_no: booking.booking_no,
                            job_no: booking.job_no,
                            estimation_requested: booking.estimation_requested,
                            address: address,
                            remarks: booking.remarks,
                            customer_requirements: booking.customer_requirements,
                            payment: booking.payment,
                            txnid: booking.txnid,
                            __v: booking.__v,
                            created_at: moment(booking.created_at).tz(req.headers['tz']).format('lll'),
                            updated_at: moment(booking.updated_at).tz(req.headers['tz']).format('lll'),
                        });

                        event.zohoLead(b._id);

                        res.status(200).json({
                            responseCode: 200,
                            responseMessage: "Booking",
                            responseData: bookings
                        });
                    });
                }
                /*}*/
            }
            else {
                var variant = await Variant.findOne({ _id: req.body.variant }).populate('model').select('-service_schedule').exec();
                if (variant) {
                    var rg = req.body.registration_no;
                    req.body.registration_no = rg.replace(/ /g, '');

                    var reg = await Car.find({ registration_no: req.body.registration_no, status: true }).count().exec();
                    if (reg == 0) {
                        var automaker = await Automaker.findById(variant.model.automaker).exec();
                        var data = {
                            geometry: [
                                0,
                                0
                            ],
                            registration_no: rg.replace(/ /g, ''),
                            reg_no_copy: rg.replace(/ /g, ''),
                            created_at: new Date(),
                            updated_at: new Date(),
                            title: variant.variant,
                            variant: variant._id,
                            _variant: variant.value,
                            automaker: automaker._id,
                            _automaker: automaker.maker,
                            model: variant.model._id,
                            _model: variant.model.value,
                            segment: variant.model.segment,
                            user: check._id,
                            vin: req.body.vin,
                            engine_no: req.body.engine_no,
                            fuel_type: variant.specification.fuel_type,
                            transmission: variant.specification.type,
                            carId: Math.round(new Date() / 1000) + Math.round((Math.random() * 9999) + 1),
                        };

                        Car.create(data).then(async function (car) {
                            var bookingService = [];
                            var customer_requirements = [];
                            var countBooking = await Booking.find({}).count().exec();

                            var payment = {
                                payment_mode: "",
                                payment_status: "Pending",
                                discount_type: "",
                                coupon: "",
                                coupon_type: "",
                                discount: 0,
                                discount_total: 0,
                                part_cost: 0,
                                labour_cost: 0,
                                paid_total: 0,
                                total: 0,
                                discount_applied: false,
                                transaction_id: "",
                                transaction_date: "",
                                transaction_status: "",
                                transaction_response: ""
                            }

                            var bookingData = {
                                package: null,
                                car: car,
                                advisor: advisor,
                                business: business,
                                user: check.id,
                                services: bookingService,
                                customer_requirements: customer_requirements,
                                booking_no: Math.round(+new Date() / 1000),
                                date: new Date(),
                                time_slot: "",
                                convenience: "",
                                status: "EstimateRequested",
                                payment: payment,
                                address: null,
                                lead: null,
                                insurance_info: insurance_info,
                                is_services: true,
                                created_at: new Date(),
                                updated_at: new Date()
                            };


                            Booking.create(bookingData).then(async function (b) {
                                var bookings = [];
                                var booking = await Booking.findById(b._id)
                                    .populate({ path: 'user', populate: { path: 'user', select: "_id id name contact_no email business_info" } })
                                    .populate({ path: 'manager', populate: { path: 'user', select: "_id id name contact_no email" } })
                                    .populate({ path: 'car', select: '_id id title registration_no ic rc', populate: { path: 'thumbnails' } })
                                    .exec();


                                if (booking.address) {
                                    var address = await Address.findOne({ _id: booking.address }).exec();
                                }
                                else {
                                    var address = {};
                                }
                                if (booking.car) {
                                    var car = {
                                        title: booking.car.title,
                                        _id: booking.car._id,
                                        id: booking.car.id,
                                        rc_address: booking.car.rc_address,
                                        ic_address: booking.car.ic_address,
                                        ic: booking.car.ic,
                                        rc: booking.car.rc,
                                        registration_no: booking.car.registration_no,
                                    }
                                }
                                else {
                                    var car = {
                                        title: "",
                                        _id: null,
                                        id: null,
                                        rc_address: "",
                                        ic_address: "",
                                        ic: "",
                                        rc: "",
                                        registration_no: "",
                                    }

                                }
                                var manager = null;
                                if (booking.manager) {
                                    manager = {
                                        name: booking.manager.name,
                                        _id: booking.manager._id,
                                        id: booking.manager.id,
                                        contact_no: booking.manager.contact_no,
                                        email: booking.manager.email
                                    }
                                }
                                bookings.push({
                                    _id: booking._id,
                                    id: booking._id,
                                    car: car,
                                    user: {
                                        name: booking.user.name,
                                        _id: booking.user._id,
                                        id: booking.user.id,
                                        contact_no: booking.user.contact_no,
                                        email: booking.user.email,
                                        business_info: booking.user.business_info
                                    },
                                    manager: manager,
                                    services: booking.services,
                                    convenience: booking.convenience,
                                    date: moment(booking.date).tz(req.headers['tz']).format('ll'),
                                    time_slot: booking.time_slot,
                                    status: booking.status,
                                    booking_no: booking.booking_no,
                                    job_no: booking.job_no,
                                    estimation_requested: booking.estimation_requested,
                                    address: address,
                                    remarks: booking.remarks,
                                    customer_requirements: booking.customer_requirements,
                                    payment: booking.payment,
                                    txnid: booking.txnid,
                                    __v: booking.__v,
                                    created_at: moment(booking.created_at).tz(req.headers['tz']).format('lll'),
                                    updated_at: moment(booking.updated_at).tz(req.headers['tz']).format('lll'),
                                });


                                event.zohoLead(b._id)

                                res.status(200).json({
                                    responseCode: 200,
                                    responseMessage: "Booking",
                                    responseData: bookings
                                });
                            });
                        });
                    }
                    else {
                        res.status(422).json({
                            responseCode: 422,
                            responseMessage: "registration no already exist",
                            responseData: {}
                        });
                    }
                }
                else {
                    return res.status(400).json({
                        responseCode: 400,
                        responseMessage: "Car variant not found",
                        responseData: {}
                    })
                }
            }
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "User not found",
                responseData: {}
            });
        }
    }
});

router.get('/booking/time-slot/get', xAccessToken.token, async function (req, res, next) {
    var rules = {
        booking: 'required',
        date: 'required',
    };

    var validation = new Validator(req.query, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Service not mention",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var user = decoded.user;
        var business = req.headers['business'];
        var slots = [];
        var booking = await Booking.findById(req.query.booking).exec();
        if (booking) {
            var business = booking.business;
            var date = new Date(new Date(req.query.date).setHours(0, 0, 0, 0));
            var next = new Date(new Date(req.query.date).setHours(0, 0, 0, 0));
            next.setDate(date.getDate() + 1);

            var check = await BookingTiming.find({ business: business }).count().exec();

            var body = booking.services;
            if (body.length <= 0) {
                body.push({
                    type: "services"
                });
            }

            body = _.uniqBy(body, 'type');

            var slots = [];


            for (var i = 0; i < body.length; i++) {

                if (body[i].type == "addOn") {
                    body[i].type = "services"
                }


                if (check > 0) {
                    await BookingTiming.find({ business: business, category: body[i].type })
                        .sort({ sort: 1 })
                        .cursor().eachAsync(async (timing) => {
                            if (timing) {
                                var slot = await Booking.find({
                                    time_slot: timing.slot,
                                    is_services: true,
                                    business: business,
                                    date: { $gte: date, $lt: next },
                                    services: { $elemMatch: { type: body[i].type } },
                                    status: { $nin: ["Inactive", "Rejected", "Cancelled", "Completed", "Closed"] },
                                }).count().exec();

                                if (slot < timing.booking_per_slot) {
                                    slot = timing.booking_per_slot - slot
                                    slots.push({
                                        slot: timing.slot,
                                        count: slot,
                                        sort: timing.sort,
                                        type: timing.category,
                                        status: true
                                    });
                                }
                                else {
                                    slots.push({
                                        slot: timing.slot,
                                        count: slot,
                                        sort: timing.sort,
                                        type: timing.category,
                                        status: false
                                    });
                                }
                            }
                            else {
                                slots.push({
                                    slot: timing.slot,
                                    count: slot,
                                    sort: timing.sort,
                                    type: timing.category,
                                    status: false
                                });
                            }
                        });
                }
                else {
                    var a = await BookingTiming.find({ business: null, category: body[i].type }).exec();

                    await BookingTiming.find({ business: null, category: body[i].type })
                        .sort({ sort: 1 })
                        .cursor().eachAsync(async (timing) => {

                            var slot = await Booking.find({
                                time_slot: timing.slot,
                                is_services: true,
                                business: business,
                                date: { $gte: date, $lt: next },
                                services: { $elemMatch: { type: body[i].type } },
                                status: { $nin: ["Inactive", "Rejected", "Cancelled", "Completed", "Closed"] },
                            }).count().exec();


                            if (slot < timing.booking_per_slot) {
                                slot = timing.booking_per_slot - slot
                                slots.push({
                                    slot: timing.slot,
                                    count: slot,
                                    sort: timing.sort,
                                    type: timing.category,
                                    status: true
                                });
                            }
                            else {
                                slots.push({
                                    slot: timing.slot,
                                    count: slot,
                                    sort: timing.sort,
                                    type: timing.category,
                                    status: false
                                });
                            }
                        });
                }
            }

            slots = _.orderBy(slots, 'count', 'desc');
            slots = _.uniqBy(slots, 'slot');
            slots = _.orderBy(slots, 'sort', 'asc');


            res.status(200).json({
                responseCode: 200,
                responseMessage: "",
                responseData: slots
            })
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Booking not found",
                responseData: {}
            })
        }
    }
});

router.put('/booking/rework', xAccessToken.token, async function (req, res, next) {
    var rules = {
        id: 'required',
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Lead required",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var booking = await Booking.findOne({ lead: req.body.id }).exec();
        if (booking) {
            var data = {
                is_rework: true,
                is_reviewed: false,
                updated_at: new Date()
            }
            Booking.findOneAndUpdate({ _id: booking._id }, { $set: data }, { new: true }, async function (err, doc) {
                if (err) {
                    var json = ({
                        responseCode: 422,
                        responseMessage: "Error occured",
                        responseData: {}
                    });
                    res.status(422).json(json)
                }
                else {
                    var activity = {
                        user: booking.business,
                        model: "Booking",
                        activity: "bookingReschedule",
                        source: booking._id,
                        modified: "",
                        created_at: data.updated_at,
                        updated_at: data.updated_at
                    }
                    fun.bookingLog(activity);

                    //event.assignedBookingMail(booking._id);
                    var notify = {
                        receiver: [booking.business],
                        activity: "booking",
                        tag: "rework",
                        source: booking._id,
                        sender: booking.user,
                        points: 0
                    }

                    fun.newNotification(notify);

                    if (booking.advisor) {
                        var notify = {
                            receiver: [booking.advisor],
                            activity: "booking",
                            tag: "rework",
                            source: booking._id,
                            sender: booking.user,
                            points: 0
                        }
                        fun.newNotification(notify);
                    }

                    res.status(200).json({
                        responseCode: 200,
                        responseMessage: "Assigned",
                        responseData: booking._id
                    });
                }
            });
        }
        else {
            var json = ({
                responseCode: 400,
                responseMessage: "Not eligible for rework",
                responseData: {}
            });
            res.status(400).json(json)
        }
    }
});

/*router.get('/bookings/get', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers['business'];
    var bookings = [];
    var totalResult = 0;


    var role = await Management.findOne({user:user,business:business}).exec();
    if(req.query.page == undefined)
    {
        var page = 0;
    }
    else
    {
        var page = req.query.page;
    }

    var date= new Date();
    var to = moment(date, "YYYY-MM-DD").subtract(1, 'days');

    var page = Math.max(0, parseInt(page));
    var queries = new Object();
    var sortBy = new Object();

    if(req.query.query)
    {
        if(role.role=="Service Advisor")
        {
            queries = {
                advisor: user,
                business: business,
                status: {$in:["Confirmed","Pending","Cancelled","EstimateRequested"]},
                is_services: true,
                $or:[
                    {'booking_no': { $eq: parseInt(req.query.query)}},
                    {'user.name': { $regex: req.query.query ,$options:'i'}},
                    {'user.contact_no': { $regex: req.query.query ,$options:'i'}},
                    {'car.title': { $regex: req.query.query ,$options:'i'}},
                    {'car.registration_no': { $regex: req.query.query ,$options:'i'}},
                    {'advisor.name': { $regex: req.query.query ,$options:'i'}},
                    {'advisor.contact_no': { $regex: req.query.query ,$options:'i'}},
                    {'insurance_info.insurance_company': { $regex: req.query.query ,$options:'i'}},
                    { 
                        "logs": { 
                            $elemMatch: {
                                "status": {$regex: req.query.query ,$options:'i'}
                            }  
                        } 
                    },
                    { 
                        "services": { 
                            $elemMatch: {
                                "service": {$regex: req.query.query ,$options:'i'}
                            }  
                        } 
                    },
                    { 
                        "services": { 
                            $elemMatch: {
                                "parts": {
                                    $elemMatch: {
                                        "item": {$regex: req.query.query ,$options:'i'},
                                    }  
                                }
                            }  
                        } 
                    },
                    { 
                        "services": { 
                            $elemMatch: {
                                "parts": {
                                    $elemMatch: {
                                        "part_no": {$regex: req.query.query ,$options:'i'},
                                    }  
                                }
                            }  
                        } 
                    },
                ]
            };
            sortBy = {date: 1}
        }
        else
        {
            queries = {
                business: business,
                status: {$in:["Confirmed","Pending","Cancelled","EstimateRequested"]},
                is_services: true,
                $or:[
                    {'booking_no': { $eq: parseInt(req.query.query)}},
                    {'user.name': { $regex: req.query.query ,$options:'i'}},
                    {'user.contact_no': { $regex: req.query.query ,$options:'i'}},
                    {'car.title': { $regex: req.query.query ,$options:'i'}},
                    {'car.registration_no': { $regex: req.query.query ,$options:'i'}},
                    {'advisor.name': { $regex: req.query.query ,$options:'i'}},
                    {'advisor.contact_no': { $regex: req.query.query ,$options:'i'}},
                    {'insurance_info.insurance_company': { $regex: req.query.query ,$options:'i'}},
                    { 
                        "logs": { 
                            $elemMatch: {
                                "status": {$regex: req.query.query ,$options:'i'}
                            }  
                        } 
                    },
                    { 
                        "services": { 
                            $elemMatch: {
                                "service": {$regex: req.query.query ,$options:'i'}
                            }  
                        } 
                    },
                    { 
                        "services": { 
                            $elemMatch: {
                                "parts": {
                                    $elemMatch: {
                                        "item": {$regex: req.query.query ,$options:'i'},
                                    }  
                                }
                            }  
                        } 
                    },
                    { 
                        "services": { 
                            $elemMatch: {
                                "parts": {
                                    $elemMatch: {
                                        "part_no": {$regex: req.query.query ,$options:'i'},
                                    }  
                                }
                            }  
                        } 
                    },
                ]
            };
            sortBy = {date: 1}
        }
    }
    else
    {
        if(role.role=="Service Advisor")
        {
            if(req.query.status=="Missed")
            {
                queries = {
                    advisor: user,
                    business: business,
                    status: "Confirmed",
                    is_services: true,
                    date: {"$lte": to}
                };
                sortBy = {date: 1}
            }
            else if(req.query.status=="Approval")
            {
                queries = {
                    advisor: user,
                    business: business,
                    is_services: true,
                    status: {$in: ["Approval","EstimateRequested","Approved","Rework","Pending"]},
                };

                sortBy = {updated_at: -1}
            }
            else if(req.query.status=="Cancelled")
            {
                queries = {
                    advisor: user,
                    business: business,
                    is_services: true,
                    status: {$in: ["Cancelled"]},
                };

                sortBy = {updated_at: -1}
            }
            else
            {
                queries = {
                    advisor: user,
                    business: business,
                    is_services: true,
                    status: {$in: ["Confirmed"]},
                    date: {"$gt": to}
                };
            }
        }
        else
        {
            if(req.query.status=="Missed")
            {
                queries = {
                    business: business,
                    status: "Confirmed",
                    is_services: true,
                    date: {"$lt": to}
                };
                sortBy = {date: 1}
            }
            else if(req.query.status=="Approval")
            {
                queries = {
                    business: business,
                    is_services: true,
                    status: {$in: ["Approval","EstimateRequested","Approved","Rework","Pending"]},
                };

                sortBy = {updated_at: -1}
            }
            else if(req.query.status=="Cancelled")
            {
                queries = {
                    business: business,
                    is_services: true,
                    status: {$in: ["Cancelled"]},
                };

                sortBy = {updated_at: -1}
            }
            else 
            {
                queries = {
                    business: business,
                    is_services: true,
                    status: req.query.status,
                    date: {"$gt": to}
                };

                sortBy = {updated_at: -1}
            }
        }  
    }

    var thumbnail = []

    var totalResult = await Booking.find(queries).count().exec();

    await Booking.find(queries)
    .populate({path: 'user',populate:{ path: 'user',select: "_id id name contact_no email business_info"}})
    .populate({path: 'manager',populate:{ path: 'user',select: "_id id name contact_no email"}})
    .populate({path: 'car',select:'_id id title registration_no ic rc _automaker _model', populate:{ path: 'thumbnails'}})
    .sort(sortBy).skip(config.perPage * page).limit(config.perPage)
    .cursor().eachAsync(async(booking) => {
        if(booking.address)
        {
            var address = await Address.findOne({_id: booking.address}).exec();
        }
        else{
            var address = {};
        }
        if(booking.car)
        {
            var car = {
                title: booking.car._automaker+" "+booking.car._model,
                _id: booking.car._id,
                id: booking.car.id,
                rc_address: booking.car.rc_address,
                ic_address: booking.car.ic_address,
                ic: booking.car.ic,
                rc: booking.car.rc,
                registration_no: booking.car.registration_no,
            }
        }
        else{
            var car = {
                title: "",
                _id:null,
                id: null,
                rc_address: "",
                ic_address:"",
                ic: "",
                rc: "",
                registration_no: "",
            }

        }
        var manager = null;
        if(booking.manager){
            manager = {
                name: booking.manager.name,
                _id: booking.manager._id,
                id: booking.manager.id,
                contact_no: booking.manager.contact_no,
                email: booking.manager.email
            }
        }
        bookings.push({
            _id: booking._id,
            id: booking._id,
            car: car,
            user:{
                name: booking.user.name,
                _id: booking.user._id,
                id: booking.user.id,
                contact_no: booking.user.contact_no,
                email: booking.user.email,
                business_info: booking.user.business_info
            },
            manager: manager,
            services: booking.services,
            convenience: booking.convenience,
            date: moment(booking.date).tz(req.headers['tz']).format('ll'),
            time_slot: booking.time_slot,
            status: booking.status,
            booking_no: booking.booking_no,
            job_no: booking.job_no,
            estimation_requested: booking.estimation_requested,
            address: address,
            remarks: booking.remarks,
            customer_requirements: booking.customer_requirements,
            payment: booking.payment,
            txnid: booking.txnid,
            __v: booking.__v,
            created_at: moment(booking.created_at).tz(req.headers['tz']).format('lll'),
            updated_at: moment(booking.updated_at).tz(req.headers['tz']).format('lll'),
        });
    });

    res.status(200).json({
        responseCode: 200,
        responseMessage: to,
        responseData: bookings,
        responseInfo: {
            totalResult:totalResult
        }
    });
});*/

router.get('/bookings/get', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers['business'];
    var bookings = [];
    var filters = [];
    var totalResult = 0;

    var role = await Management.findOne({ user: user, business: business }).exec();


    var date = new Date();
    var to = moment(date, "YYYY-MM-DD").subtract(1, 'days');

    var thumbnail = [];

    var specification = {};
    specification['$lookup'] = {
        from: "User",
        localField: "user",
        foreignField: "_id",
        as: "user",
    };
    filters.push(specification);

    var specification = {};
    specification['$unwind'] = {
        path: "$user",
        preserveNullAndEmptyArrays: false
    };
    filters.push(specification);

    var specification = {};
    specification['$lookup'] = {
        from: "Car",
        localField: "car",
        foreignField: "_id",
        as: "car",
    };
    filters.push(specification);

    var specification = {};
    specification['$lookup'] = {
        from: "User",
        localField: "advisor",
        foreignField: "_id",
        as: "advisor",
    };
    filters.push(specification);

    var specification = {};
    specification['$unwind'] = {
        path: "$advisor",
        preserveNullAndEmptyArrays: false
    };
    filters.push(specification);


    var page = 0;

    if (req.query.page == undefined) {
        page = 0;
    }
    else {
        page = req.query.page;
    }

    var page = Math.max(0, parseInt(page));

    if (role.role == "Service Advisor") {
        var specification = {};
        specification['$match'] = {
            "advisor._id": mongoose.Types.ObjectId(role.user),

        }
        filters.push(specification);
    }

    var queries = new Object();
    var sortBy = new Object();


    if (req.query.query) {
        var specification = {};
        specification['$match'] = {
            business: mongoose.Types.ObjectId(business),
            $or: [
                { 'status': { $regex: req.query.query, $options: 'i' } },
                { 'booking_no': { $eq: req.query.query } },
                { 'user.name': { $regex: req.query.query, $options: 'i' } },
                { 'user.contact_no': { $regex: req.query.query, $options: 'i' } },
                { 'car.title': { $regex: req.query.query, $options: 'i' } },
                { 'car.registration_no': { $regex: req.query.query, $options: 'i' } },
                { 'advisor.name': { $regex: req.query.query, $options: 'i' } },
                { 'advisor.contact_no': { $regex: req.query.query, $options: 'i' } },
                { 'insurance_info.insurance_company': { $regex: req.query.query, $options: 'i' } },
                {
                    "logs": {
                        $elemMatch: {
                            "status": { $regex: req.query.query, $options: 'i' }
                        }
                    }
                },
                {
                    "services": {
                        $elemMatch: {
                            "service": { $regex: req.query.query, $options: 'i' }
                        }
                    }
                },
                {
                    "services": {
                        $elemMatch: {
                            "parts": {
                                $elemMatch: {
                                    "item": { $regex: req.query.query, $options: 'i' },
                                }
                            }
                        }
                    }
                },
                {
                    "services": {
                        $elemMatch: {
                            "parts": {
                                $elemMatch: {
                                    "part_no": { $regex: req.query.query, $options: 'i' },
                                }
                            }
                        }
                    }
                },
            ]
        };
        filters.push(specification);


        var specification = {};
        specification['$sort'] = {
            updated_at: -1,
        };
        filters.push(specification);
    }
    else {
        if (req.query.status == "Missed") {
            var specification = {};
            specification['$match'] = {
                business: mongoose.Types.ObjectId(business),
                status: { $in: ["JobInitiated", "JobOpen"] },
                status: "Confirmed",
                is_services: true,
                date: { "$lte": to }
            };
            filters.push(specification);
        }

        else if (req.query.status == "Approval") {
            var specification = {};
            specification['$match'] = {
                business: mongoose.Types.ObjectId(business),
                status: { $in: ["Approval", "EstimateRequested", "Approved", "Rework", "Pending"] },
            };
            filters.push(specification);
        }
        else if (req.query.status == "Cancelled") {
            var specification = {};
            specification['$match'] = {
                business: mongoose.Types.ObjectId(business),
                status: { $in: ["Cancelled"] },
            };
            filters.push(specification);
        }
        else {
            var specification = {};
            specification['$match'] = {
                business: mongoose.Types.ObjectId(business),
                status: { $in: ["Confirmed"] },
            };
            filters.push(specification);
        }

        var specification = {};
        specification['$sort'] = {
            date: -1,
        };
        filters.push(specification);
    }


    totalResult = await Booking.aggregate(filters);

    var specification = {};
    specification['$skip'] = config.perPage * page;
    filters.push(specification);

    var specification = {};
    specification['$limit'] = config.perPage;
    filters.push(specification);

    await Booking.aggregate(filters)
        .allowDiskUse(true)
        .cursor({ batchSize: 10 })
        .exec()
        .eachAsync(async function (booking) {
            if (booking.car.length > 0) {
                var car = {
                    title: booking.car[0]._automaker + " " + booking.car[0]._model,
                    _id: booking.car[0]._id,
                    id: booking.car[0].id,
                    rc_address: booking.car[0].rc_address,
                    ic_address: booking.car[0].ic_address,
                    ic: booking.car[0].ic,
                    rc: booking.car[0].rc,
                    registration_no: booking.car[0].registration_no,
                }
            }
            else {
                var car = {
                    title: "",
                    _id: null,
                    id: null,
                    rc_address: "",
                    ic_address: "",
                    ic: "",
                    rc: "",
                    registration_no: "",
                }
            }

            var serverTime = moment.tz(new Date(), req.headers['tz']);

            var startDate = moment(serverTime, "DD.MM.YYYY");
            var endDate = moment(booking.delivery_date, "DD.MM.YYYY");

            var days_left = endDate.diff(startDate, 'days');

            bookings.push({
                _id: booking._id,
                id: booking._id,
                car: car,
                user: {
                    name: booking.user.name,
                    _id: booking.user._id,
                    id: booking.user.id,
                    contact_no: booking.user.contact_no,
                    email: booking.user.email,
                },
                manager: null,
                time_left: moment(booking.delivery_date).tz(req.headers['tz']).endOf('day').fromNow(),
                days_left: days_left,
                delivery_date: moment(booking.delivery_date).tz(req.headers['tz']).format('ll'),
                delivery_time: booking.delivery_time,
                status: _.startCase(booking.status),
                _status: booking.status,
                sub_status: booking.sub_status,
                job_no: booking.job_no,
                booking_no: booking.booking_no,
                created_at: moment(booking.created_at).tz(req.headers['tz']).format('lll'),
                updated_at: moment(booking.updated_at).tz(req.headers['tz']).format('lll'),
            });
        });

    res.status(200).json({
        responseCode: 200,
        responseMessage: to,
        responseInfo: {
            //role: role.role,
            //filters: filters,
            totalResult: totalResult.length
        },
        responseData: bookings,
    });
});


router.get('/leads/booking/get', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers['business'];
    var bookings = [];
    var totalResult = 0;

    var role = await Management.findOne({ user: user, business: business }).exec();

    if (role.role == "CRE") {
        var query = { manager: user, converted: true, status: { $nin: ["Rejected", "Cancelled", "Inactive"] } }
    }

    else {
        var query = { business: business, converted: true, status: { $nin: ["Rejected", "Cancelled", "Inactive"] } }
    }

    if (req.query.page == undefined) {
        var page = 0;
    }
    else {
        var page = req.query.page;
    }

    var page = Math.max(0, parseInt(page));

    var totalResult = await Booking.find(query).count().exec();

    await Booking.find(query)
        .populate({ path: 'user', populate: { path: 'user', select: "_id id name contact_no email business_info" } })
        .populate({ path: 'manager', populate: { path: 'user', select: "_id id name contact_no email" } })
        .populate({ path: 'car', select: '_id id title registration_no ic rc', populate: { path: 'thumbnails' } })
        .sort({ updated_at: -1 }).skip(config.perPage * page).limit(config.perPage)
        .cursor().eachAsync(async (booking) => {
            if (booking.address) {
                var address = await Address.findOne({ _id: booking.address }).exec();
            }
            else {
                var address = {};
            }

            if (booking.car) {
                var car = {
                    title: booking.car.title,
                    _id: booking.car._id,
                    id: booking.car.id,
                    rc_address: booking.car.rc_address,
                    ic_address: booking.car.ic_address,
                    ic: booking.car.ic,
                    rc: booking.car.rc,
                    registration_no: booking.car.registration_no,
                }
            }
            else {
                var car = {
                    title: "",
                    _id: null,
                    id: null,
                    rc_address: "",
                    ic_address: "",
                    ic: "",
                    rc: "",
                    registration_no: "",
                }
            }
            var manager = null;
            if (booking.manager) {
                manager = {
                    name: booking.manager.name,
                    _id: booking.manager._id,
                    id: booking.manager.id,
                    contact_no: booking.manager.contact_no,
                    email: booking.manager.email
                }
            }
            bookings.push({
                _id: booking._id,
                id: booking._id,
                car: car,
                user: {
                    name: booking.user.name,
                    _id: booking.user._id,
                    id: booking.user.id,
                    contact_no: booking.user.contact_no,
                    email: booking.user.email,
                    business_info: booking.user.business_info
                },
                manager: manager,
                services: booking.services,
                convenience: booking.convenience,
                date: moment(booking.date).tz(req.headers['tz']).format('ll'),
                time_slot: booking.time_slot,
                status: booking.status,
                booking_no: booking.booking_no,
                job_no: booking.job_no,
                estimation_requested: booking.estimation_requested,
                address: address,
                remarks: booking.remarks,
                customer_requirements: booking.customer_requirements,
                payment: booking.payment,
                txnid: booking.txnid,
                __v: booking.__v,
                created_at: moment(booking.created_at).tz(req.headers['tz']).format('lll'),
                updated_at: moment(booking.updated_at).tz(req.headers['tz']).format('lll'),
            });

        });

    res.status(200).json({
        responseCode: 200,
        responseMessage: "to",
        responseData: bookings,
        responseInfo: {
            totalResult: totalResult
        }
    });
});

router.get('/converted/bookings/get', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers['business'];
    var bookings = [];
    var totalResult = 0;
    var date = new Date();
    if (req.query.type == "range") {
        if (req.query.query) {
            var query = req.query.query;
            var ret = query.split("to");

            var from = new Date(ret[0]);
            var to = new Date(ret[1]);
        }
        else {
            var from = new Date(date.getFullYear(), date.getMonth(), 1);
            var to = new Date(date.getFullYear(), date.getMonth(), date.getDate() + 1);
        }
    }

    else if (req.query.type == "period") {
        if (req.query.query) {
            var query = parseInt(req.query.query);
        }
        else {
            var query = 7
        }

        var from = new Date(date.getFullYear(), date.getMonth(), date.getDate() - query);
        var to = new Date(date.getFullYear(), date.getMonth(), date.getDate() + 1);
    }
    else {
        var from = new Date(date.getFullYear(), date.getMonth(), 1);
        var to = new Date(date.getFullYear(), date.getMonth(), date.getDate() + 1);
    }


    if (req.query.role = "CRE") {
        var converted = await Lead.find({ business: business, assignee: req.query.user, converted: true, updated_at: { $gte: from, $lte: to } }).exec();

        var id = _.map(converted, '_id');

        var query = { lead: { $in: id }, status: { $nin: ["Rejected", "Cancelled", "Inactive", "EstimateRequested"] }, updated_at: { $gte: from, $lte: to } }
    }
    else if (req.query.role = "Service Advisor") {
        var query = { business: business, advisor: req.query.user, converted: true, status: { $nin: ["Rejected", "Cancelled", "Inactive", "EstimateRequested"] }, updated_at: { $gte: from, $lte: to } }
    }

    else {
        var query = { business: business, converted: true, status: { $nin: ["Rejected", "Cancelled", "Inactive", "EstimateRequested"] }, updated_at: { $gte: from, $lte: to } }
    }

    await Booking.find(query)
        .populate({ path: 'user', populate: { path: 'user', select: "_id id name contact_no email business_info" } })
        .populate({ path: 'manager', populate: { path: 'user', select: "_id id name contact_no email" } })
        .populate({ path: 'car', select: '_id id title registration_no ic rc _automaker _model', populate: { path: 'thumbnails' } })
        .sort({ updated_at: -1 })
        .cursor().eachAsync(async (booking) => {
            if (booking.address) {
                var address = await Address.findOne({ _id: booking.address }).exec();
            }
            else {
                var address = {};
            }

            var approved = _.filter(booking.services, customer_approval => customer_approval.customer_approval == true);

            var labour_cost = _.sumBy(approved, x => x.labour_cost);
            var part_cost = _.sumBy(approved, x => x.part_cost);
            var of_cost = _.sumBy(approved, x => x.of_cost);
            var discount_total = _.sumBy(approved, x => x.discount);

            var careager_cash = booking.payment.careager_cash;
            var pick_up_charges = booking.payment.pick_up_charges;
            var policy_clause = booking.payment.policy_clause;
            var salvage = booking.payment.salvage;
            var paid_total = booking.payment.paid_total;

            var payment_total = labour_cost + part_cost + of_cost + discount_total + policy_clause + salvage + pick_up_charges;

            var estimate_cost = labour_cost + part_cost + of_cost + policy_clause + salvage + pick_up_charges - careager_cash;

            var due_amount = labour_cost + part_cost + of_cost + policy_clause + salvage + pick_up_charges - (paid_total + careager_cash);

            var due = {
                due: Math.ceil(due_amount.toFixed(2))
            }

            var payment = {
                total: parseFloat(payment_total.toFixed(2)),
                estimate_cost: parseFloat(estimate_cost.toFixed(2)),
                careager_cash: careager_cash,
                of_cost: of_cost,
                labour_cost: labour_cost,
                part_cost: part_cost,
                payment_mode: booking.payment.payment_mode,
                payment_status: booking.payment.payment_status,
                discount_type: booking.payment.discount_type,
                coupon: booking.payment.coupon,
                coupon_type: booking.payment.coupon_type,
                discount_by: booking.payment.discount_by,
                discount: discount_total,
                discount_total: discount_total,
                policy_clause: policy_clause,
                salvage: salvage,
                terms: booking.payment.terms,
                pick_up_limit: booking.payment.pick_up_limit,
                pick_up_charges: pick_up_charges,
                paid_total: booking.payment.paid_total,
                discount_applied: booking.payment.discount_applied,
                transaction_id: booking.payment.coupon,
                transaction_date: booking.payment.transaction_date,
                transaction_status: booking.payment.transaction_status,
                transaction_response: booking.payment.transaction_response,
            };

            if (booking.car) {
                var car = {
                    title: booking.car._automaker + " " + booking.car._model,
                    _id: booking.car._id,
                    id: booking.car.id,
                    rc_address: booking.car.rc_address,
                    ic_address: booking.car.ic_address,
                    ic: booking.car.ic,
                    rc: booking.car.rc,
                    registration_no: booking.car.registration_no,
                }
            }
            else {
                var car = {
                    title: "",
                    _id: null,
                    id: null,
                    rc_address: "",
                    ic_address: "",
                    ic: "",
                    rc: "",
                    registration_no: "",
                }
            }
            var manager = null;
            if (booking.manager) {
                manager = {
                    name: booking.manager.name,
                    _id: booking.manager._id,
                    id: booking.manager.id,
                    contact_no: booking.manager.contact_no,
                    email: booking.manager.email
                }
            }
            bookings.push({
                _id: booking._id,
                id: booking._id,
                car: car,
                user: {
                    name: booking.user.name,
                    _id: booking.user._id,
                    id: booking.user.id,
                    contact_no: booking.user.contact_no,
                    email: booking.user.email,
                    business_info: booking.user.business_info
                },
                manager: manager,
                services: booking.services,
                convenience: booking.convenience,
                date: moment(booking.date).tz(req.headers['tz']).format('ll'),
                time_slot: booking.time_slot,
                status: booking.status,
                booking_no: booking.booking_no,
                job_no: booking.job_no,
                estimation_requested: booking.estimation_requested,
                address: address,
                remarks: booking.remarks,
                customer_requirements: booking.customer_requirements,
                payment: payment,
                txnid: booking.txnid,
                __v: booking.__v,
                created_at: moment(booking.created_at).tz(req.headers['tz']).format('lll'),
                updated_at: moment(booking.updated_at).tz(req.headers['tz']).format('lll'),
            });

        });

    res.status(200).json({
        responseCode: 200,
        responseMessage: id,
        responseData: bookings,
        responseInfo: {
            totalResult: totalResult
        }
    });
});

router.get('/booking/activities/get', xAccessToken.token, async function (req, res, next) {
    var rules = {
        id: 'required',
    };

    var validation = new Validator(req.query, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Booking required",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var booking = await Booking.findOne({ _id: req.query.id }).exec();
        var activities = [];

        if (booking) {
            await bookingLog.find({ source: booking._id })
                .populate({ path: 'user', populate: { path: 'user', select: "_id id name contact_no" } })
                .cursor().eachAsync(async (activity) => {
                    activities.push({
                        user: {
                            name: activity.user.name,
                            _id: activity.user._id,
                            id: activity.user.id,
                            contact_no: activity.user.contact_no
                        },
                        activity: _.startCase(activity.activity),
                        modified: activity.modified,
                        created_at: activity.created_at,
                        updated_at: activity.updated_at,
                    });
                });

            res.status(200).json({
                responseCode: 200,
                responseMessage: "",
                responseData: activities,
            });
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Booking required",
                responseData: {}
            })
        }
    }
});

router.get('/user/bookings/get', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers['business'];
    var bookings = [];
    var totalResult = 0;

    var role = await Management.findOne({ user: user, business: business }).exec();
    // console.log(role)
    if (req.query.page == undefined) {
        var page = 0;
    }
    else {
        var page = req.query.page;
    }

    var page = Math.max(0, parseInt(page));
    var queries = new Object();
    var sortBy = new Object();

    if (req.query.by == "user") {
        queries = {
            user: req.query.query,
            status: { "$in": ["Cancelled", "Confirmed", "Pending", "Rejected", "Closed", "Completed", "Failure", "EstimateRequested", "In-Process", "Dissatisfied", "Approval", "Approved", "Failed", "JobInitiated", "JobOpen", "EstimatePrepared", "ApprovalAwaited", "StartWork", "CloseWork", "CompleteWork", "QC", "Rework"] }
        }
    }

    if (req.query.by == "contact") {
        var user = await User.findOne({ contact_no: req.query.query }).exec();
        queries = {
            user: user._id,
            status: { "$in": ["Cancelled", "Confirmed", "Pending", "Rejected", "Closed", "Completed", "Failure", "EstimateRequested", "In-Process", "Dissatisfied", "Approval", "Approved", "Failed", "JobInitiated", "JobOpen", "EstimatePrepared", "ApprovalAwaited", "StartWork", "CloseWork", "CompleteWork", "QC", "Rework"] }
        }
    }

    totalResult = await Booking.find(queries).count().exec();

    await Booking.find(queries)
        .populate({ path: 'user', populate: { path: 'user', select: "_id id name contact_no" } })
        .populate({ path: 'manager', populate: { path: 'user', select: "_id id name contact_no" } })
        .populate({ path: 'car', select: '_id id title registration_no ic rc _automaker _model', populate: { path: 'thumbnails' } })
        .sort({ updated_at: -1 }).skip(config.perPage * page).limit(config.perPage)
        .cursor().eachAsync(async (booking) => {

            if (booking.address) {
                var address = await Address.findOne({ _id: booking.address }).exec();
            }
            else {
                var address = {};
            }
            if (booking.car.thumbnails[0]) {
                var thumbnail = [booking.car.thumbnails[0]];
            }
            else {
                var thumbnail = []
            }
            bookings.push({
                _id: booking._id,
                id: booking._id,
                car: {
                    title: booking.car._automaker + " " + booking.car._model,
                    _id: booking.car._id,
                    id: booking.car.id,
                    ic: booking.car.ic,
                    rc: booking.car.rc,
                    rc_address: booking.car.rc_address,
                    ic_address: booking.car.ic_address,
                    registration_no: booking.car.registration_no,
                    thumbnails: thumbnail
                },
                user: {
                    name: booking.user.name,
                    _id: booking.user._id,
                    id: booking.user.id,
                    contact_no: booking.user.contact_no
                },
                manager: booking.manager,
                services: booking.services,
                convenience: booking.convenience,
                date: moment(booking.date).tz(req.headers['tz']).format('ll'),
                time_slot: booking.time_slot,
                status: booking.status,
                booking_no: booking.booking_no,
                estimation_requested: booking.estimation_requested,
                address: address,
                payment: booking.payment,
                customer_requirements: booking.customer_requirements,
                txnid: booking.txnid,
                __v: booking.__v,
                updated_at: booking.updated_at,
                updated_at: booking.updated_at,
            });

        });

    res.status(200).json({
        responseCode: 200,
        responseMessage: "",
        responseData: bookings,
        responseInfo: {
            totalResult: totalResult
        }
    });
});

router.post('/user/car/add', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers['business'];

    var currentDate = new Date();

    /*var booking = await Booking.findOne({_id:req.body.id}).populate('model').select('-service_schedule').exec();*/
    var user = await User.findOne({ _id: req.body.user }).exec();
    var variant = await Variant.findOne({ _id: req.body.variant }).populate('model').select('-service_schedule').exec();

    if (user) {
        if (variant != null && variant) {
            var rg = req.body.registration_no;
            req.body.registration_no = rg.replace(/ /g, '');

            var reg = await Car.find({ registration_no: req.body.registration_no, status: true }).count().exec();
            if (reg == 0) {
                var count = await Car.find({}).count().exec();
                var automaker = await Automaker.findById(variant.model.automaker).exec();
                req.body.geometry = [0, 0];



                req.body.created_at = currentDate;
                req.body.updated_at = currentDate;

                req.body.title = variant.variant;
                req.body._variant = variant.value;
                req.body.automaker = variant.model.automaker;
                req.body._automaker = automaker.maker;
                req.body.model = variant.model._id;
                req.body._model = variant.model.value;
                req.body.segment = variant.model.segment;
                req.body.user = req.body.user;
                req.body.vin = req.body.vin;
                req.body.engine_no = req.body.engine_no;
                req.body.fuel_type = variant.specification.fuel_type;
                req.body.transmission = variant.specification.type;
                req.body.carId = Math.round(+new Date() / 1000) + Math.round((Math.random() * 9999) + 1),

                    Car.create(req.body).then(async function (car) {
                        User.findOneAndUpdate({ _id: user._id }, {
                            $push: {
                                "cars": car._id
                            }
                        }, { new: true }, async function (err, doc) {
                            if (err) {
                                // cconsole.log
                            }
                            else {
                                // cconsole.log
                            }
                        })

                        fun.addMember(req.body.user, variant.model);

                        /*Booking.findOneAndUpdate({_id: booking._id}, {$set:{car:car._id}},{new: false}, async function(err, doc){*/

                        await Car.find({ _id: car._id })
                            .populate('bookmark')
                            .populate('thumbnails')
                            .populate({ path: 'user', select: 'name username avatar avatar_address address' })
                            .populate({ path: 'variant', populate: { path: 'model' } })
                            .cursor().eachAsync(async (doc) => {
                                result = {
                                    __v: 0,
                                    _id: doc._id,
                                    id: doc.id,
                                    title: doc.title,
                                    variant: doc.variant._id,
                                    model: doc.model,
                                    modelName: doc.variant.model.model,
                                    price: 0,
                                    numericPrice: doc.price,
                                    vin: doc.vin,
                                    engine_no: doc.engine_no,
                                    accidental: doc.accidental,
                                    body_style: doc.body_style,
                                    description: doc.description,
                                    driven: doc.driven,
                                    carId: doc.carId,
                                    fuel_type: doc.fuel_type,
                                    insurance: doc.insurance,
                                    location: doc.location,
                                    manufacture_year: doc.manufacture_year,
                                    mileage: doc.mileage,
                                    owner: doc.owner,
                                    registration_no: doc.registration_no,
                                    service_history: doc.service_history,
                                    transmission: doc.transmission,
                                    vehicle_color: doc.vehicle_color,
                                    vehicle_status: doc.vehicle_status,
                                    geometry: doc.geometry,
                                    //link: "/car/"+slugify(doc.title+" "+doc._id),
                                    publish: doc.publish,
                                    status: doc.status,
                                    premium: doc.premium,
                                    is_bookmarked: doc.is_bookmarked,
                                    thumbnails: doc.thumbnails,
                                    user: doc.user,
                                    created_at: doc.created_at,
                                    updated_at: doc.updated_at
                                }
                            });

                        res.status(200).json({
                            responseCode: 200,
                            responseMessage: "Car has been added",
                            responseData: {
                                item: result
                            }
                        });
                        /*});*/

                    });
            }
            else {
                res.status(422).json({
                    responseCode: 422,
                    responseMessage: "registration no already exist",
                    responseData: {}
                });
            }
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Unprocessable Entity",
                responseData: {}
            });
        }
    }
    else {
        res.status(400).json({
            responseCode: 400,
            responseMessage: "user not found",
            responseData: {}
        });
    }
});

router.post('/booking/user/car/add', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers['business'];

    var currentDate = new Date();
    var booking = await Booking.findOne({ _id: req.body.booking }).exec();
    if (booking) {
        var car = await Car.findOne({ _id: req.body.car }).exec();
        if (car) {
            Booking.findOneAndUpdate({ _id: booking._id }, { $set: { car: car._id } }, { new: false }, async function (err, doc) {
                if (err) {
                    res.status(422).json({
                        responseCode: 422,
                        responseMessage: "Unprocessable Entity",
                        responseData: {}
                    });
                }
                else {
                    var booking = await Booking.findOne({ _id: req.body.booking }).exec();
                    res.status(200).json({
                        responseCode: 200,
                        responseMessage: "Car has been added",
                        responseData: booking
                    });
                }
            });
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Car not found",
                responseData: {}
            });
        }
    }
    else {
        res.status(400).json({
            responseCode: 400,
            responseMessage: "Booking not found",
            responseData: {}
        });
    }
});

router.get('/user/cars/get', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers['business'];
    var car = []
    var currentDate = new Date();


    await Car.find({ user: req.query.user, status: true })
        .populate('bookmark')
        .populate('thumbnails')
        .populate({ path: 'user', select: 'name username avatar avatar_address address' })
        .populate({ path: 'variant', populate: { path: 'model' } })
        .sort({ created_at: -1 })
        .cursor().eachAsync(async (doc) => {

            car.push({
                __v: 0,
                _id: doc._id,
                id: doc.id,
                title: doc.title,
                variant: doc.variant._id,
                model: doc.model,
                modelName: doc.variant.model.model,
                price: doc.price,
                numericPrice: doc.price,
                accidental: doc.accidental,
                body_style: doc.body_style,
                description: doc.description,
                driven: doc.driven,
                carId: doc.carId,
                fuel_type: doc.fuel_type,
                insurance: doc.insurance,
                location: doc.location,
                manufacture_year: doc.manufacture_year,
                mileage: doc.mileage,
                owner: doc.owner,
                registration_no: doc.registration_no,
                transmission: doc.transmission,
                vehicle_color: doc.vehicle_color,
                vehicle_status: doc.vehicle_status,
                geometry: doc.geometry,
                fuel_level: doc.fuel_level,
                engine_no: doc.engine_no,
                vin: doc.vin,
                ic: doc.ic,
                rc: doc.rc,
                ic_address: doc.ic_address,
                rc_address: doc.rc_address,
                publish: doc.publish,
                status: doc.status,
                premium: doc.premium,
                is_bookmarked: doc.is_bookmarked,
                thumbnails: doc.thumbnails,
                user: doc.user,
                insurance_info: doc.insurance_info,
                created_at: doc.created_at,
                updated_at: doc.updated_at
            });
        });

    res.status(200).json({
        responseCode: 200,
        responseMessage: "success",
        responseData: car
    });
});

router.get('/services/category/get', xAccessToken.token, async function (req, res, next) {
    var data = [];
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;

    await BookingCategory.find({})
        .sort({ position: 1 })
        .cursor().eachAsync(async (d) => {
            data.push({
                _id: d._id,
                id: d._id,
                tag: d.tag,
                position: d.position,
                icon: d.icon,
                title: d.title,
                image: d.image,
                video: d.video,
                home_visibility: d.home_visibility,
                id: d._id,
                nested: d.nested,
                enable: true,
                features: d.features
            })
        });

    res.status(200).json({
        responseCode: 200,
        responseMessage: "",
        responseData: data
    })
});

router.put('/booking/remarks/edit', xAccessToken.token, async function (req, res, next) {
    var rules = {
        booking: 'required',
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Booking required",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var user = decoded.user;
        var business = req.headers['business'];
        var booking = await Booking.findOne({ _id: req.body.booking, business: business }).exec();
        var loggedInDetails = await User.findById(decoded.user).exec();
        if (booking) {
            var remarks = [];
            if (booking.remarks) {
                remarks = booking.remarks;
            }

            remarks.push({
                remark: req.body.remark,
                added_by: loggedInDetails._id,
                date: moment().format('YYYY-MM-DD'),
                created_at: new Date(),
                updated_at: new Date()
            });

            var service_reminder = null;
            if (req.body.date) {
                service_reminder = new Date(req.body.date).toISOString();
            }

            var data = {
                remarks: remarks,
                service_reminder: service_reminder,
                updated_at: new Date()
            }


            Booking.findOneAndUpdate({ _id: booking._id }, { $set: data }, { new: false }, async function (err, doc) {
                if (err) {
                    res.status(422).json({
                        responseCode: 422,
                        responseMessage: "Server Error",
                        responseData: err
                    });
                }
                else {
                    var updated = await Booking.findOne({ _id: req.body.booking }).exec();
                    res.status(200).json({
                        responseCode: 200,
                        responseMessage: "Remark has been added",
                        responseData: updated
                    });
                }
            });
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Booking not found",
                responseData: {}
            });
        }
    }
});

router.get('/bookings/count', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers['business'];
    var status = [];

    var pending = await Booking.find({ business: business, is_services: true, status: "Pending" }).count().exec();

    status.push({
        status: "Pending",
        count: pending
    });

    var confirmed = await Booking.find({ business: business, is_services: true, status: "Confirmed" }).count().exec();
    status.push({
        status: "Confirmed",
        count: confirmed
    })

    var completed = await Booking.find({ business: business, is_services: true, status: "Completed" }).count().exec();
    status.push({
        status: "Completed",
        count: completed
    })

    var rejected = await Booking.find({ business: business, is_services: true, status: "Rejected" }).count().exec();
    status.push({
        status: "Rejected",
        count: rejected
    })

    var cancelled = await Booking.find({ business: business, is_services: true, status: "Cancelled" }).count().exec();
    status.push({
        status: "Cancelled",
        count: cancelled
    })


    var date = new Date();
    date.setDate(date.getDate() - 1);
    queries = {
        business: business,
        status: { $ne: "Inactive" },

        $or: [
            {
                status: { $ne: "Rejected" }
            },
            {
                status: { $ne: "Cancelled" }
            },
            {
                status: { $ne: "Completed" }
            }
        ],
        is_services: true,
        date: { "$lte": date }
    };

    var missed = await Booking.find(queries).count().exec();
    status.push({
        status: "Missed",
        count: missed
    })

    res.status(200).json({
        responseCode: 200,
        responseMessage: "success",
        responseData: status
    });
});

router.put('/booking/status', xAccessToken.token, async function (req, res, next) {
    var rules = {
        id: 'required',
        status: 'required',
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Error",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var user = decoded.user;
        var business = req.headers['business'];


        var loggedInDetails = await User.findById(user).exec();
        var check = await Booking.findOne({ _id: req.body.id, business: business, is_services: true }).exec();
        var role = await Management.findOne({ business: business, user: loggedInDetails._id }).exec();

        if (!check) {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Booking not found",
                responseData: {}
            });
        }
        else {
            var status = check.status;
            var data = {
                status: req.body.status,
                status: req.body.status,
                is_rework: false,
                is_reviewed: false,
                updated_at: new Date()
            }

            if (check.status != req.body.status) {
                Booking.findOneAndUpdate({ _id: req.body.id }, { $set: data }, { new: true }, async function (err, doc) {
                    if (err) {
                        var json = ({
                            responseCode: 422,
                            responseMessage: "Error occured",
                            responseData: {}
                        });
                        res.status(422).json(json)
                    }
                    else {
                        var booking = await Booking.findOne({ _id: check._id }).exec();
                        var activity = {
                            user: user,
                            model: "Booking",
                            activity: "updateBookingStatus",
                            source: booking._id,
                            modified: check.status + " to " + data.status,
                            created_at: data.updated_at,
                            updated_at: data.updated_at
                        }

                        fun.bookingLog(activity);

                        if (req.body.status == "Confirmed") {
                            var notify = {
                                receiver: [booking.user],
                                activity: "booking",
                                tag: "bookingConfirmation",
                                source: check._id,
                                sender: user,
                                points: 0
                            };
                            fun.newNotification(notify);
                            event.bookingStatusMail(booking.user, booking._id)
                        }

                        if (req.body.status == "Cancelled") {
                            if (req.body.remark) {
                                var remark = {
                                    remark: req.body.remark,
                                    added_by: decoded.user,
                                    created_at: data.updated_at,
                                    updated_at: data.updated_at
                                };

                                Booking.findOneAndUpdate({ _id: booking._id }, { $push: { remarks: remark } }, { new: false }, async function (err, doc) {
                                });
                            }

                            if (booking.payment.coupon) {
                                var checkCouponUsed = await CouponUsed.find({ booking: booking._id }).count().exec();
                                if (checkCouponUsed == 1) {
                                    await CouponUsed.remove({ booking: booking._id }).exec();
                                }
                            }

                            if (role.role == "Service Advisor") {
                                if (booking.converted) {
                                    if (booking.manager) {
                                        var notify = {
                                            receiver: [booking.manager],
                                            activity: "booking",
                                            tag: "BookingCancelled",
                                            source: check._id,
                                            sender: loggedInDetails._id,
                                            points: 0
                                        }

                                        fun.newNotification(notify);
                                    }
                                }
                            }
                            else if (role.role == "CRE") {
                                var notify = {
                                    receiver: [booking.advisor],
                                    activity: "booking",
                                    tag: "BookingCancelled",
                                    source: check._id,
                                    sender: loggedInDetails._id,
                                    points: 0
                                }

                                fun.newNotification(notify);
                            }
                            else {
                                if (booking.converted) {
                                    if (booking.manager) {
                                        var notify = {
                                            receiver: [booking.manager],
                                            activity: "booking",
                                            tag: "BookingCancelled",
                                            source: check._id,
                                            sender: loggedInDetails._id,
                                            points: 0
                                        }

                                        fun.newNotification(notify);
                                    }
                                }

                                var notify = {
                                    receiver: [booking.advisor],
                                    activity: "booking",
                                    tag: "BookingCancelled",
                                    source: check._id,
                                    sender: loggedInDetails._id,
                                    points: 0
                                }

                                fun.newNotification(notify);

                            }

                            var notify = {
                                receiver: [booking.user],
                                activity: "booking",
                                tag: "BookingCancelled",
                                source: check._id,
                                sender: loggedInDetails._id,
                                points: 0
                            }

                            fun.newNotification(notify);

                            if (booking.payment.careager_cash > 0) {
                                var point = {
                                    user: booking.user,
                                    activity: "coin",
                                    tag: "BookingCancelled",
                                    source: booking._id,
                                    sender: null,
                                    title: "",
                                    body: "",
                                    points: booking.payment.careager_cash,
                                    status: true
                                }

                                fun.addPoints(point)
                            }

                        }

                        else if (req.body.status == "Completed" && status != "Completed") {
                            var point = {
                                user: check.user,
                                activity: "coin",
                                tag: "bookingCompleted",
                                source: check._id,
                                sender: null,
                                points: 50,
                                title: "",
                                body: "",
                                status: true
                            }

                            fun.addPoints(point)

                            if (booking.payment.labour_cost >= 5000) {
                                var getRefree = await User.findById(booking.user).exec();

                                if (getRefree.account_info.added_by) {
                                    var refree = await User.findById(getRefree.account_info.added_by).exec();
                                    if (refree) {
                                        if (refree.account_info.type = "driver") {
                                            var commission = booking.payment.labour_cost * .05;
                                            var cashInterest = refree.careager_cash * .05;

                                            var cash = parseFloat(cashInterest) + parseFloat(commission);

                                            var point = {
                                                user: refree._id,
                                                points: parseFloat(cash),
                                                activity: "coin",
                                                tag: "commission",
                                                source: booking._id,
                                                title: "",
                                                body: "",
                                                status: true
                                            }
                                            fun.addPoints(point);
                                        }
                                    }
                                }
                            }

                            if (booking.manager) {
                                var notify = {
                                    receiver: [booking.manager],
                                    activity: "booking",
                                    tag: "bookingCompleted",
                                    source: check._id,
                                    sender: null,
                                    points: 0
                                }

                                fun.newNotification(notify);
                            }

                            if (booking.due) {
                                var paid_total = booking.payment.paid_total + booking.due.due;
                                Booking.findOneAndUpdate({ _id: req.body.id }, { $set: { "payment.payment_status": "Success", "payment.paid_total": paid_total, due: null } }, { new: false }, async function (err, doc) { })
                            }
                        }

                        var activity = {
                            user: loggedInDetails._id,
                            name: loggedInDetails.name,
                            stage: "Booking",
                            activity: req.body.status,
                        };

                        fun.bookingLog(booking._id, activity);
                        event.zohoLead(booking._id);

                        var json = ({
                            responseCode: 200,
                            responseMessage: "Booking has been " + req.body.status,
                            responseData: {}
                        });

                        res.status(200).json(json)
                    }
                });
            }
            else {
                res.status(200).json({
                    responseCode: 200,
                    responseMessage: "Booking has been " + req.body.status,
                    responseData: {}
                });
            }
        }
    }
});

router.put('/booking/reschedule/', xAccessToken.token, async function (req, res, next) {
    var rules = {
        id: 'required',
        date: 'required',
        time_slot: 'required'
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Error",
            responseData: {
                res: validation.errors.all()
            }
        });
    }
    else {
        if (req.body.package == "") {
            req.body.package = null;
        }

        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var user = decoded.user;
        var business = req.headers['business'];
        var total = 0;
        var labour_cost = 0;
        var part_cost = 0;
        var bookingService = [];
        var services = req.body.services;
        var loggedInDetails = await User.findById(decoded.user).exec();
        var role = await Management.findOne({ user: loggedInDetails._id, business: business }).exec();

        var booking = await Booking.findOne({ _id: req.body.id, business: business, is_services: true }).exec();



        if (!booking) {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Unauthorized",
                responseData: {},
            });
        }
        else {
            var check = await BookingTiming.find({ business: business }).count().exec();

            var body = booking.services;
            body = _.uniqBy(body, 'type');
            var slots = [];
            var date = new Date(new Date(req.body.date).setHours(0, 0, 0, 0));
            var next = new Date(new Date(req.body.date).setHours(0, 0, 0, 0));
            next.setDate(date.getDate() + 1);


            for (var i = 0; i < body.length; i++) {
                if (body[i].type == "addOn") {
                    body[i].type = "services"
                }
                if (check > 0) {
                    await BookingTiming.find({ business: business, category: body[i].type })
                        .sort({ sort: 1 })
                        .cursor().eachAsync(async (timing) => {

                            var slot = await Booking.find({
                                time_slot: timing.slot,
                                is_services: true,
                                business: business,
                                date: { $gte: date, $lt: next },
                                services: { $elemMatch: { type: body[i].type } },
                                status: { $nin: ["Inactive", "Rejected", "Cancelled", "Completed", "Closed"] },
                            }).count().exec();

                            if (slot < timing.booking_per_slot) {
                                slots.push({
                                    slot: timing.slot,
                                    count: slot,
                                    sort: timing.sort,
                                    type: timing.category,
                                    status: true
                                });
                            }
                        });
                }
                else {
                    await BookingTiming.find({ business: null, category: body[i].type })
                        .sort({ sort: 1 })
                        .cursor().eachAsync(async (timing) => {

                            var slot = await Booking.find({
                                time_slot: timing.slot,
                                is_services: true,
                                business: business,
                                date: { $gte: date, $lt: next },
                                services: { $elemMatch: { type: body[i].type } },
                                status: { $nin: ["Inactive", "Rejected", "Cancelled", "Completed", "Closed"] },
                            }).count().exec();

                            if (slot < timing.booking_per_slot) {
                                slots.push({
                                    slot: timing.slot,
                                    count: slot,
                                    sort: timing.sort,
                                    type: timing.category,
                                    status: true
                                });
                            }
                        });
                }
            }

            if (slots.length <= 0) {
                res.status(422).json({
                    responseCode: 422,
                    responseMessage: "All Slots are full for " + req.body.date,
                    responseData: {}
                });
            }
            else {
                var status = "Confirmed";
                var data = {
                    date: new Date(req.body.date).toISOString(),
                    time_slot: req.body.time_slot,
                    status: "Confirmed",
                    updated_at: new Date()
                };

                Booking.findOneAndUpdate({ _id: req.body.id }, { $set: data }, { new: false }, async function (err, doc) {
                    if (err) {
                        var json = ({
                            responseCode: 400,
                            responseMessage: "Error occured",
                            responseData: {}
                        });
                        res.status(400).json(json)
                    }
                    else {
                        var booking = await Booking.findById(req.body.id).exec()

                        var activity = {
                            user: loggedInDetails._id,
                            name: loggedInDetails.name,
                            stage: "Booking",
                            activity: "rescheduleBooking",
                        };

                        fun.bookingLog(booking._id, activity);
                        if (role.role == "CRE") {
                            var notify = {
                                receiver: [booking.advisor],
                                activity: "booking",
                                tag: "bookingReschedule",
                                source: booking._id,
                                sender: loggedInDetails._id,
                                points: 0,
                                tz: req.headers['tz']
                            };
                            fun.newNotification(notify);
                        }

                        if (role.role == "Service Advisor") {
                            var notify = {
                                receiver: [booking.manager],
                                activity: "booking",
                                tag: "bookingReschedule",
                                source: booking._id,
                                sender: loggedInDetails._id,
                                points: 0,
                                tz: req.headers['tz']
                            };
                            fun.newNotification(notify);
                        }


                        var notify = {
                            receiver: [booking.user],
                            activity: "booking",
                            tag: "bookingReschedule",
                            source: booking._id,
                            sender: loggedInDetails._id,
                            points: 0,
                            tz: req.headers['tz']
                        };
                        fun.newNotification(notify);
                        event.rescheduleMail(booking._id, loggedInDetails.account_info.type);

                        var json = ({
                            responseCode: 200,
                            responseMessage: "Booking rescheduled",
                            responseData: {
                                status: booking.status,
                                date: moment(data.date).tz(req.headers['tz']).format('ll'),
                                time_slot: data.time_slot,
                                updated_at: data.updated_at
                            }
                        });
                        res.status(200).json(json)
                    }
                });
            }
        }
    }
});

router.get('/product/category/get', xAccessToken.token, async function (req, res, next) {
    const productCategories = await ProductCategory.find({ parent_id: null }).exec();
    res.status(200).json({
        responseCode: 200,
        responseMessage: "success",
        responseData: productCategories
    });
});

router.get('/product/subcategory/get', xAccessToken.token, async function (req, res, next) {
    const productCategories = await ProductCategory.find({ parent_id: req.query.id }).exec();
    res.status(200).json({
        responseCode: 200,
        responseMessage: "success",
        responseData: productCategories,
    });
});

router.get('/product/brands/get', xAccessToken.token, async function (req, res, next) {
    if (req.query.by == "category") {
        var data = await ProductBrand.find({ category: req.query.query }).exec();
    }
    else if (req.query.by == "tag") {
        var data = await ProductBrand.find({ tag: req.query.query }).exec();
    }
    else if (req.query.by == "id") {
        var data = await ProductBrand.findOne({ _id: req.query.query }).exec();
    }
    else {
        var data = await ProductBrand.find({}).exec();
    }
    res.status(200).json({
        responseCode: 200,
        responseMessage: "success",
        responseData: data
    });
});

router.get('/product/models/get', xAccessToken.token, async function (req, res, next) {
    var rules = {
        id: 'required',
    };

    var validation = new Validator(req.query, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Error",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        res.status(200).json({
            responseCode: 200,
            responseMessage: "success",
            responseData: await ProductModel.find({ brand: req.query.id }).exec(),
        });
    }
});

router.get('/products/master/get', xAccessToken.token, async function (req, res, next) {
    var rules = {
        id: 'required',
    };

    var validation = new Validator(req.query, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Error",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        res.status(200).json({
            responseCode: 200,
            responseMessage: "success",
            responseData: await Product.find({ product_model: req.query.id, /*common: true*/ }).exec(),
        });
    }
});

router.get('/business/category/get', xAccessToken.token, async function (req, res, next) {
    const categories = await Category.find({}).exec();
    res.status(200).json({
        responseCode: 200,
        responseMessage: "success",
        responseData: categories
    });
});

router.post('/vendor/add', xAccessToken.token, async function (req, res, next) {
    var rules = {
        contact_no: 'required',
        name: 'required',
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Validation Error",
            responseData: {
                res: validation.errors.all()
            }
        });
    }
    else {

        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var user = decoded.user;
        var business = req.headers['business'];

        var checkPhone = await User.find({ contact_no: req.body.contact_no, "account_info.type": "business" }).count().exec();
        if (checkPhone == 0) {
            var otp = Math.floor(Math.random() * 90000) + 10000;

            req.body.username = shortid.generate();

            req.body.socialite = {};
            req.body.optional_info = {};

            var address = req.body.address;

            var country = await Country.findOne({ timezone: { $in: req.headers['tz'] } }).exec();

            req.body.address = {
                country: country.countryName,
                timezone: req.headers['tz'],
                location: req.body.location,
                address: req.body.address,
                state: req.body.state
            };

            req.body.bank_details = {
                ifsc: req.body.ifsc,
                account_no: req.body.account_no,
                account_holder: req.body.account_holder
            };

            req.body.account_info = {
                type: "business",
                status: "Complete",
                added_by: business,
                phone_verified: false,
                verified_account: false,
                approved_by_admin: false,
            };

            req.body.geometry = [0, 0];

            req.body.device = [];
            req.body.otp = otp;
            req.body.uuid = uuidv1();

            req.body.business_info = {
                business_category: req.body.business_category,
                company_name: req.body.company,
                account_no: req.body.account_no,
                gst_registration_type: req.body.gst_registration_type,
                gstin: req.body.gstin,
                tax_registration_no: req.body.tax_registration_no,
                pan_no: req.body.pan_no
            };

            var firstPart = (Math.random() * 46656) | 0;
            var secondPart = (Math.random() * 46656) | 0;
            firstPart = ("000" + firstPart.toString(36)).slice(-3);
            secondPart = ("000" + secondPart.toString(36)).slice(-3);
            req.body.referral_code = firstPart.toUpperCase() + secondPart.toUpperCase();

            User.create(req.body).then(async function (user) {
                var days = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];

                for (var i = 0; i < 7; i++) {
                    var timing = new BusinessTiming({
                        business: user._id,
                        day: days[i],
                        open: '09:30 AM',
                        close: '06:30 PM',
                        is_closed: false,
                        created_at: new Date(),
                        updated_at: new Date(),
                    });
                    timing.save();
                }

                Type.find({}).then(function (BT) {
                    BT.forEach(function (u) {
                        var businessType = new BusinessType({
                            business: user._id,
                            business_type: u._id,
                            is_added: false,
                        });
                        businessType.save();
                    });
                });

                /*Management.create({
                    business: user._id,
                    user: user._id,
                    role : "Admin",
                    created_at: new Date(),
                    updated_at: new Date(),
                });
                */

                BusinessVendor.create({
                    vendor: user._id,
                    business: business,
                    created_at: user.created_at,
                    updated_at: user.updated_at
                })

                Address.create({
                    user: user._id,
                    address: address,
                    area: req.body.area,
                    landmark: req.body.landmark,
                    zip: req.body.zip,
                    city: req.body.city,
                    state: req.body.state,
                    created_at: new Date(),
                    updated_at: new Date()
                });

                res.status(200).json({
                    responseCode: 200,
                    responseMessage: "success",
                    responseData: {
                        user: user
                    },
                });
            });
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Phone number already in use.",
                responseData: {},
            });
        }
    }
});

router.put('/vendor-info/update', xAccessToken.token, async function (req, res, next) {
    var rules = {
        user: 'required',
        name: 'required',
        contact_no: 'required',
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "All field required",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var user = await User.findById(req.body.user).exec();
        if (user) {
            var check = await User.findOne({ contact_no: req.body.contact_no, _id: { $ne: user._id }, "account_info.type": user.account_info.type, }).exec();

            if (check) {
                res.status(400).json({
                    responseCode: 400,
                    responseMessage: "Contact no already exist",
                    responseData: {}
                });
            }
            else {
                User.findOneAndUpdate({ _id: user._id }, {
                    $set: {
                        name: req.body.name,
                        contact_no: req.body.contact_no,
                        email: req.body.email,
                        "business_info.company_name": req.body.company_name,
                        "business_info.gstin": req.body.gstin,
                        updated_at: new Date()
                    }
                }, { new: false }, function (err, doc) {
                    if (err) {
                        res.status(422).json({
                            responseCode: 422,
                            responseMessage: "Error Occurred",
                            responseData: err,
                        })
                    }
                    else {
                        res.status(200).json({
                            responseCode: 200,
                            responseMessage: "User details updated...",
                            responseData: {},
                        })
                    }
                });
            }
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "User not found",
                responseData: {},
            })
        }
    }
});

router.delete('/vendor/delete', xAccessToken.token, async function (req, res, next) {
    var rules = {
        vendor: 'required',
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Business is required!",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var user = decoded.user;
        var business = req.headers['business'];

        var user = await User.findById(req.body.vendor).exec();

        if (user) {
            BusinessVendor.remove({ vendor: user._id, business: business }).exec();
            res.status(200).json({
                responseCode: 200,
                responseMessage: "Vendor has been removed from list",
                responseData: {},
            });
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Business not found",
                responseData: {},
            });
        }
    }
});

router.get('/vendors/get', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers['business'];
    var product = new Object();
    var result = [];


    if (req.query.page == undefined) {
        var page = 0;
    } else {
        var page = req.query.page;
    }
    var page = Math.max(0, parseInt(page));

    if (req.query.limit == undefined) {
        var limit = 50;
    } else {
        var limit = parseInt(req.query.limit);
    }

    var list = []
    await BusinessVendor.find({ business: business }).cursor().eachAsync(async (p) => {
        list.push(mongoose.Types.ObjectId(p.vendor))
    })

    if (req.query.query) {
        var query = {

            $and: [
                { "_id": { $in: list } },
                {
                    $or: [
                        {
                            name: { $regex: req.query.query, $options: 'i' }
                        },
                        {
                            "contact_no": { $regex: req.query.query, $options: 'i' }
                        },
                        {
                            "business_info.gstin": { $regex: req.query.query, $options: 'i' }
                        }
                    ]
                }
            ]

        }
    } else {
        var query = {
            "_id": { $in: list },
        }
    }

    await User.find(query)
        .skip(limit * page).limit(limit)
        .cursor().eachAsync(async (p) => {
            result.push({
                _id: p._id,
                name: p.name,
                email: p.email,
                contact_no: p.contact_no,
                address: p.address,
                bank_details: p.bank_details,
                business_info: p.business_info,
                account_info: p.account_info,
            })
        });
    res.status(200).json({
        responseCode: 200,
        responseQuery: query,
        responseMessage: "success",
        responseData: result
    });
});

router.get('/vendor/details/get', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var business = req.headers['business'];
    var product = new Object();
    var result = [];


    var user = await User.findById(req.query.user).exec();
    if (user) {
        var address = await Address.find({ user: user._id }).exec();
        var info = {
            _id: user.id,
            id: user.id,
            name: user.name,
            username: user.username,
            email: user.email,
            contact_no: user.contact_no,
            avatar: user.avatar,
            avatar_address: user.avatar_address,
            business_info: user.business_info,
            bank_details: user.bank_details,
            account_info: user.account_info,
            address: address,
        }

        res.status(200).json({
            responseCode: 200,
            responseMessage: "success",
            responseData: info
        });
    }
    else {
        res.status(400).json({
            responseCode: 400,
            responseMessage: "Vendor not found",
            responseData: {}
        });
    }
});

router.get('/vendor/bills/get', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var business = req.headers['business'];

    var vendor = await User.findById(req.query.user).exec();
    if (vendor) {
        var bills = [];
        if (req.query.page == undefined) {
            var page = 0;
        } else {
            var page = req.query.page;
        }

        if (req.query.limit) {
            var limit = parseInt(req.query.limit);
        } else {
            var limit = 50;
        }

        await Purchase.find({ business: business, vendor: vendor._id, status: { $ne: "Deleted" } })
            .sort({ bill_no: -1 })
            .skip(limit * page).limit(limit)
            .cursor().eachAsync(async (p) => {
                bills.push({
                    _id: p._id,
                    id: p._id,
                    bill_no: p.bill_no,
                    reference_no: p.reference_no,
                    date: moment(p.date).tz(req.headers['tz']).format('YYYY-MM-DD'),
                    due_date: moment(p.due_date).tz(req.headers['tz']).format('YYYY-MM-DD'),
                    business: p.business,
                    total: p.total,
                    status: p.status,
                    created_at: moment(p.created_at).tz(req.headers['tz']).format('lll'),
                    updated_at: moment(p.updated_at).tz(req.headers['tz']).format('lll'),
                });
            });

        res.status(200).json({
            responseCode: 200,
            responseMessage: "Sucesss",
            responseInfo: {
                totalResult: await Purchase.find({ business: business, vendor: vendor._id, status: { $ne: "Deleted" } }).count().exec()
            },
            responseData: bills
        });
    }
    else {
        res.status(400).json({
            responseCode: 400,
            responseMessage: "Vendor not found",
            responseData: {}
        });
    }
});

router.post('/products/type/update', xAccessToken.token, async function (req, res, next) {
    await Product.find({}).cursor().eachAsync(async (product) => {
        BusinessProduct.findOneAndUpdate({ product: product._id }, { $set: { type: product.type } }, { new: false }, function (err, doc) { });
    })

    res.status(200).json({
        responseCode: 200,
        responseMessage: "Product has been update",
        responseData: {}
    });
});

router.put('/product/update', xAccessToken.token, async function (req, res, next) {
    var rules = {
        id: 'required',
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Error",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var business = req.headers['business'];
        var product = [];
        var check = await BusinessProduct.find({ _id: req.body.id, business: business }).count().exec();
        if (check == 1) {
            var data = {
                title: req.body.title,
                product: req.body.product,
                description: req.body.description,
                discount: req.body.discount,
                model_no: req.body.model_no,
                models: req.body.models,
                detail: req.body.detail,
                updated_at: new Date()
            };

            BusinessProduct.findOneAndUpdate({ _id: req.body.id, business: business }, { $set: data }, { new: false }, async function (err, doc) {
                if (err) {
                    var json = ({
                        responseCode: 400,
                        responseMessage: "Error occured",
                        responseData: {}
                    });

                    res.status(400).json(json)
                }
                else {
                    await BusinessProduct.findOne({ _id: req.body.id, business: business })
                        .populate('thumbnails')
                        .cursor().eachAsync(async (p) => {
                            res.status(200).json({
                                responseCode: 200,
                                responseMessage: "Product has been edited",
                                responseData: {
                                    item: {
                                        _id: p._id,
                                        id: p.id,
                                        title: p.title,
                                        description: p.description,
                                        price: p.price,
                                        discount: p.discount,
                                        category: p.category,
                                        model_no: p.model_no,
                                        models: p.models,
                                        thumbnails: p.thumbnails,
                                        business: p.business,
                                        bookmark: p.bookmark,
                                        created_at: moment(p.created_at).tz(req.headers['tz']).format('LL'),
                                        updated_at: moment(p.updated_at).tz(req.headers['tz']).format('LL'),
                                    }
                                }
                            });
                        });
                }
            });
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Unauthorized",
                responseData: {}
            });
        }
    }
});

router.put('/product/stock/update', xAccessToken.token, async function (req, res, next) {
    var rules = {
        product: 'required',
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Error",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var business = req.headers['business'];
        var product = [];
        var loggedInDetails = await User.findById(decoded.user).exec();
        var check = await BusinessProduct.find({ _id: req.body.product, business: business }).count().exec();
        if (check == 1) {
            var total = req.body.total;
            var available = req.body.available;

            BusinessProduct.findOneAndUpdate({
                _id: req.body.product,
                business: business,
            },
                {
                    $set: {
                        stock: {
                            total: parseFloat(total.toFixed(2)),
                            available: parseFloat(available.toFixed(2)),
                            consumed: parseFloat(total.toFixed(2)) - parseFloat(available.toFixed(2)),
                        }
                    }
                }, { new: false }, async function (err, doc) {
                    if (err) {
                        var json = ({
                            responseCode: 400,
                            responseMessage: "Error occured",
                            responseData: {}
                        });

                        res.status(400).json(json)
                    }
                    else {

                        var activity = {
                            user: loggedInDetails._id,
                            name: loggedInDetails.name,
                            stage: "Stock Update",
                            activity: "Stock Change Total: " + parseFloat(total.toFixed(2)) + " Available: " + parseFloat(available.toFixed(2)),
                        };

                        fun.productLog(req.body.product, activity);

                        res.status(200).json({
                            responseCode: 200,
                            responseMessage: "Successfully updated",
                            responseData: {}
                        })
                    }
                });
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Product not found",
                responseData: {}
            });
        }
    }
});

router.put('/product/sku/update', xAccessToken.token, async function (req, res, next) {
    var rules = {
        product: 'required',
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Error",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var business = req.headers['business'];
        var product = [];
        var loggedInDetails = await User.findById(decoded.user).exec();
        var check = await BusinessProduct.find({ _id: req.body.product, business: business }).count().exec();
        if (check == 1) {
            BusinessProduct.findOneAndUpdate({
                _id: req.body.product,
                business: business,
                sku: {
                    $elemMatch: {
                        '_id': req.body.id
                    }
                }
            },
                {
                    $set: {
                        'sku.$.sku': req.body.sku,
                        'sku.$.total': req.body.total,
                        'sku.$.available': req.body.available,
                    }
                }, { new: false }, async function (err, doc) {
                    if (err) {
                        var json = ({
                            responseCode: 400,
                            responseMessage: "Error occured",
                            responseData: {}
                        });

                        res.status(400).json(json)
                    }
                    else {
                        var activity = {
                            user: loggedInDetails._id,
                            name: loggedInDetails.name,
                            stage: "SKU Update",
                            activity: "SKU Update SKU: " + req.body.sku + " Total: " + parseFloat(req.body.total.toFixed(2)) + " Available: " + parseFloat(req.body.available.toFixed(2)),
                        };

                        fun.productLog(req.body.product, activity);

                        res.status(200).json({
                            responseCode: 200,
                            responseMessage: "Successfully updated",
                            responseData: {}
                        })
                    }
                });
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Unauthorized",
                responseData: {}
            });
        }
    }
});

router.delete('/product/sku/delete', xAccessToken.token, async function (req, res, next) {
    var rules = {
        product: 'required',
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Error",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var business = req.headers['business'];
        var product = await BusinessProduct.findOne({ _id: req.body.product, business: business }).exec();
        if (product) {
            var totalSKU = product.sku
            if (totalSKU.length > 1) {
                BusinessProduct.findOneAndUpdate({
                    _id: req.body.product,
                    business: business,
                    sku: {
                        $elemMatch: {
                            '_id': req.body.id
                        }
                    }
                },
                    {
                        "$pull": {
                            "sku": { "_id": req.body.id }
                        }
                    },
                    function (err, doc) {
                        if (err) {
                            res.status(400).json({
                                responseCode: 400,
                                responseMessage: "Server Error",
                                responseData: err,
                            });
                        }
                        else {
                            res.status(200).json({
                                responseCode: 200,
                                responseMessage: "SKU updated",
                                responseData: {},
                            });
                        }
                    });
            }
            else {
                res.status(400).json({
                    responseCode: 400,
                    responseMessage: "You cannot delete this SKU location. Permission to edit only",
                    responseData: {}
                });
            }
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Unauthorized",
                responseData: {}
            });
        }
    }
});

router.get('/vertical/products/get', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var business = req.headers['business'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    //paginate
    if (req.query.page == undefined) {
        var page = 0;
    } else {
        var page = req.query.page;
    }

    var page = Math.max(0, parseInt(page));
    var result = [];


    await Product.find({ $or: [{ part_no: new RegExp(req.query.query, "i") }, { title: new RegExp(req.query.query, "i") }] })
        .cursor().eachAsync(async (p) => {
            result.push({
                _id: p._id,
                id: p._id,
                product: p.product,
                part_no: p.part_no,
                hsn_sac: p.hsn_sac,
                specification: p.specification,
                long_description: p.long_description,
                unit: p.unit,
            })
        });

    res.status(200).json({
        responseCode: 200,
        responseMessage: "success",
        responseData: result
    })
});

router.get('/products/search/get', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var business = req.headers['business'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    if (req.query.page == undefined) {
        var page = 0;
    } else {
        var page = req.query.page;
    }

    var page = Math.max(0, parseInt(page));
    var result = [];


    await BusinessProduct.find({ business: business, $or: [{ part_no: new RegExp(req.query.query, "i") }, { title: new RegExp(req.query.query, "i") }] })
        .cursor().eachAsync(async (p) => {
            result.push({
                _id: p._id,
                id: p._id,
                product: p.title,
                part_no: p.part_no,
                hsn_sac: p.hsn_sac,
                specification: p.specification,
                //long_description: p.long_description,
                unit: p.unit,
            })
        });


    res.status(200).json({
        responseCode: 200,
        responseMessage: "success",
        responseData: result
    })
});

router.get('/product/detail/get', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var business = req.headers['business'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);


    var product = {};

    await BusinessProduct.findOne({ _id: req.query.id, business: business })
        .cursor().eachAsync(async (p) => {

            product = {
                product: p.product,
                _id: p._id,
                id: p._id,
                product_brand: p.product_brand,
                _product_brand: p.product_brand,
                product_model: p.product_model,
                _product_model: p._product_model,
                category: p.category,
                _category: p._category,
                subcategory: p.subcategory,
                _subcategory: p._subcategory,
                business: p.business,
                title: p.title,
                part_no: p.part_no,
                hsn_sac: p.hsn_sac,
                price: p.price,
                stock: p.stock,
                sku: p.sku,
                list_type: p.list_type,
                tax: p.tax,
                amount_is_tax: p.amount_is_tax,
                specification: p.specification,
                product_id: p.product_id,
                short_description: p.short_description,
                long_description: p.long_description,
                thumbnail: p.preview,
                models: p.models,
                services: p.services,
                unit: p.unit,
                warranty: p.warranty,
                quantity: p.quantity,
                logs: p.logs,
            }
        });

    res.status(200).json({
        responseCode: 200,
        responseMessage: "success",
        responseData: product
    })
});

router.get('/expense/category/get', xAccessToken.token, async function (req, res, next) {
    const expenseCategory = await ExpenseCategory.find({}).sort({ category: 1 }).exec();
    res.status(200).json({
        responseCode: 200,
        responseMessage: "success",
        responseData: expenseCategory
    });
});

router.post('/expense/add', xAccessToken.token, async function (req, res, next) {
    var rules = {
        category: 'required',
        name: 'required',
        contact_no: 'required',
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Payee Info required",
            responseData: {
                res: validation.errors.all()
            }
        });
    }
    else {
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var user = decoded.user;
        var business = req.headers['business'];
        var product = new Object();
        var result = [];
        var tax = [];
        var total = 0;

        var newDate = new Date();

        var vendor = null;
        var bill = {
            name: req.body.name,
            contact_no: req.body.contact_no,
            category: req.body.category,
            reference: req.body.reference,
            date: null,
            due_date: null,
            payee: null,
            items: [],
            business: business,
            total: 0,
            status: "Completed",
            created_at: newDate,
            updated_at: newDate,
        };

        Expense.create(bill).then(async function (expense) {
            var count = await Expense.find({ _id: { $lt: expense._id }, business: business }).count();
            var expense_no = count + 1;

            Expense.findOneAndUpdate({ _id: expense._id }, { $set: { expense_no: expense_no } }, { new: true }, async function (err, doc) {
                res.status(200).json({
                    responseCode: 200,
                    responseMessage: "Expense has been added.",
                    responseData: expense
                });
            });
        });
    }
});

router.delete('/expense/cancel', xAccessToken.token, async function (req, res, next) {
    var rules = {
        expense: 'required',
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Error",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var user = decoded.user;
        var business = req.headers['business'];
        var product = new Object();
        var result = [];
        var tax = [];
        var total = 0;
        var expense = await Expense.findOne({ _id: req.body.expense }).exec();
        if (expense) {
            Expense.findOneAndUpdate({ _id: expense._id }, { $set: { status: "Cancelled" } }, { new: false }, async function (err, doc) {
                if (err) {
                    res.status(422).json({
                        responseCode: 422,
                        responseMessage: "Server Error...",
                        responseData: err
                    });
                }
                else {
                    res.status(200).json({
                        responseCode: 200,
                        responseMessage: "Removed Successfully",
                        responseData: {}
                    });
                }
            });
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Expense not found",
                responseData: {}
            });
        }
    }
});

router.put('/expense/date/update', xAccessToken.token, async function (req, res, next) {
    var rules = {
        expense: 'required',
        date: 'required',
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Due Date required",
            responseData: {
                res: validation.errors.all()
            }
        });
    }
    else {
        var business = req.headers['business'];
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var date = new Date();
        var loggedInDetails = decoded.user;
        var items = [];
        var data = [];

        var item_total = 0;
        var discount = 0;
        var item_total = 0;
        var total = 0;

        var expense = await Expense.findById(req.body.expense).exec();
        var loggedInDetails = await User.findById(decoded.user).exec();
        if (expense) {
            var date = new Date(req.body.date).toISOString();

            Expense.findOneAndUpdate({ _id: expense._id }, { $set: { date: date, updated_at: new Date() } }, { new: false }, async function (err, doc) {
                if (err) {
                    res.status(422).json({
                        responseCode: 422,
                        responseMessage: "Server Error",
                        responseData: err
                    });
                }
                else {
                    res.status(200).json({
                        responseCode: 200,
                        responseMessage: "Saved",
                        responseData: {
                            due_date: moment(date).tz(req.headers['tz']).format("YYYY-MM-DD")
                        }
                    });
                }
            });
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Expense not found",
                responseData: {}
            });
        }
    }
});

router.put('/expense/category/update', xAccessToken.token, async function (req, res, next) {
    var rules = {
        expense: 'required',
        category: 'required',
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Due Date required",
            responseData: {
                res: validation.errors.all()
            }
        });
    }
    else {
        var business = req.headers['business'];
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var date = new Date();
        var loggedInDetails = decoded.user;
        var items = [];
        var data = [];

        var item_total = 0;
        var discount = 0;
        var item_total = 0;
        var total = 0;

        var expense = await Expense.findById(req.body.expense).exec();
        var loggedInDetails = await User.findById(decoded.user).exec();
        if (expense) {
            Expense.findOneAndUpdate({ _id: expense._id }, { $set: { category: req.body.category, updated_at: new Date() } }, { new: false }, async function (err, doc) {
                if (err) {
                    res.status(422).json({
                        responseCode: 422,
                        responseMessage: "Server Error",
                        responseData: err
                    });
                }
                else {
                    res.status(200).json({
                        responseCode: 200,
                        responseMessage: "Saved",
                        responseData: {
                            category: req.body.category
                        }
                    });
                }
            });
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Expense not found",
                responseData: {}
            });
        }
    }
});

router.put('/expense/payee/update', xAccessToken.token, async function (req, res, next) {
    var rules = {
        expense: 'required',
        payee_name: 'required',
        payee_contact_no: 'required',
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Payee Info required",
            responseData: {
                res: validation.errors.all()
            }
        });
    }
    else {
        var business = req.headers['business'];
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var date = new Date();
        var loggedInDetails = decoded.user;
        var items = [];
        var data = [];

        var item_total = 0;
        var discount = 0;
        var item_total = 0;
        var total = 0;

        var expense = await Expense.findById(req.body.expense).exec();
        var loggedInDetails = await User.findById(decoded.user).exec();
        if (expense) {
            var payee = await User.findById(req.body.payee).exec();
            if (payee) {
                Expense.findOneAndUpdate({ _id: expense._id }, { $set: { payee: null, payee_name: req.body.payee_name, updated_at: new Date() } }, { new: false }, async function (err, doc) {
                    if (err) {
                        res.status(422).json({
                            responseCode: 422,
                            responseMessage: "Server Error",
                            responseData: err
                        });
                    }
                    else {
                        res.status(200).json({
                            responseCode: 200,
                            responseMessage: "Saved",
                            responseData: {}
                        });
                    }
                });
            }
            else {
                res.status(400).json({
                    responseCode: 400,
                    responseMessage: "User not found",
                    responseData: {}
                });
            }
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Expense not found",
                responseData: {}
            });
        }
    }
});

router.put('/expense/update', xAccessToken.token, async function (req, res, next) {
    var rules = {
        reference: 'required',
        date: 'required',
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Date is required",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var user = decoded.user;
        var business = req.headers['business'];
        var product = new Object();
        var result = [];

        var total = 0;
        var expense = await Expense.findById(req.body.expense).exec();
        if (expense) {
            var date = new Date();
            if (req.body.date) {
                date = new Date(req.body.date).toISOString();
            }

            var newDate = new Date();

            var items = [];
            var products = req.body.items;

            if (products.length > 0) {
                for (var p = 0; p < products.length; p++) {
                    if (products[p].quantity) {
                        var tax_info = await Tax.findOne({ tax: products[p].tax }).exec();
                        if (tax_info) {
                            var tax = [];
                            var rate = parseFloat(products[p].rate) * parseFloat(products[p].quantity);
                            var amount = parseFloat(products[p].rate) * parseFloat(products[p].quantity);
                            var tax_rate = tax_info.detail;
                            var base = amount



                            if (products[p].amount_is_tax == "exclusive") {
                                var tax_on_amount = amount;
                                if (tax_rate.length > 0) {
                                    for (var r = 0; r < tax_rate.length; r++) {
                                        if (tax_rate[r].rate != tax_info.rate) {
                                            var t = tax_on_amount * (tax_rate[r].rate / 100);
                                            amount = amount + t;
                                            tax.push({
                                                tax: tax_rate[r].tax,
                                                rate: tax_rate[r].rate,
                                                amount: parseFloat(t.toFixed(2))
                                            })
                                        }
                                        else {
                                            var t = tax_on_amount * (tax_info.rate / 100);
                                            amount = amount + t;
                                            tax.push({
                                                tax: tax_info.tax, tax_rate: tax_info.rate,
                                                rate: tax_info.rate,
                                                amount: parseFloat(t.toFixed(2))
                                            })
                                        }
                                    }
                                }

                                total = total + amount;
                            }

                            if (products[p].amount_is_tax == "inclusive") {
                                amount = amount;
                                var x = (100 + tax_info.rate) / 100;
                                var tax_on_amount = amount / x;
                                if (tax_rate.length > 0) {
                                    for (var r = 0; r < tax_rate.length; r++) {
                                        if (tax_rate[r].rate != tax_info.rate) {
                                            var t = tax_on_amount * (tax_rate[r].rate / 100);
                                            base = base - t;
                                            tax.push({
                                                tax: tax_rate[r].tax,
                                                rate: tax_rate[r].rate,
                                                amount: parseFloat(t.toFixed(2))
                                            });
                                        }
                                        else {
                                            var t = amount - tax_on_amount;
                                            base = base - t;
                                            tax.push({
                                                tax: tax_info.tax,
                                                rate: tax_info.rate,
                                                amount: parseFloat(t.toFixed(2))
                                            });
                                        }
                                    }
                                }
                                total = total + amount;
                            }

                            var tax_details = {
                                tax: tax_info.tax,
                                rate: tax_info.rate,
                                amount: total,
                                detail: tax
                            }

                            items.push({
                                part_no: products[p].part_no,
                                hsn_sac: products[p].hsn_sac,
                                title: products[p].title,
                                quantity: products[p].quantity,
                                unit: products[p].unit,
                                sku: products[p].sku,
                                mrp: products[p].mrp,
                                rate: products[p].rate,
                                base: base,
                                amount: parseFloat(amount.toFixed(2)),
                                tax_amount: _.sumBy(tax, x => x.amount),
                                models: products[p].models,
                                amount_is_tax: products[p].amount_is_tax,
                                unit_price: products[p].unit_price,
                                sell_price: products[p].rate,
                                margin: products[p].margin,
                                discount: "0",
                                discount_total: 0,
                                tax: tax_info.tax,
                                tax_rate: tax_info.rate,
                                tax_info: tax,
                            });
                        }
                        else {
                            return res.status(422).json({
                                responseCode: 422,
                                responseMessage: "Please check tax",
                                responseData: {}
                            });
                        }
                    }
                    else {
                        return res.status(422).json({
                            responseCode: 422,
                            responseMessage: "Quantity required",
                            responseData: {}
                        });
                    }
                }

                var total = _.sumBy(items, x => x.amount);

                var data = {
                    name: req.body.name,
                    contact_no: req.body.contact_no,
                    reference: req.body.reference,
                    category: req.body.category,
                    items: items,
                    date: date,
                    total: parseFloat(total.toFixed(2)),
                    updated_at: new Date(),
                };

                Expense.findOneAndUpdate({ _id: expense._id }, { $set: data }, { new: false }, async function (err, doc) {
                    if (err) {
                        res.status(422).json({
                            responseCode: 422,
                            responseMessage: "Server Error...",
                            responseData: err
                        });
                    }
                    else {
                        res.status(200).json({
                            responseCode: 200,
                            responseMessage: "Successfully Saved",
                            responseData: await Expense.findById(req.body.expense).populate({ path: 'vendor', select: 'name contact_no email account_info business_info' }).exec()
                        });
                    }
                });
            }
            else {
                res.status(400).json({
                    responseCode: 400,
                    responseMessage: "Items not found",
                    responseData: {}
                });
            }

        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Expense not found",
                responseData: {}
            });
        }
    }
});

router.get('/expenses/get', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var business = req.headers['business'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    //paginate
    if (req.query.page == undefined) {
        var page = 0;
    }
    else {
        var page = req.query.page;
    }

    var page = Math.max(0, parseInt(page));

    var orders = [];

    var filters = [];
    var match = [];
    var queries = {};


    if (req.query.query) {
        var specification = {};
        specification['$lookup'] = {
            from: "User",
            localField: "payee",
            foreignField: "_id",
            as: "payee",
        };
        filters.push(specification);

        var specification = {};
        specification['$unwind'] = {
            path: "$payee",
            preserveNullAndEmptyArrays: true
        };
        filters.push(specification);

        var specification = {};
        specification['$match'] = {
            business: mongoose.Types.ObjectId(business),
            $or: [
                { 'status': { $regex: req.query.query, $options: 'i' } },
                { 'category': { $regex: req.query.query, $options: 'i' } },
                { 'reference': { $regex: req.query.query, $options: 'i' } },
                { 'expense_no': { $regex: req.query.query, $options: 'i' } },
                { 'name': { $regex: req.query.query, $options: 'i' } },
                { 'contact_no': { $regex: req.query.query, $options: 'i' } },
                { 'payee.name': { $regex: req.query.query, $options: 'i' } },
                { 'payee.contact_no': { $regex: req.query.query, $options: 'i' } },
            ]
        };
        filters.push(specification);

        var specification = {};
        specification['$sort'] = {
            updated_at: -1,
        };
        filters.push(specification);

        var specification = {};
        specification['$skip'] = config.perPage * page;
        filters.push(specification);

        var specification = {};
        specification['$limit'] = config.perPage;
        filters.push(specification);
    }
    else {
        var specification = {};
        specification['$match'] = {
            business: mongoose.Types.ObjectId(business)
        };
        filters.push(specification);

        var specification = {};
        specification['$sort'] = {
            updated_at: -1,
        };
        filters.push(specification);

        var specification = {};
        specification['$skip'] = config.perPage * page;
        filters.push(specification);

        var specification = {};
        specification['$limit'] = config.perPage;
        filters.push(specification);
    }

    var query = filters;

    var totalResult = await Expense.aggregate(query);

    var allExpense = _.filter(totalResult, x => x.status != "Cancelled")



    await Expense.aggregate(query)
        .allowDiskUse(true)
        .cursor({ batchSize: 20 })
        .exec()
        .eachAsync(async function (p) {

            orders.push({
                _id: p._id,
                id: p._id,
                payee: {
                    _id: null,
                    id: null,
                    name: p.name,
                    contact_no: p.contact_no,
                },
                date: moment(p.date).tz(req.headers['tz']).format('lll'),
                expense_no: p.expense_no,
                category: p.category,
                total: p.total,
                status: p.status,
                reference: p.reference,
                created_at: moment(p.created_at).tz(req.headers['tz']).format('lll'),
                updated_at: moment(p.updated_at).tz(req.headers['tz']).format('lll'),
            });
        });

    res.status(200).json({
        responseCode: 200,
        responseMessage: "success",
        responseInfo: {
            totalExpense: _.sumBy(allExpense, x => x.total),
            totalResult: totalResult.length,
        },
        responseData: orders
    });
});

router.get('/expense/details/get', xAccessToken.token, async function (req, res, next) {
    var rules = {
        expense: 'required',
    };

    var validation = new Validator(req.query, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Expense is required",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var p = await Expense.findById(req.query.expense).populate({ path: 'vendor', select: 'name contact_no email account_info business_info' }).exec();

        if (p) {
            var expense = {
                _id: p._id,
                id: p._id,
                items: p.items,
                category: p.category,
                expense_no: p.expense_no,
                reference: p.reference,
                date: moment(p.date).tz(req.headers['tz']).format('YYYY-MM-DD'),
                due_date: moment(p.due_date).tz(req.headers['tz']).format('YYYY-MM-DD'),
                payee: {
                    _id: null,
                    id: null,
                    name: p.name,
                    contact_no: p.contact_no,
                },
                business: p.business,
                total: p.total,
                status: p.status,
                created_at: moment(p.created_at).tz(req.headers['tz']).format('lll'),
                updated_at: moment(p.updated_at).tz(req.headers['tz']).format('lll'),
            };

            res.status(200).json({
                responseCode: 200,
                responseMessage: "Success",
                responseData: expense
            });
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Expense not found",
                responseData: {}
            });
        }
    }
});

router.post('/bill/add', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers['business'];
    var product = new Object();
    var result = [];
    var tax = [];
    var total = 0;


    var vendor = await User.findById(req.body.vendor).exec();
    var newDate = new Date();
    if (vendor) {

        var bill = {
            reference_no: "",
            date: null,
            due_date: null,
            vendor: vendor._id,
            vendor_address: null,
            items: [],
            business: business,
            total: 0,
            status: "Incomplete",
            created_at: newDate,
            updated_at: newDate,
        };

        Purchase.create(bill).then(async function (purchase) {
            var count = await Purchase.find({ _id: { $lt: purchase._id }, business: purchase.business }).count();
            var bill_no = count + 10000;

            Purchase.findOneAndUpdate({ _id: purchase._id }, { $set: { bill_no: bill_no } }, { new: true }, async function (err, doc) {
                res.status(200).json({
                    responseCode: 200,
                    responseMessage: "Bill has been added.",
                    responseData: purchase
                });
            });
        })


    }
    else {
        res.status(400).json({
            responseCode: 400,
            responseMessage: "Vendor not found",
            responseData: {}
        });
    }
});

router.put('/bill/update', xAccessToken.token, async function (req, res, next) {
    var rules = {
        reference_no: 'required',
        address: 'required',
        date: 'required',
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Address is required",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var user = decoded.user;
        var business = req.headers['business'];
        var product = new Object();
        var result = [];
        var tax = [];
        var total = 0;
        var purchase = await Purchase.findById(req.body.bill).exec();
        if (purchase) {
            var date = new Date(req.body.date).toISOString();
            if (req.body.due) {
                var due = new Date(req.body.due).toISOString();
            }
            else {
                var due = null
            }

            var vendor = await User.findById(req.body.vendor).exec();
            var newDate = new Date();
            if (vendor) {
                var items = [];
                var products = req.body.items;

                if (products.length > 0) {
                    for (var p = 0; p < products.length; p++) {
                        if (products[p].lot != null && products[p].quantity != null) {
                            var product = await BusinessProduct.findOne({ part_no: products[p].part_no, business: business }).exec();
                            var tax_info = await Tax.findOne({ tax: products[p].tax }).exec();
                            if (tax_info) {
                                if (product) {
                                    var rate = products[p].mrp;
                                    var amount = products[p].mrp;
                                    var tax_rate = tax_info.detail;
                                    var base = amount

                                    var discount = products[p].discount;

                                    if (discount.indexOf("%") >= 0) {
                                        discount = parseFloat(discount);
                                        if (!isNaN(discount) && discount > 0) {
                                            var discount_total = amount * (discount / 100);
                                            amount = amount - parseFloat(discount_total.toFixed(2))
                                        }
                                    }
                                    else {
                                        discount = parseFloat(discount);
                                        if (!isNaN(discount) && discount > 0) {
                                            amount = amount - parseFloat(discount.toFixed(2))
                                        }
                                    }

                                    if (products[p].amount_is_tax == "exclusive") {
                                        var tax_on_amount = amount;
                                        if (tax_rate.length > 0) {
                                            for (var r = 0; r < tax_rate.length; r++) {
                                                if (tax_rate[r].rate != tax_info.rate) {
                                                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                                                    amount = amount + t;
                                                    tax.push({
                                                        tax: tax_rate[r].tax,
                                                        rate: tax_rate[r].rate,
                                                        amount: parseFloat(t.toFixed(2))
                                                    })
                                                }
                                                else {
                                                    var t = tax_on_amount * (tax_info.rate / 100);
                                                    amount = amount + t;
                                                    tax.push({
                                                        tax: tax_info.tax, tax_rate: tax_info.rate,
                                                        rate: tax_info.rate,
                                                        amount: parseFloat(t.toFixed(2))
                                                    })
                                                }
                                            }
                                        }
                                        total = total + amount;
                                    }

                                    if (products[p].amount_is_tax == "inclusive") {
                                        var x = (100 + tax_info.rate) / 100;
                                        var tax_on_amount = amount / x;
                                        if (tax_rate.length > 0) {
                                            for (var r = 0; r < tax_rate.length; r++) {
                                                if (tax_rate[r].rate != tax_info.rate) {
                                                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                                                    base = base - t;
                                                    tax.push({
                                                        tax: tax_rate[r].tax,
                                                        rate: tax_rate[r].rate,
                                                        amount: parseFloat(t.toFixed(2))
                                                    });
                                                }
                                                else {
                                                    var t = amount - tax_on_amount;
                                                    base = base - t;
                                                    tax.push({
                                                        tax: tax_info.tax,
                                                        rate: tax_info.rate,
                                                        amount: parseFloat(t.toFixed(2))
                                                    });
                                                }
                                            }
                                        }
                                        total = total + amount;
                                    }

                                    var tax_details = {
                                        tax: tax_info.tax,
                                        rate: tax_info.rate,
                                        amount: total,
                                        detail: tax
                                    }


                                    items.push({
                                        product: product.product,
                                        part_no: products[p].part_no,
                                        hsn_sac: products[p].hsn_sac,
                                        title: products[p].title,
                                        quantity: products[p].quantity,
                                        stock: products[p].quantity * products[p].lot,
                                        sku: products[p].sku,
                                        unit_price: products[p].unit_price,
                                        unit: products[p].unit,
                                        lot: products[p].lot,
                                        mrp: products[p].mrp,
                                        rate: products[p].rate,
                                        base: base,
                                        tax_amount: _.sumBy(tax, x => x.amount),
                                        amount: amount,
                                        models: product.models,
                                        amount_is_tax: products[p].amount_is_tax,
                                        sell_price: products[p].rate,
                                        margin: products[p].margin,
                                        discount: products[p].discount,
                                        discount_type: products[p].discount_type,
                                        discount_total: discount_total,
                                        tax: tax_info.tax,
                                        tax_rate: tax_info.rate,
                                        tax_info: tax,
                                    });

                                    tax = [];
                                }
                                else {
                                    var rate = products[p].mrp;
                                    var amount = products[p].mrp;
                                    var tax_rate = tax_info.detail;
                                    var base = amount
                                    var discount = products[p].discount;

                                    if (discount.indexOf("%") >= 0) {
                                        discount = parseFloat(discount);
                                        if (!isNaN(discount) && discount > 0) {
                                            var discount_total = amount * (discount / 100);
                                            amount = amount - parseFloat(discount_total.toFixed(2))
                                        }
                                    }
                                    else {
                                        discount = parseFloat(discount);
                                        if (!isNaN(discount) && discount > 0) {
                                            amount = amount - parseFloat(discount.toFixed(2))
                                        }
                                    }


                                    if (products[p].amount_is_tax == "exclusive") {
                                        var tax_on_amount = amount;
                                        if (tax_rate.length > 0) {
                                            for (var r = 0; r < tax_rate.length; r++) {
                                                if (tax_rate[r].rate != tax_info.rate) {
                                                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                                                    amount = amount + t;
                                                    tax.push({
                                                        tax: tax_rate[r].tax,
                                                        rate: tax_rate[r].rate,
                                                        amount: parseFloat(t.toFixed(2))
                                                    })
                                                }
                                                else {
                                                    var t = tax_on_amount * (tax_info.rate / 100);
                                                    amount = amount + t;
                                                    tax.push({
                                                        tax: tax_info.tax, tax_rate: tax_info.rate,
                                                        rate: tax_info.rate,
                                                        amount: parseFloat(t.toFixed(2))
                                                    })
                                                }
                                            }
                                        }

                                        total = total + amount;
                                    }

                                    if (products[p].amount_is_tax == "inclusive") {
                                        amount = amount;
                                        var x = (100 + tax_info.rate) / 100;
                                        var tax_on_amount = amount / x;
                                        if (tax_rate.length > 0) {
                                            for (var r = 0; r < tax_rate.length; r++) {
                                                if (tax_rate[r].rate != tax_info.rate) {
                                                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                                                    base = base - t;
                                                    tax.push({
                                                        tax: tax_rate[r].tax,
                                                        rate: tax_rate[r].rate,
                                                        amount: parseFloat(t.toFixed(2))
                                                    });
                                                }
                                                else {
                                                    var t = amount - tax_on_amount;
                                                    base = base - t;
                                                    tax.push({
                                                        tax: tax_info.tax,
                                                        rate: tax_info.rate,
                                                        amount: parseFloat(t.toFixed(2))
                                                    });
                                                }
                                            }
                                        }
                                        //amount = products[p].mrp;
                                        total = total + amount;
                                    }

                                    var tax_details = {
                                        tax: tax_info.tax,
                                        rate: tax_info.rate,
                                        amount: total,
                                        detail: tax
                                    }

                                    items.push({
                                        product: null,
                                        part_no: products[p].part_no,
                                        hsn_sac: products[p].hsn_sac,
                                        title: products[p].title,
                                        quantity: products[p].quantity,
                                        stock: products[p].quantity * products[p].lot,
                                        lot: products[p].lot,
                                        unit: products[p].unit,
                                        sku: products[p].sku,
                                        mrp: products[p].mrp,
                                        rate: products[p].rate,
                                        base: base,
                                        amount: amount,
                                        tax_amount: _.sumBy(tax, x => x.amount),
                                        models: products[p].models,
                                        amount_is_tax: products[p].amount_is_tax,
                                        unit_price: products[p].unit_price,
                                        sell_price: products[p].rate,
                                        margin: products[p].margin,
                                        discount: products[p].discount,
                                        discount_total: discount_total,
                                        tax: tax_info.tax,
                                        tax_rate: tax_info.rate,
                                        tax_info: tax,
                                    });

                                    tax = [];
                                }
                            }
                            else {
                                res.status(422).json({
                                    responseCode: 422,
                                    responseMessage: "Please check tax",
                                    responseData: {}
                                });
                            }
                        }
                    }

                    var total = _.sumBy(items, x => x.amount);

                    var address = null;
                    if (req.body.address) {
                        address = req.body.address;
                    }

                    var bill = {
                        reference_no: req.body.reference_no,
                        date: date,
                        due_date: due,
                        vendor: vendor._id,
                        vendor_address: req.body.address,
                        items: items,
                        business: business,
                        total: total,
                        updated_at: new Date(),
                    };

                    Purchase.findOneAndUpdate({ _id: purchase._id }, { $set: bill }, { new: false }, async function (err, doc) {
                        if (err) {
                            res.status(422).json({
                                responseCode: 422,
                                responseMessage: "Server Error...",
                                responseData: err
                            });
                        }
                        else {
                            res.status(200).json({
                                responseCode: 200,
                                responseMessage: "Successfully Saved",
                                responseData: await Purchase.findById(req.body.bill).exec()
                            });
                        }
                    });
                }
                else {
                    res.status(400).json({
                        responseCode: 400,
                        responseMessage: "Items not found",
                        responseData: {}
                    });
                }
            }
            else {
                res.status(400).json({
                    responseCode: 400,
                    responseMessage: "Vendor not found",
                    responseData: {}
                });
            }
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Purchase not found",
                responseData: {}
            });
        }
    }
});

router.put('/bill/status/update', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers['business'];
    var product = new Object();
    var result = [];
    var tax = [];
    var total = 0;
    var purchase = await Purchase.findById(req.body.bill).exec();
    if (purchase) {
        var products = purchase.items;
        //console.logoducts.length)
        for (var p = 0; p < products.length; p++) {
            stockEntry(purchase._id, products[p], business);
            //console.log
        }

        Purchase.findOneAndUpdate({ _id: purchase._id }, { $set: { status: "Completed", updated_at: new Date() } }, { new: false }, async function (err, doc) {
            res.status(200).json({
                responseCode: 200,
                responseMessage: "Updated...",
                responseData: {}
            });
        });
    }
    else {
        res.status(400).json({
            responseCode: 400,
            responseMessage: "Purchase not found",
            responseData: {}
        });
    }
});

router.post('/stock/import', async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers['business'];
    var not_inserted = [];
    var storage = multer.diskStorage({
        destination: function (req, file, cb) {
            cb(null, '/home/ubuntu/CarEager/uploads')
        },
        filename: function (req, file, cb) {
            var datetimestamp = Date.now();
            cb(null, uuidv1() + "." + file.originalname.split('.')[file.originalname.split('.').length - 1])
        }
    });

    var upload = multer({
        storage: storage,
        fileFilter: function (req, file, callback) {
            if (['xls', 'xlsx'].indexOf(file.originalname.split('.')[file.originalname.split('.').length - 1]) === -1) {
                return callback(new Error('Wrong extension type'));
            }
            callback(null, true);
        }
    }).single('media');


    upload(req, res, function (err) {
        if (err) {
            return res.status(422).json({
                responseCode: 422,
                responseMessage: "Server Error",
                responseData: err
            })
        }

        if (!req.file) {
            return res.status(422).json({
                responseCode: 422,
                responseMessage: "No File Passed",
                responseData: {}
            })
        }

        if (req.file.originalname.split('.')[req.file.originalname.split('.').length - 1] === 'xlsx') {
            exceltojson = xlsxtojson;
        }
        else {
            return res.status(422).json({
                responseCode: 422,
                responseMessage: "Error",
                responseData: {}
            })
        }

        exceltojson({
            input: req.file.path,
            output: null,
            lowerCaseHeaders: true
        }, async function (err, result) {
            if (err) {
                return res.status(422).json({
                    responseCode: 422,
                    responseMessage: "Error",
                    responseData: err
                });
            }
            else {
                var invalid_data = _.filter(result, x => x.title == "" || x.part_no == "" || parseFloat(x.purchase_price) < 0 || parseFloat(x.selling_price) < 0 || parseFloat(x.tax_rate) <= 0 || x.total == "" || x.consumed == "" || x.available == "" || x.hsn_sac == "" || x.amount_is_tax == "" || x.unit == "");

                if (invalid_data.length > 0) {
                    res.status(422).json({
                        responseCode: 422,
                        responseMessage: "Unformatted Data! Please check & upload again.",
                        responseData: {}
                    });
                }
                else {

                    for (var i = 0; i < result.length; i++) {
                        var product = result[i];

                        var part_no = product.part_no;
                        part_no = part_no.replace(/,/g, ", ");
                        part_no = part_no.toUpperCase();

                        var businessProduct = await BusinessProduct.findOne({ part_no: part_no, unit: product.unit, business: business }).sort({ updated_at: -1 }).exec();

                        var margin_total = 0;
                        if (businessProduct) {
                            var tax = [];
                            var tax_info = await Tax.findOne({ rate: parseFloat(product.tax_rate), type: "GST" }).exec();
                            var rate = parseFloat(product.selling_price);
                            var amount = parseFloat(product.selling_price);
                            var tax_rate = tax_info.detail;
                            var base = amount

                            if (product.amount_is_tax == "exclusive") {
                                var tax_on_amount = amount;
                                if (tax_rate.length > 0) {
                                    for (var r = 0; r < tax_rate.length; r++) {
                                        if (tax_rate[r].rate != tax_info.rate) {
                                            var t = tax_on_amount * (tax_rate[r].rate / 100);
                                            amount = amount + t;
                                            tax.push({
                                                tax: tax_rate[r].tax,
                                                rate: tax_rate[r].rate,
                                                amount: parseFloat(t.toFixed(2))
                                            })
                                        }
                                        else {
                                            var t = tax_on_amount * (tax_info.rate / 100);
                                            amount = amount + t;
                                            tax.push({
                                                tax: tax_info.tax, tax_rate: tax_info.rate,
                                                rate: tax_info.rate,
                                                amount: parseFloat(t.toFixed(2))
                                            })
                                        }
                                    }
                                }
                            }

                            if (product.amount_is_tax == "inclusive") {
                                var x = (100 + tax_info.rate) / 100;
                                var tax_on_amount = amount / x;
                                if (tax_rate.length > 0) {
                                    for (var r = 0; r < tax_rate.length; r++) {
                                        if (tax_rate[r].rate != tax_info.rate) {
                                            var t = tax_on_amount * (tax_rate[r].rate / 100);
                                            base = base - t;
                                            tax.push({
                                                tax: tax_rate[r].tax,
                                                rate: tax_rate[r].rate,
                                                amount: parseFloat(t.toFixed(2))
                                            });
                                        }
                                        else {
                                            var t = amount - tax_on_amount;
                                            base = base - t;
                                            tax.push({
                                                tax: tax_info.tax,
                                                rate: tax_info.rate,
                                                amount: parseFloat(t.toFixed(2))
                                            });
                                        }
                                    }
                                }
                            }

                            var tax_details = {
                                tax: tax_info.tax,
                                rate: tax_info.rate,
                                amount: amount,
                                detail: tax
                            }


                            var sku = {
                                sku: product.sku,
                                total: parseFloat(product.total),
                                available: parseFloat(product.available),
                            };

                            var stock = {
                                total: parseFloat(product.total),
                                consumed: parseFloat(product.consumed),
                                available: parseFloat(product.available),
                            };

                            var list_type = [];
                            list_type = _.concat(businessProduct.list_type, "Offline", "Import");
                            list_type = _.uniq(list_type);

                            var models = [];
                            if (product.models) {
                                models = product.models.split(',')
                            }
                            models = _.concat(businessProduct.models, models);
                            models = _.uniq(models);

                            margin_total = amount - parseFloat(product.purchase_price);

                            var data = {
                                purchase: null,
                                purchases: [],
                                business: business,
                                product: businessProduct.product,
                                product_id: businessProduct.product_id,
                                part_no: businessProduct.part_no,
                                product_brand: businessProduct.product_brand,
                                product_model: businessProduct.product_model,
                                model: businessProduct.model,
                                category: businessProduct.category,
                                subcategory: businessProduct.subcategory,
                                title: _.startCase(_.lowerCase(businessProduct.title)),
                                short_description: businessProduct.short_description,
                                long_description: businessProduct.long_description,
                                thumbnail: businessProduct.thumbnail,
                                specification: businessProduct.specification,
                                hsn_sac: product.hsn_sac,
                                unit: product.unit,
                                quantity: parseFloat(product.total),
                                models: models,
                                stock: stock,
                                list_type: list_type,
                                sku: sku,
                                price: {
                                    mrp: parseFloat(product.purchase_price),
                                    rate: parseFloat(amount),
                                    amount: amount,
                                    sell_price: amount,
                                    margin_total: margin_total,
                                    margin: margin_total,
                                },
                                amount_is_tax: "inclusive",
                                tax: tax_info.tax,
                                tax_rate: tax_info.rate,
                                tax_type: "GST",
                                tax_info: tax_details,
                                created_at: new Date(),
                                updated_at: new Date()
                            };

                            BusinessProduct.create(data).then(async function (bp) { });
                        }
                        else {
                            var tax = [];
                            var tax_info = await Tax.findOne({ rate: parseFloat(product.tax_rate), type: "GST" }).exec();
                            var rate = parseFloat(product.selling_price);
                            var amount = parseFloat(product.selling_price);
                            var tax_rate = tax_info.detail;
                            var base = amount
                            /* if(product.margin){
                                 var margin = product.margin;
                                 margin = margin.toString();
                                 if(margin.indexOf("%")>=0)
                                 {
                                     margin = parseFloat(margin);
                                     if(!isNaN(margin) && margin>0)
                                     {
                                         margin_total = amount*(margin/100);
                                         amount = amount+margin_total
                                     }
                                 }
                                 else
                                 {
                                     margin_total = parseFloat(margin);
                                     amount = amount+margin_total
                                 }
                             }     */

                            if (product.amount_is_tax == "exclusive") {
                                var tax_on_amount = amount;
                                if (tax_rate.length > 0) {
                                    for (var r = 0; r < tax_rate.length; r++) {
                                        if (tax_rate[r].rate != tax_info.rate) {
                                            var t = tax_on_amount * (tax_rate[r].rate / 100);
                                            amount = amount + t;
                                            tax.push({
                                                tax: tax_rate[r].tax,
                                                rate: tax_rate[r].rate,
                                                amount: parseFloat(t.toFixed(2))
                                            })
                                        }
                                        else {
                                            var t = tax_on_amount * (tax_info.rate / 100);
                                            amount = amount + t;
                                            tax.push({
                                                tax: tax_info.tax, tax_rate: tax_info.rate,
                                                rate: tax_info.rate,
                                                amount: parseFloat(t.toFixed(2))
                                            })
                                        }
                                    }
                                }
                            }

                            if (product.amount_is_tax == "inclusive") {
                                var x = (100 + tax_info.rate) / 100;
                                var tax_on_amount = amount / x;
                                if (tax_rate.length > 0) {
                                    for (var r = 0; r < tax_rate.length; r++) {
                                        if (tax_rate[r].rate != tax_info.rate) {
                                            var t = tax_on_amount * (tax_rate[r].rate / 100);
                                            base = base - t;
                                            tax.push({
                                                tax: tax_rate[r].tax,
                                                rate: tax_rate[r].rate,
                                                amount: parseFloat(t.toFixed(2))
                                            });
                                        }
                                        else {
                                            var t = amount - tax_on_amount;
                                            base = base - t;
                                            tax.push({
                                                tax: tax_info.tax,
                                                rate: tax_info.rate,
                                                amount: parseFloat(t.toFixed(2))
                                            });
                                        }
                                    }
                                }
                            }

                            var tax_details = {
                                tax: tax_info.tax,
                                rate: tax_info.rate,
                                amount: amount,
                                detail: tax
                            }

                            var sku = {
                                sku: product.sku,
                                total: parseFloat(product.total),
                                available: parseFloat(product.available),
                            };

                            var stock = {
                                total: parseFloat(product.total),
                                consumed: parseFloat(product.consumed),
                                available: parseFloat(product.available),
                            };

                            var list_type = ["Offline", "Import"];


                            var models = [];
                            if (product.models) {
                                models = product.models.split(',')
                            }

                            margin_total = amount - parseFloat(product.purchase_price);

                            var data = {
                                purchase: null,
                                purchases: [],
                                business: business,
                                product: null,
                                product_id: Math.round(+new Date() / 1000) + Math.round((Math.random() * 9999) + 1),
                                part_no: part_no,
                                product_brand: null,
                                product_model: null,
                                model: null,
                                category: null,
                                subcategory: null,
                                title: _.startCase(_.lowerCase(product.title)),
                                short_description: "",
                                long_description: "",
                                thumbnail: "",
                                specification: "",
                                hsn_sac: product.hsn_sac,
                                quantity: parseFloat(product.total),
                                unit: product.unit,
                                models: models,
                                stock: stock,
                                sku: sku,
                                list_type: list_type,
                                price: {
                                    mrp: parseFloat(product.purchase_price),
                                    rate: parseFloat(amount),
                                    amount: amount,
                                    sell_price: amount,
                                    margin_total: margin_total,
                                    margin: margin_total,
                                },
                                amount_is_tax: "inclusive",
                                tax: tax_info.tax,
                                tax_rate: tax_info.rate,
                                tax_type: "GST",
                                tax_info: tax_details,
                                list_type: list_type,
                                created_at: new Date(),
                                updated_at: new Date()
                            };

                            BusinessProduct.create(data).then(async function (bp) {
                            });
                        }
                    }

                    res.status(200).json({
                        responseCode: 200,
                        responseMessage: "Successfully Import",
                        responseData: {}
                    });
                }
            }
        });
    });
});

router.delete('/bill/delete', xAccessToken.token, async function (req, res, next) {
    var rules = {
        query: 'required',
    };

    var validation = new Validator(req.query, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Error",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var user = decoded.user;
        var business = req.headers['business'];
        var product = new Object();
        var result = [];
        var tax = [];
        var total = 0;
        var purchase = await Purchase.findOne({ _id: req.query.query, status: "Incomplete" }).exec();
        if (purchase) {
            Purchase.findOneAndUpdate({ _id: purchase._id }, { $set: { status: "Deleted" } }, { new: false }, async function (err, doc) {
                if (err) {
                    res.status(422).json({
                        responseCode: 422,
                        responseMessage: "Server Error...",
                        responseData: err
                    });
                }
                else {
                    res.status(200).json({
                        responseCode: 200,
                        responseMessage: "Removed Successfully",
                        responseData: {}
                    });
                }
            });
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Purchase not found",
                responseData: {}
            });
        }
    }
});

router.put('/bill/revert/', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers['business'];
    var product = new Object();
    var result = [];
    var tax = [];
    var total = 0;
    var purchase = await Purchase.findById(req.body.bill).exec();
    if (purchase) {
        var products = purchase.items;
        for (var p = 0; p < products.length; p++) {
            stockRemove(purchase._id, products[p], business);
        }

        Purchase.findOneAndUpdate({ _id: purchase._id }, { $set: { status: "Incomplete", updated_at: new Date() } }, { new: false }, async function (err, doc) {
            res.status(200).json({
                responseCode: 200,
                responseMessage: "Updated...",
                responseData: {}
            });
        });
    }
    else {
        res.status(400).json({
            responseCode: 400,
            responseMessage: "Purchase not found",
            responseData: {}
        });
    }
});

router.get('/bills/get', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers['business'];
    var bills = [];
    var filters = [];
    var totalResult = 0;

    var role = await Management.findOne({ user: user, business: business }).exec();
    if (req.query.page == undefined) {
        var page = 0;
    }
    else {
        var page = req.query.page;
    }


    var page = Math.max(0, parseInt(page));
    var queries = new Object();
    var sortBy = new Object();

    var thumbnail = [];

    var specification = {};
    specification['$lookup'] = {
        from: "User",
        localField: "vendor",
        foreignField: "_id",
        as: "vendor",
    };
    filters.push(specification);

    var specification = {};
    specification['$unwind'] = {
        path: "$vendor",
        preserveNullAndEmptyArrays: false
    };
    filters.push(specification);


    if (business == "5bfec47ef651033d1c99fbca") {
        var specification = {};
        specification['$match'] = {
            status: { $ne: "Deleted" },
        };
        filters.push(specification);
    }
    else {
        var specification = {};
        specification['$match'] = {
            status: { $ne: "Deleted" },
        };
        filters.push(specification);
    }

    if (req.query.query) {
        var specification = {};
        specification['$match'] = {
            business: mongoose.Types.ObjectId(business),
            $or: [
                { 'vendor.name': { $regex: req.query.query, $options: 'i' } },
                { 'vendor.contact_no': { $regex: req.query.query, $options: 'i' } },
                /*{'vendor.business_info.gstin': { $regex: req.query.query ,$options:'i'}},*/
                {
                    items: {
                        $elemMatch: {
                            title: { $regex: req.query.query, $options: 'i' }
                        }
                    }
                },
                {
                    //bill_no: {$regex: req.query.query ,$options:'i'}
                    bill_no: req.query.query
                },
                {
                    reference_no: { $regex: req.query.query, $options: 'i' }
                },
                {
                    items: {
                        $elemMatch: {
                            part_no: { $regex: req.query.query, $options: 'i' }
                        }
                    }
                },
                {
                    items: {
                        $elemMatch: {
                            sku: { $regex: req.query.query, $options: 'i' }
                        }
                    }
                },
            ]
        };
        filters.push(specification);
    }
    else {
        var specification = {};
        specification['$match'] = {
            business: mongoose.Types.ObjectId(business),

        };
        filters.push(specification);
    }

    var totalResult = await Purchase.aggregate(filters);

    var all = _.filter(totalResult, x => x.status == "Completed");
    var due = parseFloat(_.sumBy(all, x => x.total).toFixed(2));

    var specification = {};
    specification['$sort'] = {
        updated_at: -1,
    };
    filters.push(specification);

    var specification = {};
    specification['$skip'] = config.perPage * page;
    filters.push(specification);

    var specification = {};
    specification['$limit'] = config.perPage;
    filters.push(specification);

    await Purchase.aggregate(filters)
        .allowDiskUse(true)
        .cursor({ batchSize: 10 })
        .exec()
        .eachAsync(async function (p) {
            bills.push({
                _id: p._id,
                id: p._id,
                bill_no: p.bill_no,
                reference_no: p.reference_no,
                date: moment(p.date).tz(req.headers['tz']).format('YYYY-MM-DD'),
                due_date: moment(p.due_date).tz(req.headers['tz']).format('YYYY-MM-DD'),
                vendor: {
                    name: p.vendor.name,
                    _id: p.vendor._id,
                    id: p.vendor.id,
                    name: p.vendor.name,
                    contact_no: p.vendor.contact_no,
                    email: p.vendor.email,
                    business_info: p.vendor.business_info,
                    account_info: p.vendor.account_info,
                },
                business: p.business,
                total: p.total,
                status: p.status,
                created_at: moment(p.created_at).tz(req.headers['tz']).format('lll'),
                updated_at: moment(p.updated_at).tz(req.headers['tz']).format('lll'),
            });
        });


    res.status(200).json({
        responseCode: 200,
        responseMessage: "",
        responseInfo: {
            //query: filters,
            puchased: due,
            totalResult: totalResult.length
        },
        responseData: bills
    });
});


router.get('/bill/details/get', xAccessToken.token, async function (req, res, next) {
    var rules = {
        bill: 'required',
    };

    var validation = new Validator(req.query, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Error",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {

        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var user = decoded.user;
        var business = req.headers['business'];



        var p = await Purchase.findById({ _id: req.query.bill })
            .populate({ path: 'vendor_address' })
            .populate({ path: 'vendor', select: 'name username avatar avatar_address address contact_no business_info' })
            .exec();

        if (p) {
            var bill = {
                _id: p._id,
                id: p._id,
                bill_no: p.bill_no,
                reference_no: p.reference_no,
                date: moment(p.date).tz(req.headers['tz']).format('YYYY-MM-DD'),
                due_date: moment(p.due_date).tz(req.headers['tz']).format('YYYY-MM-DD'),
                vendor: p.vendor,
                vendor_address: p.vendor_address,
                items: p.items,
                business: p.business,
                total: p.total,
                status: p.status,
                created_at: moment(p.created_at).tz(req.headers['tz']).format('lll'),
                updated_at: moment(p.updated_at).tz(req.headers['tz']).format('lll'),
            };

            res.status(200).json({
                responseCode: 200,
                responseMessage: "Sucess",
                responseData: bill
            });
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Bill not found",
                responseData: {}
            });
        }
    }
});

router.post('/purchase-return/add', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers['business'];
    var product = new Object();
    var result = [];
    var tax = [];
    var total = 0;


    var purchase = await Purchase.findById(req.body.bill).exec();
    var newDate = new Date();
    if (purchase) {
        var purchase_return = await PurchaseReturn.find({ purchase: req.body.bill, status: "Closed" }).count().exec();
        if (purchase_return == 0) {
            var bill = {
                purchase: purchase._id,
                reference_no: purchase.reference_no,
                bill_no: purchase.bill_no,
                date: purchase.date,
                due_date: purchase.due_date,
                vendor: purchase.vendor,
                vendor_address: purchase.vendor_address,
                items: purchase.items,
                business: purchase.business,
                total: purchase.total,
                status: "Active",
                created_at: newDate,
                updated_at: newDate,
            };

            PurchaseReturn.create(bill).then(async function (purchase) {
                var count = await PurchaseReturn.find({ _id: { $lt: purchase._id }, business: business }).count();
                var bill_no = count + 10000;

                PurchaseReturn.findOneAndUpdate({ _id: purchase._id }, { $set: { return_no: bill_no } }, { new: true }, async function (err, doc) {
                    res.status(200).json({
                        responseCode: 200,
                        responseMessage: "Bill is ready for return",
                        responseData: await PurchaseReturn.findById(purchase._id).exec()
                    });
                });
            })
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Bill not found",
                responseData: {}
            });
        }
    }
    else {
        res.status(400).json({
            responseCode: 400,
            responseMessage: "Bill not found",
            responseData: {}
        });
    }
});

router.put('/purchase-return', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers['business'];
    var product = new Object();
    var result = [];
    var tax = [];
    var total = 0;

    var purchase = await PurchaseReturn.findOne({ _id: req.body.purchase, status: "Active" }).exec();
    var newDate = new Date();
    if (purchase) {
        var items = [];
        var products = purchase.items;

        if (products.length > 0) {
            for (var p = 0; p < products.length; p++) {
                if (products[p].status == true) {
                    if (products[p].lot != null && products[p].quantity != null) {
                        var quantity = products[p].quantity * products[p].lot;
                        var businessProduct = await BusinessProduct.findById(products[p].product).exec();
                        if (businessProduct) {
                            var stockTotal = parseFloat(businessProduct.stock.total) - quantity;
                            var stockAvailable = parseFloat(businessProduct.stock.available) - quantity;
                            var stockConsumed = parseFloat(businessProduct.stock.consumed);

                            if (stockAvailable < 0) {
                                stockAvailable = 0;
                            }

                            var stock = {
                                total: stockTotal,
                                available: stockAvailable,
                                consumed: stockConsumed
                            }

                            BusinessProduct.findOneAndUpdate({ _id: businessProduct._id }, { $set: { stock: stock } }, { new: false }, async function () {
                            });
                        }
                    }
                }
            }

            var bill = {
                updated_at: new Date(),
                status: "Closed"
            };

            PurchaseReturn.findOneAndUpdate({ _id: purchase._id }, { $set: bill }, { new: false }, async function (err, doc) {
                if (err) {
                    res.status(422).json({
                        responseCode: 422,
                        responseMessage: "Server Error...",
                        responseData: {}
                    });
                }
                else {
                    res.status(200).json({
                        responseCode: 200,
                        responseMessage: "Successfully Saved",
                        responseData: await PurchaseReturn.findById(purchase._id).exec()
                    });
                }
            });
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Items not found",
                responseData: {}
            });
        }
    }
    else {
        res.status(400).json({
            responseCode: 400,
            responseMessage: "Purchase not found",
            responseData: {}
        });
    }
});

router.put('/purchase-return/update', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers['business'];
    var product = new Object();
    var result = [];
    var tax = [];
    var total = 0;

    var date = new Date(req.body.date).toISOString();
    if (req.body.due) {
        var due = new Date(req.body.due).toISOString();
    }
    else {
        var due = null
    }

    var purchase = await PurchaseReturn.findById(req.body.purchase).exec();
    var newDate = new Date();
    if (purchase) {
        var items = [];
        var products = req.body.items;

        if (products.length > 0) {
            for (var p = 0; p < products.length; p++) {
                if (products[p].lot != null && products[p].quantity != null) {
                    var tax_info = await Tax.findOne({ tax: products[p].tax }).exec();
                    if (tax_info) {

                        var rate = products[p].mrp;
                        var amount = products[p].mrp;
                        var tax_rate = tax_info.detail;
                        var base = amount
                        var discount = products[p].discount;

                        if (discount.indexOf("%") >= 0) {
                            discount = parseFloat(discount);
                            if (!isNaN(discount) && discount > 0) {
                                var discount_total = amount * (discount / 100);
                                amount = amount - parseFloat(discount_total.toFixed(2))
                            }
                        }
                        else {
                            discount = parseFloat(discount);
                            if (!isNaN(discount) && discount > 0) {
                                amount = amount - parseFloat(discount.toFixed(2))
                            }
                        }


                        if (products[p].amount_is_tax == "exclusive") {
                            var tax_on_amount = amount;
                            if (tax_rate.length > 0) {
                                for (var r = 0; r < tax_rate.length; r++) {
                                    if (tax_rate[r].rate != tax_info.rate) {
                                        var t = tax_on_amount * (tax_rate[r].rate / 100);
                                        amount = amount + t;
                                        tax.push({
                                            tax: tax_rate[r].tax,
                                            rate: tax_rate[r].rate,
                                            amount: parseFloat(t.toFixed(2))
                                        })
                                    }
                                    else {
                                        var t = tax_on_amount * (tax_info.rate / 100);
                                        amount = amount + t;
                                        tax.push({
                                            tax: tax_info.tax, tax_rate: tax_info.rate,
                                            rate: tax_info.rate,
                                            amount: parseFloat(t.toFixed(2))
                                        })
                                    }
                                }
                            }

                            total = total + amount;
                        }

                        if (products[p].amount_is_tax == "inclusive") {
                            amount = amount;
                            var x = (100 + tax_info.rate) / 100;
                            var tax_on_amount = amount / x;
                            if (tax_rate.length > 0) {
                                for (var r = 0; r < tax_rate.length; r++) {
                                    if (tax_rate[r].rate != tax_info.rate) {
                                        var t = tax_on_amount * (tax_rate[r].rate / 100);
                                        base = base - t;
                                        tax.push({
                                            tax: tax_rate[r].tax,
                                            rate: tax_rate[r].rate,
                                            amount: parseFloat(t.toFixed(2))
                                        });
                                    }
                                    else {
                                        var t = amount - tax_on_amount;
                                        base = base - t;
                                        tax.push({
                                            tax: tax_info.tax,
                                            rate: tax_info.rate,
                                            amount: parseFloat(t.toFixed(2))
                                        });
                                    }
                                }
                            }
                            //amount = products[p].mrp;
                            total = total + amount;
                        }

                        var tax_details = {
                            tax: tax_info.tax,
                            rate: tax_info.rate,
                            amount: total,
                            detail: tax
                        }

                        items.push({
                            product: products[p].product,
                            part_no: products[p].part_no,
                            hsn_sac: products[p].hsn_sac,
                            title: products[p].title,
                            quantity: products[p].quantity,
                            stock: products[p].quantity * products[p].lot,
                            lot: products[p].lot,
                            unit: products[p].unit,
                            sku: products[p].sku,
                            mrp: products[p].mrp,
                            rate: products[p].rate,
                            base: base,
                            amount: amount,
                            tax_amount: _.sumBy(tax, x => x.amount),
                            models: products[p].models,
                            amount_is_tax: products[p].amount_is_tax,
                            unit_price: products[p].unit_price,
                            sell_price: products[p].rate,
                            margin: products[p].margin,
                            discount: products[p].discount,
                            discount_total: discount_total,
                            tax: tax_info.tax,
                            tax_rate: tax_info.rate,
                            tax_info: tax,
                            status: products[p].status,
                        });

                        tax = [];
                    }
                    else {
                        res.status(422).json({
                            responseCode: 422,
                            responseMessage: "Please check tax rate",
                            responseData: {}
                        });
                    }
                }
            }

            var returnItems = _.filter(items, status => status.status == true);
            var total = _.sumBy(returnItems, x => x.amount);

            var bill = {
                reference_no: req.body.reference_no,
                date: date,
                due_date: due,
                items: items,
                total: total,
                vendor_address: req.body.address,
                updated_at: new Date(),
            };

            PurchaseReturn.findOneAndUpdate({ _id: purchase._id }, { $set: bill }, { new: false }, async function (err, doc) {
                if (err) {
                    res.status(422).json({
                        responseCode: 422,
                        responseMessage: "Server Error...",
                        responseData: {}
                    });
                }
                else {
                    res.status(200).json({
                        responseCode: 200,
                        responseMessage: "Successfully Saved",
                        responseData: await PurchaseReturn.findById(purchase._id).exec()
                    });
                }
            });
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Items not found",
                responseData: {}
            });
        }
    }
    else {
        res.status(400).json({
            responseCode: 400,
            responseMessage: "Purchase not found",
            responseData: {}
        });
    }
});

router.delete('/purchase-return/delete', xAccessToken.token, async function (req, res, next) {
    var rules = {
        query: 'required',
    };

    var validation = new Validator(req.query, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Error",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var user = decoded.user;
        var business = req.headers['business'];
        var product = new Object();
        var result = [];
        var tax = [];
        var total = 0;
        var purchase = await PurchaseReturn.findOne({ _id: req.query.query, status: "Incomplete" }).exec();
        if (purchase) {
            await PurchaseReturn.findByIdAndRemove(purchase._id).exec();
            res.status(200).json({
                responseCode: 200,
                responseMessage: "File has been deleted",
                responseData: {},
            })
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Purchase not found",
                responseData: {}
            });
        }
    }
})

router.get('/purchase-return/get', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers['business'];
    var bills = [];

    if (req.query.page == undefined) {
        var page = 0;
    } else {
        var page = req.query.page;
    }

    await PurchaseReturn.find({ business: business })
        .populate({ path: 'vendor_address', select: 'name username avatar avatar_address address contact_no' })
        .populate({ path: 'vendor', select: 'name username avatar avatar_address address contact_no' })
        .sort({ updated_at: -1 })
        .skip(config.perPage * page).limit(config.perPage)
        .cursor().eachAsync(async (p) => {
            bills.push({
                _id: p._id,
                id: p._id,
                bill_no: p.bill_no,
                return_no: p.return_no,
                reference_no: p.reference_no,
                vendor_address: p.vendor_address,
                date: moment(p.date).tz(req.headers['tz']).format('YYYY-MM-DD'),
                due_date: moment(p.due_date).tz(req.headers['tz']).format('YYYY-MM-DD'),
                vendor: p.vendor,
                business: p.business,
                total: p.total,
                status: p.status,
                created_at: moment(p.created_at).tz(req.headers['tz']).format('lll'),
                updated_at: moment(p.updated_at).tz(req.headers['tz']).format('lll'),
            });
        });

    res.status(200).json({
        responseCode: 200,
        responseMessage: "Sucess",
        responseInfo: {
            totalResult: await PurchaseReturn.find({ business: business }).count().exec()
        },
        responseData: bills
    });
});

router.get('/purchase-return/details/get', xAccessToken.token, async function (req, res, next) {
    var rules = {
        purchase: 'required',
    };

    var validation = new Validator(req.query, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Error",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {

        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var user = decoded.user;
        var business = req.headers['business'];


        var p = await PurchaseReturn.findById({ _id: req.query.purchase })
            .populate({ path: 'vendor_address' })
            .populate({ path: 'vendor', select: 'name username avatar avatar_address address contact_no business_info' })
            .exec();

        if (p) {
            var bill = {
                _id: p._id,
                id: p._id,
                return_no: p.return_no,
                bill_no: p.bill_no,
                reference_no: p.reference_no,
                date: moment(p.date).tz(req.headers['tz']).format('YYYY-MM-DD'),
                due_date: moment(p.due_date).tz(req.headers['tz']).format('YYYY-MM-DD'),
                vendor_address: p.vendor_address,
                vendor: p.vendor,
                items: p.items,
                business: p.business,
                purchase: p.purchase,
                total: p.total,
                status: p.status,
                created_at: moment(p.created_at).tz(req.headers['tz']).format('lll'),
                updated_at: moment(p.updated_at).tz(req.headers['tz']).format('lll'),
            };

            res.status(200).json({
                responseCode: 200,
                responseMessage: "Sucess",
                responseData: bill
            });
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Purchase not found",
                responseData: {}
            });
        }
    }
});



router.post('/tax/calculator', xAccessToken.token, async function (req, res, next) {
    var rules = {
        tax: 'required',
        quantity: 'required',
        rate: 'required',
        amount_is_tax: 'required',
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Error",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var tax = []
        var tax_info = await Tax.findOne({ tax: req.body.tax }).exec();

        if (tax_info) {
            var rate = req.body.rate;
            var amount = req.body.rate * req.body.quantity;
            var tax_rate = tax_info.detail;


            if (req.body.discount) {
                var discount = req.body.discount;
                if (discount.indexOf("%") >= 0) {
                    discount = parseFloat(discount);
                    if (!isNaN(discount) && discount > 0) {
                        var discount_total = amount * (discount / 100);
                        amount = amount - parseFloat(discount_total.toFixed(2))
                    }
                }
                else {
                    discount = parseFloat(discount);
                    if (!isNaN(discount) && discount > 0) {
                        var discount_total = discount.toFixed(2);
                        amount = amount - parseFloat(discount.toFixed(2))
                    }
                }
            }

            if (req.body.amount_is_tax == "exclusive") {
                var tax_on_amount = amount;
                if (tax_rate.length > 0) {
                    for (var r = 0; r < tax_rate.length; r++) {
                        if (tax_rate[r].rate != tax_info.rate) {
                            var t = tax_on_amount * (tax_rate[r].rate / 100);
                            amount = amount + t;
                            tax.push({
                                tax: tax_rate[r].tax,
                                rate: tax_rate[r].rate,
                                amount_is_tax: req.body.amount_is_tax,
                                amount: parseFloat(t.toFixed(2)),
                            })
                        }
                        else {
                            var t = tax_on_amount * (tax_info.rate / 100);
                            amount = amount + t;
                            tax.push({
                                tax: tax_info.tax, tax_rate: tax_info.rate,
                                rate: tax_info.rate,
                                amount_is_tax: req.body.amount_is_tax,
                                amount: parseFloat(t.toFixed(2)),
                            })
                        }
                    }
                }
            }

            if (req.body.amount_is_tax == "inclusive") {
                var x = (100 + tax_info.rate) / 100;
                var tax_on_amount = amount / x;
                if (tax_rate.length > 0) {
                    for (var r = 0; r < tax_rate.length; r++) {
                        if (tax_rate[r].rate != tax_info.rate) {
                            var t = tax_on_amount * (tax_rate[r].rate / 100);

                            tax.push({
                                tax: tax_rate[r].tax,
                                rate: tax_rate[r].rate,
                                amount_is_tax: req.body.amount_is_tax,
                                amount: parseFloat(t.toFixed(2)),
                            });
                        }
                        else {
                            var t = amount - tax_on_amount;
                            tax.push({
                                tax: tax_info.tax, tax_rate: tax_info.rate,
                                rate: tax_info.rate,
                                amount_is_tax: req.body.amount_is_tax,
                                amount: parseFloat(t.toFixed(2)),
                            });
                        }
                    }
                }
            }

            var data = {
                rate: rate,
                quantity: req.body.quantity,
                amount: amount,
                tax_amount: parseFloat(_.sumBy(tax, x => x.amount).toFixed(2)),
                discount: discount_total,
                tax: tax_info.tax,
                tax_rate: tax_info.rate,
                tax_info: tax
            }

            res.status(200).json({
                responseCode: 200,
                responseMessage: "success",
                responseData: data
            })
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Invalid Tax Slab",
                responseData: {}
            })
        }
    }
});

router.get('/margin/calculator', xAccessToken.token, async function (req, res, next) {

    var margin = req.query.margin;
    var amount = parseFloat(req.query.amount);
    margin = margin.toString();
    if (margin.indexOf("%") >= 0) {
        margin = parseFloat(margin);
        if (!isNaN(margin) && margin > 0) {
            margin_total = amount * (margin / 100);
            amount = amount + margin_total
        }
    }
    else {
        margin_total = parseFloat(margin);
        amount = amount + margin_total
    }


    res.status(200).json({
        responseCode: 200,
        responseMessage: "Margin",
        responseData: {
            sell_price: amount
        }
    });
});

router.put('/product/publish', xAccessToken.token, async function (req, res, next) {
    var rules = {
        id: 'required',
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Error",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);

        var business = decoded.user;

        var product = await BusinessProduct.findOne({ _id: req.body.id, business: business }).exec();
        if (product) {
            if (product.publish == false) {
                var data = {
                    publish: true,
                    updated_at: new Date()
                };
            } else {
                var data = {
                    publish: false,
                    updated_at: new Date()
                };
            }

            BusinessProduct.findOneAndUpdate({ _id: req.body.id, business: business }, { $set: data }, { new: true }, function (err, doc) { });

            if (data.publish == true) {
                var status = 'published';
                var isPublished = true;
            } else {
                var status = "unpublished";
                var isPublished = false;
            }

            const totalProductCount = await BusinessProduct.count({ business: business }).exec();
            const publishedProductCount = await BusinessProduct.count({ business: business, publish: true }).exec();

            res.status(200).json({
                responseCode: 200,
                responseMessage: "Product has been " + status,
                responseData: {
                    total: totalProductCount,
                    published: publishedProductCount,
                    publish: isPublished,
                }
            });
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Unauthorized",
                responseData: {}
            });
        }
    }
});

router.post('/product/image/add', xAccessToken.token, function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    var upload = multer({
        storage: multerS3({
            s3: s3,
            bucket: config.BUCKET_NAME + '/product',
            acl: 'public-read',
            contentType: multerS3.AUTO_CONTENT_TYPE,
            // contentDisposition: 'attachment',
            key: function (req, file, cb) {
                let extArray = file.mimetype.split("/");
                let extension = extArray[extArray.length - 1];
                var filename = uuidv1() + '.' + extension;
                if (extension == 'png' || extension == 'jpg' || extension == 'jpeg' || extension == 'gif') {
                    cb(null, filename);
                }
                else {
                    var params = {
                        Bucket: config.BUCKET_NAME + "/product",
                        Key: filename
                    };
                    s3.deleteObject(params, async function (err, data) {
                        var json = ({
                            responseCode: 422,
                            responseMessage: "Invalid extension",
                            responseData: {}
                        });
                        res.status(422).json(json)
                    });
                }
            }
        })
    }).array('media', 1);

    upload(req, res, function (error) {
        if (error) {
            var json = ({
                responseCode: 400,
                responseMessage: "Error occured",
                responseData: {}
            });
            res.status(400).json(json)
        }

        if (req.files.length == 0) {
            var json = ({
                responseCode: 400,
                responseMessage: "Media is required",
                responseData: {}
            });
            res.status(400).json(json)
        } else {

            var rules = {
                id: 'required'
            };

            var validation = new Validator(req.body, rules);

            if (validation.fails()) {
                res.status(422).json({
                    responseCode: 422,
                    responseMessage: "Error",
                    responseData: {
                        res: validation.errors.all()
                    }
                })
            } else {
                var data = {
                    product: req.body.id,
                    file: req.files[0].key,
                    created_at: new Date(),
                    updated_at: new Date(),
                };

                var productImage = new ProductImage(data);
                productImage.save();

                res.status(200).json({
                    responseCode: 200,
                    responseMessage: "File has been uploaded",
                    responseData: {
                        item: productImage
                    }
                })
            }
        }
    });
});

router.post('/product/image/add', xAccessToken.token, function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    var upload = multer({
        storage: multerS3({
            s3: s3,
            bucket: config.BUCKET_NAME + '/product',
            acl: 'public-read',
            contentType: multerS3.AUTO_CONTENT_TYPE,
            // contentDisposition: 'attachment',
            key: function (req, file, cb) {
                let extArray = file.mimetype.split("/");
                let extension = extArray[extArray.length - 1];

                var filename = uuidv1() + '.' + extension;
                if (extension == 'png' || extension == 'jpg' || extension == 'jpeg' || extension == 'gif') {
                    cb(null, filename);
                }
                else {
                    var params = {
                        Bucket: config.BUCKET_NAME + "/product",
                        Key: filename
                    };
                    s3.deleteObject(params, async function (err, data) {
                        var json = ({
                            responseCode: 422,
                            responseMessage: "Invalid extension",
                            responseData: {}
                        });
                        res.status(422).json(json)
                    });
                }
            }
        })
    }).array('media', 1);

    upload(req, res, function (error) {
        if (error) {
            var json = ({
                responseCode: 400,
                responseMessage: "Error occured",
                responseData: {}
            });
            res.status(400).json(json)
        }

        if (req.files.length == 0) {
            var json = ({
                responseCode: 400,
                responseMessage: "Media is required",
                responseData: {}
            });
            res.status(400).json(json)
        } else {

            var rules = {
                id: 'required'
            };

            var validation = new Validator(req.body, rules);

            if (validation.fails()) {
                res.status(422).json({
                    responseCode: 422,
                    responseMessage: "Error",
                    responseData: {
                        res: validation.errors.all()
                    }
                })
            }
            else {
                var data = {
                    product: req.body.id,
                    file: req.files[0].key,
                    created_at: new Date(),
                    updated_at: new Date(),
                };

                var productImage = new ProductImage(data);
                productImage.save();

                res.status(200).json({
                    responseCode: 200,
                    responseMessage: "File has been uploaded",
                    responseData: {
                        item: productImage
                    }
                })
            }
        }
    });
});

router.delete('/product/image/delete', xAccessToken.token, async function (req, res, next) {
    var rules = {
        id: 'required',
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Error",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);

        var image_id = req.body.id;
        const media = await ProductImage.findById(image_id).exec();

        if (media) {
            var params = {
                Bucket: config.BUCKET_NAME + "/product",
                Key: media.file
            };
            s3.deleteObject(params, async function (err, data) {
                if (err) {
                    res.status(400).json({
                        responseCode: 400,
                        responseMessage: "Error occured",
                        responseData: {}
                    });
                }
                else {
                    var deleteImage = ProductImage.findByIdAndRemove(image_id).exec();
                    if (deleteImage) {
                        res.status(200).json({
                            responseCode: 200,
                            responseMessage: "File has been deleted",
                            responseData: {}
                        })
                    } else {
                        res.status(400).json({
                            responseCode: 400,
                            responseMessage: "Error occured",
                            responseData: {}
                        })
                    }
                }
            });
        } else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Wrong image",
                responseData: {}
            })
        }
    }
});

router.get('/products/get', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    var business = req.headers['business'];

    //paginate
    if (req.query.page == undefined) {
        var page = 0;
    }
    else {
        var page = req.query.page;
    }

    var page = Math.max(0, parseInt(page));

    if (req.query.limit == undefined) {
        var limit = 50;
    }
    else {
        var limit = parseInt(req.query.limit);
    }


    //paginate

    var product = [];

    if (req.query.page == undefined) {
        var page = 0;
    }
    else {
        var page = req.query.page;
    }

    var page = Math.max(0, parseInt(page));

    var product = [];
    var array = [];

    if (req.query.by == "category") {
        var query = {
            "$match": {
                category: mongoose.Types.ObjectId(req.query.query),
                business: mongoose.Types.ObjectId(business)
            }
        }
    }
    else if (req.query.by == "subcategory") {
        var query = { "$match": { subcategory: mongoose.Types.ObjectId(req.query.query) }, business: mongoose.Types.ObjectId(business) }
    }
    else if (req.query.by == "brand") {
        var query = { "$match": { product_brand: mongoose.Types.ObjectId(req.query.query), business: mongoose.Types.ObjectId(business) } }
    }
    else if (req.query.by == "model") {
        var query = { "$match": { product_model: mongoose.Types.ObjectId(req.query.query), business: mongoose.Types.ObjectId(business) } }
    }
    else if (req.query.by == "id") {
        var query = { "$match": { product: mongoose.Types.ObjectId(req.query.query), business: mongoose.Types.ObjectId(business), } }
    }
    else if (req.query.by == "filter") {

        var specification = {};
        var subcategory = req.query.subcategory;
        specification["business"] = business;
        array.push(specification);


        if (req.query.subcategory) {
            var specification = {};
            var subcategory = req.query.subcategory;
            specification["_subcategory"] = { $in: subcategory.split(',') }
            array.push(specification);
        }

        if (req.query.brand) {
            var specification = {};
            var brand = req.query.brand;
            specification['_product_brand'] = { $in: brand.split(',') }
            array.push(specification);
        }

        if (req.query.type) {
            var specification = {};
            var type = req.query.type;
            specification['type'] = { $in: type.split(',') }
            array.push(specification);
        }

        if (req.query.size) {
            var specification = {};
            var size = req.query.size;
            specification['specification.size'] = { $in: size.split(',') }
            array.push(specification);
        }

        if (req.query.material) {
            var specification = {};
            var material = req.query.material;
            specification['specification.specification'] = { $in: material.split(',') }
            array.push(specification);
        }

        if (req.query.variants) {
            var specification = {};
            var variants = req.query.variants;
            specification['specification.type'] = { $in: variants.split(',') }
            array.push(specification);
        }

        if (req.query.price) {
            var specification = {};
            var price = req.query.price;
            var min = price.split(',')[0];
            var max = price.split(',')[1];
            specification['price.sell_price'] = { $gte: parseInt(min), $lte: parseInt(max) }
            array.push(specification);
        }

        if (req.query.car) {
            var specification = {};
            var models = req.query.car;
            specification['models'] = { $in: models.split(',') }
            array.push(specification);
        }

        var specification = {};
        var list_type = req.query.list_type;
        specification['list_type'] = { $in: list_type.split(',') }
        array.push(specification);


        var query = {
            "$match": {
                "$and": array
            }
        }
    }
    else {
        var list_type = req.query.list_type;
        var query = {
            "$match": {
                business: mongoose.Types.ObjectId(business),
                list_type: { $in: list_type.split(',') },
                "$or": [
                    { type: { $regex: req.query.query, $options: 'i' } },
                    { models: { $regex: req.query.query, $options: 'i' } },
                    { title: { $regex: req.query.query, $options: 'i' } },
                    { part_no: { $regex: req.query.query, $options: 'i' } },
                    { keywords: { $regex: req.query.query, $options: 'i' } },
                    {
                        sku: {
                            $elemMatch: {
                                sku: { $regex: req.query.query, $options: 'i' }
                            }
                        }
                    },
                ]
            }
        }
    }

    await BusinessProduct.aggregate([
        query,
        { $sort: { "price.sell_price": -1 } },
        //{$group: {_id: '$_id', data: {$push:'$$ROOT'}}},
        { $skip: limit * page },
        { $limit: limit }
    ])
        .allowDiskUse(true)
        .cursor({ batchSize: limit })
        .exec()
        .eachAsync(async function (p) {
            var title = p.title;
            if (_.includes(title, ',')) { title = title.replace(/,/g, ", ") }

            var offers = []
            await ProductOffer.find({ $or: [{ source: null }, { source: p.category }] })
                .cursor().eachAsync(async (o) => {
                    var ofrs = o.offers;
                    ofrs.forEach(function (ofr) {
                        if (ofr.offer) {
                            offers.push({
                                offer: ofr.offer
                            });
                        }
                    });
                });


            var gallery = await Gallery.find({ source: p._id }).exec();

            product.push({
                product: p.product,
                _id: p._id,
                id: p._id,
                product_brand: await ProductBrand.findById(p.product_brand).exec(),
                product_model: await ProductCategory.findById(p.product_model).exec(),
                category: await ProductCategory.findById(p.category).exec(),
                subcategory: await ProductCategory.findById(p.subcategory).exec(),
                business: p.business,
                title: _.startCase(_.toLower(title)),
                price: p.price,
                stock: p.stock,
                part_no: p.part_no,
                hsn_sac: p.hsn_sac,
                tax: p.tax,
                sku: p.sku,
                specification: p.specification,
                product_id: p.product_id,
                short_description: p.short_description,
                long_description: p.long_description,
                thumbnail: p.preview,
                models: p.models,
                services: p.services,
                offers: offers,
                unit: p.unit,
                warranty: p.warranty,
                quantity: p.quantity,
            });
        });

    const totalProductCount = await BusinessProduct.aggregate([
        query,
        { $sort: { "price.sell_price": -1 } },
    ]).exec()

    const publishedProductCount = await BusinessProduct.count({ business: business, publish: true, list_type: { $in: ["Offline"] } }).exec();

    res.status(200).json({
        responseCode: 200,
        //responseQuery: query,
        responseMessage: "success",
        responseData: {
            total: totalProductCount.length,
            published: publishedProductCount,
            products: product,
        }
    })
});

router.get('/stocks/export', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    var business = decoded.user;


    var product = [];

    if (req.query.page == undefined) {
        var page = 0;
    }
    else {
        var page = req.query.page;
    }

    var page = Math.max(0, parseInt(page));

    var product = [];
    var array = [];

    if (req.query.by == "category") {
        var query = {
            "$match": {
                category: mongoose.Types.ObjectId(req.query.query),
                business: mongoose.Types.ObjectId(business)
            }
        }
    }
    else if (req.query.by == "subcategory") {
        var query = { "$match": { subcategory: mongoose.Types.ObjectId(req.query.query) }, business: mongoose.Types.ObjectId(business) }
    }
    else if (req.query.by == "brand") {
        var query = { "$match": { product_brand: mongoose.Types.ObjectId(req.query.query), business: mongoose.Types.ObjectId(business) } }
    }
    else if (req.query.by == "model") {
        var query = { "$match": { product_model: mongoose.Types.ObjectId(req.query.query), business: mongoose.Types.ObjectId(business) } }
    }
    else if (req.query.by == "id") {
        var query = { "$match": { product: mongoose.Types.ObjectId(req.query.query), business: mongoose.Types.ObjectId(business), } }
    }
    else if (req.query.by == "filter") {

        var specification = {};
        var subcategory = req.query.subcategory;
        specification["business"] = business;
        array.push(specification);


        if (req.query.subcategory) {
            var specification = {};
            var subcategory = req.query.subcategory;
            specification["_subcategory"] = { $in: subcategory.split(',') }
            array.push(specification);
        }

        if (req.query.brand) {
            var specification = {};
            var brand = req.query.brand;
            specification['_product_brand'] = { $in: brand.split(',') }
            array.push(specification);
        }

        if (req.query.type) {
            var specification = {};
            var type = req.query.type;
            specification['type'] = { $in: type.split(',') }
            array.push(specification);
        }

        if (req.query.size) {
            var specification = {};
            var size = req.query.size;
            specification['specification.size'] = { $in: size.split(',') }
            array.push(specification);
        }

        if (req.query.material) {
            var specification = {};
            var material = req.query.material;
            specification['specification.specification'] = { $in: material.split(',') }
            array.push(specification);
        }

        if (req.query.variants) {
            var specification = {};
            var variants = req.query.variants;
            specification['specification.type'] = { $in: variants.split(',') }
            array.push(specification);
        }

        if (req.query.price) {
            var specification = {};
            var price = req.query.price;
            var min = price.split(',')[0];
            var max = price.split(',')[1];
            specification['price.sell_price'] = { $gte: parseInt(min), $lte: parseInt(max) }
            array.push(specification);
        }

        if (req.query.car) {
            var specification = {};
            var models = req.query.car;
            specification['models'] = { $in: models.split(',') }
            array.push(specification);
        }

        var specification = {};
        var list_type = req.query.list_type;
        specification['list_type'] = { $in: list_type.split(',') }
        array.push(specification);


        var query = {
            "$match": {
                "$and": array
            }
        }
    }
    else {
        var list_type = req.query.list_type;
        var query = {
            "$match": {
                business: mongoose.Types.ObjectId(business),
                list_type: { $in: list_type.split(',') },
                "$or": [
                    { type: { $regex: req.query.query, $options: 'i' } },
                    { models: { $regex: req.query.query, $options: 'i' } },
                    { title: { $regex: req.query.query, $options: 'i' } },
                    { part_no: { $regex: req.query.query, $options: 'i' } },
                    { keywords: { $regex: req.query.query, $options: 'i' } },
                    {
                        sku: {
                            $elemMatch: {
                                sku: { $regex: req.query.query, $options: 'i' }
                            }
                        }
                    },
                ]
            }
        }
    }

    await BusinessProduct.aggregate([
        query,
        { $sort: { "price.sell_price": -1 } },
    ])
        .allowDiskUse(true)
        .cursor({})
        .exec()
        .eachAsync(async function (p) {
            var title = p.title;
            if (_.includes(title, ',')) { title = title.replace(/,/g, ", ") }

            product.push({
                product: p.product,
                _id: p._id,
                id: p._id,
                product_brand: await ProductBrand.findById(p.product_brand).exec(),
                product_model: await ProductCategory.findById(p.product_model).exec(),
                category: await ProductCategory.findById(p.category).exec(),
                subcategory: await ProductCategory.findById(p.subcategory).exec(),
                business: p.business,
                title: title,
                price: p.price,
                stock: p.stock,
                part_no: p.part_no,
                hsn_sac: p.hsn_sac,
                tax: p.tax,
                sku: p.sku,
                specification: p.specification,
                product_id: p.product_id,
                short_description: p.short_description,
                long_description: p.long_description,
                thumbnail: p.preview,
                models: p.models,
                services: p.services,
                unit: p.unit,
                warranty: p.warranty,
                quantity: p.quantity,
            });
        });

    const totalProductCount = await BusinessProduct.aggregate([
        query,
        { $sort: { "price.sell_price": -1 } },
    ]).exec()

    const publishedProductCount = await BusinessProduct.count({ business: business, publish: true, list_type: { $in: ["Offline"] } }).exec();

    res.status(200).json({
        responseCode: 200,
        //responseQuery: query,
        responseMessage: "success",
        responseData: {
            total: totalProductCount.length,
            published: publishedProductCount,
            products: product,
        }
    })
});

router.get('/order/items/get', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    var business = decoded.user;

    var page = Math.max(0, parseInt(page));
    var convenience = "";
    var orders = [];
    var order = await Order.findById(req.query.order).populate({ 'path': 'user' }).populate({ 'path': 'address' }).exec();
    if (order) {
        await OrderLine.find({ order: order._id, business: business })
            .populate({ 'path': 'product', select: 'stock' })
            .cursor().eachAsync(async (p) => {
                convenience = p.convenience;

                orders.push({
                    product: p.product.product,
                    order_no: p.order_no,
                    tracking_no: p.tracking_no,
                    _category: p._category,
                    category: p.category,
                    source: p.source,
                    cost: p.cost,
                    total: p.total,
                    discount: p.discount,
                    discount_type: p.discount_type,
                    discount_total: p.discount_total,
                    paid_cost: p.paid_cost,
                    title: p.title,
                    description: p.description,
                    quantity: p.quantity,
                    stock: p.product.stock,
                    tax_info: p.tax_info,
                    services: p.services,
                    log: p.log,
                    status: p.status,
                    created_at: p.created_at,
                    updated_at: p.updated_at,
                });
            })

        var data = {
            items: orders,
            payment: order.payment,
            due: order.due,
            address: order.address,
            convenience: convenience,
            status: order.status,
            user: {
                _id: order.user._id,
                id: order.user.id,
                name: order.user.name,
                contact_no: order.user.contact_no,
            },
        }
        res.status(200).json({
            responseCode: 200,
            responseMessage: "success",
            responseData: data,
        })
    }
    else {
        res.status(400).json({
            responseCode: 400,
            responseMessage: "success",
            responseData: orders,
        })
    }
});

router.get('/customers/orders/get', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    var business = req.headers['business'];

    if (req.query.page == undefined) {
        var page = 0;
    } else {
        var page = req.query.page;
    }

    var page = Math.max(0, parseInt(page));

    var orders = [];
    if (business) {
        await OrderLine.aggregate([
            {
                "$match": {
                    business: mongoose.Types.ObjectId(business)
                }
            },
            { "$unwind": "$user" },
            {
                "$lookup": {
                    "from": "User",
                    "localField": "user",
                    "foreignField": "_id",
                    "as": "user"
                }
            },
            { "$unwind": "$order" },
            {
                "$lookup": {
                    "from": "Order",
                    "localField": "order",
                    "foreignField": "_id",
                    "as": "order"
                }
            },
            { "$unwind": "$product" },
            {
                "$lookup": {
                    "from": "BusinessProduct",
                    "localField": "product",
                    "foreignField": "_id",
                    "as": "product"
                }
            },
            { $group: { _id: '$order._id', data: { $push: '$$ROOT' } } },
            { $skip: config.perPage * page },
            { $limit: config.perPage }
        ])
            .allowDiskUse(true)
            .cursor({ batchSize: 10 })
            .exec()
            .eachAsync(async function (doc) {
                var data = doc.data;
                var stock = true;
                data.forEach(async function (d) {
                    if (d.product[0].stock.available <= 0) {
                        stock = false
                    }
                })

                var address = await Address.findById(doc.data[0].order[0].address).exec();
                var time_left = moment(doc.data[0].date).endOf('day').fromNow();

                if (time_left.includes("ago")) {
                    time_left = time_left;
                }
                else {
                    time_left = time_left.replace("in ", "") + " left";
                }

                orders.push({
                    _id: doc.data[0].order[0]._id,
                    id: doc.data[0].order[0]._id,
                    order_no: doc.data[0].order[0].order_no,
                    name: doc.data[0].user[0].name,
                    contact_no: doc.data[0].user[0].contact_no,
                    stock: stock,
                    address: address,
                    convenience: doc.data[0].convenience,
                    time_left: time_left,
                    status: doc.data[0].order[0].status,
                    created_at: moment(doc.data[0].order[0].created_at).tz(req.headers['tz']).format('lll'),
                    delivered_by: moment(doc.data[0].date).tz(req.headers['tz']).format('ll'),
                    time_slot: doc.data[0].time_slot,
                });
            });

        res.status(200).json({
            responseCode: 200,
            responseMessage: "success",
            responseData: orders
        })
    }
    else {
        res.status(400).json({
            responseCode: 400,
            responseMessage: "Business not mention",
            responseData: {}
        })
    }
});

router.post('/offer/add', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var business = req.headers['business'];
    var upload = multer({
        storage: multerS3({
            s3: s3,
            bucket: config.BUCKET_NAME + '/offer',
            acl: 'public-read',
            contentType: multerS3.AUTO_CONTENT_TYPE,
            // contentDisposition: 'attachment',
            key: function (req, file, cb) {
                let extArray = file.mimetype.split("/");
                let extension = extArray[extArray.length - 1];

                var filename = uuidv1() + '.' + extension;
                if (extension == 'png' || extension == 'jpg' || extension == 'jpeg' || extension == 'gif') {
                    cb(null, filename);
                }
                else {
                    var params = {
                        Bucket: config.BUCKET_NAME + "/offer",
                        Key: filename
                    };
                    s3.deleteObject(params, async function (err, data) {
                        var json = ({
                            responseCode: 422,
                            responseMessage: "Invalid extension",
                            responseData: {}
                        });
                        res.status(422).json(json)
                    });
                }
            }
        })
    }).array('media', 1);

    upload(req, res, function (error) {


        if (error) {
            var json = ({
                responseCode: 400,
                responseMessage: "Error occured",
                responseData: {}
            });
            res.status(400).json(json)
        }

        if (req.files.length == 0) {
            var json = ({
                responseCode: 400,
                responseMessage: "Media is required",
                responseData: {}
            });
            res.status(400).json(json)
        }
        else {

            req.body.business = business._id;
            req.body.image = req.files[0].key;
            req.body.geometry = business.geometry;
            req.body.isCarEager = business.isCarEager;
            req.body.created_at = new Date();
            req.body.updated_at = new Date();

            BusinessOffer.create(req.body).then(function (offer) {
                res.status(200).json({
                    responseCode: 200,
                    responseMessage: "Offer has been added",
                    responseData: {
                        item: offer,
                    }
                });
            });
        }
    });
});

router.put('/offer/edit', xAccessToken.token, async function (req, res, next) {
    var rules = {
        id: 'required',
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Error",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);

        var business = decoded.user;
        var check = await BusinessOffer.find({ _id: req.body.id, business: business }).count().exec();
        if (check == 1) {
            var data = {
                offer: req.body.offer,
                description: req.body.description,
                valid_till: req.body.valid_till,
                updated_at: new Date()
            };

            BusinessOffer.findOneAndUpdate({ _id: req.body.id, business: business }, { $set: data }, { new: true }, function (err, doc) {
                if (err) {
                    var json = ({
                        responseCode: 400,
                        responseMessage: "Error occured",
                        responseData: {}
                    });

                    res.status(400).json(json)
                } else {
                    var json = ({
                        responseCode: 200,
                        responseMessage: "Offer has been edited",
                        responseData: {
                            item: doc,
                        }
                    });
                    res.status(200).json(json)
                }
            });
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Unauthorized",
                responseData: {}
            });
        }
    }
});

router.put('/offer/publish', xAccessToken.token, async function (req, res, next) {
    var rules = {
        id: 'required',
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Error",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);

        var business = decoded.user;
        var check = await BusinessOffer.find({ _id: req.body.id, business: business }).count().exec();
        if (check == 1) {
            var offer_id = req.body.id;

            BusinessOffer.findOne({ _id: offer_id, business: business }).exec().then(async function (result) {
                return result;
            }).then(function (result) {
                if (result.publish == false) {
                    var status = true;
                } else {
                    var status = false
                }
                var data = {
                    publish: status,
                };

                BusinessOffer.findOneAndUpdate({ _id: req.body.id, business: business }, { $set: data }, { new: true }, function (err, doc) { });
                return status;
            }).then(function (result) {
                BusinessOffer.count({ business: business, publish: true }, async function (err, count) {
                    if (result == 1) {
                        var status = 'published';
                        var isPublished = true;
                    } else {
                        var status = "unpublished";
                        var isPublished = false;
                    }

                    const totalOfferCount = await BusinessOffer.count({ business: business }).exec();

                    const publishedOfferCount = await BusinessOffer.count({ business: business, publish: true }).exec();

                    var json = ({
                        responseCode: 200,
                        responseMessage: "Offer has been " + status,
                        responseData: {
                            total: totalOfferCount,
                            published: publishedOfferCount,
                            publish: isPublished,
                        }
                    });
                    res.status(200).json(json)
                })
            });
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Unauthorized",
                responseData: {}
            });
        }
    }
});

router.get('/offer', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    var business = decoded.user;

    //paginate
    if (req.query.page == undefined) {
        var page = 0;
    } else {
        var page = req.query.page;
    }

    var page = Math.max(0, parseInt(page));
    var offer = await BusinessOffer.find({ business: business }).populate('bookmark').limit(config.perPage).skip(config.perPage * page).exec();
    const totalOfferCount = await BusinessOffer.count({ business: business }).exec();

    const publishedOfferCount = await BusinessOffer.count({ business: business, publish: true }).exec();

    res.status(200).json({
        responseCode: 200,
        responseMessage: "success",
        responseData: {
            total: totalOfferCount,
            published: publishedOfferCount,
            offers: offer,
        }
    })
});

router.post('/offer/image/add', xAccessToken.token, function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    var upload = multer({
        storage: multerS3({
            s3: s3,
            bucket: config.BUCKET_NAME + '/offer',
            acl: 'public-read',
            contentType: multerS3.AUTO_CONTENT_TYPE,
            // contentDisposition: 'attachment',
            key: function (req, file, cb) {
                let extArray = file.mimetype.split("/");
                let extension = extArray[extArray.length - 1];
                var filename = uuidv1() + '.' + extension;
                if (extension == 'png' || extension == 'jpg' || extension == 'jpeg' || extension == 'gif') {
                    cb(null, filename);
                }
                else {
                    var params = {
                        Bucket: config.BUCKET_NAME + "/offer",
                        Key: filename
                    };
                    s3.deleteObject(params, async function (err, data) {
                        var json = ({
                            responseCode: 422,
                            responseMessage: "Invalid extension",
                            responseData: {}
                        });
                        res.status(422).json(json)
                    });
                }
            }
        })
    }).array('media', 1);

    upload(req, res, async function (error) {
        if (error) {
            var json = ({
                responseCode: 400,
                responseMessage: "Error occured",
                responseData: {}
            });
            res.status(400).json(json)
        }

        if (req.files.length == 0) {
            var json = ({
                responseCode: 400,
                responseMessage: "Media is required",
                responseData: {}
            });
            res.status(400).json(json)
        }
        else {
            const media = await BusinessOffer.findById(req.body.id).exec();

            if (media) {
                var params = {
                    Bucket: config.BUCKET_NAME + "/offer",
                    Key: media.image
                };
                s3.deleteObject(params, async function (err, data) {
                    if (err) {
                        res.status(400).json({
                            responseCode: 400,
                            responseMessage: "Error occured",
                            responseData: err
                        });
                    }
                    else {
                        var data = {
                            image: req.files[0].key,
                        };

                        BusinessOffer.findOneAndUpdate({ _id: req.body.id }, { $set: data }, { new: true }, function (err, doc) {
                            res.status(200).json({
                                responseCode: 200,
                                responseMessage: "Offer image has been updated",
                                responseData: {
                                    item: doc
                                }
                            })
                        });
                    }
                });
            }
            else {
                res.status(400).json({
                    responseCode: 400,
                    responseMessage: "Wrong image",
                    responseData: {}
                })
            }
        }
    });
});

router.delete('/offer/image/delete', xAccessToken.token, async function (req, res, next) {
    var rules = {
        id: 'required',
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Error",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        const media = await BusinessOffer.findById(req.body.id).exec();

        if (media) {
            var params = {
                Bucket: config.BUCKET_NAME + "/offer",
                Key: media.image
            };
            s3.deleteObject(params, async function (err, data) {
                if (err) {
                    res.status(400).json({
                        responseCode: 400,
                        responseMessage: "Error occured",
                        responseData: {}
                    });
                }
                else {
                    var data = {
                        image: 'default.png',
                    };
                    BusinessOffer.findOneAndUpdate({ _id: req.body.id }, { $set: data }, { new: true }, function (err, doc) {
                        res.status(200).json({
                            responseCode: 200,
                            responseMessage: "Image has been delete",
                            responseData: {}
                        })
                    });
                }
            });
        } else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Wrong image",
                responseData: {}
            })
        }
    }
});

router.post('/gallery/update', xAccessToken.token, function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    var upload = multer({
        storage: multerS3({
            s3: s3,
            bucket: config.BUCKET_NAME + '/gallery',
            acl: 'public-read',
            contentType: multerS3.AUTO_CONTENT_TYPE,
            // contentDisposition: 'attachment',
            key: function (req, file, cb) {
                let extArray = file.mimetype.split("/");
                let extension = extArray[extArray.length - 1];

                var filename = uuidv1() + '.' + extension;
                if (extension == 'png' || extension == 'jpg' || extension == 'jpeg' || extension == 'gif') {
                    cb(null, filename);
                }
                else {
                    var params = {
                        Bucket: config.BUCKET_NAME + "/gallery",
                        Key: filename
                    };
                    s3.deleteObject(params, async function (err, data) {
                        var json = ({
                            responseCode: 422,
                            responseMessage: "Invalid extension",
                            responseData: {}
                        });
                        res.status(422).json(json)
                    });
                }
            }
        })
    }).array('media', 1);

    upload(req, res, function (error) {
        if (error) {
            var json = ({
                responseCode: 400,
                responseMessage: "Error occured",
                responseData: {}
            });
            res.status(400).json(json)
        }

        if (req.files.length == 0) {
            var json = ({
                responseCode: 400,
                responseMessage: "Media is required",
                responseData: {}
            });
            res.status(400).json(json)
        } else {
            var data = {
                business: decoded.user,
                file: req.files[0].key,
                created_at: new Date(),
                updated_at: new Date()
            };

            var businessGallery = new BusinessGallery(data);
            businessGallery.save();

            res.status(200).json({
                responseCode: 200,
                responseMessage: "File has been uploaded",
                responseData: {
                    item: businessGallery,
                }
            })
        }
    });
});

router.delete('/gallery/delete', xAccessToken.token, async function (req, res, next) {
    var rules = {
        id: 'required',
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Error",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);

        var image_id = req.body.id;
        const media = await BusinessGallery.findById(image_id).exec();

        if (media) {
            var params = {
                Bucket: config.BUCKET_NAME + "/gallery",
                Key: media.file
            };
            s3.deleteObject(params, async function (err, data) {
                if (err) {
                    res.status(400).json({
                        responseCode: 400,
                        responseMessage: "Error occured",
                        responseData: {}
                    });
                }
                else {
                    var deleteImage = BusinessGallery.findByIdAndRemove(image_id).exec();
                    if (deleteImage) {
                        res.status(200).json({
                            responseCode: 200,
                            responseMessage: "File has been deleted",
                            responseData: {},
                        })
                    } else {
                        res.status(400).json({
                            responseCode: 400,
                            responseMessage: "Error occured",
                            responseData: {},
                        })
                    }
                }
            });
        } else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Wrong image",
                responseData: {}
            })
        }
    }
});

router.put('/location/update', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    const count = await User.count({ _id: decoded.user }).exec();

    if (count == 1) {
        var data = {
            geometry: [req.body.latitude, req.body.longitude],
            address: {
                location: req.body.location,
            },
        };

        User.findOneAndUpdate({ _id: decoded.user }, { $set: data }, { new: true }, function (err, doc) {
            if (err) {
                var json = ({
                    responseCode: 400,
                    responseMessage: "Error Occurred",
                    responseData: err
                });

                res.status(400).json(json)
            } else {
                var json = ({
                    responseCode: 200,
                    responseMessage: "Location has been updated",
                    responseData: {}
                });
                res.status(200).json(json)
            }
        })
    } else {
        var json = ({
            responseCode: 400,
            responseMessage: "Invalid user",
            responseData: {}
        });

        res.status(400).json(json)
    }
});


router.get('/search', xAccessToken.token, async function (req, res, next) {

    if (req.query.page == undefined) {
        var page = 0;
    } else {
        var page = req.query.page;
    }

    var page = Math.max(0, parseInt(page));

    var query = req.query.query;

    var business = await User.find({ 'name': new RegExp(query, 'i') }).limit(config.perPage).skip(config.perPage * page).exec();

    res.status(200).json({
        responseCode: 200,
        responseMessage: "",
        responseData: business,
    });
});

router.get('/analytics', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    var business = req.headers['business'];
    var analytics = [];
    var paid_total = 0;
    var labour_cost = 0;
    var convenience = 0;
    var salvage = 0;
    var policy_clause = 0;
    var part_cost = 0;
    var of_cost = 0;
    var date = new Date();

    var country = await Country.findOne({ timezone: { $in: req.headers['tz'] } }).exec();

    if (req.query.type == "range") {
        if (req.query.query) {
            var query = req.query.query;
            var ret = query.split("to");

            var from = new Date(ret[0]);
            var to = new Date(ret[1]);
        }
        else {
            var from = new Date(date.getFullYear(), date.getMonth(), 1);
            var to = new Date(date.getFullYear(), date.getMonth(), date.getDate() + 1);
        }
    }

    else if (req.query.type == "period") {
        if (req.query.query) {
            var query = parseInt(req.query.query);
        }
        else {
            var query = 7
        }

        var from = new Date(date.getFullYear(), date.getMonth(), date.getDate() - query);
        var to = new Date(date.getFullYear(), date.getMonth(), date.getDate() + 1);
    }
    else {
        var from = new Date(date.getFullYear(), date.getMonth(), 1);
        var to = new Date(date.getFullYear(), date.getMonth(), date.getDate() + 1);
    }


    var totalLeads = await Lead.find({ business: business, "remark.status": { $in: ["Open", "Follow-Up", "PSF", "Closed", "Lost"] }, created_at: { $gte: from, $lte: to } }).count().exec();

    var excludeLeads = await Lead.find({ psf: false, converted: false, "remark.status": "Closed", business: business, created_at: { $gte: from, $lte: to } }).count().exec();

    var converted = await Lead.find({ business: business, psf: true, converted: true, "remark.status": "Closed", updated_at: { $gte: from, $lte: to } }).count().exec();

    var calc = totalLeads - excludeLeads;

    var conversion = 0;
    conversion = (converted / calc) * 100;

    if (conversion) {
        conversion = parseFloat(conversion.toFixed(2))
    }
    else {
        conversion = 0;
    }

    var category = await q.all(businessPlanCategory(business));

    for (var i = 0; i < category.length; i++) {
        if (category[i] == "Workshop") {
            analytics.push({
                title: "Total Leads",
                count: totalLeads,
                group: "Customer Overview",
                category: "CRM"
            });


            analytics.push({
                title: "Conversion",
                count: conversion,
                group: "Customer Overview",
                category: "CRM"
            });


            var totalBooking = await Booking.find({ business: business, is_services: true, status: { $ne: "Inactive" }, created_at: { $gte: from, $lte: to } }).count().exec();

            analytics.push({
                title: "Total Services",
                group: "General Overview",
                category: "WMS",
                count: totalBooking,
            });

            var totalPackage = await UserPackage.find({ business: business, created_at: { $gte: from, $lte: to } }).count().exec();

            analytics.push({
                title: "Total Packages",
                group: "General Overview",
                category: "WMS",
                count: totalPackage
            });

            await Invoice.find({ business: business, status: "Active", created_at: { $gte: from, $lte: to } })
                .cursor().eachAsync(async (booking) => {

                    paid_total = booking.payment.paid_total + paid_total;

                    if (booking.payment.convenience_charges) {
                        convenience = parseInt(booking.payment.convenience_charges) + convenience;
                    }

                    if (booking.payment.policy_clause) {
                        policy_clause = parseInt(booking.payment.policy_clause) + policy_clause;
                    }

                    if (booking.payment.salvage) {
                        salvage = parseInt(booking.payment.salvage) + salvage;
                    }

                    labour_cost = booking.payment.labour_cost + labour_cost + booking.payment.of_cost;
                    part_cost = booking.payment.part_cost + part_cost;
                });


            var other = convenience + policy_clause + salvage;

            analytics.push({
                title: "Service Revenue",
                group: "General Overview",
                category: "WMS",
                count: price(paid_total)
            });

            analytics.push({
                title: "Labour",
                group: "General Overview",
                category: "WMS",
                count: price(labour_cost)
            });

            analytics.push({
                title: "Parts",
                group: "General Overview",
                category: "WMS",
                count: price(part_cost)
            });

            analytics.push({
                title: "Others",
                group: "General Overview",
                category: "WMS",
                count: price(other)
            });
        }
        else if (category[i] == "Dealer") {
            analytics.push({
                title: "Total Leads",
                count: totalLeads,
                group: "Customer Overview",
                category: "CRM"
            });

            analytics.push({
                title: "Conversion",
                count: conversion,
                group: "Customer Overview",
                category: "CRM"
            });

            var cars = await Car.find({ user: business }).exec();

            var carSold = await CarSell.find({ seller: business, sold: true, created_at: { $gte: from, $lte: to } }).exec();

            var packageSold = await CarSell.find({ seller: business, sold: true, package_sold: true, created_at: { $gte: from, $lte: to } }).exec();

            var carListed = await Car.find({ user: business, publish: true, admin_approved: true, created_at: { $gte: from, $lte: to } }).exec();

            var packageSold = await CarSell.find({ seller: business, sold: true, package_sold: true, created_at: { $gte: from, $lte: to } }).exec();


            var sold_price = _.sumBy(carSold, x => x.price);
            var package_cost = _.sumBy(carSold, x => x.package_cost);
            var refurbishment_cost = _.sumBy(carSold, x => x.refurbishment_cost);
            var purchase_price = _.sumBy(carSold, x => x.purchase_price);

            var profit = sold_price - (package_cost + refurbishment_cost + purchase_price)

            analytics.push({
                title: "Cars In Garage",
                count: cars.length,
                group: "General Overview",
                category: category[i]
            });


            analytics.push({
                title: "Car Listed",
                count: carListed.length,
                group: "General Overview",
                category: category[i]
            });


            analytics.push({
                title: "Revenue",
                count: sold_price,
                group: "Income Overview",
                category: category[i]
            });

            analytics.push({
                title: "Profit",
                count: profit,
                group: "Income Overview",
                category: category[i]
            });

            analytics.push({
                title: "Packages Sold",
                count: packageSold.length,
                group: "General Overview",
                category: category[i]
            });

            analytics.push({
                title: "Cars Sold",
                count: carSold.length,
                group: "General Overview",
                category: category[i]
            });
        }

        else if (category[i] == "Fleet") {
            var cars = await Car.find({ user: business }).exec();

            var carSold = await CarSell.find({ seller: business, sold: true, created_at: { $gte: from, $lte: to } }).exec();

            var packageSold = await CarSell.find({ seller: business, sold: true, package_sold: true, created_at: { $gte: from, $lte: to } }).exec();

            var carListed = await Car.find({ user: business, publish: true, admin_approved: true, created_at: { $gte: from, $lte: to } }).exec();

            var packageSold = await CarSell.find({ seller: business, sold: true, package_sold: true, created_at: { $gte: from, $lte: to } }).exec();


            var sold_price = _.sumBy(carSold, x => x.price);
            var package_cost = _.sumBy(carSold, x => x.package_cost);
            var refurbishment_cost = _.sumBy(carSold, x => x.refurbishment_cost);
            var purchase_price = _.sumBy(carSold, x => x.purchase_price);

            var profit = sold_price - (package_cost + refurbishment_cost + purchase_price)

            analytics.push({
                title: "Cars In Garage",
                group: "General Overview",
                count: cars.length,
                category: category[i]
            });

            var check = await Point.find({ user: business, tag: "ReferralCommission" }).exec();

            var credit = _.filter(check, type => type.type == "credit");
            var credit_commission = _.sumBy(credit, x => x.points);

            var debit = _.filter(check, type => type.type == "debit");
            var debit_commission = _.sumBy(debit, x => x.points);


            analytics.push({
                title: "Commission Earned",
                group: "Income Overview",
                count: credit_commission - debit_commission,
                category: category[i]
            });

            analytics.push({
                title: "Car Listed",
                group: "General Overview",
                count: carListed.length,
                category: category[i]
            });


            /*analytics.push({
                title: "Revenue",
                count: sold_price,
                category: category[i]
            });

            analytics.push({
                title: "Profit",
                count: profit,
                category: category[i]
            });*/

            /* analytics.push({
                 title: "Package Sold",
                 count: packageSold.length,
                 category: category[i]
             });*/

            analytics.push({
                title: "Cars Sold",
                group: "General Overview",
                count: carSold.length,
                category: category[i]
            });
        }
    }

    analytics = _.uniqBy(analytics, "title");
    analytics = _(analytics).groupBy(x => x.group).map((value, key) => ({ group: key, data: value })).value(),


        res.status(200).json({
            responseCode: 200,
            responseMessage: from + " - " + to,
            responseData: analytics
        });
});

router.get('/performance/analytic', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    var business = req.headers['business'];

    var managements = [];
    var paid_total = 0;
    var labour_cost = 0;
    var part_cost = 0;
    var date = new Date();
    if (req.query.type == "range") {
        if (req.query.query) {
            var query = req.query.query;
            var ret = query.split("to");

            var from = new Date(ret[0]).toISOString();
            var to = new Date(ret[1]).toISOString();
        }
        else {
            var from = new Date(date.getFullYear(), date.getMonth(), 1);
            var to = new Date(date.getFullYear(), date.getMonth(), date.getDate() + 1);
        }
    }

    else if (req.query.type == "period") {
        if (req.query.query) {
            var query = parseInt(req.query.query);
        }
        else {
            var query = 7
        }

        var from = new Date(date.getFullYear(), date.getMonth(), date.getDate() - query);
        var to = new Date(date.getFullYear(), date.getMonth(), date.getDate() + 1);
    }
    else {
        var from = new Date(date.getFullYear(), date.getMonth(), date.getDate() - 30);
        var to = new Date(date.getFullYear(), date.getMonth(), date.getDate() + 1);
    }

    await Management.find({ business: business })
        .populate({ path: 'user', select: '_id id name contact_no avatar avatar_address email' })
        .cursor().eachAsync(async (management) => {
            if (management.role != "Admin") {
                if (management.role == "Service Advisor") {
                    var analytics = [];
                    var totalBooking = await Booking.find({ advisor: management.user._id, is_services: true, status: { $ne: "Inactive" }, created_at: { $gte: from, $lte: to } }).count().exec();

                    analytics.push({
                        title: "Total Booking",
                        count: totalBooking
                    });

                    var completed = await Booking.find({ advisor: management.user._id, is_services: true, status: "Completed", created_at: { $gte: from, $lte: to } }).count().exec();

                    analytics.push({
                        title: "Completed Booking",
                        count: completed
                    });



                    var inProcess = await Booking.find({ advisor: management.user._id, is_services: true, status: "In-Process",/* created_at:{$gte: from, $lte: to}*/ }).count().exec();

                    analytics.push({
                        title: "InProcess Booking",
                        count: inProcess
                    });

                    var rework = await Booking.find({ advisor: management.user._id, is_services: true, is_rework: true }).count().exec();

                    analytics.push({
                        title: "Rework",
                        count: rework
                    });

                    managements.push({
                        id: management.user._id,
                        role: management.role,
                        name: management.user.name,
                        username: management.user.username,
                        email: management.user.email,
                        contact_no: management.user.contact_no,
                        avatar: management.user.avatar,
                        avatar_address: management.user.avatar_address,
                        analytics: analytics
                    });
                }
                else if (management.role == "CRE") {
                    var analytics = [];
                    var leads = [];

                    var totalLeads = await Lead.find({ assignee: management.user._id, created_at: { $gte: from, $lte: to } }).count().exec();

                    var excludeLeads = await Lead.find({ psf: false, converted: false, "remark.status": "Closed", assignee: management.user._id, created_at: { $gte: from, $lte: to } }).count().exec();

                    var c = await Lead.find({ assignee: management.user._id, converted: true, updated_at: { $gte: from, $lte: to } }).exec();

                    var id = _.map(c, '_id');

                    var converted = await Booking.find({ lead: { $in: id }, status: { $nin: ["Rejected", "Cancelled", "Inactive", "EstimateRequested"] }, updated_at: { $gte: from, $lte: to } }).count();

                    var calc = totalLeads - excludeLeads;

                    var conversion = 0;
                    conversion = (converted / calc) * 100;

                    if (conversion) {
                        conversion = parseFloat(conversion.toFixed(2))
                    }

                    analytics.push({
                        title: "Total Leads",
                        count: totalLeads
                    });

                    analytics.push({
                        title: "Converted",
                        count: converted
                    });

                    analytics.push({
                        title: "Conversion",
                        count: conversion
                    });


                    var open = await Lead.find({ assignee: management.user._id, "remark.status": "Open" }).count().exec();
                    analytics.push({
                        title: "Open",
                        count: open
                    });

                    var follow_up = await Lead.find({ assignee: management.user._id, "remark.status": "Follow-Up" }).count().exec();
                    analytics.push({
                        title: "Follow Up",
                        count: follow_up
                    });

                    var pipeline = await Booking.find({ manager: management.user._id, converted: true, status: { $nin: ["Completed", "CompleteWork", "QC", "Closed", "Ready", "Rejected", "Cancelled", "Inactive"] } }).count().exec();

                    analytics.push({
                        title: "Estimate",
                        count: pipeline
                    });

                    var totalClosedLeads = await Lead.find({ assignee: management.user._id, "remark.status": "Closed" }).count().exec();
                    analytics.push({
                        title: "Closed",
                        count: totalClosedLeads
                    });

                    managements.push({
                        id: management.user._id,
                        name: management.user.name,
                        role: management.role,
                        username: management.user.username,
                        email: management.user.email,
                        contact_no: management.user.contact_no,
                        avatar: management.user.avatar,
                        avatar_address: management.user.avatar_address,
                        analytics: analytics
                    });
                }
            }
        });

    managements = _(managements).groupBy(x => x.role).map((value, key) => ({ role: key, data: value })).value(),
        res.status(200).json({
            responseCode: 200,
            responseMessage: "Analytics",
            responseData: managements
        });
});

/*router.get('/teams/analytic/', xAccessToken.token,async function(req,res,next){
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    var business = req.headers['business'];
    
    var managements = [];
    var paid_total = 0;
    var labour_cost = 0;
    var part_cost = 0;
    var date =  new Date();
    if(req.query.type=="range")
    {
        if(req.query.query)
        { 
            var query = req.query.query;
            var ret = query.split("to");

            var from = new Date(ret[0]);
            var to = new Date(ret[1]);
        }
        else{
            var from = new Date(date.getFullYear(), date.getMonth(), 1);
            var to = new Date(date.getFullYear(), date.getMonth(),  date.getDate()+1);
        }
    }

    else if(req.query.type=="period")
    {
        if(parseInt(req.query.query)==0)
        {
            var query = parseInt(req.query.query);
            var from = new Date(date.getFullYear(), date.getMonth(), date.getDate());
            var to = new Date(date.getFullYear(), date.getMonth(),  date.getDate()+1);
        }
        else if(parseInt(req.query.query)>=1)
        {
            var query = parseInt(req.query.query);
            var from = new Date(date.getFullYear(), date.getMonth(), date.getDate()-query);
            var to = new Date(date.getFullYear(), date.getMonth(),  date.getDate());
        }
        else
        {
            var query = 7;
            var from = new Date(date.getFullYear(), date.getMonth(), date.getDate()-query);
            var to = new Date(date.getFullYear(), date.getMonth(),  date.getDate()+1);
        }
    }
    else{
        var from = new Date(date.getFullYear(), date.getMonth(), date.getDate());
        var to = new Date(date.getFullYear(), date.getMonth(),  date.getDate()+1);
    }

    await Management.find({business: business, role: "Service Advisor"})
    .populate({path: 'user', select:'_id id name contact_no avatar avatar_address email'})
    .cursor().eachAsync(async(management)=>{
        var analytics = [];
        var totalBooking = await Booking.find({advisor:management.user._id, is_services: true, status:{$ne : "Inactive"}, updated_at:{$gte: from, $lte: to}}).count().exec();

        analytics.push({
            title: "Total",
            count: totalBooking
        });

        var totalUpcoming = await Booking.find({advisor:management.user._id, is_services: true, status:{$in :["Confirmed","Pending"]} }).count().exec();

        analytics.push({
            title: "Upcoming",
            count: totalUpcoming
        });

        var totalEstimated = await Booking.find({advisor:management.user._id, is_services: true, status:{$in :["EstimateRequested"]} }).count().exec();

        analytics.push({
            title: "Estimated",
            count: totalEstimated
        });

        var inProcess = await Booking.find({advisor:management.user._id, is_services: true, status:{$in :["JobOpen","In-Process","QC","StoreApproval"]},}).count().exec();

        analytics.push({
            title: "In Process",
            count: inProcess
        });  
    

        var completed = await Booking.find({advisor:management.user._id, is_services: true, status:{$in :["Closed","Completed","Ready"]}, updated_at:{$gte: from, $lte: to}}).count().exec();

        analytics.push({
            title: "Completed",
            count: completed
        });  
      
        
        var rework = await Booking.find({advisor:management.user._id, is_services: true, is_rework: true}).count().exec();
        analytics.push({
            title: "Rework",
            count: rework
        });  

        managements.push({
            id : management.user._id,
            role : management.role,
            department : management.department,
            name : management.user.name,
            username : management.user.username,
            email : management.user.email,
            contact_no : management.user.contact_no,
            avatar : management.user.avatar,
            avatar_address: management.user.avatar_address,
            analytics: analytics
        });                                                                                         
        
    });

    await Management.find({business: business,role: "CRE"})
    .populate({path: 'user', select:'_id id name contact_no avatar avatar_address email'})
    .cursor().eachAsync(async(management)=>{
        
        var analytics =[];
        var leads =[];

        var totalLeads = await Lead.find({assignee:management.user._id, "remark.status": { $in : ["Open","Follow-Up","PSF","Closed","Lost"]}, updated_at:{$gte: from, $lte: to}}).count().exec();

        var excludeLeads = await Lead.find({psf: false, converted: false,"remark.status": "Closed", assignee:management.user._id, created_at:{$gte: from, $lte: to}}).count().exec();

        var c = await Lead.find({assignee:management.user._id, converted: true, updated_at:{$gte: from, $lte: to}}).exec();

        var id = _.map(c, '_id');

        var converted = await Booking.find({lead : {$in: id}, status: {$nin: ["Rejected","Cancelled","Inactive","EstimateRequested"]},updated_at:{$gte: from, $lte: to }}).count();

        var calc = totalLeads-excludeLeads;

        var conversion = 0;
        conversion = (converted/calc)*100;

        if(conversion)
        {
            conversion = parseFloat(conversion.toFixed(2))
        }

        analytics.push({
            title: "Total Leads",
            count: totalLeads
        });

        analytics.push({
            title: "Converted",
            count: converted
        });

        analytics.push({
            title: "Conversion",
            count: conversion
        });


        var open = await Lead.find({assignee:management.user._id, "remark.status": "Open"}).count().exec();
        analytics.push({
            title: "Open",
            count: open
        });

        var follow_up = await Lead.find({assignee:management.user._id, "remark.status": "Follow-Up", updated_at:{$gte: from, $lte: to}}).count().exec();
        analytics.push({
            title: "Follow Up",
            count: follow_up
        });

        var pipeline = await Booking.find({manager:management.user._id, converted:true, status: {$nin: ["Completed","CompleteWork","QC","Closed","Ready","Rejected","Cancelled","Inactive"]}, updated_at:{$gte: from, $lte: to} }).count().exec();

        
        var totalPSFLeads = await Lead.find({assignee:management.user._id, "remark.status": "PSF", updated_at:{$gte: from, $lte: to}}).count().exec();

        analytics.push({
            title: "PSF",
            count: totalPSFLeads
        });
        
        var totalClosedLeads = await Lead.find({assignee:management.user._id, "remark.status": "Closed", updated_at:{$gte: from, $lte: to}}).count().exec();

        analytics.push({
            title: "Closed",
            count: totalClosedLeads
        });

        var totalLostLeads = await Lead.find({assignee:management.user._id, "remark.status": "Lost", updated_at:{$gte: from, $lte: to}}).count().exec();
        analytics.push({
            title: "Lost",
            count: totalLostLeads
        });

        analytics.push({
            title: "Estimate",
            count: pipeline
        });

        managements.push({
            id : management.user._id,
            name : management.user.name,
            role : "CRE",
            department : management.department,
            username : management.user.username,
            email : management.user.email,
            contact_no : management.user.contact_no,
            avatar : management.user.avatar,
            avatar_address: management.user.avatar_address,
            analytics: analytics
        });                                                                                         
    });

    res.status(200).json({
        responseCode:200,
        responseMessage: from+" "+to,
        responseData: managements
    });
});
*/

router.get('/teams/analytic/', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    var business = req.headers['business'];

    var managements = [];
    var paid_total = 0;
    var labour_cost = 0;
    var part_cost = 0;
    var date = new Date();
    if (req.query.type == "range") {
        if (req.query.query) {
            var query = req.query.query;
            var ret = query.split("to");

            var from = new Date(ret[0]);
            var to = new Date(ret[1]);
        }
        else {
            var from = new Date(date.getFullYear(), date.getMonth(), 1);
            var to = new Date(date.getFullYear(), date.getMonth(), date.getDate() + 1);
        }
    }

    else if (req.query.type == "period") {
        if (parseInt(req.query.query) == 0) {
            var query = parseInt(req.query.query);
            var from = new Date(date.getFullYear(), date.getMonth(), date.getDate());
            var to = new Date(date.getFullYear(), date.getMonth(), date.getDate() + 1);
        }
        else if (parseInt(req.query.query) >= 1) {
            var query = parseInt(req.query.query);
            var from = new Date(date.getFullYear(), date.getMonth(), date.getDate() - query);
            var to = new Date(date.getFullYear(), date.getMonth(), date.getDate());
        }
        else {
            var query = 7;
            var from = new Date(date.getFullYear(), date.getMonth(), date.getDate() - query);
            var to = new Date(date.getFullYear(), date.getMonth(), date.getDate() + 1);
        }
    }
    else {
        var from = new Date(date.getFullYear(), date.getMonth(), date.getDate());
        var to = new Date(date.getFullYear(), date.getMonth(), date.getDate() + 1);
    }

    await Management.find({ business: business, role: "Service Advisor" /* department: req.query.department*/ })
        .populate({ path: 'user', select: '_id id name contact_no avatar avatar_address email' })
        .cursor().eachAsync(async (management) => {
            var analytics = [];

            var totalBooking = await Booking.find({ advisor: management.user._id, is_services: true, status: { $ne: "Inactive" }, updated_at: { $gte: from, $lte: to } }).populate({ path: 'user', select: "name" }).populate({ path: 'car', select: 'title registration_no' }).exec();

            analytics.push({
                title: "Total",
                count: totalBooking.length,
                data: totalBooking
            });

            var totalUpcoming = await Booking.find({ advisor: management.user._id, is_services: true, status: { $in: ["Confirmed", "Pending"] } }).populate({ path: 'user', select: "name" }).populate({ path: 'car', select: 'title registration_no' }).exec();

            analytics.push({
                title: "Upcoming",
                count: totalUpcoming.length,
                data: totalUpcoming
            });

            var totalEstimated = await Booking.find({ advisor: management.user._id, is_services: true, status: { $in: ["EstimateRequested"] } }).populate({ path: 'user', select: "name" }).populate({ path: 'car', select: 'title registration_no' }).exec();

            analytics.push({
                title: "Estimated",
                count: totalEstimated.length,
                data: totalEstimated
            });

            var inProcess = await Booking.find({ advisor: management.user._id, is_services: true, status: { $in: ["JobOpen", "In-Process", "QC", "StoreApproval"] },/* created_at:{$gte: from, $lte: to}*/ }).populate({ path: 'user', select: "name" }).populate({ path: 'car', select: 'title registration_no' }).exec();

            analytics.push({
                title: "In Process",
                count: inProcess.length,
                data: inProcess
            });


            var completed = await Booking.find({ advisor: management.user._id, is_services: true, status: { $in: ["Closed", "Completed", "Ready"] }, updated_at: { $gte: from, $lte: to } }).populate({ path: 'user', select: "name" }).populate({ path: 'car', select: 'title registration_no' }).exec();

            analytics.push({
                title: "Completed",
                count: completed.length,
                data: completed
            });


            var rework = await Booking.find({ advisor: management.user._id, is_services: true, is_rework: true }).populate({ path: 'user', select: "name" }).populate({ path: 'car', select: 'title registration_no' }).exec();
            analytics.push({
                title: "Rework",
                count: rework.length,
                data: rework,
            });

            managements.push({
                id: management.user._id,
                role: management.role,
                department: management.department,
                name: management.user.name,
                username: management.user.username,
                email: management.user.email,
                contact_no: management.user.contact_no,
                avatar: management.user.avatar,
                avatar_address: management.user.avatar_address,
                analytics: analytics
            });

        });

    await Management.find({ business: business, role: "CRE"/* department: req.query.department*/ })
        .populate({ path: 'user', select: '_id id name contact_no avatar avatar_address email' })
        .cursor().eachAsync(async (management) => {

            var analytics = [];
            var leads = [];

            var totalLeads = await Lead.find({ assignee: management.user._id, "remark.status": { $in: ["Open", "Follow-Up", "PSF", "Closed", "Lost"] }, updated_at: { $gte: from, $lte: to } }).exec();

            var excludeLeads = await Lead.find({ psf: false, converted: false, "remark.status": "Closed", assignee: management.user._id, created_at: { $gte: from, $lte: to } }).exec();

            var c = await Lead.find({ assignee: management.user._id, converted: true, updated_at: { $gte: from, $lte: to } }).exec();

            var id = _.map(c, '_id');

            var converted = await Booking.find({ lead: { $in: id }, status: { $nin: ["Rejected", "Cancelled", "Inactive", "EstimateRequested"] }, updated_at: { $gte: from, $lte: to } }).populate({ path: 'user', select: "name" }).populate({ path: 'car', select: 'title registration_no' }).exec();

            var calc = totalLeads.length - excludeLeads.length;

            var conversion = 0;
            conversion = (converted.length / calc) * 100;

            if (conversion) {
                conversion = parseFloat(conversion.toFixed(2))
            }

            analytics.push({
                title: "Total Leads",
                count: totalLeads.length,
                data: totalLeads,
            });

            analytics.push({
                title: "Converted",
                count: converted.length,
                data: converted
            });

            analytics.push({
                title: "Conversion",
                count: conversion,
                data: {}
            });


            var open = await Lead.find({ assignee: management.user._id, "remark.status": "Open" }).exec();
            analytics.push({
                title: "Open",
                count: open.length,
                data: open
            });

            var follow_up = await Lead.find({ assignee: management.user._id, "remark.status": "Follow-Up", updated_at: { $gte: from, $lte: to } }).exec();
            analytics.push({
                title: "Follow Up",
                count: follow_up.length,
                data: follow_up,
            });

            var pipeline = await Booking.find({ manager: management.user._id, converted: true, status: { $nin: ["Completed", "CompleteWork", "QC", "Closed", "Ready", "Rejected", "Cancelled", "Inactive"] }, updated_at: { $gte: from, $lte: to } }).populate({ path: 'user', select: "name" }).populate({ path: 'car', select: 'title registration_no' }).exec();


            var totalPSFLeads = await Lead.find({ assignee: management.user._id, "remark.status": "PSF", updated_at: { $gte: from, $lte: to } }).exec();

            analytics.push({
                title: "PSF",
                count: totalPSFLeads.length,
                data: totalPSFLeads
            });

            var totalClosedLeads = await Lead.find({ assignee: management.user._id, "remark.status": "Closed", updated_at: { $gte: from, $lte: to } }).exec();

            analytics.push({
                title: "Closed",
                count: totalClosedLeads.length,
                data: totalClosedLeads
            });

            var totalLostLeads = await Lead.find({ assignee: management.user._id, "remark.status": "Lost", updated_at: { $gte: from, $lte: to } }).exec();
            analytics.push({
                title: "Lost",
                count: totalLostLeads.length,
                data: totalLostLeads
            });

            analytics.push({
                title: "Estimate",
                count: pipeline.length,
                data: pipeline
            });

            managements.push({
                id: management.user._id,
                name: management.user.name,
                role: "CRE",
                department: management.department,
                username: management.user.username,
                email: management.user.email,
                contact_no: management.user.contact_no,
                avatar: management.user.avatar,
                avatar_address: management.user.avatar_address,
                analytics: analytics
            });
        });

    res.status(200).json({
        responseCode: 200,
        responseMessage: from + " " + to,
        responseData: managements
    });
});


router.get('/packages/get', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;

    var packages = [];

    if (req.query.page == undefined) {
        var page = 0;
    } else {
        var page = req.query.page;
    }

    var page = Math.max(0, parseInt(page));

    await UserPackage.find({})
        .populate({ path: 'user', select: '_id id name contact_no avatar avatar_address email' })
        .populate({ path: 'car', select: '_id id title registration_no' })
        .sort({ created_at: -1 }).skip(config.perPage * page).limit(config.perPage)
        .cursor().eachAsync(async (package) => {
            var discounts = [];
            package.discount.forEach(async function (discount) {
                var remain = 0;

                if (discount.discount != 0) {
                    if (discount.for == "specific") {
                        var label = discount.label;
                        var usedPackage = await PackageUsed.findOne({ package: package._id, user: user, label: discount.label }).count().exec();
                        remains = discount.limit - usedPackage;
                    }
                    else {
                        var bookingCategory = await BookingCategory.findOne({ tag: discount.label }).exec();
                        var label = bookingCategory.title;
                    }

                    discounts.push({
                        _id: discount._id,
                        for: discount.for,
                        label: label,
                        discount: discount.discount,
                        type: discount.type,
                        limit: discount.limit,
                        remains: remains
                    });
                }
            });

            packages.push({
                user: package.user,
                name: package.name,
                _id: package._id,
                id: package._id,
                description: package.description,
                discount: discounts,
                car: package.car,
                payment: package.payment,
                created_at: moment(package.created_at).tz(req.headers['tz']).format('lll'),
                expired_at: moment(package.expired_at).tz(req.headers['tz']).format('lll'),
            });
        })

    res.status(200).json({
        responseCode: 200,
        responseMessage: "Packages",
        responseData: packages
    })
});

router.post('/gallery/image/add', xAccessToken.token, function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    var upload = multer({
        storage: multerS3({
            s3: s3,
            bucket: config.BUCKET_NAME + '/gallery',
            acl: 'public-read',
            contentType: multerS3.AUTO_CONTENT_TYPE,
            // contentDisposition: 'attachment',
            key: function (req, file, cb) {
                let extArray = file.mimetype.split("/");
                let extension = extArray[extArray.length - 1];

                var filename = uuidv1() + '.' + extension;
                if (extension == 'png' || extension == 'jpg' || extension == 'jpeg' || extension == 'gif') {
                    cb(null, filename);
                }
                else {
                    var params = {
                        Bucket: config.BUCKET_NAME + "/gallery",
                        Key: filename
                    };
                    s3.deleteObject(params, async function (err, data) {
                        var json = ({
                            responseCode: 422,
                            responseMessage: "Invalid extension",
                            responseData: {}
                        });
                        res.status(422).json(json)
                    });
                }
            }
        })
    }).array('media', 1);

    upload(req, res, async function (error) {
        if (error) {
            var json = ({
                responseCode: 400,
                responseMessage: "Error occured",
                responseData: {}
            });
            res.status(400).json(json)
        }

        if (req.files.length == 0) {
            var json = ({
                responseCode: 400,
                responseMessage: "Media is required",
                responseData: {}
            });
            res.status(400).json(json)
        } else {

            var rules = {
                source: 'required'
            };

            var validation = new Validator(req.body, rules);

            if (validation.fails()) {
                res.status(422).json({
                    responseCode: 422,
                    responseMessage: "Error",
                    responseData: {
                        res: validation.errors.all()
                    }
                })
            } else {
                if (req.body.category == "service") {
                    var check = await Service.findById(req.body.source).exec()
                }
                else if (req.body.category == "collision") {
                    var check = await Collision.findById(req.body.source).exec()
                }
                else if (req.body.category == "washing") {
                    var check = await Washing.findById(req.body.source).exec()
                }
                else if (req.body.category == "product") {
                    var check = await Product.findById(req.body.source).exec()
                }
                else if (req.body.category == "customization") {
                    var check = await Customization.findById(req.body.source).exec()
                }
                else {
                    var check = {}
                }

                if (check) {
                    var data = {
                        source: req.body.source,
                        file: req.files[0].key,
                        type: req.body.type,
                        category: req.body.category,
                        created_at: new Date(),
                        updated_at: new Date(),
                    };

                    var galleryImage = new Gallery(data);
                    galleryImage.save();

                    res.status(200).json({
                        responseCode: 200,
                        responseMessage: "File has been uploaded",
                        responseData: {
                            item: galleryImage
                        }
                    })
                }
                else {
                    res.status(400).json({
                        responseCode: 400,
                        responseMessage: "Source not found",
                        responseData: {}
                    })
                }
            }
        }
    });
});

router.delete('/gallery/image/delete', xAccessToken.token, async function (req, res, next) {
    var rules = {
        id: 'required',
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Error",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);

        var image_id = req.body.id;
        const media = await Gallery.findById(image_id).exec();

        if (media) {
            var params = {
                Bucket: config.BUCKET_NAME + "/gallery",
                Key: media.file
            };
            s3.deleteObject(params, async function (err, data) {
                if (err) {
                    res.status(400).json({
                        responseCode: 400,
                        responseMessage: "Error occured",
                        responseData: {}
                    });
                }
                else {
                    var deleteImage = Gallery.findByIdAndRemove(image_id).exec();
                    if (deleteImage) {
                        res.status(200).json({
                            responseCode: 200,
                            responseMessage: "File has been deleted",
                            responseData: {}
                        })
                    } else {
                        res.status(400).json({
                            responseCode: 400,
                            responseMessage: "Error occured",
                            responseData: {}
                        })
                    }
                }
            });
        } else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Wrong image",
                responseData: {}
            })
        }
    }
});

router.get('/users/list/get', xAccessToken.token, async function (req, res, next) {
    var carsFilter = [];
    var segment = [];
    var filterBy = [];
    var booking = [];

    if (req.query.page == undefined) {
        var page = 0;
    } else {
        var page = req.query.page;
    }
    var page = Math.max(0, parseInt(page));
    var peoples = [];
    var date = new Date();
    if (req.query.type == "range") {
        if (req.query.query) {
            var query = req.query.query;
            var ret = query.split("to");

            var from = new Date(ret[0]);
            var to = new Date(ret[1]);
        }
        else {
            var from = new Date(date.getFullYear(), date.getMonth(), 1);
            var to = new Date(date.getFullYear(), date.getMonth(), date.getDate() + 1);
        }
    }

    else if (req.query.type == "period") {
        if (req.query.query) {
            var query = parseInt(req.query.query);
        }
        else {
            var query = 7
        }

        var from = new Date(date.getFullYear(), date.getMonth(), date.getDate() - query);
        var to = new Date(date.getFullYear(), date.getMonth(), date.getDate() + 1);

    }
    else {
        var from = new Date(date.getFullYear(), date.getMonth(), date.getDate() - 365);
        var to = new Date(date.getFullYear(), date.getMonth(), date.getDate() + 1);
    }


    filterBy['created_at'] = { $gte: from, $lte: to }

    if (req.query.segment) {
        var segment = req.query.segment;
        carsFilter['segment'] = { $in: segment.split(',') }
    }

    if (req.query.automaker) {
        var automaker = req.query.automaker;
        carsFilter['automaker'] = { $in: automaker.split(',') }
    }

    await User.find({ 'account_info.type': 'user', created_at: { $gte: from, $lte: to } })
        .select('name username email avatar avatar_address contact_no account_info created_at updated_at')
        .sort({ created_at: -1 }).skip(100 * page).limit(100)
        .cursor().eachAsync(async (user) => {
            var booking_date = "";
            var last_booking = await Booking.findOne({ user: user._id, status: { $ne: "Inactive" } }).sort({ created_at: -1 }).exec();
            if (last_booking) {
                booking_date = moment(last_booking.created_at).tz(req.headers['tz']).format('ll');
            }

            var feedback = null;

            var lead = await Lead.findOne({ user: user._id /*,type: "Feedback"*/ }).sort({ created_at: -1 }).exec();
            if (lead) {
                var assignee = await User.findById(lead.assignee).exec();

                if (assignee) {
                    var a = {
                        name: assignee.name,
                        email: assignee.email,
                        contact_no: assignee.contact_no,
                        _id: assignee._id,
                        _id: assignee._id,
                    }
                }
                else {
                    var a = null;
                }

                if (lead.follow_up == null) {
                    var follow_up = {}
                } else {
                    follow_up = lead.follow_up
                }

                var l = lead.remark;

                if (l) {
                    if (l.assignee_remark == "") {
                        l.assignee_remark = l.customer_remark
                    }
                    var remark = {
                        source: l.source,
                        type: l.type,
                        status: l.status,
                        customer_remark: l.customer_remark,
                        assignee_remark: l.assignee_remark,
                        assignee: a,
                        color_code: l.color_code,
                        created_at: moment(l.created_at).tz(req.headers['tz']).format('lll'),
                        updated_at: moment(l.updated_at).tz(req.headers['tz']).format('lll'),
                    }
                }

                feedback = {
                    user: lead.user,
                    name: lead.name,
                    contact_no: lead.contact_no,
                    email: lead.email,
                    _id: lead._id,
                    id: lead.id,
                    priority: lead.priority,
                    contacted: lead.contacted,
                    type: lead.type,
                    lead_id: lead.lead_id,
                    geometry: lead.geometry,
                    date: moment(lead.updated_at).tz(req.headers['tz']).format('lll'),
                    status: lead.status,
                    source: lead.source,
                    important: lead.important,
                    follow_up: follow_up,
                    remark: remark,
                    assignee: a,
                    created_at: moment(lead.created_at).tz(req.headers['tz']).format('lll'),
                    updated_at: moment(lead.updated_at).tz(req.headers['tz']).format('lll'),
                }
            }

            var cars = [];
            var segment = [];


            peoples.push({
                _id: user._id,
                id: user._id,
                name: user.name,
                username: user.username,
                email: user.email,
                contact_no: user.contact_no,
                avatar_address: "https://s3.ap-south-1.amazonaws.com/" + config.BUCKET_NAME + "/avatar/" + user.avatar,
                account_info: user.account_info,
                created_at: user.created_at,
                updated_at: user.updated_at,
                last_booking: booking_date,
                feedback: feedback,
                agent: user.agent,
                joined: moment(user.updated_at).tz(req.headers['tz']).format('ll'),
            });
        });

    res.status(200).json({
        responseCode: 200,
        responseMessage: "Success",
        responseData: peoples,
        responseInfo: {
            totalResult: await User.find({ 'account_info.type': 'user', created_at: { $gte: from, $lte: to } }).count().exec()
        }
    })
});

router.get('/users/get', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    //paginate
    if (req.query.page == undefined) {
        var page = 0;
    } else {
        var page = req.query.page;
    }

    var page = Math.max(0, parseInt(page));
    var product = [];

    if (req.query.by == "category") {
        var query = {
            "$match": {
                category: mongoose.Types.ObjectId(req.query.query)
            }
        }
    }
    else if (req.query.by == "subcategory") {
        var query = { "$match": { subcategory: mongoose.Types.ObjectId(req.query.query) } }
    }
    else if (req.query.by == "brand") {
        var query = { "$match": { product_brand: mongoose.Types.ObjectId(req.query.query) } }
    }
    else if (req.query.by == "model") {
        var query = { "$match": { product_model: mongoose.Types.ObjectId(req.query.query) } }
    }
    else if (req.query.by == "id") {
        var query = { "$match": { product: mongoose.Types.ObjectId(req.query.query) } }
    }
    else {
        var query = {
            "$match": {
                "$or": [
                    { _subcategory: new RegExp(req.query.query, "i") },
                    { _category: new RegExp(req.query.query, "i") },
                    { type: new RegExp(req.query.query, "i") },
                    { _model: new RegExp(req.query.query, "i") },
                    { models: new RegExp(req.query.query, "i") },
                    { title: new RegExp(req.query.query, "i") },
                    { keywords: new RegExp(req.query.query, "i") },
                ]
            }
        }

    }


    await BusinessProduct.aggregate([
        query,
        { "$unwind": "$product_brand" },
        {
            "$lookup": {
                "from": "ProductBrand",
                "localField": "product_brand",
                "foreignField": "_id",
                "as": "product_brand"
            }
        },
        { "$unwind": "$category" },
        {
            "$lookup": {
                "from": "ProductCategory",
                "localField": "category",
                "foreignField": "_id",
                "as": "category"
            }
        },
        { "$unwind": "$subcategory" },
        {
            "$lookup": {
                "from": "ProductCategory",
                "localField": "subcategory",
                "foreignField": "_id",
                "as": "subcategory"
            }
        },
        { $sort: { "price.sell_price": -1 } },
        { $group: { _id: '$product', data: { $push: '$$ROOT' } } },
        { $skip: 20 * page },
        { $limit: 20 }
    ])
        .allowDiskUse(true)
        .cursor({ batchSize: 10 })
        .exec()
        .eachAsync(async function (p) {
            var cart = await Cart.findOne({ product: p.data[0]._id, user: user }).exec();
            var title = p.data[0].title;
            if (_.includes(title, ',')) { title = title.replace(/,/g, ", ") }
            product.push({
                _id: p.data[0]._id,
                id: p.data[0]._id,
                product: p.data[0].product,
                title: title,
                price: p.data[0].price,
                thumbnail: 'https://s3.ap-south-1.amazonaws.com/' + config.BUCKET_NAME + '/master/product/300/' + p.data[0].thumbnail,
                unit: p.data[0].unit,
                quantity: p.data[0].quantity,
            });
        });

    res.status(200).json({
        responseCode: 200,
        responseMessage: "success",
        responseData: {
            products: product
        }
    })
});

router.post('/products/offers/add', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var business = req.headers['business'];


    req.body.valid_till = new Date(req.body.valid_till).toISOString();
    req.body.business = business._id;
    req.body.isCarEager = business.isCarEager;
    req.body.created_at = new Date();
    req.body.updated_at = new Date();

    ProductOffer.create(req.body).then(function (offer) {
        res.status(200).json({
            responseCode: 200,
            responseMessage: "Offer has been added",
            responseData: {
                item: offer,
            }
        });
    });
});

router.get('/taxes/get', async function (req, res, next) {
    var tz = req.headers['tz'];
    if (tz) {
        var country = await Country.findOne({ timezone: { $in: tz } }).exec();
        if (country) {
            var taxes = await Tax.find({ country: country._id }).exec()
            res.status(200).json({
                responseCode: 200,
                responseMessage: "Tax Slabs",
                responseInfo: {
                    taxes: _.map(taxes, 'rate'),
                },
                responseData: taxes,
            })
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Tax Slabs",
                responseData: {}
            })
        }
    }
    else {
        res.status(400).json({
            responseCode: 400,
            responseMessage: "Tax Slabs",
            responseData: {}
        })
    }
});

router.get('/booking/taxes/get', async function (req, res, next) {
    var tz = req.headers['tz'];
    if (tz) {
        var booking = await Booking.findById(req.query.booking).exec();
        if (booking) {
            var country = await Country.findOne({ timezone: { $in: tz } }).exec();
            if (country) {
                res.status(200).json({
                    responseCode: 200,
                    responseMessage: "Tax Slabs",
                    responseData: await Tax.find({ country: country._id }).exec(),
                })
            }
            else {
                res.status(400).json({
                    responseCode: 400,
                    responseMessage: "Tax Slabs",
                    responseData: {}
                })
            }
        }
    }
    else {
        res.status(400).json({
            responseCode: 400,
            responseMessage: "Tax Slabs",
            responseData: {}
        })
    }
});

router.post('/owner/car/add', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var business = req.headers['business'];
    var loggedInDetails = await User.findById(decoded.user).exec();
    var currentDate = new Date();
    var booking = null;
    var user = await User.findOne({ _id: req.body.user }).exec();
    var advisor = await q.all(getAdvisor(loggedInDetails._id, business));
    if (user) {
        var customer_requirements = []
        if (req.body.requirement) {
            customer_requirements.push({
                user: user,
                requirement: req.body.requirement,
            });
        }

        var expire = "";
        if (req.body.expire) {
            expire = new Date(req.body.expire).toISOString();
        }
        var insurance_info = {
            policy_holder: req.body.policy_holder,
            insurance_company: req.body.insurance_company,
            policy_no: req.body.policy_no,
            premium: req.body.premium,
            expire: expire,
            branch: "",
            gstin: "",
            claim: false,
            cashless: false,
            accident_place: "",
            accident_date: null,
            accident_time: "",
            accident_cause: "",
            driver_accident: "",
            spot_survey: "",
            fir: "",
            policy_type: "",
            claim_no: "",
        };

        var rg = req.body.registration_no;
        req.body.registration_no = rg.replace(/ /g, '');

        var checkCar = await Car.findOne({ registration_no: req.body.registration_no, status: true }).populate({ path: 'user', select: 'name username avatar avatar_address account_info' }).exec();

        if (checkCar) {
            Car.findOneAndUpdate({
                _id: checkCar._id
            },
                {
                    $set: {
                        odometer: req.body.odometer,
                        fuel_level: req.body.fuel_level,
                        vin: req.body.vin,
                        engine_no: req.body.engine_no,
                        insurance_info: insurance_info
                    }
                }, {
                new: false
            }, function (err, doc) { });

            var checkBooking = await Booking.findOne({ car: checkCar._id, status: { $nin: ["Completed", "CompleteWork", "QC", "Closed", "Ready", "Rejected", "Cancelled", "Inactive"] } }).exec();

            if (checkBooking) {
                res.status(422).json({
                    responseCode: 422,
                    responseMessage: "This job already exists in " + checkBooking.status,
                    responseData: {}
                })
            }
            else {
                var payment = {
                    payment_mode: "",
                    payment_status: "Pending",
                    discount_type: "",
                    coupon: "",
                    coupon_type: "",
                    discount: 0,
                    discount_total: 0,
                    part_cost: 0,
                    labour_cost: 0,
                    paid_total: 0,
                    total: 0,
                    discount_applied: false,
                    transaction_id: "",
                    transaction_date: "",
                    transaction_status: "",
                    transaction_response: ""
                };

                var bookingData = {
                    package: null,
                    car: checkCar._id,
                    advisor: advisor,
                    manager: null,
                    business: business,
                    user: user._id,
                    odometer: req.body.odometer,
                    fuel_level: req.body.fuel_level,
                    services: [],
                    job_no: new Date().valueOf(),
                    customer_requirements: customer_requirements,
                    booking_no: Math.round(+new Date() / 1000) + Math.round((Math.random() * 9999) + 1),
                    date: new Date(),
                    time_slot: "",
                    convenience: "",
                    status: "JobInitiated",
                    sub_status: "JobInitiated",
                    estimation_requested: false,
                    insurance_info: insurance_info,
                    payment: payment,
                    lead: null,
                    is_services: true,
                    started_at: new Date(),
                    created_at: new Date(),
                    updated_at: new Date()
                };

                Booking.create(bookingData).then(async function (b) {
                    var activity = {
                        user: loggedInDetails._id,
                        name: loggedInDetails.name,
                        stage: "NewJob",
                        activity: "JobInititated",
                    };

                    fun.bookingLog(b._id, activity);

                    var notify = {
                        receiver: [b.user],
                        activity: "jobcard",
                        tag: "JobInititated",
                        source: b._id,
                        sender: b.business,
                        points: 0
                    }

                    fun.newNotification(notify);
                    event.jobSms(notify);

                    event.zohoLead(b._id);

                    res.status(200).json({
                        responseCode: 200,
                        responseMessage: "Car has been added",
                        responseData: {
                            car: checkCar._id,
                            user: user._id,
                            booking: b._id
                        }
                    });
                });
            }
        }
        else {
            if (req.body.variant == "" || req.body.variant == null) {
                return res.status(422).json({
                    responseCode: 422,
                    responseMessage: "Car not found. Please select a car.",
                    responseData: {}
                });
            }
            else {
                var variant = await Variant.findOne({ _id: req.body.variant }).populate('model').select('-service_schedule').exec();
                if (variant) {
                    var rg = req.body.registration_no;
                    req.body.registration_no = rg.replace(/ /g, '');
                    var reg = await Car.find({ registration_no: req.body.registration_no, status: true }).count().exec();
                    if (reg == 0) {
                        var carData = {};
                        var automaker = await Automaker.findById(variant.model.automaker).exec();
                        var rg = req.body.registration_no;
                        carData.reg_no_copy = rg.replace(/\s/g, '');
                        carData.geometry = [0, 0];
                        carData.created_at = currentDate;
                        carData.updated_at = currentDate;
                        carData.variant = variant._id;
                        carData._variant = variant.value;
                        carData.title = variant.variant;
                        carData.automaker = variant.model.automaker;
                        carData._automaker = automaker._maker;
                        carData.model = variant.model._id;
                        carData._model = variant.model.value;
                        carData.segment = variant.model.segment;
                        carData.user = user._id;
                        carData.registration_no = req.body.registration_no;
                        carData.fuel_type = variant.specification.fuel_type;
                        carData.transmission = variant.specification.type;
                        carData.odometer = req.body.odometer
                        carData.fuel_level = req.body.fuel_level;
                        carData.vin = req.body.vin;
                        carData.engine_no = req.body.engine_no;
                        carData.insurance_info = insurance_info;
                        carData.carId = Math.round(+new Date() / 1000) + Math.round((Math.random() * 9999) + 1);

                        Car.create(carData).then(async function (car) {
                            User.findOneAndUpdate({ _id: user._id }, {
                                $push: {
                                    "cars": car._id
                                }
                            }, { new: true }, async function (err, doc) {
                                if (err) {
                                    res.status(400).json({
                                        responseCode: 400,
                                        responseMessage: "Error Occurred",
                                        responseData: err
                                    })
                                }
                                else {
                                    fun.addMember(user._id, variant.model);

                                    var payment = {
                                        payment_mode: "",
                                        payment_status: "Pending",
                                        discount_type: "",
                                        coupon: "",
                                        coupon_type: "",
                                        discount: 0,
                                        discount_total: 0,
                                        part_cost: 0,
                                        labour_cost: 0,
                                        paid_total: 0,
                                        total: 0,
                                        discount_applied: false,
                                        transaction_id: "",
                                        transaction_date: "",
                                        transaction_status: "",
                                        transaction_response: ""
                                    };

                                    var bookingData = {
                                        package: null,
                                        car: car._id,
                                        advisor: advisor,
                                        manager: null,
                                        business: business,
                                        user: user._id,
                                        services: [],
                                        job_no: new Date().valueOf(),
                                        customer_requirements: customer_requirements,
                                        booking_no: Math.round(+new Date() / 1000) + Math.round((Math.random() * 9999) + 1),
                                        date: new Date(),
                                        time_slot: "",
                                        convenience: "",
                                        status: "JobInitiated",
                                        sub_status: "JobInitiated",
                                        odometer: req.body.odometer,
                                        fuel_level: req.body.fuel_level,
                                        estimation_requested: false,
                                        payment: payment,
                                        address: req.body.address,
                                        lead: null,
                                        is_services: true,
                                        insurance_info: insurance_info,
                                        started_at: new Date(),
                                        created_at: new Date(),
                                        updated_at: new Date()
                                    };

                                    Booking.create(bookingData).then(async function (b) {



                                        var activity = {
                                            user: loggedInDetails._id,
                                            name: loggedInDetails.name,
                                            stage: "NewJob",
                                            activity: "JobInititated",
                                        };

                                        fun.bookingLog(b._id, activity);

                                        var notify = {
                                            receiver: [b.user],
                                            activity: "jobcard",
                                            tag: "JobInititated",
                                            source: b._id,
                                            sender: b.business,
                                            points: 0
                                        }

                                        fun.newNotification(notify);
                                        event.jobSms(notify);

                                        event.zohoLead(b._id);

                                        res.status(200).json({
                                            responseCode: 200,
                                            responseMessage: "Car has been added",
                                            responseData: {
                                                car: car._id,
                                                user: user._id,
                                                booking: b._id
                                            }
                                        });
                                    });
                                }
                            })
                        });
                    }
                    else {
                        res.status(422).json({
                            responseCode: 422,
                            responseMessage: "registration no already exist",
                            responseData: {}
                        });
                    }
                }
                else {
                    res.status(422).json({
                        responseCode: 422,
                        responseMessage: "Unprocessable Entity",
                        responseData: {}
                    });
                }
            }
        }
    }
    else {
        res.status(400).json({
            responseCode: 400,
            responseMessage: "User Not Found",
            responseData: {}
        })
    }
});

router.get('/booking/car/get', xAccessToken.token, async function (req, res, next) {
    var rules = {
        booking: 'required',
    };

    var validation = new Validator(req.query, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Booking required",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var user = decoded.user;
        var business = req.headers['business'];
        var currentDate = new Date();
        var car = [];

        var booking = await Booking.findById(req.query.booking).exec();

        if (booking) {
            var doc = await Car.findById(booking.car)
                .populate('bookmark')
                .populate('thumbnails')
                .populate({ path: 'user', select: 'name username avatar avatar_address address' })
                .populate({ path: 'variant', populate: { path: 'model' } })
                .exec();

            car.push({
                __v: 0,
                _id: doc._id,
                id: doc.id,
                title: doc.title,
                variant: doc.variant._id,
                registration_no: doc.registration_no,
                insurance_info: doc.insurance_info,
                engine_no: doc.engine_no,
                vin: doc.vin,
                premium: doc.premium,
                is_bookmarked: doc.is_bookmarked,
                user: doc.user,
            })

            res.status(200).json({
                responseCode: 200,
                responseMessage: "success",
                responseData: car
            });
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Booking not found",
                responseData: {}
            })
        }
    }
});

router.get('/booked/services/get', xAccessToken.token, async function (req, res, next) {
    var rules = {
        booking: 'required',
    };

    var validation = new Validator(req.query, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Booking required",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var user = decoded.user;
        var business = req.headers['business'];
        var currentDate = new Date();
        var car = [];

        var booking = await Booking.findById(req.query.booking).exec();

        if (booking) {

            res.status(200).json({
                responseCode: 200,
                responseMessage: "success",
                responseData: booking.services
            });
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Booking not found",
                responseData: {}
            })
        }
    }
});

router.post('/booking/job/add', xAccessToken.token, async function (req, res, next) {
    var rules = {
        booking: 'required',
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Booking required",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var business = req.headers['business'];

        var loggedInDetails = await User.findById(decoded.user).exec();

        var currentDate = new Date();
        var booking = await Booking.findOne({ _id: req.body.booking, business: business, status: { $nin: ["Completed", "CompleteWork", "QC", "Closed", "Ready", "Inactive", "Cancelled"] } }).exec();

        if (booking) {
            var insurance_company = await InsuranceCompany.findOne({ company: req.body.insurance_company }).exec();
            if (insurance_company) {
                var expire = "";
                if (req.body.expire) {
                    expire = new Date(req.body.expire).toISOString();
                }
                var insurance_info = {
                    policy_holder: req.body.policy_holder,
                    insurance_company: req.body.insurance_company,
                    gstin: insurance_company.gstin,
                    policy_no: req.body.policy_no,
                    premium: req.body.premium,
                    expire: expire
                };
            }
            else {
                var insurance_info = {
                    policy_holder: "",
                    insurance_company: "",
                    gstin: "",
                    policy_no: "",
                    premium: 0,
                    expire: null
                };
            }

            Booking.findOneAndUpdate({ _id: booking._id }, { $set: { status: "JobInitiated", sub_status: "JobInitiated", odometer: req.body.odometer, fuel_level: req.body.fuel_level, insurance_info: insurance_info, started_at: new Date(), job_no: new Date().valueOf() } }, { new: false }, async function (err, doc) {
                if (err) {
                    res.status(422).json({
                        responseCode: 422,
                        responseMessage: "Server Error",
                        responseData: err
                    });
                }
                else {
                    Car.findOneAndUpdate({ _id: booking.car }, { $set: { odometer: req.body.odometer, fuel_level: req.body.fuel_level, vin: req.body.vin, engine_no: req.body.engine_no, insurance_info: insurance_info } }, { new: false }, async function (err, doc) {
                        if (err) {
                            return res.status(422).json({
                                responseCode: 422,
                                responseMessage: "Server Error",
                                responseData: err
                            });
                        }
                        else {
                            var activity = {
                                user: loggedInDetails._id,
                                name: loggedInDetails.name,
                                stage: "NewJob",
                                activity: "JobInitiated",
                            };

                            fun.bookingLog(booking._id, activity);

                            var notify = {
                                receiver: [booking.user],
                                activity: "jobcard",
                                tag: "JobInititated",
                                source: booking._id,
                                sender: booking.business,
                                points: 0
                            }

                            fun.newNotification(notify);
                            event.jobSms(notify);
                            event.zohoLead(booking._id);

                            var updated = await Booking.findById(booking._id).exec();

                            res.status(200).json({
                                responseCode: 200,
                                responseMessage: "Car has been added",
                                responseData: updated
                            });
                        }
                    });
                }
            });
        }
        else {
            res.status(422).json({
                responseCode: 422,
                responseMessage: "This job already exists " + booking.status,
                responseData: {}
            })
        }
    }
});

router.put('/job/inspection/add', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var loggedInDetails = await User.findById(decoded.user).exec();

    var file_type = "";

    var upload = multer({
        storage: multerS3({
            s3: s3,
            bucket: config.BUCKET_NAME + '/inspection',
            acl: 'public-read',
            contentType: multerS3.AUTO_CONTENT_TYPE,
            // contentDisposition: 'attachment',
            key: function (req, file, cb) {
                let extArray = file.mimetype.split("/");
                let extension = extArray[extArray.length - 1];

                var filename = uuidv1() + '.' + extension;
                if (extension == 'png' || extension == 'jpg' || extension == 'jpeg' || extension == 'gif') {
                    cb(null, filename);
                }
                else {
                    var params = {
                        Bucket: config.BUCKET_NAME + "/inspection",
                        Key: filename
                    };
                    s3.deleteObject(params, async function (err, data) {
                        var json = ({
                            responseCode: 422,
                            responseMessage: "Invalid extension",
                            responseData: {}
                        });
                        return res.status(422).json(json)
                    });
                }
            }
        })
    }).array('media', 1);

    upload(req, res, async function (error) {
        if (error) {
            var json = ({
                responseCode: 400,
                responseMessage: "Error occured",
                responseData: {}
            });
            return res.status(400).json(json)
        }

        if (req.files.length == 0) {
            var json = ({
                responseCode: 400,
                responseMessage: "Media is required",
                responseData: {}
            });
            return res.status(400).json(json)
        } else {

            var rules = {
                booking: 'required'
            };

            var validation = new Validator(req.body, rules);

            if (validation.fails()) {
                return res.status(422).json({
                    responseCode: 422,
                    responseMessage: "Error",
                    responseData: {
                        res: validation.errors.all()
                    }
                })
            }
            else {
                JobInspection.create({
                    booking: req.body.booking,
                    index: req.body.index,
                    file: req.files[0].key,
                    type: file_type,
                    stage: "Job",
                    created_at: new Date(),
                    updated_at: new Date(),
                }).then(async function (jobInspection) {

                    var count = await JobInspection.find({ booking: req.body.booking }).count().exec();

                    if (count >= 13) {
                        Booking.findOneAndUpdate({ _id: req.body.booking }, { $set: { sub_status: "Inspection" }, updated_at: new Date() }, { new: true }, async function (err, doc) {

                            var activity = {
                                user: loggedInDetails._id,
                                name: loggedInDetails.name,
                                stage: "NewJob",
                                activity: "Inspection",
                            };
                            fun.bookingLog(req.body.booking, activity);
                        });
                        res.status(200).json({
                            responseCode: 200,
                            responseMessage: "File has been uploaded",
                            responseData: jobInspection

                        })
                    }
                    else {
                        res.status(200).json({
                            responseCode: 200,
                            responseMessage: "File has been uploaded",
                            responseData: jobInspection

                        })
                    }
                });
            }
        }
    });
});

router.put('/quality/inspection/add', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var loggedInDetails = await User.findById(decoded.user).exec();

    var file_type = "";

    var upload = multer({
        storage: multerS3({
            s3: s3,
            bucket: config.BUCKET_NAME + '/inspection',
            acl: 'public-read',
            contentType: multerS3.AUTO_CONTENT_TYPE,
            // contentDisposition: 'attachment',
            key: function (req, file, cb) {
                let extArray = file.mimetype.split("/");
                let extension = extArray[extArray.length - 1];

                var filename = uuidv1() + '.' + extension;
                if (extension == 'png' || extension == 'jpg' || extension == 'jpeg' || extension == 'gif') {
                    cb(null, filename);
                }
                else {
                    var params = {
                        Bucket: config.BUCKET_NAME + "/inspection",
                        Key: filename
                    };
                    s3.deleteObject(params, async function (err, data) {
                        var json = ({
                            responseCode: 422,
                            responseMessage: "Invalid extension",
                            responseData: {}
                        });
                        res.status(422).json(json)
                    });
                }
            }
        })
    }).array('media', 1);

    upload(req, res, async function (error) {
        if (error) {
            var json = ({
                responseCode: 400,
                responseMessage: "Error occured",
                responseData: {}
            });
            res.status(400).json(json)
        }

        if (req.files.length == 0) {
            var json = ({
                responseCode: 400,
                responseMessage: "Media is required",
                responseData: {}
            });
            res.status(400).json(json)
        } else {

            var rules = {
                booking: 'required'
            };

            var validation = new Validator(req.body, rules);

            if (validation.fails()) {
                res.status(422).json({
                    responseCode: 422,
                    responseMessage: "Error",
                    responseData: {
                        res: validation.errors.all()
                    }
                })
            }
            else {
                var data = {
                    booking: req.body.booking,
                    index: req.body.index,
                    file: req.files[0].key,
                    type: file_type,
                    stage: "QC",
                    created_at: new Date(),
                    updated_at: new Date(),
                };

                var jobInspection = new JobInspection(data);
                jobInspection.save();

                res.status(200).json({
                    responseCode: 200,
                    responseMessage: "File has been uploaded",
                    responseData: jobInspection

                })
            }
        }
    });
});

router.put('/job/snaps/add', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var loggedInDetails = await User.findById(decoded.user).exec();

    var file_type = "";

    var upload = multer({
        storage: multerS3({
            s3: s3,
            bucket: config.BUCKET_NAME + '/inspection',
            acl: 'public-read',
            contentType: multerS3.AUTO_CONTENT_TYPE,
            // contentDisposition: 'attachment',
            key: function (req, file, cb) {
                let extArray = file.mimetype.split("/");
                let extension = extArray[extArray.length - 1];

                var filename = uuidv1() + '.' + extension;
                if (extension == 'png' || extension == 'jpg' || extension == 'jpeg' || extension == 'gif') {
                    cb(null, filename);
                }
                else {
                    var params = {
                        Bucket: config.BUCKET_NAME + "/inspection",
                        Key: filename
                    };
                    s3.deleteObject(params, async function (err, data) {
                        var json = ({
                            responseCode: 422,
                            responseMessage: "Invalid extension",
                            responseData: {}
                        });
                        res.status(422).json(json)
                    });
                }
            }
        })
    }).array('media', 1);

    upload(req, res, async function (error) {
        if (error) {
            var json = ({
                responseCode: 400,
                responseMessage: "Error occured",
                responseData: {}
            });
            res.status(400).json(json)
        }

        if (req.files.length == 0) {
            var json = ({
                responseCode: 400,
                responseMessage: "Media is required",
                responseData: {}
            });
            res.status(400).json(json)
        } else {

            var rules = {
                booking: 'required'
            };

            var validation = new Validator(req.body, rules);

            if (validation.fails()) {
                res.status(422).json({
                    responseCode: 422,
                    responseMessage: "Error",
                    responseData: {
                        res: validation.errors.all()
                    }
                })
            }
            else {
                var data = {
                    booking: req.body.booking,
                    index: req.body.index,
                    file: req.files[0].key,
                    type: file_type,
                    stage: "Additional",
                    created_at: new Date(),
                    updated_at: new Date(),
                };

                var jobInspection = new JobInspection(data);
                jobInspection.save();

                res.status(200).json({
                    responseCode: 200,
                    responseMessage: "File has been uploaded",
                    responseData: jobInspection
                })
            }
        }
    });
});

router.delete('/job/snaps/delete', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var loggedInDetails = await User.findById(decoded.user).exec();

    var image_id = req.body.id;
    const media = await JobInspection.findById(image_id).exec();

    if (media) {
        var params = {
            Bucket: config.BUCKET_NAME + "/inspection",
            Key: media.file
        };

        s3.deleteObject(params, async function (err, data) {
            if (err) {
                res.status(400).json({
                    responseCode: 400,
                    responseMessage: "Error occured",
                    responseData: {}
                });
            }
            else {
                await JobInspection.findByIdAndRemove(image_id).exec();
                res.status(200).json({
                    responseCode: 200,
                    responseMessage: "File has been deleted",
                    responseData: {},
                })
            }
        });
    } else {
        res.status(400).json({
            responseCode: 400,
            responseMessage: "Wrong image",
            responseData: {},
        })
    }
});

router.get('/job/inspection/get', async function (req, res, next) {
    var rules = {
        booking: 'required',
    };

    var validation = new Validator(req.query, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Error",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var booking = await Booking.findById(req.query.booking).exec();
        if (booking) {
            var file = await JobInspection.find({ booking: booking._id }).select('file type stage').exec();
            res.status(200).json({
                responseCode: 200,
                responseMessage: "",
                responseData: file
            });
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Booking not found",
                responseData: {}
            });
        }
    }
});

router.get('/assets/get', xAccessToken.token, async function (req, res, next) {
    var rules = {
        booking: 'required',
    };

    var validation = new Validator(req.query, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Booking required",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var business = req.headers['business'];

        var booking = await Booking.findById(req.query.booking).exec();
        if (booking) {
            var a = booking.assets;
            if (a.length > 0) {
                res.status(200).json({
                    responseCode: 200,
                    responseMessage: "Asset",
                    responseData: booking.assets,
                })
            }
            else {
                var assets = [];
                await Asset.find({})
                    .cursor().eachAsync(async (v) => {
                        assets.push({
                            value: v.value,
                            checked: false
                        })
                    })

                res.status(200).json({
                    responseCode: 200,
                    responseMessage: "Asset",
                    responseData: assets,
                })
            }
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Booking not found",
                responseData: {}
            })
        }
    }
});

router.put('/assets/update', xAccessToken.token, async function (req, res, next) {
    var rules = {
        booking: 'required',
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Booking required",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var loggedInDetails = await User.findById(decoded.user).exec();
        var business = await User.findById(req.headers['business']).exec();

        var booking = await Booking.findById(req.body.booking).exec();
        if (booking) {
            var address = await Address.findOne({ _id: req.body.address, user: booking.user }).exec();
            if (address) {
                var status = booking.status;
                var sub_status = "Assets";

                if (req.body.web == true) {
                    var status = "JobOpen";
                    var sub_status = "JobOpen";
                }

                Booking.findOneAndUpdate({ _id: booking._id }, { $set: { status: status, sub_status: sub_status, assets: req.body.assets, other_assets: req.body.other, convenience: req.body.convenience, address: req.body.address, updated_at: new Date() } }, { new: false }, async function (err, doc) {
                    if (err) {
                        res.status(422).json({
                            responseCode: 422,
                            responseMessage: "Server",
                            responseData: err,
                        });
                    }
                    else {
                        if (req.body.web) {
                            var activity = {
                                user: loggedInDetails._id,
                                name: loggedInDetails.name,
                                stage: "JobOpen",
                                activity: "JobOpen",
                            };
                            fun.bookingLog(req.body.booking, activity);
                        }

                        var update = await Booking.findById(booking._id).exec();

                        res.status(200).json({
                            responseCode: 200,
                            responseMessage: "Asset",
                            responseData: update.assets
                        });
                    }
                });
            }
            else {
                res.status(400).json({
                    responseCode: 400,
                    responseMessage: "Address not found",
                    responseData: {},
                });
            }
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Booking not found",
                responseData: {},
            });
        }
    }
});

router.put('/job/surveyor/update', xAccessToken.token, async function (req, res, next) {
    var rules = {
        booking: 'required',
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Booking required",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var business = req.headers['business'];
        var loggedInDetails = await User.findById(decoded.user).exec();
        var booking = await Booking.findById(req.body.booking).exec();
        if (booking) {
            if (req.body.surveyor) {
                var surveyor = await User.findById(req.body.surveyor).exec();
                if (surveyor) {
                    User.findOneAndUpdate({ _id: surveyor._id }, { $set: { email: req.body.surveyor_email } }, { new: false }, function (err, doc) { });

                    Booking.findOneAndUpdate({ _id: booking._id }, { $set: { surveyor: surveyor._id, updated_at: new Date() } }, { new: false }, function (err, doc) {

                        var activity = {
                            user: loggedInDetails._id,
                            name: loggedInDetails.name,
                            stage: "Estimation",
                            activity: "SurveyorAssigned",
                        };

                        fun.bookingLog(req.body.booking, activity);

                        var notify = {
                            receiver: [booking.user],
                            activity: "jobcard",
                            tag: "SurveyorAssigned",
                            source: booking._id,
                            sender: loggedInDetails._id,
                            points: 0
                        };

                        fun.newNotification(notify);
                        event.jobSms(notify);

                        res.status(200).json({
                            responseCode: 200,
                            responseMessage: "Surveyor details has been updated...",
                            responseData: {},
                        })

                    });
                }
                else {
                    res.status(400).json({
                        responseCode: 400,
                        responseMessage: "Surveyor not found",
                        responseData: {},
                    })
                }
            }
            else {
                var user = await User.findOne({ contact_no: req.body.surveyor_contact_no, 'account_info.type': "user" }).count().exec();
                if (user == 0) {
                    var data = {};
                    var country = await Country.findOne({ timezone: req.headers['tz'] }).exec();
                    data.address = {
                        country: country.countryName,
                        timezone: req.headers['tz'],
                        location: data.location,
                    };

                    data.account_info = {
                        type: "user",
                        added_by: null,
                        status: "Complete",
                    };


                    /*var expired_at = new Date();
                    expired_at.setDate(expired_at.getDate() + 365);*/

                    data.agent = {
                        agent: false,
                        commission: 0,
                        started_at: new Date(),
                        expired_at: null,
                    };


                    var name = req.body.surveyor_name;
                    name = name.substring(0, 3);
                    var rand = Math.floor((Math.random() * 100000) + 1);

                    data.username = name + "" + shortid.generate();
                    data.contact_no = req.body.surveyor_contact_no;
                    data.email = req.body.surveyor_email;
                    data.name = req.body.surveyor_name;

                    var firstPart = (Math.random() * 46656) | 0;
                    var secondPart = (Math.random() * 46656) | 0;
                    firstPart = ("000" + firstPart.toString(36)).slice(-3);
                    secondPart = ("000" + secondPart.toString(36)).slice(-3);
                    data.referral_code = firstPart.toUpperCase() + secondPart.toUpperCase();

                    data.geometry = [0, 0];
                    data.device = [];
                    data.otp = Math.floor(Math.random() * 90000) + 10000;

                    data.careager_cash = 0;
                    data.socialite = "";
                    data.optional_info = "";
                    data.business_info = "";
                    req.body.uuid = uuidv1();

                    User.create(data).then(async function (user) {
                        event.signupSMS(user);
                        //event.otpSms(user);
                        Booking.findOneAndUpdate({ _id: booking._id }, { $set: { surveyor: user._id, updated_at: new Date() } }, { new: false }, function (err, doc) {

                            var activity = {
                                user: loggedInDetails._id,
                                name: loggedInDetails.name,
                                stage: "Estimation",
                                activity: "SurveyorAssigned",
                            };
                            fun.bookingLog(req.body.booking, activity);

                            var notify = {
                                receiver: [booking.user],
                                activity: "jobcard",
                                tag: "SurveyorAssigned",
                                source: booking._id,
                                sender: loggedInDetails._id,
                                points: 0
                            };

                            fun.newNotification(notify);

                            res.status(200).json({
                                responseCode: 200,
                                responseMessage: "Surveyor details has been update",
                                responseData: {},
                            })
                        });
                    });
                }
                else {
                    res.status(400).json({
                        responseCode: 400,
                        responseMessage: "Surveyor already exist",
                        responseData: {},
                    })
                }
            }
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Booking not found",
                responseData: {},
            })
        }
    }
});

router.put('/surveyor-info/update', xAccessToken.token, async function (req, res, next) {
    var rules = {
        user: 'required',
        name: 'required',
        contact_no: 'required',
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "All field required",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var user = await User.findById(req.body.user).exec();
        if (user) {
            var check = await User.findOne({ contact_no: req.body.contact_no, _id: { $ne: user._id }, "account_info.type": user.account_info.type, }).exec();

            if (check) {
                res.status(400).json({
                    responseCode: 400,
                    responseMessage: "Contact no already exist",
                    responseData: {}
                });
            }
            else {
                User.findOneAndUpdate({ _id: user._id }, {
                    $set: {
                        name: req.body.name,
                        contact_no: req.body.contact_no,
                        email: req.body.email,
                        "business_info.company_name": req.body.company_name,
                        "business_info.gstin": req.body.gstin,
                        updated_at: new Date()
                    }
                }, { new: false }, function (err, doc) {
                    if (err) {
                        res.status(422).json({
                            responseCode: 422,
                            responseMessage: "Error Occurred",
                            responseData: err,
                        })
                    }
                    else {
                        res.status(200).json({
                            responseCode: 200,
                            responseMessage: "User details updated...",
                            responseData: {},
                        })
                    }
                });
            }
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "User not found",
                responseData: {},
            })
        }
    }
});

router.get('/technicians/get', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var business = req.headers['business'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    var loggedInDetails = await User.findById(decoded.user).exec();

    var technicians = [];
    await Management.find({ business: business, role: { $in: ["Denter", "Painter", "Electrician", "Technician", "Washing Technician", "DryCleaner"] } })
        .populate({ path: "user" })
        .cursor().eachAsync(async (v) => {
            technicians.push({
                _id: v.user._id,
                id: v.user.id,
                name: v.user.name + " (" + v.role + ")",
                username: v.user.username,
                email: v.user.email,
                contact_no: v.user.contact_no,
            });
        });

    res.status(200).json({
        responseCode: 200,
        responseMessage: "Technicians",
        responseData: technicians
    })
});

router.get('/service-advisors/get', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var business = req.headers['business'];


    var technicians = [];
    await Management.find({ business: business, role: "Service Advisor" })
        .populate({ path: "user" })
        .cursor().eachAsync(async (v) => {
            technicians.push({
                _id: v.user._id,
                id: v.user.id,
                name: v.user.name,
                username: v.user.username,
                email: v.user.email,
                contact_no: v.user.contact_no,
            })
        })

    res.status(200).json({
        responseCode: 200,
        responseMessage: "Service Advisors",
        responseData: technicians
    })
});

router.get('/cre/get', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var business = req.headers['business'];


    var technicians = [];
    await Management.find({ business: business, role: "CRE" })
        .populate({ path: "user" })
        .cursor().eachAsync(async (v) => {
            technicians.push({
                _id: v.user._id,
                id: v.user.id,
                name: v.user.name,
                username: v.user.username,
                email: v.user.email,
                contact_no: v.user.contact_no,
            })
        })

    res.status(200).json({
        responseCode: 200,
        responseMessage: "Service Advisors",
        responseData: technicians
    })
});

router.put('/job/delivery-date/update', xAccessToken.token, async function (req, res, next) {
    var rules = {
        booking: 'required',
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Booking required",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var loggedInDetails = await User.findById(decoded.user).exec();
        var business = await User.findById(req.headers['business']).exec();
        var driver = null;

        var booking = await Booking.findById(req.body.booking).exec();
        if (booking) {


            var data = {
                delivery_date: new Date(req.body.delivery_date).toISOString(),
                delivery_time: req.body.delivery_time,
            }

            Booking.findOneAndUpdate({ _id: booking._id }, { $set: data }, { new: true }, function (err, doc) { });

            var activity = {
                user: loggedInDetails._id,
                name: loggedInDetails.name,
                stage: "Updates",
                activity: "Delivery date updated " + moment(new Date(req.body.delivery_date).toISOString()).tz(req.headers['tz']).format('lll'),
            };

            fun.bookingLog(booking._id, activity);

            var updated = await Booking.findById(booking._id).exec();

            res.status(200).json({
                responseCode: 200,
                responseMessage: "Asset",
                responseData: updated,
            })
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Booking not found",
                responseData: {},
            })
        }
    }
});

router.put('/job/requirements/update', xAccessToken.token, async function (req, res, next) {
    var rules = {
        booking: 'required',
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Booking required",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var loggedInDetails = await User.findById(decoded.user).exec();
        var business = req.headers['business'];
        var driver = null;

        var booking = await Booking.findById(req.body.booking).exec();
        if (booking) {

            if (req.body.is_driver) {
                if (req.body.driver) {
                    var checkDriver = await User.findById(req.body.driver).exec();
                    driver = checkDriver._id;
                    Booking.findOneAndUpdate({ _id: booking._id }, { $set: { driver: driver } }, { new: true }, function (err, doc) { });
                }
                else {
                    var data = {};
                    var country = await Country.findOne({ timezone: req.headers['tz'] }).exec();
                    data.address = {
                        country: country.countryName,
                        timezone: req.headers['tz'],
                        location: data.location,
                    };

                    data.account_info = {
                        type: "user",
                        added_by: null,
                        status: "Complete",
                    };

                    var expired_at = new Date();
                    expired_at.setDate(expired_at.getDate() + 365);

                    data.agent = {
                        agent: true,
                        commission: 10,
                        started_at: new Date(),
                        expired_at: expired_at,
                    };

                    var name = req.body.name;
                    name = name.substring(0, 3);
                    var rand = Math.floor((Math.random() * 100000) + 1);

                    data.username = name + "" + shortid.generate();
                    data.contact_no = req.body.contact_no;
                    data.email = "";
                    data.name = req.body.name;

                    var firstPart = (Math.random() * 46656) | 0;
                    var secondPart = (Math.random() * 46656) | 0;
                    firstPart = ("000" + firstPart.toString(36)).slice(-3);
                    secondPart = ("000" + secondPart.toString(36)).slice(-3);
                    data.referral_code = firstPart.toUpperCase() + secondPart.toUpperCase();

                    data.geometry = [0, 0];
                    data.device = [];
                    data.otp = Math.floor(Math.random() * 90000) + 10000;

                    data.careager_cash = 0;
                    data.socialite = "";
                    data.optional_info = "";
                    data.business_info = "";
                    req.body.uuid = uuidv1();




                    User.create(data).then(async function (user) {
                        event.signupSMS(user);
                        //event.otpSms(user);
                        driver = user._id;
                        Booking.findOneAndUpdate({ _id: booking._id }, { $set: { driver: driver } }, { new: true }, function (err, doc) { });

                    });

                }
            }

            var technician = null;
            if (req.body.technician) {
                var checkTechnician = await Management.findOne({ business: business, user: req.body.technician }).exec();
                if (checkTechnician) {
                    technician = checkTechnician.user;
                }
            }

            Car.findOneAndUpdate({ _id: booking.car }, { $set: { manufacture_year: req.body.manufacture_year } }, { $new: false }, function (err, doc) { });

            var claim = false;
            if (req.body.claim == "yes") {
                claim = true
            }

            var cashless = false;
            if (req.body.cashless == "yes") {
                cashless = true
            }

            if (!req.body.accident_date) {
                req.body.accident_date = null
            }

            var insurance_info = {
                policy_holder: booking.insurance_info.policy_holder,
                insurance_company: booking.insurance_info.insurance_company,
                branch: booking.insurance_info.branch,
                gstin: booking.insurance_info.gstin,
                policy_no: booking.insurance_info.policy_no,
                premium: booking.insurance_info.premium,
                expire: booking.insurance_info.expire,
                claim: claim,
                cashless: cashless,
                policy_type: booking.insurance_info.policy_type,
                claim_no: booking.insurance_info.claim_no,
                driver_accident: req.body.driver_accident,
                accident_place: req.body.accident_place,
                accident_date: new Date(req.body.accident_date).toISOString(),
                accident_time: req.body.accident_time,
                accident_cause: req.body.accident_cause,
                spot_survey: req.body.spot_survey,
                fir: req.body.fir,
                manufacture_year: req.body.manufacture_year
            };

            var customer_requirements = req.body.demands;
            if (customer_requirements.length <= 0) {
                customer_requirements = booking.customer_requirements;
            }

            var data = {
                customer_requirements: customer_requirements,
                technician: technician,
                delivery_date: new Date(req.body.delivery_date).toISOString(),
                delivery_time: req.body.delivery_time,
                status: "JobOpen",
                sub_status: "JobOpen",
                insurance_info: insurance_info,
                updated_at: new Date()
            }

            Booking.findOneAndUpdate({ _id: booking._id }, { $set: data }, { new: true }, function (err, doc) { });
            if (claim == true) {
                Booking.findOneAndUpdate({ _id: booking._id }, { $set: { "payment.policy_clause": 1000 } }, { new: true }, function (err, doc) { });
            }

            var activity = {
                user: loggedInDetails._id,
                name: loggedInDetails.name,
                stage: "NewJob",
                activity: "JobOpen",
            };

            fun.bookingLog(booking._id, activity);

            var updated = await Booking.findById(booking._id).exec();

            res.status(200).json({
                responseCode: 200,
                responseMessage: "Asset",
                responseData: updated,
            })
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Booking not found",
                responseData: {},
            })
        }
    }
});

router.put('/job/insurance-info/update', xAccessToken.token, async function (req, res, next) {
    var rules = {
        booking: 'required',
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Booking required",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var loggedInDetails = await User.findById(decoded.user).exec();
        var business = req.headers['business'];

        var booking = await Booking.findById(req.body.booking).exec();
        if (booking) {
            var insurance_company = await InsuranceCompany.findOne({ company: req.body.insurance_company }).exec();
            var expire = null;
            if (req.body.expire) {
                expire = new Date(req.body.expire).toISOString()
            }

            var insurance_info = {
                policy_holder: req.body.policy_holder,
                insurance_company: req.body.insurance_company,
                branch: req.body.branch,
                state: req.body.state,
                contact_no: req.body.contact_no,
                gstin: req.body.gstin,
                policy_no: req.body.policy_no,
                premium: req.body.premium,
                expire: expire,
                claim: booking.insurance_info.claim,
                cashless: booking.insurance_info.cashless,
                policy_type: booking.insurance_info.policy_type,
                claim_no: booking.insurance_info.claim_no,
                driver_accident: booking.insurance_info.driver_accident,
                accident_place: booking.insurance_info.accident_place,
                accident_date: booking.insurance_info.accident_date,
                accident_time: booking.insurance_info.accident_time,
                accident_cause: booking.insurance_info.accident_cause,
                spot_survey: booking.insurance_info.spot_survey,
                fir: booking.insurance_info.fir,
                manufacture_year: booking.insurance_info.manufacture_year
            };

            Car.findOneAndUpdate({ _id: booking.car }, { $set: { insurance_info: insurance_info } }, { new: false }, function (err, doc) { });

            Booking.findOneAndUpdate({ _id: booking._id }, { $set: { insurance_info: insurance_info, updated_at: new Date() } }, { new: false }, function (err, doc) { });

            var activity = {
                user: loggedInDetails._id,
                name: loggedInDetails.name,
                stage: "Job",
                activity: "InsuranceDetailsUpdate",
            };

            fun.bookingLog(booking._id, activity);

            var updated = await Booking.findById(booking._id).exec();

            res.status(200).json({
                responseCode: 200,
                responseMessage: "Insurance details updated...",
                responseData: updated,
            })
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Booking not found",
                responseData: {},
            })
        }
    }
});

router.put('/job/insurance/update', xAccessToken.token, async function (req, res, next) {
    var rules = {
        booking: 'required',
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Booking required",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var loggedInDetails = await User.findById(decoded.user).exec();
        var business = req.headers['business'];

        var booking = await Booking.findById(req.body.booking).exec();
        if (booking) {
            var insurance_company = await InsuranceCompany.findOne({ company: req.body.insurance_company }).exec();
            var expire = "";
            var accident_date = "";
            if (req.body.expire) {
                expire = new Date(req.body.expire).toISOString()
            }
            if (req.body.accident_date) {
                accident_date = new Date(req.body.accident_date).toISOString()
            }
            var insurance_info = {
                policy_holder: req.body.policy_holder,
                insurance_company: req.body.insurance_company,
                branch: req.body.branch,
                state: req.body.state,
                contact_no: req.body.contact_no,
                gstin: req.body.gstin,
                policy_no: req.body.policy_no,
                premium: req.body.premium,
                expire: expire,
                claim: req.body.claim,
                cashless: req.body.cashless,
                policy_type: req.body.policy_type,
                claim_no: req.body.claim_no,
                driver_accident: req.body.driver_accident,
                accident_place: req.body.accident_place,
                accident_date: accident_date,
                accident_time: req.body.accident_time,
                accident_cause: req.body.accident_cause,
                spot_survey: req.body.spot_survey,
                fir: req.body.fir,
                manufacture_year: req.body.manufacture_year
            };

            Car.findOneAndUpdate({ _id: booking.car }, { $set: { insurance_info: insurance_info } }, { new: false }, function (err, doc) { });

            Booking.findOneAndUpdate({ _id: booking._id }, { $set: { insurance_info: insurance_info, updated_at: new Date() } }, { new: false }, function (err, doc) { });

            var updated = await Booking.findById(booking._id).exec();

            res.status(200).json({
                responseCode: 200,
                responseMessage: "Insurance details updated...",
                responseData: updated,
            })
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Booking not found",
                responseData: {},
            })
        }
    }
});

router.put('/customer-info/update', xAccessToken.token, async function (req, res, next) {
    var rules = {
        user: 'required',
        name: 'required',
        contact_no: 'required',
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "All field required",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var user = await User.findById(req.body.user).exec();
        if (user) {
            var check = await User.findOne({ contact_no: req.body.contact_no, _id: { $ne: user._id }, "account_info.type": user.account_info.type, }).exec();

            if (check) {
                res.status(400).json({
                    responseCode: 400,
                    responseMessage: "Contact no already exist",
                    responseData: {}
                });
            }
            else {
                User.findOneAndUpdate({ _id: user._id }, {
                    $set: {
                        name: req.body.name,
                        contact_no: req.body.contact_no,
                        email: req.body.email,
                        "business_info.company_name": req.body.company_name,
                        "business_info.gstin": req.body.gstin,
                        updated_at: new Date()
                    }
                }, { new: false }, function (err, doc) {
                    if (err) {
                        res.status(422).json({
                            responseCode: 422,
                            responseMessage: "Error Occurred",
                            responseData: err,
                        })
                    }
                    else {
                        res.status(200).json({
                            responseCode: 200,
                            responseMessage: "User details updated...",
                            responseData: {},
                        })
                    }
                });
            }
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "User not found",
                responseData: {},
            })
        }
    }
});

router.put('/booking/address/update', xAccessToken.token, async function (req, res, next) {
    var rules = {
        booking: 'required',
        address: 'required',
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Address is required",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var loggedInDetails = await User.findById(decoded.user).exec();
        var business = await User.findById(req.headers['business']).exec();

        var booking = await Booking.findById(req.body.booking).exec();
        if (booking) {
            var address = await Address.findOne({ _id: req.body.address, user: booking.user }).exec();
            if (address) {
                if (address.state == business.address.state) {
                    var tax_type = "GST";
                }
                else {
                    var tax_type = "IGST";
                }

                Booking.findOneAndUpdate({ _id: booking._id }, { $set: { tax_type: tax_type, address: req.body.address, updated_at: new Date() } }, { new: false }, async function (err, doc) {
                    if (err) {
                        res.status(422).json({
                            responseCode: 422,
                            responseMessage: "Error",
                            responseData: {}
                        })
                    }
                    else {
                        var update = await Booking.findById(booking._id).exec();
                        res.status(200).json({
                            responseCode: 200,
                            responseMessage: "Updated Successfully",
                            responseData: update
                        })
                    }
                });
            }
            else {
                res.status(400).json({
                    responseCode: 400,
                    responseMessage: "Address not found",
                    responseData: {},
                });
            }
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Booking not found",
                responseData: {},
            })
        }
    }
});

router.put('/booking/tax-preference/update', xAccessToken.token, async function (req, res, next) {
    var rules = {
        booking: 'required',
        with_tax: 'required',
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Validation Error",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var loggedInDetails = await User.findById(decoded.user).exec();
        var business = await User.findById(req.headers['business']).exec();

        var booking = await Booking.findById(req.body.booking).exec();
        if (booking) {

            Booking.findOneAndUpdate({ _id: booking._id }, { $set: { with_tax: req.body.with_tax, updated_at: new Date() } }, { new: false }, async function (err, doc) {
                if (err) {
                    res.status(422).json({
                        responseCode: 422,
                        responseMessage: "Error",
                        responseData: {}
                    })
                }
                else {
                    var update = await Booking.findById(booking._id).exec();
                    res.status(200).json({
                        responseCode: 200,
                        responseMessage: "Updated Successfully",
                        responseData: update
                    })
                }
            });

        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Booking not found",
                responseData: {},
            })
        }
    }
});

router.put('/booking/car/update', xAccessToken.token, async function (req, res, next) {
    var rules = {
        car: "required",
        user: "required",
        booking: "required",
        variant: "required",
        registration_no: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Car is required",
            responseData: {}
        })
    }
    else {
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);

        var checkuser = await User.findOne({ _id: req.body.user }).populate('user').exec();
        if (checkuser) {
            var user = checkuser._id;
            var booking = await Booking.findOne({ _id: req.body.booking }).exec();
            var car = await Car.findOne({ _id: req.body.car }).populate('user').exec();
            var variant = await Variant.findOne({ _id: req.body.variant }).populate('model').select('-service_schedule').exec();
            if (car) {
                var rg = req.body.registration_no;
                req.body.registration_no = rg.replace(/ /g, '');

                var check_rn = await Car.findOne({ registration_no: req.body.registration_no, _id: { $ne: car._id }, status: true }).exec();

                if (check_rn) {
                    res.status(400).json({
                        responseCode: 400,
                        responseMessage: "Car registration no already exist",
                        responseData: {}
                    });
                }
                else {
                    if (variant) {
                        var automaker = await Automaker.findById(variant.model.automaker).exec();
                        if (variant.specification.type) {
                            req.body.transmission = variant.specification.type
                        }

                        req.body.automaker = variant.model.automaker;
                        req.body._automaker = automaker.maker;
                        req.body._variant = variant.value;
                        req.body.model = variant.model.id;
                        req.body._model = variant.model.value;
                        req.body.title = variant.variant;
                        req.body.fuel_type = variant.specification.fuel_type;
                        req.body.updated_at = new Date();

                        Car.findOneAndUpdate({ _id: req.body.car, user: user }, { $set: req.body }, { new: false }, async function (err, s) {
                            if (err) {
                                res.status(400).json({
                                    responseCode: 400,
                                    responseMessage: "Error occured",
                                    responseData: err
                                });
                            }
                            else {
                                Booking.findOneAndUpdate({ _id: booking._id }, { $set: { odometer: req.body.odometer, fuel_level: req.body.fuel_level, updated_at: new Date() } }, { new: false }, async function (err, doc) {
                                    if (err) {
                                        res.status(400).json({
                                            responseCode: 400,
                                            responseMessage: "Error occured",
                                            responseData: err
                                        });
                                    }
                                    else {
                                        res.status(200).json({
                                            responseCode: 200,
                                            responseMessage: "Saved",
                                            responseData: {}
                                        })
                                    }
                                });

                            }
                        });
                    }
                    else {
                        res.status(400).json({
                            responseCode: 400,
                            responseMessage: "Unprocessable Entity",
                            responseData: {}
                        });
                    }
                }
            }
            else {
                res.status(400).json({
                    responseCode: 400,
                    responseMessage: "Unauthorized",
                    responseData: {}
                });
            }
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "User not found",
                responseData: {}
            });
        }

    }
});

router.put('/job/claim-info/update', xAccessToken.token, async function (req, res, next) {
    var rules = {
        booking: 'required',
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Booking required",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var loggedInDetails = await User.findById(decoded.user).exec();
        var business = req.headers['business'];


        var booking = await Booking.findById(req.body.booking).exec();
        if (booking) {

            Car.findOneAndUpdate({ _id: booking.car }, { $set: { manufacture_year: req.body.manufacture_year } }, { $new: false }, function (err, doc) { });

            var claim = false;
            if (req.body.claim == "yes") {
                claim = true
            }

            var cashless = false;
            if (req.body.cashless == "yes") {
                cashless = true
            }

            if (!req.body.accident_date) {
                req.body.accident_date = null
            }

            var insurance_info = {
                policy_holder: booking.insurance_info.policy_holder,
                insurance_company: booking.insurance_info.insurance_company,
                branch: booking.insurance_info.branch,
                gstin: booking.insurance_info.gstin,
                policy_no: booking.insurance_info.policy_no,
                premium: booking.insurance_info.premium,
                expire: booking.insurance_info.expire,
                claim: claim,
                cashless: cashless,
                policy_type: booking.insurance_info.policy_type,
                claim_no: booking.insurance_info.claim_no,
                driver_accident: req.body.driver_accident,
                accident_place: req.body.accident_place,
                accident_date: new Date(req.body.accident_date).toISOString(),
                accident_time: req.body.accident_time,
                accident_cause: req.body.accident_cause,
                spot_survey: req.body.spot_survey,
                fir: req.body.fir,
                manufacture_year: req.body.manufacture_year
            };

            var data = {
                insurance_info: insurance_info,
                updated_at: new Date()
            }

            Booking.findOneAndUpdate({ _id: booking._id }, { $set: data }, { new: true }, function (err, doc) { });
            if (claim == true) {
                Booking.findOneAndUpdate({ _id: booking._id }, { $set: { "payment.policy_clause": 1000 } }, { new: true }, function (err, doc) { });
            }

            var activity = {
                user: loggedInDetails._id,
                name: loggedInDetails.name,
                stage: "Job",
                activity: "ClaimDetailsUpdate",
            };

            fun.bookingLog(booking._id, activity);

            var updated = await Booking.findById(booking._id).exec();

            res.status(200).json({
                responseCode: 200,
                responseMessage: "Claim details updated...",
                responseData: updated,
            })
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Booking not found",
                responseData: {},
            })
        }
    }
});

router.put('/advisor/update', xAccessToken.token, async function (req, res, next) {
    var rules = {
        booking: 'required',
        advisor: 'required',
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Booking required",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var loggedInDetails = await User.findById(decoded.user).exec();
        var business = req.headers['business'];


        var booking = await Booking.findById(req.body.booking).populate('advisor').exec();
        if (booking) {
            var advisor = await User.findOne({ _id: req.body.advisor }).exec();
            if (advisor) {
                var management = await Management.findOne({ user: advisor._id, business: business }).exec();
                if (management) {
                    Booking.findOneAndUpdate({ _id: booking._id }, { $set: { advisor: advisor._id } }, { new: true }, async function (err, doc) {
                        if (err) {
                            res.status(422).json({
                                responseCode: 422,
                                responseMessage: "Server Error",
                                responseData: err,
                            });
                        }
                        else {
                            var activity = {
                                user: loggedInDetails._id,
                                name: loggedInDetails.name,
                                stage: "Updates",
                                activity: booking.advisor.name + " to " + advisor.name,
                            };

                            fun.bookingLog(booking._id, activity);

                            var updated = await Booking.findById(booking._id).exec();

                            res.status(200).json({
                                responseCode: 200,
                                responseMessage: "Details updated...",
                                responseData: updated,
                            });
                        }
                    });
                }
                else {
                    res.status(400).json({
                        responseCode: 400,
                        responseMessage: "Advisor not found",
                        responseData: {},
                    })
                }
            }
            else {
                res.status(400).json({
                    responseCode: 400,
                    responseMessage: "Advisor not found",
                    responseData: {},
                })
            }
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Booking not found",
                responseData: {},
            })
        }
    }
});

router.put('/technician/update', xAccessToken.token, async function (req, res, next) {
    var rules = {
        booking: 'required',
        technician: 'required',
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Booking required",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var loggedInDetails = await User.findById(decoded.user).exec();
        var business = req.headers['business'];


        var booking = await Booking.findById(req.body.booking).populate('technician').exec();
        if (booking) {
            var technician = await User.findOne({ _id: req.body.technician }).exec();
            if (technician) {
                var management = await Management.findOne({ user: technician._id, business: business }).exec();
                if (management) {
                    Booking.findOneAndUpdate({ _id: booking._id }, { $set: { technician: technician._id } }, { new: true }, async function (err, doc) {
                        if (err) {
                            res.status(422).json({
                                responseCode: 422,
                                responseMessage: "Server Error",
                                responseData: err,
                            });
                        }
                        else {
                            if (booking.technician) {
                                var s = booking.technician.name + " to " + technician.name;
                            }
                            else {
                                var s = technician.name;
                            }

                            var activity = {
                                user: loggedInDetails._id,
                                name: loggedInDetails.name,
                                stage: "Updates",
                                activity: s
                            };

                            fun.bookingLog(booking._id, activity);

                            var updated = await Booking.findById(booking._id).exec();

                            res.status(200).json({
                                responseCode: 200,
                                responseMessage: "Details updated...",
                                responseData: updated,
                            });
                        }
                    });
                }
                else {
                    res.status(400).json({
                        responseCode: 400,
                        responseMessage: "Technician not found",
                        responseData: {},
                    })
                }
            }
            else {
                res.status(400).json({
                    responseCode: 400,
                    responseMessage: "Technician not found",
                    responseData: {},
                })
            }
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Booking not found",
                responseData: {},
            })
        }
    }
});

router.put('/job/assets/update', xAccessToken.token, async function (req, res, next) {
    var rules = {
        booking: 'required',
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Booking required",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var loggedInDetails = await User.findById(decoded.user).exec();
        var business = req.headers['business'];


        var booking = await Booking.findById(req.body.booking).exec();
        if (booking) {
            var data = {
                other_assets: req.body.other,
                assets: req.body.assets,
                updated_at: new Date()
            }

            Booking.findOneAndUpdate({ _id: booking._id }, { $set: data }, { new: true }, function (err, doc) { });

            var activity = {
                user: loggedInDetails._id,
                name: loggedInDetails.name,
                stage: "Job",
                activity: "AssetsUpdate",
            };

            fun.bookingLog(booking._id, activity);

            var updated = await Booking.findById(booking._id).exec();

            res.status(200).json({
                responseCode: 200,
                responseMessage: "Assets updated...",
                responseData: updated,
            })
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Booking not found",
                responseData: {},
            })
        }
    }
});

router.get('/jobs/get', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers['business'];
    var bookings = [];
    var filters = [];
    var totalResult = 0;

    var role = await Management.findOne({ user: user, business: business }).exec();

    var date = new Date();
    var to = new Date();
    to.setDate(date.getDate() - 1);
    to.setHours(23, 59, 58)



    var thumbnail = [];

    var specification = {};
    specification['$lookup'] = {
        from: "User",
        localField: "user",
        foreignField: "_id",
        as: "user",
    };
    filters.push(specification);

    var specification = {};
    specification['$unwind'] = {
        path: "$user",
        preserveNullAndEmptyArrays: false
    };
    filters.push(specification);

    var specification = {};
    specification['$lookup'] = {
        from: "Car",
        localField: "car",
        foreignField: "_id",
        as: "car",
    };
    filters.push(specification);

    var specification = {};
    specification['$lookup'] = {
        from: "User",
        localField: "advisor",
        foreignField: "_id",
        as: "advisor",
    };
    filters.push(specification);

    var specification = {};
    specification['$unwind'] = {
        path: "$advisor",
        preserveNullAndEmptyArrays: false
    };
    filters.push(specification);


    var page = 0;

    if (req.query.page == undefined) {
        page = 0;
    }
    else {
        page = req.query.page;
    }



    var page = Math.max(0, parseInt(page));

    if (role.role == "Service Advisor") {
        var specification = {};
        specification['$match'] = {
            "advisor._id": mongoose.Types.ObjectId(role.user),

        }
        filters.push(specification);
    }

    var queries = new Object();
    var sortBy = new Object();


    if (req.query.query) {
        var specification = {};
        specification['$match'] = {
            business: mongoose.Types.ObjectId(business),
            status: { $in: ["In-Process", "Rework", "JobInitiated", "JobOpen", "CompleteWork", "QC", "StoreApproval", "Ready", "Completed", "Closed"] },
            $or: [
                { 'status': { $regex: req.query.query, $options: 'i' } },
                { 'booking_no': { $eq: req.query.query } },
                { 'user.name': { $regex: req.query.query, $options: 'i' } },
                { 'user.contact_no': { $regex: req.query.query, $options: 'i' } },
                { 'car.title': { $regex: req.query.query, $options: 'i' } },
                { 'car.registration_no': { $regex: req.query.query, $options: 'i' } },
                { 'advisor.name': { $regex: req.query.query, $options: 'i' } },
                { 'advisor.contact_no': { $regex: req.query.query, $options: 'i' } },
                { 'insurance_info.insurance_company': { $regex: req.query.query, $options: 'i' } },
                {
                    "logs": {
                        $elemMatch: {
                            "status": { $regex: req.query.query, $options: 'i' }
                        }
                    }
                },
                {
                    "services": {
                        $elemMatch: {
                            "service": { $regex: req.query.query, $options: 'i' }
                        }
                    }
                },
                {
                    "services": {
                        $elemMatch: {
                            "parts": {
                                $elemMatch: {
                                    "item": { $regex: req.query.query, $options: 'i' },
                                }
                            }
                        }
                    }
                },
                {
                    "services": {
                        $elemMatch: {
                            "parts": {
                                $elemMatch: {
                                    "part_no": { $regex: req.query.query, $options: 'i' },
                                }
                            }
                        }
                    }
                },
            ]
        };
        filters.push(specification);


        var specification = {};
        specification['$sort'] = {
            updated_at: -1,
        };
        filters.push(specification);
    }
    else {
        if (req.query.status == "NewJob") {
            var specification = {};
            specification['$match'] = {
                business: mongoose.Types.ObjectId(business),
                status: { $in: ["JobInitiated", "JobOpen"] }
            };
            filters.push(specification);
        }

        else if (req.query.status == "In-Process") {
            var specification = {};
            specification['$match'] = {
                business: mongoose.Types.ObjectId(business),
                status: { $in: ["In-Process", "StartWork", "Rework"] }
            };
            filters.push(specification);
        }

        else if (req.query.status == "QC") {
            var specification = {};
            specification['$match'] = {
                business: mongoose.Types.ObjectId(business),
                status: { $in: ["QC", "CompleteWork"] }
            };
            filters.push(specification);
        }

        else if (req.query.status == "StoreApproval") {
            var specification = {};
            specification['$match'] = {
                business: mongoose.Types.ObjectId(business),
                status: { $in: ["StoreApproval"] }
            };
            filters.push(specification);
        }

        else if (req.query.status == "Ready") {
            var specification = {};
            specification['$match'] = {
                business: mongoose.Types.ObjectId(business),
                status: { $in: ["Ready"] }
            };
            filters.push(specification);

        }

        var specification = {};
        specification['$sort'] = {
            updated_at: -1,
        };
        filters.push(specification);
    }


    totalResult = await Booking.aggregate(filters);

    var specification = {};
    specification['$skip'] = config.perPage * page;
    filters.push(specification);

    var specification = {};
    specification['$limit'] = config.perPage;
    filters.push(specification);

    await Booking.aggregate(filters)
        .allowDiskUse(true)
        .cursor({ batchSize: 10 })
        .exec()
        .eachAsync(async function (booking) {
            if (booking.car.length > 0) {
                var car = {
                    title: booking.car[0]._automaker + " " + booking.car[0]._model,
                    _id: booking.car[0]._id,
                    id: booking.car[0].id,
                    rc_address: booking.car[0].rc_address,
                    ic_address: booking.car[0].ic_address,
                    ic: booking.car[0].ic,
                    rc: booking.car[0].rc,
                    registration_no: booking.car[0].registration_no,
                }
            }
            else {
                var car = {
                    title: "",
                    _id: null,
                    id: null,
                    rc_address: "",
                    ic_address: "",
                    ic: "",
                    rc: "",
                    registration_no: "",
                }
            }

            var serverTime = moment.tz(new Date(), req.headers['tz']);

            var startDate = moment(serverTime, "DD.MM.YYYY");
            var endDate = moment(booking.delivery_date, "DD.MM.YYYY");

            var days_left = endDate.diff(startDate, 'days');

            bookings.push({
                _id: booking._id,
                id: booking._id,
                car: car,
                user: {
                    name: booking.user.name,
                    _id: booking.user._id,
                    id: booking.user.id,
                    contact_no: booking.user.contact_no,
                    email: booking.user.email,
                },
                manager: null,
                time_left: moment(booking.delivery_date).tz(req.headers['tz']).endOf('day').fromNow(),
                days_left: days_left,
                delivery_date: moment(booking.delivery_date).tz(req.headers['tz']).format('ll'),
                delivery_time: booking.delivery_time,
                status: _.startCase(booking.status),
                _status: booking.status,
                sub_status: booking.sub_status,
                job_no: booking.job_no,
                booking_no: booking.booking_no,
                created_at: moment(booking.created_at).tz(req.headers['tz']).format('lll'),
                updated_at: moment(booking.updated_at).tz(req.headers['tz']).format('lll'),
            });
        });

    res.status(200).json({
        responseCode: 200,
        responseMessage: to,
        responseInfo: {
            //role: role.role,
            //filters: filters,
            totalResult: totalResult.length
        },
        responseData: bookings,
    });
});

router.post('/services/rate', xAccessToken.token, async function (req, res, next) {
    var rules = {
        car: 'required',
    };

    var validation = new Validator(req.query, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Validation Error",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var user = decoded.user;
        var business = req.headers['business'];

        var totalResult = 0;

        var quantity = 1
        var car = await Variant.findById(req.query.car).populate('model').exec();
        if (car) {
            var packages = [];

            if (req.query.type == "services") {
                await Service.find({ segment: car.model.segment, part_cost: 0, publish: true, business: business })
                    .cursor().eachAsync(async (service) => {

                        var getDiscount = {
                            booking: null,
                            package: null,
                            car: null,
                            category: service.type,
                            service: service.service,
                            claim: false,
                            tz: req.headers['tz'],
                        };

                        var package = await q.all(getPackageDiscount(getDiscount));

                        var labour_list = service.labour;
                        var labours = [];

                        var discount_eligible_labour_cost = _.sumBy(labour_list, x => x.amount);
                        if (labour_list.length > 0) {
                            for (var l = 0; l < labour_list.length; l++) {
                                var discount_total = 0;
                                var total = 0;
                                var tax_info = await Tax.findOne({ tax: labour_list[l].tax }).exec();

                                var tax = [];
                                var rate = labour_list[l].rate;
                                var amount = parseFloat(labour_list[l].amount) * quantity;
                                var tax_rate = tax_info.detail;
                                var base = amount;

                                if (Object.keys(package).length > 0) {
                                    if (package.discount_type == "percent") {
                                        discount = parseFloat(package.discount);
                                        if (!isNaN(discount) && discount > 0) {
                                            var discount_total = amount * (discount / 100);
                                            amount = amount - parseFloat(discount_total.toFixed(2))
                                            if (amount < 0) {
                                                amount = 0
                                            }
                                        }
                                    }
                                    else if (package.discount_type == "fixed") {
                                        discount = parseFloat(package.discount);
                                        if (!isNaN(discount) && discount > 0) {
                                            var discount_total = (amount / discount_eligible_labour_cost) * discount;
                                            amount = parseFloat(discount_total.toFixed(2))
                                            discount = amount - discount_total;
                                            if (amount < 0) {
                                                amount = 0
                                            }
                                        }
                                    }
                                    else {
                                        discount = parseFloat(package.discount);
                                        if (!isNaN(discount) && discount > 0) {
                                            var discount_total = (amount / discount_eligible_labour_cost) * discount;
                                            amount = amount - parseFloat(discount_total.toFixed(2))
                                            if (amount < 0) {
                                                amount = 0
                                            }
                                        }
                                    }
                                }

                                if (labour_list[l].amount_is_tax == "inclusive") {
                                    var x = (100 + tax_info.rate) / 100;
                                    var tax_on_amount = amount / x;
                                    if (tax_rate.length > 0) {
                                        for (var r = 0; r < tax_rate.length; r++) {
                                            if (tax_rate[r].rate != tax_info.rate) {
                                                var t = tax_on_amount * (tax_rate[r].rate / 100);
                                                base = base - t;
                                                tax.push({
                                                    tax: tax_rate[r].tax,
                                                    rate: tax_rate[r].rate,
                                                    amount: parseFloat(t.toFixed(2))
                                                });
                                            }
                                            else {
                                                var t = amount - tax_on_amount;
                                                base = base - t;
                                                tax.push({
                                                    tax: tax_info.tax, tax_rate: tax_info.rate,
                                                    rate: tax_info.rate,
                                                    amount: parseFloat(t.toFixed(2))
                                                });
                                            }
                                        }

                                        //base = base - discount_total;
                                    }
                                    total = total + amount;
                                }

                                var tax_details = {
                                    tax: tax_info.tax,
                                    rate: tax_info.rate,
                                    amount: total,
                                    detail: tax
                                }


                                labours.push({
                                    item: labour_list[l].item,
                                    source: labour_list[l].source,
                                    rate: parseFloat(labour_list[l].rate),
                                    quantity: quantity,
                                    base: parseFloat(base.toFixed(2)),
                                    discount: parseFloat(discount_total.toFixed(2)),
                                    amount: total,
                                    tax_amount: parseFloat(_.sumBy(tax, x => x.amount).toFixed(2)),
                                    amount_is_tax: labour_list[l].amount_is_tax,
                                    tax: tax_info.tax, tax_rate: tax_info.rate,
                                    tax_info: tax_details
                                });
                            }
                        }

                        packages.push({
                            package: service.package,
                            service: service.service,
                            labour: labours,
                            labour_cost: _.sumBy(labours, x => x.amount),
                            discount: _.sumBy(labours, x => x.discount),
                            parts: service.parts,
                            part_cost: parseFloat(service.part_cost),
                            opening_fitting: service.opening_fitting,
                            of_cost: parseFloat(service.of_cost),
                            exceeded_cost: 0,
                            mrp: parseFloat(service.mrp),
                            cost: parseFloat(service.part_cost) + _.sumBy(labours, x => x.amount),
                            doorstep: service.doorstep,
                            unit: service.unit,
                            quantity: quantity,
                            part_cost_editable: service.part_cost_editable,
                            labour_cost_editable: service.labour_cost_editable,
                            of_cost_editable: service.of_cost_editable,
                            type: service.type,
                            source: service.id,
                            description: service.description,
                            id: service.id,
                            _id: service._id
                        });

                        packageDiscountOn = []
                    });

                await Service.find({ model: car.model._id, part_cost: { $gt: 0 }, publish: true, business: business })
                    .cursor().eachAsync(async (service) => {
                        var labels = [];

                        labels.push(service.type)
                        labels.push(service.service)
                        var coupons = await Coupon.find({ label: { $in: labels }, expired_at: { "$gte": new Date() }, physical: false }).exec();

                        var gallery = service.gallery;
                        var getDiscount = {
                            booking: null,
                            package: null,
                            car: null,
                            category: service.type,
                            service: service.service,
                            claim: false,
                            tz: req.headers['tz'],
                        };

                        var package = await q.all(getPackageDiscount(getDiscount));
                        var labour_list = service.labour;
                        var labours = [];

                        var discount_eligible_labour_cost = _.sumBy(labour_list, x => x.amount);
                        if (labour_list.length > 0) {
                            for (var l = 0; l < labour_list.length; l++) {
                                var quantity = 1;
                                if (labour_list[l].quantity) {
                                    quantity = labour_list[l].quantity;
                                }

                                var discount_total = 0;
                                var total = 0;
                                var tax_info = await Tax.findOne({ tax: labour_list[l].tax }).exec();

                                var tax = [];
                                var rate = labour_list[l].rate;
                                var amount = parseFloat(labour_list[l].amount);
                                var tax_rate = tax_info.detail;
                                var base = amount;

                                if (Object.keys(package).length > 0) {
                                    if (package.discount_type == "percent") {
                                        discount = parseFloat(package.discount);
                                        if (!isNaN(discount) && discount > 0) {
                                            var discount_total = amount * (discount / 100);
                                            amount = amount - parseFloat(discount_total.toFixed(2))
                                            if (amount < 0) {
                                                amount = 0
                                            }
                                        }
                                    }
                                    else if (package.discount_type == "fixed") {
                                        discount = parseFloat(package.discount);
                                        if (!isNaN(discount) && discount > 0) {
                                            var discount_total = (amount / discount_eligible_labour_cost) * discount;
                                            amount = parseFloat(discount_total.toFixed(2))
                                            discount = amount - discount_total;
                                            if (amount < 0) {
                                                amount = 0
                                            }
                                        }
                                    }
                                    else {
                                        discount = parseFloat(package.discount);
                                        if (!isNaN(discount) && discount > 0) {
                                            var discount_total = (amount / discount_eligible_labour_cost) * discount;
                                            amount = amount - parseFloat(discount_total.toFixed(2))
                                            if (amount < 0) {
                                                amount = 0
                                            }
                                        }
                                    }
                                }

                                if (labour_list[l].amount_is_tax == "inclusive") {
                                    var x = (100 + tax_info.rate) / 100;
                                    var tax_on_amount = amount / x;
                                    if (tax_rate.length > 0) {
                                        for (var r = 0; r < tax_rate.length; r++) {
                                            if (tax_rate[r].rate != tax_info.rate) {
                                                var t = tax_on_amount * (tax_rate[r].rate / 100);
                                                base = base - t;
                                                tax.push({
                                                    tax: tax_rate[r].tax,
                                                    rate: tax_rate[r].rate,
                                                    amount: parseFloat(t.toFixed(2))
                                                });
                                            }
                                            else {
                                                var t = amount - tax_on_amount;
                                                base = base - t;
                                                tax.push({
                                                    tax: tax_info.tax, tax_rate: tax_info.rate,
                                                    rate: tax_info.rate,
                                                    amount: parseFloat(t.toFixed(2))
                                                });
                                            }
                                        }

                                        //base = base - discount_total;
                                    }
                                    total = total + amount;
                                }

                                var tax_details = {
                                    tax: tax_info.tax,
                                    rate: tax_info.rate,
                                    amount: total,
                                    detail: tax
                                }


                                labours.push({
                                    item: labour_list[l].item,
                                    source: labour_list[l].source,
                                    rate: parseFloat(labour_list[l].rate),
                                    quantity: 1,
                                    base: parseFloat(total.toFixed(2)),
                                    discount: parseFloat(discount_total.toFixed(2)),
                                    amount: total,
                                    tax_amount: parseFloat(_.sumBy(tax, x => x.amount).toFixed(2)),
                                    amount_is_tax: labour_list[l].amount_is_tax,
                                    tax: tax_info.tax, tax_rate: tax_info.rate,
                                    tax_info: tax_details
                                });
                            }
                        }
                        packages.push({
                            package: service.package,
                            service: service.service,
                            labour: labours,
                            labour_cost: _.sumBy(labours, x => x.amount),
                            parts: service.parts,
                            part_cost: Math.ceil(service.part_cost),
                            opening_fitting: service.opening_fitting,
                            of_cost: Math.ceil(service.of_cost),
                            exceeded_cost: 0,
                            mrp: Math.ceil(service.part_cost) + _.sumBy(labours, x => x.amount) + (_.sumBy(labours, x => x.amount) * (40 / 100)),
                            cost: Math.ceil(service.part_cost) + _.sumBy(labours, x => x.amount) + service.of_cost,
                            doorstep: service.doorstep,
                            unit: service.unit,
                            quantity: service.quantity,
                            discount: _.sumBy(labours, x => x.discount) + _.sumBy(service.opening_fitting, x => x.discount) + _.sumBy(service.parts, x => x.discount),
                            part_cost_editable: service.part_cost_editable,
                            labour_cost_editable: service.labour_cost_editable,
                            of_cost_editable: service.of_cost_editable,
                            type: service.type,
                            source: service.id,
                            gallery: gallery.length,
                            description: service.description,
                            coupons: coupons,
                            id: service.id,
                            _id: service._id
                        });
                    });
            }

            else if (req.query.type == "collision") {
                await Collision.find({ segment: car.model.segment, publish: true, business: business })
                    .cursor().eachAsync(async (service) => {
                        var getDiscount = {
                            booking: null,
                            package: null,
                            car: null,
                            category: service.type,
                            service: service.service,
                            claim: false,
                            tz: req.headers['tz'],
                        };

                        var package = await q.all(getPackageDiscount(getDiscount));
                        var labour_list = service.labour;
                        var labours = [];

                        var discount_eligible_labour_cost = _.sumBy(labour_list, x => x.amount);
                        if (labour_list.length > 0) {
                            for (var l = 0; l < labour_list.length; l++) {
                                var discount_total = 0;
                                var total = 0;
                                var tax_info = await Tax.findOne({ tax: labour_list[l].tax }).exec();

                                var tax = [];
                                var rate = labour_list[l].rate;
                                var amount = parseFloat(labour_list[l].amount) * quantity;
                                var tax_rate = tax_info.detail;
                                var base = amount;

                                if (Object.keys(package).length > 0) {
                                    if (package.discount_type == "percent") {
                                        discount = parseFloat(package.discount);
                                        if (!isNaN(discount) && discount > 0) {
                                            var discount_total = amount * (discount / 100);
                                            amount = amount - parseFloat(discount_total.toFixed(2))
                                            if (amount < 0) {
                                                amount = 0
                                            }
                                        }
                                    }
                                    else if (package.discount_type == "fixed") {
                                        discount = parseFloat(package.discount);
                                        if (!isNaN(discount) && discount > 0) {
                                            var discount_total = (amount / discount_eligible_labour_cost) * discount;
                                            amount = parseFloat(discount_total.toFixed(2))
                                            discount = amount - discount_total;
                                            if (amount < 0) {
                                                amount = 0
                                            }
                                        }
                                    }
                                    else {
                                        discount = parseFloat(package.discount);
                                        if (!isNaN(discount) && discount > 0) {
                                            var discount_total = (amount / discount_eligible_labour_cost) * discount;
                                            amount = amount - parseFloat(discount_total.toFixed(2))
                                            if (amount < 0) {
                                                amount = 0
                                            }
                                        }
                                    }
                                }

                                if (labour_list[l].amount_is_tax == "inclusive") {
                                    var x = (100 + tax_info.rate) / 100;
                                    var tax_on_amount = amount / x;
                                    if (tax_rate.length > 0) {
                                        for (var r = 0; r < tax_rate.length; r++) {
                                            if (tax_rate[r].rate != tax_info.rate) {
                                                var t = tax_on_amount * (tax_rate[r].rate / 100);
                                                base = base - t;
                                                tax.push({
                                                    tax: tax_rate[r].tax,
                                                    rate: tax_rate[r].rate,
                                                    amount: parseFloat(t.toFixed(2))
                                                });
                                            }
                                            else {
                                                var t = amount - tax_on_amount;
                                                base = base - t;
                                                tax.push({
                                                    tax: tax_info.tax, tax_rate: tax_info.rate,
                                                    rate: tax_info.rate,
                                                    amount: parseFloat(t.toFixed(2))
                                                });
                                            }
                                        }

                                        //base = base - discount_total;
                                    }
                                    total = total + amount;
                                }

                                var tax_details = {
                                    tax: tax_info.tax,
                                    rate: tax_info.rate,
                                    amount: total,
                                    detail: tax
                                }


                                labours.push({
                                    item: labour_list[l].item,
                                    source: labour_list[l].source,
                                    rate: parseFloat(labour_list[l].rate),
                                    quantity: quantity,
                                    base: parseFloat(base.toFixed(2)),
                                    discount: parseFloat(discount_total.toFixed(2)),
                                    amount: total,
                                    tax_amount: parseFloat(_.sumBy(tax, x => x.amount).toFixed(2)),
                                    amount_is_tax: labour_list[l].amount_is_tax,
                                    tax: tax_info.tax, tax_rate: tax_info.rate,
                                    tax_info: tax_details
                                });

                                // cconsole.logtoFixed(2))
                            }
                        }

                        packages.push({
                            package: service.package,
                            service: service.service,
                            labour: labours,
                            labour_cost: _.sumBy(labours, x => x.amount),
                            parts: service.parts,
                            discount: _.sumBy(labours, x => x.discount),
                            part_cost: parseFloat(service.part_cost),
                            opening_fitting: service.opening_fitting,
                            of_cost: parseFloat(service.of_cost),
                            exceeded_cost: 0,
                            mrp: parseFloat(service.mrp),
                            cost: parseFloat(service.part_cost) + _.sumBy(labours, x => x.amount),
                            doorstep: service.doorstep,
                            unit: service.unit,
                            quantity: quantity,
                            part_cost_editable: service.part_cost_editable,
                            labour_cost_editable: service.labour_cost_editable,
                            of_cost_editable: service.of_cost_editable,
                            type: service.type,
                            source: service.id,
                            description: service.description,
                            id: service.id,
                            _id: service._id
                        });

                        packageDiscountOn = []
                    });
            }

            else if (req.query.type == "customization") {
                await Customization.find({ segment: car.model.segment, publish: true, business: business })
                    .cursor().eachAsync(async (service) => {
                        var getDiscount = {
                            booking: null,
                            package: null,
                            car: null,
                            category: service.type,
                            service: service.service,
                            claim: false,
                            tz: req.headers['tz'],
                        };
                        var package = await q.all(getPackageDiscount(getDiscount));
                        var labour_list = service.labour;
                        var labours = [];

                        var discount_eligible_labour_cost = _.sumBy(labour_list, x => x.amount);
                        if (labour_list.length > 0) {
                            for (var l = 0; l < labour_list.length; l++) {
                                /*var quantity = 1;*/
                                /*if(labour_list[l].quantity)
                                {
                                    quantity = labour_list[l].quantity;
                                }*/

                                var discount_total = 0;
                                var total = 0;
                                var tax_info = await Tax.findOne({ tax: labour_list[l].tax }).exec();

                                var tax = [];
                                var rate = labour_list[l].rate;
                                var amount = parseFloat(labour_list[l].amount) * quantity;
                                var tax_rate = tax_info.detail;
                                var base = amount;

                                if (Object.keys(package).length > 0) {
                                    if (package.discount_type == "percent") {
                                        discount = parseFloat(package.discount);
                                        if (!isNaN(discount) && discount > 0) {
                                            var discount_total = amount * (discount / 100);
                                            amount = amount - parseFloat(discount_total.toFixed(2))
                                            if (amount < 0) {
                                                amount = 0
                                            }
                                        }
                                    }
                                    else if (package.discount_type == "fixed") {
                                        discount = parseFloat(package.discount);
                                        if (!isNaN(discount) && discount > 0) {
                                            var discount_total = (amount / discount_eligible_labour_cost) * discount;
                                            amount = parseFloat(discount_total.toFixed(2))
                                            discount = amount - discount_total;
                                            if (amount < 0) {
                                                amount = 0
                                            }
                                        }
                                    }
                                    else {
                                        discount = parseFloat(package.discount);
                                        if (!isNaN(discount) && discount > 0) {
                                            var discount_total = (amount / discount_eligible_labour_cost) * discount;
                                            amount = amount - parseFloat(discount_total.toFixed(2))
                                            if (amount < 0) {
                                                amount = 0
                                            }
                                        }
                                    }
                                }

                                if (labour_list[l].amount_is_tax == "inclusive") {
                                    var x = (100 + tax_info.rate) / 100;
                                    var tax_on_amount = amount / x;
                                    if (tax_rate.length > 0) {
                                        for (var r = 0; r < tax_rate.length; r++) {
                                            if (tax_rate[r].rate != tax_info.rate) {
                                                var t = tax_on_amount * (tax_rate[r].rate / 100);
                                                base = base - t;
                                                tax.push({
                                                    tax: tax_rate[r].tax,
                                                    rate: tax_rate[r].rate,
                                                    amount: parseFloat(t.toFixed(2))
                                                });
                                            }
                                            else {
                                                var t = amount - tax_on_amount;
                                                base = base - t;
                                                tax.push({
                                                    tax: tax_info.tax, tax_rate: tax_info.rate,
                                                    rate: tax_info.rate,
                                                    amount: parseFloat(t.toFixed(2))
                                                });
                                            }
                                        }

                                        //base = base - discount_total;
                                    }
                                    total = total + amount;
                                }

                                var tax_details = {
                                    tax: tax_info.tax,
                                    rate: tax_info.rate,
                                    amount: total,
                                    detail: tax
                                }


                                labours.push({
                                    item: labour_list[l].item,
                                    source: labour_list[l].source,
                                    rate: parseFloat(labour_list[l].rate),
                                    quantity: quantity,
                                    base: parseFloat(base.toFixed(2)),
                                    discount: parseFloat(discount_total.toFixed(2)),
                                    amount: total,
                                    tax_amount: parseFloat(_.sumBy(tax, x => x.amount).toFixed(2)),
                                    amount_is_tax: labour_list[l].amount_is_tax,
                                    tax: tax_info.tax, tax_rate: tax_info.rate,
                                    tax_info: tax_details
                                });

                                // cconsole.logtoFixed(2))
                            }
                        }

                        packages.push({
                            package: service.package,
                            service: service.service,
                            labour: labours,
                            discount: _.sumBy(labours, x => x.discount),
                            labour_cost: _.sumBy(labours, x => x.amount),
                            parts: service.parts,
                            part_cost: parseFloat(service.part_cost),
                            opening_fitting: service.opening_fitting,
                            of_cost: parseFloat(service.of_cost),
                            exceeded_cost: 0,
                            mrp: parseFloat(service.mrp),
                            cost: parseFloat(service.part_cost) + _.sumBy(labours, x => x.amount),
                            doorstep: service.doorstep,
                            unit: service.unit,
                            quantity: quantity,
                            part_cost_editable: service.part_cost_editable,
                            labour_cost_editable: service.labour_cost_editable,
                            of_cost_editable: service.of_cost_editable,
                            type: service.type,
                            source: service.id,
                            description: service.description,
                            id: service.id,
                            _id: service._id
                        });

                        packageDiscountOn = []
                    });
            }

            else if (req.query.type == "detailing") {
                await Detailing.find({ segment: car.model.segment, publish: true, business: business })
                    .cursor().eachAsync(async (service) => {
                        var getDiscount = {
                            booking: null,
                            package: null,
                            car: null,
                            category: service.type,
                            service: service.service,
                            claim: false,
                            tz: req.headers['tz'],
                        };
                        var package = await q.all(getPackageDiscount(getDiscount));

                        var labour_list = service.labour;
                        var labours = [];

                        var discount_eligible_labour_cost = _.sumBy(labour_list, x => x.amount);
                        if (labour_list.length > 0) {
                            for (var l = 0; l < labour_list.length; l++) {
                                var discount_total = 0;
                                var total = 0;
                                var tax_info = await Tax.findOne({ tax: labour_list[l].tax }).exec();

                                var tax = [];
                                var rate = labour_list[l].rate;
                                var amount = parseFloat(labour_list[l].amount) * quantity;
                                var tax_rate = tax_info.detail;
                                var base = amount;

                                if (Object.keys(package).length > 0) {
                                    if (package.discount_type == "percent") {
                                        discount = parseFloat(package.discount);
                                        if (!isNaN(discount) && discount > 0) {
                                            var discount_total = amount * (discount / 100);
                                            amount = amount - parseFloat(discount_total.toFixed(2))
                                            if (amount < 0) {
                                                amount = 0
                                            }
                                        }
                                    }
                                    else if (package.discount_type == "fixed") {
                                        discount = parseFloat(package.discount);
                                        if (!isNaN(discount) && discount > 0) {
                                            var discount_total = (amount / discount_eligible_labour_cost) * discount;
                                            amount = parseFloat(discount_total.toFixed(2))
                                            discount = amount - discount_total;
                                            if (amount < 0) {
                                                amount = 0
                                            }
                                        }
                                    }
                                    else {
                                        discount = parseFloat(package.discount);
                                        if (!isNaN(discount) && discount > 0) {
                                            var discount_total = (amount / discount_eligible_labour_cost) * discount;
                                            amount = amount - parseFloat(discount_total.toFixed(2))
                                            if (amount < 0) {
                                                amount = 0
                                            }
                                        }
                                    }
                                }


                                if (labour_list[l].amount_is_tax == "inclusive") {
                                    var x = (100 + tax_info.rate) / 100;
                                    var tax_on_amount = amount / x;
                                    if (tax_rate.length > 0) {
                                        for (var r = 0; r < tax_rate.length; r++) {
                                            if (tax_rate[r].rate != tax_info.rate) {
                                                var t = tax_on_amount * (tax_rate[r].rate / 100);
                                                base = base - t;
                                                tax.push({
                                                    tax: tax_rate[r].tax,
                                                    rate: tax_rate[r].rate,
                                                    amount: parseFloat(t.toFixed(2))
                                                });
                                            }
                                            else {
                                                var t = amount - tax_on_amount;
                                                base = base - t;
                                                tax.push({
                                                    tax: tax_info.tax, tax_rate: tax_info.rate,
                                                    rate: tax_info.rate,
                                                    amount: parseFloat(t.toFixed(2))
                                                });
                                            }
                                        }

                                        //base = base - discount_total;
                                    }
                                    total = total + amount;
                                }

                                var tax_details = {
                                    tax: tax_info.tax,
                                    rate: tax_info.rate,
                                    amount: total,
                                    detail: tax
                                }


                                labours.push({
                                    item: labour_list[l].item,
                                    source: labour_list[l].source,
                                    rate: parseFloat(labour_list[l].rate),
                                    quantity: quantity,
                                    base: parseFloat(base.toFixed(2)),
                                    discount: parseFloat(discount_total.toFixed(2)),
                                    amount: total,
                                    tax_amount: parseFloat(_.sumBy(tax, x => x.amount).toFixed(2)),
                                    amount_is_tax: labour_list[l].amount_is_tax,
                                    tax: tax_info.tax, tax_rate: tax_info.rate,
                                    tax_info: tax_details
                                });
                            }
                        }

                        packages.push({
                            package: service.package,
                            service: service.service,
                            labour: labours,
                            discount: _.sumBy(labours, x => x.discount),
                            labour_cost: _.sumBy(labours, x => x.amount),
                            parts: service.parts,
                            part_cost: parseFloat(service.part_cost),
                            opening_fitting: service.opening_fitting,
                            of_cost: parseFloat(service.of_cost),
                            exceeded_cost: 0,
                            mrp: parseFloat(service.mrp),
                            cost: parseFloat(service.part_cost) + _.sumBy(labours, x => x.amount),
                            doorstep: service.doorstep,
                            unit: service.unit,
                            quantity: quantity,
                            part_cost_editable: service.part_cost_editable,
                            labour_cost_editable: service.labour_cost_editable,
                            of_cost_editable: service.of_cost_editable,
                            type: service.type,
                            source: service.id,
                            description: service.description,
                            id: service.id,
                            _id: service._id
                        });

                        packageDiscountOn = []
                    });
            }

            packages = _(packages).groupBy(x => x.package).map((value, key) => ({ package: key, services: value })).value();

            res.status(200).json({
                responseCode: 200,
                responseMessage: "",
                responseData: packages
            });
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Car not found",
                responseData: {}
            });
        }

    }
});

router.post('/estimation/services/search', xAccessToken.token, async function (req, res, next) {
    var rules = {
        booking: 'required',
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Validation Error",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var user = decoded.user;
        var business = req.headers['business'];

        var totalResult = 0;

        var booking = await Booking.findOne({ _id: req.body.booking }).exec();
        if (booking) {
            var claim = false;
            if (booking.insurance_info) {
                claim = booking.insurance_info.claim
            }

            var quantity = 1;
            if (req.body.quantity) {
                quantity = parseInt(req.body.quantity)
            }

            var car = await Car.findById(booking.car).populate('model').exec();
            if (car) {
                var packages = [];

                await Service.find({ business: business, segment: car.model.segment, part_cost: 0, publish: true, service: new RegExp(req.body.service, "i"), business: business })
                    .cursor().eachAsync(async (service) => {

                        var getDiscount = {
                            booking: booking._id,
                            package: booking.package,
                            car: booking.car,
                            category: service.type,
                            service: service.service,
                            claim: claim,
                            tz: req.headers['tz'],
                        };

                        var package = await q.all(getPackageDiscount(getDiscount));

                        // console.log(package);

                        var labour_list = service.labour;
                        var labours = [];

                        var discount_eligible_labour_cost = _.sumBy(labour_list, x => x.amount);
                        if (labour_list.length > 0) {
                            for (var l = 0; l < labour_list.length; l++) {
                                var discount_total = 0;
                                var total = 0;
                                var tax_info = await Tax.findOne({ tax: labour_list[l].tax }).exec();

                                var tax = [];
                                var rate = labour_list[l].rate;
                                var amount = parseFloat(labour_list[l].amount) * quantity;
                                var tax_rate = tax_info.detail;
                                var base = amount;

                                if (Object.keys(package).length > 0) {
                                    if (package.discount_type == "percent") {
                                        discount = parseFloat(package.discount);
                                        if (!isNaN(discount) && discount > 0) {
                                            var discount_total = amount * (discount / 100);
                                            amount = amount - parseFloat(discount_total.toFixed(2))
                                            if (amount < 0) {
                                                amount = 0
                                            }
                                        }
                                    }
                                    else if (package.discount_type == "fixed") {
                                        discount = parseFloat(package.discount);
                                        if (!isNaN(discount) && discount > 0) {
                                            var discount_total = (amount / discount_eligible_labour_cost) * discount;
                                            amount = parseFloat(discount_total.toFixed(2))
                                            discount = amount - discount_total;
                                            if (amount < 0) {
                                                amount = 0
                                            }
                                        }
                                    }
                                    else {
                                        discount = parseFloat(package.discount);
                                        if (!isNaN(discount) && discount > 0) {
                                            var discount_total = (amount / discount_eligible_labour_cost) * discount;
                                            amount = amount - parseFloat(discount_total.toFixed(2))
                                            if (amount < 0) {
                                                amount = 0
                                            }
                                        }
                                    }
                                }

                                if (labour_list[l].amount_is_tax == "inclusive") {
                                    var x = (100 + tax_info.rate) / 100;
                                    var tax_on_amount = amount / x;
                                    if (tax_rate.length > 0) {
                                        for (var r = 0; r < tax_rate.length; r++) {
                                            if (tax_rate[r].rate != tax_info.rate) {
                                                var t = tax_on_amount * (tax_rate[r].rate / 100);
                                                base = base - t;
                                                tax.push({
                                                    tax: tax_rate[r].tax,
                                                    rate: tax_rate[r].rate,
                                                    amount: parseFloat(t.toFixed(2))
                                                });
                                            }
                                            else {
                                                var t = amount - tax_on_amount;
                                                base = base - t;
                                                tax.push({
                                                    tax: tax_info.tax, tax_rate: tax_info.rate,
                                                    rate: tax_info.rate,
                                                    amount: parseFloat(t.toFixed(2))
                                                });
                                            }
                                        }

                                        //base = base - discount_total;
                                    }
                                    total = total + amount;
                                }

                                var tax_details = {
                                    tax: tax_info.tax,
                                    rate: tax_info.rate,
                                    amount: total,
                                    detail: tax
                                }


                                labours.push({
                                    item: labour_list[l].item,
                                    source: labour_list[l].source,
                                    rate: parseFloat(labour_list[l].rate),
                                    quantity: quantity,
                                    base: parseFloat(base.toFixed(2)),
                                    discount: parseFloat(discount_total.toFixed(2)),
                                    amount: total,
                                    customer_dep: 100,
                                    insurance_dep: 0,
                                    tax_amount: parseFloat(_.sumBy(tax, x => x.amount).toFixed(2)),
                                    amount_is_tax: labour_list[l].amount_is_tax,
                                    tax: tax_info.tax,
                                    tax_rate: tax_info.rate,
                                    tax_info: tax_details
                                });
                            }
                        }

                        if (service.opening_fitting.length != 0) {
                            service.opening_fitting[0].customer_dep = 100;
                            service.opening_fitting[0].insurance_dep = 0;
                        }

                        if (service.parts.length != 0) {
                            service.parts[0].customer_dep = 100;
                            service.parts[0].insurance_dep = 0;
                        }

                        packages.push({
                            package: service.package,
                            service: service.service,
                            labour: labours,
                            labour_cost: _.sumBy(labours, x => x.amount),
                            discount: _.sumBy(labours, x => x.discount),
                            parts: service.parts,
                            part_cost: parseFloat(service.part_cost),
                            opening_fitting: service.opening_fitting,
                            of_cost: parseFloat(service.of_cost),
                            exceeded_cost: 0,
                            mrp: parseFloat(service.mrp),
                            cost: parseFloat(service.part_cost) + _.sumBy(labours, x => x.amount),
                            doorstep: service.doorstep,
                            unit: service.unit,
                            quantity: quantity,
                            part_cost_editable: service.part_cost_editable,
                            labour_cost_editable: service.labour_cost_editable,
                            of_cost_editable: service.of_cost_editable,
                            type: service.type,
                            source: service.id,
                            description: service.description,
                            id: service.id,
                            _id: service._id
                        });

                        packageDiscountOn = []
                    });

                await Service.find({ business: business, model: car.model._id, publish: true, business: business })
                    .cursor().eachAsync(async (service) => {
                        var labels = [];

                        labels.push(service.type)
                        labels.push(service.service)
                        var coupons = await Coupon.find({ label: { $in: labels }, expired_at: { "$gte": new Date() }, physical: false }).exec();

                        var gallery = service.gallery;
                        var getDiscount = {
                            booking: booking._id,
                            package: booking.package,
                            car: booking.car,
                            category: service.type,
                            service: service.service,
                            claim: claim,
                            tz: req.headers['tz'],
                        };

                        var package = await q.all(getPackageDiscount(getDiscount));
                        var labour_list = service.labour;
                        var labours = [];

                        var discount_eligible_labour_cost = _.sumBy(labour_list, x => x.amount);
                        if (labour_list.length > 0) {
                            for (var l = 0; l < labour_list.length; l++) {
                                var quantity = 1;
                                if (labour_list[l].quantity) {
                                    quantity = labour_list[l].quantity;
                                }

                                var discount_total = 0;
                                var total = 0;
                                var tax_info = await Tax.findOne({ tax: labour_list[l].tax }).exec();

                                var tax = [];
                                var rate = labour_list[l].rate;
                                var amount = parseFloat(labour_list[l].amount);
                                var tax_rate = tax_info.detail;
                                var base = amount;

                                if (Object.keys(package).length > 0) {
                                    if (package.discount_type == "percent") {
                                        discount = parseFloat(package.discount);
                                        if (!isNaN(discount) && discount > 0) {
                                            var discount_total = amount * (discount / 100);
                                            amount = amount - parseFloat(discount_total.toFixed(2))
                                            if (amount < 0) {
                                                amount = 0
                                            }
                                        }
                                    }
                                    else if (package.discount_type == "fixed") {
                                        discount = parseFloat(package.discount);
                                        if (!isNaN(discount) && discount > 0) {
                                            var discount_total = (amount / discount_eligible_labour_cost) * discount;
                                            amount = parseFloat(discount_total.toFixed(2))
                                            discount = amount - discount_total;
                                            if (amount < 0) {
                                                amount = 0
                                            }
                                        }
                                    }
                                    else {
                                        discount = parseFloat(package.discount);
                                        if (!isNaN(discount) && discount > 0) {
                                            var discount_total = (amount / discount_eligible_labour_cost) * discount;
                                            amount = amount - parseFloat(discount_total.toFixed(2))
                                            if (amount < 0) {
                                                amount = 0
                                            }
                                        }
                                    }
                                }

                                if (labour_list[l].amount_is_tax == "inclusive") {
                                    var x = (100 + tax_info.rate) / 100;
                                    var tax_on_amount = amount / x;
                                    if (tax_rate.length > 0) {
                                        for (var r = 0; r < tax_rate.length; r++) {
                                            if (tax_rate[r].rate != tax_info.rate) {
                                                var t = tax_on_amount * (tax_rate[r].rate / 100);
                                                base = base - t;
                                                tax.push({
                                                    tax: tax_rate[r].tax,
                                                    rate: tax_rate[r].rate,
                                                    amount: parseFloat(t.toFixed(2))
                                                });
                                            }
                                            else {
                                                var t = amount - tax_on_amount;
                                                base = base - t;
                                                tax.push({
                                                    tax: tax_info.tax, tax_rate: tax_info.rate,
                                                    rate: tax_info.rate,
                                                    amount: parseFloat(t.toFixed(2))
                                                });
                                            }
                                        }

                                        //base = base - discount_total;
                                    }
                                    total = total + amount;
                                }

                                var tax_details = {
                                    tax: tax_info.tax,
                                    rate: tax_info.rate,
                                    amount: total,
                                    detail: tax
                                }


                                labours.push({
                                    item: labour_list[l].item,
                                    source: labour_list[l].source,
                                    rate: parseFloat(labour_list[l].rate),
                                    quantity: 1,
                                    base: parseFloat(total.toFixed(2)),
                                    discount: parseFloat(discount_total.toFixed(2)),
                                    amount: total,
                                    customer_dep: 100,
                                    insurance_dep: 0,
                                    tax_amount: parseFloat(_.sumBy(tax, x => x.amount).toFixed(2)),
                                    amount_is_tax: labour_list[l].amount_is_tax,
                                    tax: tax_info.tax, tax_rate: tax_info.rate,
                                    tax_info: tax_details
                                });
                            }
                        }

                        if (service.opening_fitting.length != 0) {
                            service.opening_fitting[0].customer_dep = 100;
                            service.opening_fitting[0].insurance_dep = 0;
                        }

                        if (service.parts.length != 0) {
                            service.parts[0].customer_dep = 100;
                            service.parts[0].insurance_dep = 0;
                        }


                        packages.push({
                            package: service.package,
                            service: service.service,
                            labour: labours,
                            labour_cost: _.sumBy(labours, x => x.amount),
                            parts: service.parts,
                            part_cost: Math.ceil(service.part_cost),
                            opening_fitting: service.opening_fitting,
                            of_cost: Math.ceil(service.of_cost),
                            exceeded_cost: 0,
                            mrp: Math.ceil(service.part_cost) + _.sumBy(labours, x => x.amount) + (_.sumBy(labours, x => x.amount) * (40 / 100)),
                            cost: Math.ceil(service.part_cost) + _.sumBy(labours, x => x.amount) + service.of_cost,
                            doorstep: service.doorstep,
                            unit: service.unit,
                            quantity: service.quantity,
                            discount: _.sumBy(labours, x => x.discount) + _.sumBy(service.opening_fitting, x => x.discount) + _.sumBy(service.parts, x => x.discount),
                            part_cost_editable: service.part_cost_editable,
                            labour_cost_editable: service.labour_cost_editable,
                            of_cost_editable: service.of_cost_editable,
                            type: service.type,
                            source: service.id,
                            gallery: gallery.length,
                            description: service.description,
                            coupons: coupons,
                            id: service.id,
                            _id: service._id
                        });
                    });

                await Collision.find({ business: business, segment: car.model.segment, publish: true, service: new RegExp(req.body.service, "i"), business: business })
                    .cursor().eachAsync(async (service) => {
                        var getDiscount = {
                            booking: booking._id,
                            package: booking.package,
                            car: booking.car,
                            category: service.type,
                            service: service.service,
                            claim: claim,
                            tz: req.headers['tz'],
                        };
                        var package = await q.all(getPackageDiscount(getDiscount));
                        var labour_list = service.labour;
                        var labours = [];

                        var discount_eligible_labour_cost = _.sumBy(labour_list, x => x.amount);
                        if (labour_list.length > 0) {
                            for (var l = 0; l < labour_list.length; l++) {
                                var discount_total = 0;
                                var total = 0;
                                var tax_info = await Tax.findOne({ tax: labour_list[l].tax }).exec();

                                var tax = [];
                                var rate = labour_list[l].rate;
                                var amount = parseFloat(labour_list[l].amount) * quantity;
                                var tax_rate = tax_info.detail;
                                var base = amount;

                                if (Object.keys(package).length > 0) {
                                    if (package.discount_type == "percent") {
                                        discount = parseFloat(package.discount);
                                        if (!isNaN(discount) && discount > 0) {
                                            var discount_total = amount * (discount / 100);
                                            amount = amount - parseFloat(discount_total.toFixed(2))
                                            if (amount < 0) {
                                                amount = 0
                                            }
                                        }
                                    }
                                    else if (package.discount_type == "fixed") {
                                        discount = parseFloat(package.discount);
                                        if (!isNaN(discount) && discount > 0) {
                                            var discount_total = (amount / discount_eligible_labour_cost) * discount;
                                            amount = parseFloat(discount_total.toFixed(2))
                                            discount = amount - discount_total;
                                            if (amount < 0) {
                                                amount = 0
                                            }
                                        }
                                    }
                                    else {
                                        discount = parseFloat(package.discount);
                                        if (!isNaN(discount) && discount > 0) {
                                            var discount_total = (amount / discount_eligible_labour_cost) * discount;
                                            amount = amount - parseFloat(discount_total.toFixed(2))
                                            if (amount < 0) {
                                                amount = 0
                                            }
                                        }
                                    }
                                }

                                if (labour_list[l].amount_is_tax == "inclusive") {
                                    var x = (100 + tax_info.rate) / 100;
                                    var tax_on_amount = amount / x;
                                    if (tax_rate.length > 0) {
                                        for (var r = 0; r < tax_rate.length; r++) {
                                            if (tax_rate[r].rate != tax_info.rate) {
                                                var t = tax_on_amount * (tax_rate[r].rate / 100);
                                                base = base - t;
                                                tax.push({
                                                    tax: tax_rate[r].tax,
                                                    rate: tax_rate[r].rate,
                                                    amount: parseFloat(t.toFixed(2))
                                                });
                                            }
                                            else {
                                                var t = amount - tax_on_amount;
                                                base = base - t;
                                                tax.push({
                                                    tax: tax_info.tax, tax_rate: tax_info.rate,
                                                    rate: tax_info.rate,
                                                    amount: parseFloat(t.toFixed(2))
                                                });
                                            }
                                        }

                                        //base = base - discount_total;
                                    }
                                    total = total + amount;
                                }

                                var tax_details = {
                                    tax: tax_info.tax,
                                    rate: tax_info.rate,
                                    amount: total,
                                    detail: tax
                                }


                                labours.push({
                                    item: labour_list[l].item,
                                    source: labour_list[l].source,
                                    rate: parseFloat(labour_list[l].rate),
                                    quantity: quantity,
                                    base: parseFloat(base.toFixed(2)),
                                    discount: parseFloat(discount_total.toFixed(2)),
                                    amount: total,
                                    customer_dep: 100,
                                    insurance_dep: 0,
                                    tax_amount: parseFloat(_.sumBy(tax, x => x.amount).toFixed(2)),
                                    amount_is_tax: labour_list[l].amount_is_tax,
                                    tax: tax_info.tax, tax_rate: tax_info.rate,
                                    tax_info: tax_details
                                });

                                // cconsole.logtoFixed(2))
                            }
                        }

                        if (service.opening_fitting.length != 0) {
                            service.opening_fitting[0].customer_dep = 100;
                            service.opening_fitting[0].insurance_dep = 0;
                        }

                        if (service.parts.length != 0) {
                            service.parts[0].customer_dep = 100;
                            service.parts[0].insurance_dep = 0;
                        }


                        packages.push({
                            package: service.package,
                            service: service.service,
                            labour: labours,
                            labour_cost: _.sumBy(labours, x => x.amount),
                            parts: service.parts,
                            discount: _.sumBy(labours, x => x.discount),
                            part_cost: parseFloat(service.part_cost),
                            opening_fitting: service.opening_fitting,
                            of_cost: parseFloat(service.of_cost),
                            exceeded_cost: 0,
                            mrp: parseFloat(service.mrp),
                            cost: parseFloat(service.part_cost) + _.sumBy(labours, x => x.amount),
                            doorstep: service.doorstep,
                            unit: service.unit,
                            quantity: quantity,
                            part_cost_editable: service.part_cost_editable,
                            labour_cost_editable: service.labour_cost_editable,
                            of_cost_editable: service.of_cost_editable,
                            type: service.type,
                            source: service.id,
                            description: service.description,
                            id: service.id,
                            _id: service._id
                        });

                        packageDiscountOn = []
                    });

                await Customization.find({ business: business, segment: car.model.segment, publish: true, service: new RegExp(req.body.service, "i"), business: business })
                    .cursor().eachAsync(async (service) => {
                        var getDiscount = {
                            booking: booking._id,
                            package: booking.package,
                            car: booking.car,
                            category: service.type,
                            service: service.service,
                            claim: claim,
                            tz: req.headers['tz'],
                        };
                        var package = await q.all(getPackageDiscount(getDiscount));
                        var labour_list = service.labour;
                        var labours = [];

                        var discount_eligible_labour_cost = _.sumBy(labour_list, x => x.amount);
                        if (labour_list.length > 0) {
                            for (var l = 0; l < labour_list.length; l++) {
                                /*var quantity = 1;*/
                                if (labour_list[l].quantity) {
                                    quantity = labour_list[l].quantity;
                                }

                                var discount_total = 0;
                                var total = 0;
                                var tax_info = await Tax.findOne({ tax: labour_list[l].tax }).exec();

                                var tax = [];
                                var rate = labour_list[l].rate;
                                var amount = parseFloat(labour_list[l].amount) * quantity;
                                var tax_rate = tax_info.detail;
                                var base = amount;

                                if (Object.keys(package).length > 0) {
                                    if (package.discount_type == "percent") {
                                        discount = parseFloat(package.discount);
                                        if (!isNaN(discount) && discount > 0) {
                                            var discount_total = amount * (discount / 100);
                                            amount = amount - parseFloat(discount_total.toFixed(2))
                                            if (amount < 0) {
                                                amount = 0
                                            }
                                        }
                                    }
                                    else if (package.discount_type == "fixed") {
                                        discount = parseFloat(package.discount);
                                        if (!isNaN(discount) && discount > 0) {
                                            var discount_total = (amount / discount_eligible_labour_cost) * discount;
                                            amount = parseFloat(discount_total.toFixed(2))
                                            discount = amount - discount_total;
                                            if (amount < 0) {
                                                amount = 0
                                            }
                                        }
                                    }
                                    else {
                                        discount = parseFloat(package.discount);
                                        if (!isNaN(discount) && discount > 0) {
                                            var discount_total = (amount / discount_eligible_labour_cost) * discount;
                                            amount = amount - parseFloat(discount_total.toFixed(2))
                                            if (amount < 0) {
                                                amount = 0
                                            }
                                        }
                                    }
                                }

                                if (labour_list[l].amount_is_tax == "inclusive") {
                                    var x = (100 + tax_info.rate) / 100;
                                    var tax_on_amount = amount / x;
                                    if (tax_rate.length > 0) {
                                        for (var r = 0; r < tax_rate.length; r++) {
                                            if (tax_rate[r].rate != tax_info.rate) {
                                                var t = tax_on_amount * (tax_rate[r].rate / 100);
                                                base = base - t;
                                                tax.push({
                                                    tax: tax_rate[r].tax,
                                                    rate: tax_rate[r].rate,
                                                    amount: parseFloat(t.toFixed(2))
                                                });
                                            }
                                            else {
                                                var t = amount - tax_on_amount;
                                                base = base - t;
                                                tax.push({
                                                    tax: tax_info.tax, tax_rate: tax_info.rate,
                                                    rate: tax_info.rate,
                                                    amount: parseFloat(t.toFixed(2))
                                                });
                                            }
                                        }

                                        //base = base - discount_total;
                                    }
                                    total = total + amount;
                                }

                                var tax_details = {
                                    tax: tax_info.tax,
                                    rate: tax_info.rate,
                                    amount: total,
                                    detail: tax
                                }


                                labours.push({
                                    item: labour_list[l].item,
                                    source: labour_list[l].source,
                                    rate: parseFloat(labour_list[l].rate),
                                    quantity: quantity,
                                    base: parseFloat(base.toFixed(2)),
                                    discount: parseFloat(discount_total.toFixed(2)),
                                    amount: total,
                                    customer_dep: 100,
                                    insurance_dep: 0,
                                    tax_amount: parseFloat(_.sumBy(tax, x => x.amount).toFixed(2)),
                                    amount_is_tax: labour_list[l].amount_is_tax,
                                    tax: tax_info.tax, tax_rate: tax_info.rate,
                                    tax_info: tax_details
                                });

                                // cconsole.logtoFixed(2))
                            }
                        }

                        if (service.opening_fitting.length != 0) {
                            service.opening_fitting[0].customer_dep = 100;
                            service.opening_fitting[0].insurance_dep = 0;
                        }

                        if (service.parts.length != 0) {
                            service.parts[0].customer_dep = 100;
                            service.parts[0].insurance_dep = 0;
                        }


                        packages.push({
                            package: service.package,
                            service: service.service,
                            labour: labours,
                            discount: _.sumBy(labours, x => x.discount),
                            labour_cost: _.sumBy(labours, x => x.amount),
                            parts: service.parts,
                            part_cost: parseFloat(service.part_cost),
                            opening_fitting: service.opening_fitting,
                            of_cost: parseFloat(service.of_cost),
                            exceeded_cost: 0,
                            mrp: parseFloat(service.mrp),
                            cost: parseFloat(service.part_cost) + _.sumBy(labours, x => x.amount),
                            doorstep: service.doorstep,
                            unit: service.unit,
                            quantity: quantity,
                            part_cost_editable: service.part_cost_editable,
                            labour_cost_editable: service.labour_cost_editable,
                            of_cost_editable: service.of_cost_editable,
                            type: service.type,
                            source: service.id,
                            description: service.description,
                            id: service.id,
                            _id: service._id
                        });

                        packageDiscountOn = []
                    });

                await Detailing.find({ business: business, segment: car.model.segment, publish: true, service: new RegExp(req.body.service, "i"), business: business })
                    .cursor().eachAsync(async (service) => {
                        var getDiscount = {
                            booking: booking._id,
                            package: booking.package,
                            car: booking.car,
                            category: service.type,
                            service: service.service,
                            claim: claim,
                            tz: req.headers['tz'],
                        };
                        var package = await q.all(getPackageDiscount(getDiscount));

                        var labour_list = service.labour;
                        var labours = [];

                        var discount_eligible_labour_cost = _.sumBy(labour_list, x => x.amount);
                        if (labour_list.length > 0) {
                            for (var l = 0; l < labour_list.length; l++) {
                                var discount_total = 0;
                                var total = 0;
                                var tax_info = await Tax.findOne({ tax: labour_list[l].tax }).exec();

                                var tax = [];
                                var rate = labour_list[l].rate;
                                var amount = parseFloat(labour_list[l].amount) * quantity;
                                var tax_rate = tax_info.detail;
                                var base = amount;

                                if (Object.keys(package).length > 0) {
                                    if (package.discount_type == "percent") {
                                        discount = parseFloat(package.discount);
                                        if (!isNaN(discount) && discount > 0) {
                                            var discount_total = amount * (discount / 100);
                                            amount = amount - parseFloat(discount_total.toFixed(2))
                                            if (amount < 0) {
                                                amount = 0
                                            }
                                        }
                                    }
                                    else if (package.discount_type == "fixed") {
                                        discount = parseFloat(package.discount);
                                        if (!isNaN(discount) && discount > 0) {
                                            var discount_total = (amount / discount_eligible_labour_cost) * discount;
                                            amount = parseFloat(discount_total.toFixed(2))
                                            discount = amount - discount_total;
                                            if (amount < 0) {
                                                amount = 0
                                            }
                                        }
                                    }
                                    else {
                                        discount = parseFloat(package.discount);
                                        if (!isNaN(discount) && discount > 0) {
                                            var discount_total = (amount / discount_eligible_labour_cost) * discount;
                                            amount = amount - parseFloat(discount_total.toFixed(2))
                                            if (amount < 0) {
                                                amount = 0
                                            }
                                        }
                                    }
                                }


                                if (labour_list[l].amount_is_tax == "inclusive") {
                                    var x = (100 + tax_info.rate) / 100;
                                    var tax_on_amount = amount / x;
                                    if (tax_rate.length > 0) {
                                        for (var r = 0; r < tax_rate.length; r++) {
                                            if (tax_rate[r].rate != tax_info.rate) {
                                                var t = tax_on_amount * (tax_rate[r].rate / 100);
                                                base = base - t;
                                                tax.push({
                                                    tax: tax_rate[r].tax,
                                                    rate: tax_rate[r].rate,
                                                    amount: parseFloat(t.toFixed(2))
                                                });
                                            }
                                            else {
                                                var t = amount - tax_on_amount;
                                                base = base - t;
                                                tax.push({
                                                    tax: tax_info.tax, tax_rate: tax_info.rate,
                                                    rate: tax_info.rate,
                                                    amount: parseFloat(t.toFixed(2))
                                                });
                                            }
                                        }

                                        //base = base - discount_total;
                                    }
                                    total = total + amount;
                                }

                                var tax_details = {
                                    tax: tax_info.tax,
                                    rate: tax_info.rate,
                                    amount: total,
                                    detail: tax
                                }


                                labours.push({
                                    item: labour_list[l].item,
                                    source: labour_list[l].source,
                                    rate: parseFloat(labour_list[l].rate),
                                    quantity: quantity,
                                    base: parseFloat(base.toFixed(2)),
                                    discount: parseFloat(discount_total.toFixed(2)),
                                    amount: total,
                                    customer_dep: 100,
                                    insurance_dep: 0,
                                    tax_amount: parseFloat(_.sumBy(tax, x => x.amount).toFixed(2)),
                                    amount_is_tax: labour_list[l].amount_is_tax,
                                    tax: tax_info.tax, tax_rate: tax_info.rate,
                                    tax_info: tax_details
                                });
                            }
                        }

                        if (service.opening_fitting.length != 0) {
                            service.opening_fitting[0].customer_dep = 100;
                            service.opening_fitting[0].insurance_dep = 0;
                        }

                        if (service.parts.length != 0) {
                            service.parts[0].customer_dep = 100;
                            service.parts[0].insurance_dep = 0;
                        }



                        packages.push({
                            package: service.package,
                            service: service.service,
                            labour: labours,
                            discount: _.sumBy(labours, x => x.discount),
                            labour_cost: _.sumBy(labours, x => x.amount),
                            parts: service.parts,
                            part_cost: parseFloat(service.part_cost),
                            opening_fitting: service.opening_fitting,
                            of_cost: parseFloat(service.of_cost),
                            exceeded_cost: 0,
                            mrp: parseFloat(service.mrp),
                            cost: parseFloat(service.part_cost) + _.sumBy(labours, x => x.amount),
                            doorstep: service.doorstep,
                            unit: service.unit,
                            quantity: quantity,
                            part_cost_editable: service.part_cost_editable,
                            labour_cost_editable: service.labour_cost_editable,
                            of_cost_editable: service.of_cost_editable,
                            type: service.type,
                            source: service.id,
                            description: service.description,
                            id: service.id,
                            _id: service._id
                        });

                        packageDiscountOn = []
                    });

                res.status(200).json({
                    responseCode: 200,
                    responseMessage: "",
                    responseData: packages
                });
            }
            else {
                res.status(400).json({
                    responseCode: 400,
                    responseMessage: "Car not found",
                    responseData: {}
                });
            }
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Booking not found",
                responseData: {}
            });
        }
    }
});

router.get('/user/packages/get', xAccessToken.token, async function (req, res, next) {
    var rules = {
        type: 'required',
        query: 'required',
    };

    var validation = new Validator(req.query, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Validation Error",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var business = req.headers['business'];
        var labour_cost = 0;
        var part_cost = 0;
        var of_cost = 0;
        var due_amount = 0;
        var totalResult = 0;
        var bookingService = [];

        if (req.query.type == "booking") {
            var booking = await Booking.findById(req.query.query).exec();
            if (booking) {
                var user = booking.user;
                var car = booking.car;
                var packages = [];

                var purchased = [];

                await UserPackage.find({ user: user, business: business, $or: [{ car: car }, { car: null }] }).cursor().eachAsync(async (package) => {
                    var serverTime = moment.tz(new Date(), req.headers['tz']);
                    var bar = package.created_at;
                    bar.setDate(bar.getDate() + package.validity);
                    var e = bar;
                    bar = moment.tz(bar, req.headers['tz'])

                    var baz = bar.diff(serverTime);
                    if (baz > 0) {
                        purchased.push(package._id);
                        packages.push({
                            package: package._id,
                            name: package.name,
                            description: package.description,
                            payment: package.payment,
                            discount: package.discount,
                            type: "package",
                            cost: package.cost,
                            id: package._id,
                            _id: package._id,
                            category: package.category,
                            label: package.label,
                            validity: package.validity,
                            expired_at: moment(e).tz(req.headers['tz']).format('ll'),
                            listing: "purchased"
                        });
                    }
                });

                await Package.find({ label: "special" }).cursor().eachAsync(async (service) => {
                    var serverTime = moment.tz(new Date(), req.headers['tz']);

                    var bar = service.created_at;
                    bar.setDate(bar.getDate() + service.validity);

                    var e = bar;
                    bar = moment.tz(bar, req.headers['tz'])

                    var baz = bar.diff(serverTime);

                    var check = await UserPackage.find({ user: user, package: service._id, car: car.car }).count().exec();
                    if (check <= 0) {
                        if (baz > 0) {
                            packages.push({
                                package: service._id,
                                name: service.name + ' - (Package)',
                                mrp: 0,
                                discount: service.discount,
                                labour_cost: service.cost,
                                part_cost: 0,
                                type: "package",
                                cost: service.cost,
                                id: service.id,
                                _id: service._id,
                                label: service.label,
                                doorstep: false,
                                validity: service.validity,
                                doorstep: service.doorstep,
                                expired_at: moment(service.expired_at).tz(req.headers['tz']).format('ll'),
                                listing: "new"
                            });
                        }
                    }
                });

                res.status(200).json({
                    responseCode: 200,
                    responseMessage: "",
                    responseData: packages
                });
            }
            else {
                res.status(400).json({
                    responseCode: 400,
                    responseMessage: "Booking not found",
                    responseData: {}
                });
            }
        }
        else if (req.query.type == "user") {
            var booking = await Booking.findById(req.query.query).exec();
            if (booking) {
                var user = booking.user;
                var car = booking.car;
                var packages = [];

                var purchased = [];

                await UserPackage.find({ user: user, car: car, business: business }).cursor().eachAsync(async (package) => {
                    var serverTime = moment.tz(new Date(), req.headers['tz']);
                    var bar = package.created_at;
                    bar.setDate(bar.getDate() + package.validity);
                    var e = bar;
                    bar = moment.tz(bar, req.headers['tz'])

                    var baz = bar.diff(serverTime);
                    if (baz > 0) {
                        purchased.push(package._id);
                        packages.push({
                            package: package._id,
                            name: package.name,
                            description: package.description,
                            payment: package.payment,
                            discount: package.discount,
                            type: "package",
                            cost: package.cost,
                            id: package._id,
                            _id: package._id,
                            category: package.category,
                            label: package.label,
                            validity: package.validity,
                            expired_at: moment(e).tz(req.headers['tz']).format('ll'),
                            listing: "purchased"
                        });
                    }
                });

                await Package.find({ label: "special" }).cursor().eachAsync(async (service) => {
                    var serverTime = moment.tz(new Date(), req.headers['tz']);

                    var bar = service.created_at;
                    bar.setDate(bar.getDate() + service.validity);

                    var e = bar;
                    bar = moment.tz(bar, req.headers['tz'])

                    var baz = bar.diff(serverTime);

                    var check = await UserPackage.find({ user: user, package: service._id, car: car.car }).count().exec();
                    if (check <= 0) {
                        if (baz > 0) {
                            packages.push({
                                package: service._id,
                                service: service.name,
                                mrp: 0,
                                discount: service.discount,
                                labour_cost: service.cost,
                                part_cost: 0,
                                type: "package",
                                cost: service.cost,
                                id: service.id,
                                _id: service._id,
                                label: service.label,
                                doorstep: false,
                                validity: service.validity,
                                doorstep: service.doorstep,
                                expired_at: moment(service.expired_at).tz(req.headers['tz']).format('ll'),
                                listing: "new"
                            });
                        }
                    }
                });

                res.status(200).json({
                    responseCode: 200,
                    responseMessage: "",
                    responseData: packages
                });
            }
            else {
                res.status(400).json({
                    responseCode: 400,
                    responseMessage: "Booking not found",
                    responseData: {}
                });
            }
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Packages not found",
                responseData: {}
            })
        }
    }
});

router.post('/booking/package/add', xAccessToken.token, async function (req, res, next) {
    var rules = {
        booking: 'required',
        listing: 'required',
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Validation Error",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var business = req.headers['business'];
        var labour_cost = 0;
        var part_cost = 0;
        var of_cost = 0;
        var due_amount = 0;
        var totalResult = 0;
        var bookingService = [];
        var booking = await Booking.findById(req.body.booking).exec();
        if (booking) {
            if (booking.insurance_info) {
                if (booking.insurance_info.claim == true) {
                    var claim = true;
                }
                else {
                    var claim = false;
                }
            }
            else {
                var claim = false;
            }

            var listing = req.body.listing;

            if (claim == false) {
                if (listing == "purchased") {
                    var package = await UserPackage.findOne({ user: booking.user, _id: req.body.package }).exec();
                    if (package) {
                        Booking.findOneAndUpdate({ _id: booking._id }, { $set: { package: package._id } }, { new: false }, async function (err, doc) {
                            if (err) {
                                res.status(400).json({
                                    responseCode: 400,
                                    responseMessage: "Error Occurred! Try again.",
                                    responseData: {}
                                });
                            }
                            else {
                                var updated = await Booking.findById(req.body.booking).exec();
                                var services = updated.services;

                                for (var i = 0; i < services.length; i++) {
                                    if (services[i].claim == true) {
                                        bookingService.push(services[i])
                                    }
                                    else {
                                        var getDiscount = {
                                            booking: updated._id,
                                            package: updated.package,
                                            car: updated.car,
                                            category: services[i].type,
                                            service: services[i].service,
                                            claim: services[i].claim,
                                            tz: req.headers['tz']
                                        };

                                        var package = await q.all(getPackageDiscount(getDiscount));

                                        var labour_list = services[i].labour;
                                        var labours = [];

                                        var discount_eligible_labour_cost = _.sumBy(labour_list, x => x.rate * x.quantity);
                                        if (labour_list.length > 0) {
                                            for (var l = 0; l < labour_list.length; l++) {
                                                var discount = req.body.discount;
                                                var discount_total = 0;
                                                var total = 0;
                                                var tax_info = await Tax.findOne({ tax: labour_list[l].tax }).exec();

                                                var tax = [];
                                                var rate = labour_list[l].rate;
                                                var amount = parseFloat(labour_list[l].rate) * parseFloat(labour_list[l].quantity);
                                                var tax_rate = tax_info.detail;
                                                var base = amount;

                                                if (Object.keys(package).length > 0) {
                                                    // cconsole.log
                                                    if (package.discount_type == "percent") {
                                                        discount = parseFloat(package.discount);
                                                        if (!isNaN(discount) && discount > 0) {
                                                            var discount_total = amount * (discount / 100);
                                                            amount = amount - parseFloat(discount_total.toFixed(2))
                                                            if (amount < 0) {
                                                                amount = 0
                                                            }
                                                        }
                                                    }
                                                    else if (package.discount_type == "fixed") {
                                                        discount = parseFloat(package.discount);
                                                        if (!isNaN(discount) && discount > 0) {
                                                            var discount_total = (amount / discount_eligible_labour_cost) * discount;
                                                            amount = parseFloat(discount_total.toFixed(2))
                                                            discount = amount - discount_total;
                                                            if (amount < 0) {
                                                                amount = 0
                                                            }
                                                        }
                                                    }
                                                    else {
                                                        discount = parseFloat(package.discount);
                                                        if (!isNaN(discount) && discount > 0) {
                                                            var discount_total = (amount / discount_eligible_labour_cost) * discount;
                                                            amount = amount - parseFloat(discount_total.toFixed(2))
                                                            if (amount < 0) {
                                                                amount = 0
                                                            }
                                                        }
                                                    }
                                                }

                                                if (labour_list[l].amount_is_tax == "exclusive") {
                                                    var tax_on_amount = amount;
                                                    if (tax_rate.length > 0) {
                                                        for (var r = 0; r < tax_rate.length; r++) {
                                                            if (tax_rate[r].rate != tax_info.rate) {
                                                                var t = tax_on_amount * (tax_rate[r].rate / 100);
                                                                amount = amount + t;
                                                                tax.push({
                                                                    tax: tax_rate[r].tax,
                                                                    rate: tax_rate[r].rate,
                                                                    amount: parseFloat(t.toFixed(2))
                                                                });
                                                            }
                                                            else {
                                                                var t = tax_on_amount * (tax_rate[r].rate / 100);
                                                                amount = amount + t;
                                                                tax.push({
                                                                    tax: tax_info.tax, tax_rate: tax_info.rate,
                                                                    rate: tax_info.rate,
                                                                    amount: parseFloat(t.toFixed(2))
                                                                });
                                                            }
                                                        }
                                                    }
                                                    total = total + amount;
                                                }

                                                if (labour_list[l].amount_is_tax == "inclusive") {
                                                    var x = (100 + tax_info.rate) / 100;
                                                    var tax_on_amount = amount / x;
                                                    if (tax_rate.length > 0) {
                                                        for (var r = 0; r < tax_rate.length; r++) {
                                                            if (tax_rate[r].rate != tax_info.rate) {
                                                                var t = tax_on_amount * (tax_rate[r].rate / 100);
                                                                base = base - t;
                                                                tax.push({
                                                                    tax: tax_rate[r].tax,
                                                                    rate: tax_rate[r].rate,
                                                                    amount: parseFloat(t.toFixed(2))
                                                                });
                                                            }
                                                            else {
                                                                var t = amount - tax_on_amount;
                                                                base = base - t;
                                                                tax.push({
                                                                    tax: tax_info.tax, tax_rate: tax_info.rate,
                                                                    rate: tax_info.rate,
                                                                    amount: parseFloat(t.toFixed(2))
                                                                });
                                                            }
                                                        }
                                                        //base = base - discount_total;
                                                    }
                                                    total = total + amount;
                                                }

                                                var tax_details = {
                                                    tax: tax_info.tax,
                                                    rate: tax_info.rate,
                                                    amount: total,
                                                    detail: tax
                                                }

                                                if (!labour_list[l].customer_dep) {
                                                    customer_dep = 100
                                                }
                                                else {
                                                    customer_dep = labour_list[l].customer_dep;
                                                }


                                                if (!labour_list[l].insurance_dep) {
                                                    insurance_dep = 0
                                                }
                                                else {
                                                    insurance_dep = labour_list[l].insurance_dep;
                                                }

                                                labours.push({
                                                    item: labour_list[l].item,
                                                    source: labour_list[l].source,
                                                    rate: parseFloat(labour_list[l].rate),
                                                    quantity: parseFloat(labour_list[l].quantity),
                                                    base: parseFloat(base.toFixed(2)),
                                                    discount: parseFloat(discount_total.toFixed(2)),
                                                    amount: total,
                                                    customer_dep: customer_dep,
                                                    insurance_dep: insurance_dep,
                                                    tax_amount: parseFloat(_.sumBy(tax, x => x.amount).toFixed(2)),
                                                    amount_is_tax: labour_list[l].amount_is_tax,
                                                    tax: tax_info.tax,
                                                    tax_rate: tax_info.rate,
                                                    tax_info: tax_details
                                                });

                                                // cconsole.logrs)
                                            }

                                            bookingService.push({
                                                part_cost: services[i].part_cost,
                                                labour_cost: _.sumBy(labours, x => x.amount),
                                                of_cost: services[i].of_cost,
                                                exceeded_cost: services[i].exceeded_cost,
                                                part_rate: services[i].part_rate,
                                                labour_rate: services[i].labour_rate,
                                                quantity: services[i].quantity,
                                                of_rate: services[i].of_rate,
                                                parts: services[i].parts,
                                                labour: labours,
                                                cost: services[i].part_cost + _.sumBy(labours, x => x.amount) + services[i].of_cost,
                                                discount: _.sumBy(labours, x => x.discount) + _.sumBy(services[i].opening_fitting, x => x.discount) + _.sumBy(services[i].parts, x => x.discount),
                                                opening_fitting: services[i].opening_fitting,
                                                part_cost_editable: services[i].part_cost_editable,
                                                labour_cost_editable: services[i].part_cost_editable,
                                                of_cost_editable: services[i].part_cost_editable,
                                                description: services[i].description,
                                                service: services[i].service,
                                                type: services[i].type,
                                                claim: services[i].claim,
                                                custom: services[i].custom,
                                                customer_approval: services[i].customer_approval, surveyor_approval: services[i].surveyor_approval,
                                                source: services[i].source,
                                            });
                                        }
                                    }
                                }

                                var policy_clause = 0
                                if (booking.payment.policy_clause) {
                                    policy_clause = booking.payment.policy_clause;
                                }
                                var salvage = 0
                                if (booking.payment.salvage) {
                                    salvage = booking.payment.salvage;
                                }

                                var approved = _.filter(bookingService, customer_approval => customer_approval.customer_approval == true);

                                var labour_cost = _.sumBy(bookingService, x => x.labour_cost);
                                var part_cost = _.sumBy(bookingService, x => x.part_cost);
                                var of_cost = _.sumBy(bookingService, x => x.of_cost);
                                var discount_total = _.sumBy(bookingService, x => x.discount);
                                var pick_up_charges = booking.payment.pick_up_charges;

                                var paid_total = booking.payment.paid_total;

                                var careager_cash = await q.all(fun.getBookingCarEagerCash(booking._id));

                                var payment_total = labour_cost + part_cost + of_cost + discount_total + policy_clause + salvage + pick_up_charges;

                                var estimate_cost = labour_cost + part_cost + of_cost + policy_clause + salvage + pick_up_charges - careager_cash;

                                var due_amount = _.sumBy(approved, x => x.labour_cost) + _.sumBy(approved, x => x.part_cost) + _.sumBy(approved, x => x.of_cost) + policy_clause + salvage + pick_up_charges - (paid_total + careager_cash);

                                var due = {
                                    due: Math.ceil(due_amount.toFixed(2))
                                };

                                var payment = {
                                    total: payment_total,
                                    careager_cash: careager_cash,
                                    estimate_cost: estimate_cost,
                                    of_cost: of_cost,
                                    labour_cost: labour_cost,
                                    part_cost: part_cost,
                                    payment_mode: booking.payment.payment_mode,
                                    payment_status: booking.payment.payment_status,
                                    coupon: "",
                                    coupon_type: "",
                                    discount_by: "",
                                    discount_type: "Package",
                                    discount: discount_total,
                                    discount_total: discount_total,
                                    policy_clause: policy_clause,
                                    salvage: salvage,
                                    terms: booking.payment.terms,
                                    pick_up_limit: booking.payment.pick_up_limit,
                                    pick_up_charges: booking.payment.pick_up_charges,
                                    paid_total: parseFloat(booking.payment.paid_total),
                                    discount_applied: booking.payment.discount_applied,
                                    transaction_id: booking.payment.transaction_id,
                                    transaction_date: booking.payment.transaction_date,
                                    transaction_status: booking.payment.transaction_status,
                                    transaction_response: booking.payment.transaction_response
                                };


                                Booking.findOneAndUpdate({ _id: req.body.booking }, { $set: { services: bookingService, payment: payment, due: due } }, { new: false }, async function (err, doc) {
                                    if (err) {
                                        res.status(400).json({
                                            responseCode: 400,
                                            responseMessage: "Error 1",
                                            responseData: err
                                        });
                                    }
                                    else {
                                        var updated = await Booking.findById(req.body.booking).exec();
                                        res.status(200).json({
                                            responseCode: 200,
                                            responseMessage: "Package has been applied",
                                            responseData: updated
                                        });
                                    }
                                });
                            }
                        });
                    }
                    else {
                        res.status(400).json({
                            responseCode: 400,
                            responseMessage: "Package not found",
                            responseData: {}
                        });
                    }
                }
                else if (listing == "new") {
                    var getPackage = await Package.findOne({ _id: req.body.package }).exec();
                    if (getPackage) {
                        var expired_at = new Date();
                        expired_at.setDate(expired_at.getDate() + getPackage.validity);
                        var check = await UserPackage.find({ package: req.body.package, user: booking.user, car: booking.car }).exec();

                        if (check <= 0) {
                            UserPackage.create({
                                user: booking.user,
                                car: booking.car,
                                name: getPackage.name,
                                booking: booking._id,
                                business: booking.business,
                                description: getPackage.description,
                                category: getPackage.category,
                                package: getPackage._id,
                                payment: {
                                    total: getPackage.cost,
                                    paid_total: getPackage.cost,
                                },
                                discount: getPackage.discount,
                                validity: getPackage.validity,
                                expired_at: expired_at,
                                status: false,
                                created_at: new Date(),
                                updated_at: new Date()
                            }).then(async function (package) {

                                var package_array = [];
                                var tax_info = await Tax.findOne({ tax: "18.0% GST" }).exec();
                                var tax_rate = tax_info.detail;

                                var amount = parseFloat(getPackage.cost);
                                var base = amount;
                                var package_tax = [];

                                var x = (100 + tax_info.rate) / 100;
                                var tax_on_amount = amount / x;
                                if (tax_rate.length > 0) {
                                    for (var r = 0; r < tax_rate.length; r++) {
                                        if (tax_rate[r].rate != tax_info.rate) {
                                            var t = tax_on_amount * (tax_rate[r].rate / 100);
                                            base = base - t
                                            package_tax.push({
                                                tax: tax_rate[r].tax,
                                                rate: parseFloat(tax_rate[r].rate.toFixed(2)),
                                                amount: parseFloat(t.toFixed(2))
                                            })
                                        }
                                        else {
                                            base = base - t
                                            package_tax.push({
                                                tax: tax_info.tax, tax_rate: tax_info.rate,
                                                rate: parseFloat(tax_info.rate.toFixed(2)),
                                                amount: parseFloat(tax_on_amount.toFixed(2))
                                            })
                                        }
                                    }
                                }

                                package_array.push({
                                    item: getPackage.name,
                                    quantity: 1,
                                    rate: parseFloat(getPackage.cost),
                                    base: parseFloat(base.toFixed(2)),
                                    amount: parseFloat(amount),
                                    discount: 0,
                                    amount_is_tax: "inclusive",
                                    tax_amount: _.sumBy(package_tax, x => x.amount),
                                    tax: tax_info.tax, tax_rate: tax_info.rate,
                                    tax_info: {
                                        tax: tax_info.tax, tax_rate: tax_info.rate,
                                        rate: tax_info.rate,
                                        base: parseFloat(base.toFixed(2)),
                                        detail: package_tax
                                    }
                                });

                                var service = {
                                    source: package._id,
                                    service: getPackage.name,
                                    description: package.description,
                                    cost: parseFloat(getPackage.cost),
                                    labour_cost: parseFloat(getPackage.cost),
                                    labour: package_array,
                                    part_cost: 0,
                                    parts: [],
                                    opening_fitting: [],
                                    of_cost: 0,
                                    custom: false,
                                    claim: false,
                                    discount: 0,
                                    part_cost_editable: false,
                                    labour_cost_editable: false,
                                    of_cost_editable: false,
                                    customer_approval: false,
                                    surveyor_approval: false,
                                    type: "package"
                                };

                                bookingService.push(service)

                                Booking.findOneAndUpdate({ _id: req.body.booking }, { $set: { package: package._id } }, { new: false }, async function (err, doc) {

                                    var updated = await Booking.findById(req.body.booking).exec();

                                    var services = updated.services;

                                    if (services.length > 0) {
                                        for (var i = 0; i < services.length; i++) {
                                            if (services[i].claim == true) {
                                                bookingService.push(services[i])
                                            }
                                            else {
                                                var getDiscount = {
                                                    booking: updated._id,
                                                    package: updated.package,
                                                    car: updated.car,
                                                    category: services[i].type,
                                                    service: services[i].service,
                                                    claim: services[i].claim,
                                                    tz: req.headers['tz']
                                                };

                                                var package = await q.all(getPackageDiscount(getDiscount));

                                                var labour_list = services[i].labour;
                                                var labours = [];

                                                var discount_eligible_labour_cost = _.sumBy(labour_list, x => x.rate * x.quantity);
                                                if (labour_list.length > 0) {
                                                    for (var l = 0; l < labour_list.length; l++) {
                                                        var discount = req.body.discount;
                                                        var discount_total = 0;
                                                        var total = 0;
                                                        var tax_info = await Tax.findOne({ tax: labour_list[l].tax }).exec();

                                                        var tax = [];
                                                        var rate = labour_list[l].rate;
                                                        var amount = parseFloat(labour_list[l].rate) * parseFloat(labour_list[l].quantity);
                                                        var tax_rate = tax_info.detail;
                                                        var base = amount;

                                                        if (Object.keys(package).length > 0) {
                                                            if (package.discount_type == "percent") {
                                                                discount = parseFloat(package.discount);
                                                                if (!isNaN(discount) && discount > 0) {
                                                                    var discount_total = amount * (discount / 100);
                                                                    amount = amount - parseFloat(discount_total.toFixed(2))
                                                                    if (amount < 0) {
                                                                        amount = 0
                                                                    }
                                                                }
                                                            }
                                                            else if (package.discount_type == "fixed") {
                                                                discount = parseFloat(package.discount);
                                                                if (!isNaN(discount) && discount > 0) {
                                                                    var discount_total = (amount / discount_eligible_labour_cost) * discount;
                                                                    amount = parseFloat(discount_total.toFixed(2))
                                                                    discount = amount - discount_total;
                                                                    if (amount < 0) {
                                                                        amount = 0
                                                                    }
                                                                }
                                                            }
                                                            else {
                                                                discount = parseFloat(package.discount);
                                                                if (!isNaN(discount) && discount > 0) {
                                                                    var discount_total = (amount / discount_eligible_labour_cost) * discount;
                                                                    amount = amount - parseFloat(discount_total.toFixed(2))
                                                                    if (amount < 0) {
                                                                        amount = 0
                                                                    }
                                                                }
                                                            }
                                                        }

                                                        if (labour_list[l].amount_is_tax == "exclusive") {
                                                            var tax_on_amount = amount;
                                                            if (tax_rate.length > 0) {
                                                                for (var r = 0; r < tax_rate.length; r++) {
                                                                    if (tax_rate[r].rate != tax_info.rate) {
                                                                        var t = tax_on_amount * (tax_rate[r].rate / 100);
                                                                        amount = amount + t;
                                                                        tax.push({
                                                                            tax: tax_rate[r].tax,
                                                                            rate: tax_rate[r].rate,
                                                                            amount: parseFloat(t.toFixed(2))
                                                                        });
                                                                    }
                                                                    else {
                                                                        var t = tax_on_amount * (tax_rate[r].rate / 100);
                                                                        amount = amount + t;
                                                                        tax.push({
                                                                            tax: tax_info.tax, tax_rate: tax_info.rate,
                                                                            rate: tax_info.rate,
                                                                            amount: parseFloat(t.toFixed(2))
                                                                        });
                                                                    }
                                                                }
                                                            }
                                                            total = total + amount;
                                                        }

                                                        if (labour_list[l].amount_is_tax == "inclusive") {
                                                            var x = (100 + tax_info.rate) / 100;
                                                            var tax_on_amount = amount / x;
                                                            if (tax_rate.length > 0) {
                                                                for (var r = 0; r < tax_rate.length; r++) {
                                                                    if (tax_rate[r].rate != tax_info.rate) {
                                                                        var t = tax_on_amount * (tax_rate[r].rate / 100);
                                                                        base = base - t;
                                                                        tax.push({
                                                                            tax: tax_rate[r].tax,
                                                                            rate: tax_rate[r].rate,
                                                                            amount: parseFloat(t.toFixed(2))
                                                                        });
                                                                    }
                                                                    else {
                                                                        var t = amount - tax_on_amount;
                                                                        base = base - t;
                                                                        tax.push({
                                                                            tax: tax_info.tax, tax_rate: tax_info.rate,
                                                                            rate: tax_info.rate,
                                                                            amount: parseFloat(t.toFixed(2))
                                                                        });
                                                                    }
                                                                }

                                                                //base = base - discount_total;
                                                            }
                                                            total = total + amount;
                                                        }

                                                        var tax_details = {
                                                            tax: tax_info.tax,
                                                            rate: tax_info.rate,
                                                            amount: total,
                                                            detail: tax
                                                        }

                                                        // cconsole.logunt_total)
                                                        if (!labour_list[l].customer_dep) {
                                                            customer_dep = 100
                                                        }
                                                        else {
                                                            customer_dep = labour_list[l].customer_dep;
                                                        }


                                                        if (!labour_list[l].insurance_dep) {
                                                            insurance_dep = 0
                                                        }
                                                        else {
                                                            insurance_dep = labour_list[l].insurance_dep;
                                                        }


                                                        labours.push({
                                                            item: labour_list[l].item,
                                                            source: labour_list[l].source,
                                                            rate: parseFloat(labour_list[l].rate),
                                                            quantity: parseFloat(labour_list[l].quantity),
                                                            base: parseFloat(base.toFixed(2)),
                                                            discount: parseFloat(discount_total.toFixed(2)),
                                                            amount: total,
                                                            customer_dep: customer_dep,
                                                            insurance_dep: insurance_dep,
                                                            tax_amount: parseFloat(_.sumBy(tax, x => x.amount).toFixed(2)),
                                                            amount_is_tax: labour_list[l].amount_is_tax,
                                                            tax: tax_info.tax, tax_rate: tax_info.rate,
                                                            tax_info: tax_details
                                                        });
                                                    }

                                                    bookingService.push({
                                                        part_cost: services[i].part_cost,
                                                        labour_cost: _.sumBy(labours, x => x.amount),
                                                        of_cost: services[i].of_cost,
                                                        exceeded_cost: services[i].exceeded_cost,
                                                        part_rate: services[i].part_rate,
                                                        labour_rate: services[i].labour_rate,
                                                        quantity: services[i].quantity,
                                                        of_rate: services[i].of_rate,
                                                        parts: services[i].parts,
                                                        labour: labours,
                                                        cost: services[i].part_cost + _.sumBy(labours, x => x.amount) + services[i].of_cost,
                                                        discount: _.sumBy(labours, x => x.discount) + _.sumBy(services[i].opening_fitting, x => x.discount) + _.sumBy(services[i].parts, x => x.discount),
                                                        opening_fitting: services[i].opening_fitting,
                                                        part_cost_editable: services[i].part_cost_editable,
                                                        labour_cost_editable: services[i].part_cost_editable,
                                                        of_cost_editable: services[i].part_cost_editable,
                                                        description: services[i].description,
                                                        service: services[i].service,
                                                        type: services[i].type,
                                                        custom: services[i].custom,
                                                        claim: services[i].claim,
                                                        customer_approval: services[i].customer_approval,
                                                        surveyor_approval: services[i].surveyor_approval,
                                                        source: services[i].source,
                                                    });
                                                }
                                            }
                                        }
                                    }

                                    var policy_clause = 0
                                    if (booking.payment.policy_clause) {
                                        policy_clause = booking.payment.policy_clause;
                                    }
                                    var salvage = 0
                                    if (booking.payment.salvage) {
                                        salvage = booking.payment.salvage;
                                    }

                                    var approved = _.filter(bookingService, customer_approval => customer_approval.customer_approval == true);

                                    var paid_total = booking.payment.paid_total;

                                    var labour_cost = _.sumBy(bookingService, x => x.labour_cost);
                                    var part_cost = _.sumBy(bookingService, x => x.part_cost);
                                    var of_cost = _.sumBy(bookingService, x => x.of_cost);
                                    var discount_total = _.sumBy(bookingService, x => x.discount);
                                    var pick_up_charges = booking.payment.pick_up_charges;
                                    var careager_cash = await q.all(fun.getBookingCarEagerCash(booking._id));

                                    var payment_total = labour_cost + part_cost + of_cost + discount_total + policy_clause + salvage + pick_up_charges;

                                    var estimate_cost = labour_cost + part_cost + of_cost + policy_clause + salvage + pick_up_charges - careager_cash;
                                    var due_amount = _.sumBy(approved, x => x.labour_cost) + _.sumBy(approved, x => x.part_cost) + _.sumBy(approved, x => x.of_cost) + policy_clause + salvage + pick_up_charges - (paid_total + careager_cash);

                                    var due = {
                                        due: Math.ceil(due_amount.toFixed(2))
                                    }

                                    var payment = {
                                        estimate_cost: estimate_cost,
                                        total: payment_total,
                                        careager_cash: careager_cash,
                                        of_cost: of_cost,
                                        labour_cost: labour_cost,
                                        part_cost: part_cost,
                                        payment_mode: booking.payment.payment_mode,
                                        payment_status: booking.payment.payment_status,
                                        coupon: "",
                                        coupon_type: "",
                                        discount_by: "",
                                        discount_type: "Package",
                                        discount: discount_total,
                                        discount_total: discount_total,
                                        policy_clause: policy_clause,
                                        salvage: salvage,
                                        terms: booking.payment.terms,
                                        pick_up_limit: booking.payment.pick_up_limit,
                                        pick_up_charges: booking.payment.pick_up_charges,
                                        paid_total: parseFloat(booking.payment.paid_total),
                                        discount_applied: booking.payment.discount_applied,
                                        transaction_id: booking.payment.transaction_id,
                                        transaction_date: booking.payment.transaction_date,
                                        transaction_status: booking.payment.transaction_status,
                                        transaction_response: booking.payment.transaction_response
                                    };

                                    Booking.findOneAndUpdate({ _id: req.body.booking }, { $set: { services: bookingService, payment: payment, due: due } }, { new: false }, async function (err, doc) {
                                        if (err) {
                                            res.status(400).json({
                                                responseCode: 400,
                                                responseMessage: "Error",
                                                responseData: err
                                            });
                                        }
                                        else {
                                            var updated = await Booking.findById(req.body.booking).exec();
                                            res.status(200).json({
                                                responseCode: 200,
                                                responseMessage: "Package has been applied",
                                                responseData: updated
                                            });
                                        }
                                    });
                                });
                            });
                        }
                        else {
                            res.status(400).json({
                                responseCode: 400,
                                responseMessage: "Package has been already applied",
                                responseData: {}
                            });
                        }
                    }
                    else {
                        res.status(400).json({
                            responseCode: 400,
                            responseMessage: "Package not found",
                            responseData: {}
                        });
                    }
                }
                else {
                    Booking.findOneAndUpdate({ _id: booking._id }, { $set: { package: null } }, { new: false }, async function (err, doc) {
                        if (err) {
                            res.status(400).json({
                                responseCode: 400,
                                responseMessage: "Error Occurred! Try again.",
                                responseData: {}
                            });
                        }
                        else {
                            await UserPackage.remove({ user: booking.user, status: false }).exec();

                            var updated = await Booking.findById(req.body.booking).exec();
                            var services = updated.services;

                            for (var i = 0; i < services.length; i++) {
                                if (services[i].type != "package") {
                                    if (services[i].claim == true) {
                                        bookingService.push(services[i])
                                    }
                                    else {
                                        var getDiscount = {
                                            booking: updated._id,
                                            package: null,
                                            car: updated.car,
                                            category: services[i].type,
                                            service: services[i].service,
                                            claim: services[i].claim,
                                            tz: req.headers['tz']
                                        };

                                        var package = await q.all(getPackageDiscount(getDiscount));

                                        var labour_list = services[i].labour;
                                        var labours = [];

                                        var discount_eligible_labour_cost = _.sumBy(labour_list, x => x.rate * x.quantity);
                                        // cconsole.logunt_eligible_labour_cost)
                                        if (labour_list.length > 0) {
                                            for (var l = 0; l < labour_list.length; l++) {
                                                var discount = req.body.discount;
                                                var discount_total = 0;
                                                var total = 0;
                                                var tax_info = await Tax.findOne({ tax: labour_list[l].tax }).exec();

                                                var tax = [];
                                                var rate = labour_list[l].rate;
                                                var amount = parseFloat(labour_list[l].rate) * parseFloat(labour_list[l].quantity);
                                                var tax_rate = tax_info.detail;
                                                var base = amount;

                                                if (Object.keys(package).length > 0) {
                                                    // cconsole.log
                                                    if (package.discount_type == "percent") {
                                                        discount = parseFloat(package.discount);
                                                        if (!isNaN(discount) && discount > 0) {
                                                            var discount_total = amount * (discount / 100);
                                                            amount = amount - parseFloat(discount_total.toFixed(2))
                                                        }
                                                    }
                                                    else if (package.discount_type == "fixed") {
                                                        discount = parseFloat(package.discount);
                                                        if (!isNaN(discount) && discount > 0) {
                                                            var discount_total = (amount / discount_eligible_labour_cost) * discount;
                                                            amount = parseFloat(discount_total.toFixed(2))
                                                            discount = amount - discount_total;
                                                        }
                                                    }
                                                    else {
                                                        discount = parseFloat(package.discount);
                                                        if (!isNaN(discount) && discount > 0) {
                                                            var discount_total = (amount / discount_eligible_labour_cost) * discount;
                                                            amount = amount - parseFloat(discount_total.toFixed(2))
                                                        }
                                                    }
                                                }

                                                if (labour_list[l].amount_is_tax == "exclusive") {
                                                    var tax_on_amount = amount;
                                                    if (tax_rate.length > 0) {
                                                        for (var r = 0; r < tax_rate.length; r++) {
                                                            if (tax_rate[r].rate != tax_info.rate) {
                                                                var t = tax_on_amount * (tax_rate[r].rate / 100);
                                                                amount = amount + t;
                                                                tax.push({
                                                                    tax: tax_rate[r].tax,
                                                                    rate: tax_rate[r].rate,
                                                                    amount: parseFloat(t.toFixed(2))
                                                                });
                                                            }
                                                            else {
                                                                var t = tax_on_amount * (tax_rate[r].rate / 100);
                                                                amount = amount + t;
                                                                tax.push({
                                                                    tax: tax_info.tax, tax_rate: tax_info.rate,
                                                                    rate: tax_info.rate,
                                                                    amount: parseFloat(t.toFixed(2))
                                                                });
                                                            }
                                                        }
                                                    }
                                                    total = total + amount;
                                                }

                                                if (labour_list[l].amount_is_tax == "inclusive") {
                                                    var x = (100 + tax_info.rate) / 100;
                                                    var tax_on_amount = amount / x;
                                                    if (tax_rate.length > 0) {
                                                        for (var r = 0; r < tax_rate.length; r++) {
                                                            if (tax_rate[r].rate != tax_info.rate) {
                                                                var t = tax_on_amount * (tax_rate[r].rate / 100);
                                                                base = base - t;
                                                                tax.push({
                                                                    tax: tax_rate[r].tax,
                                                                    rate: tax_rate[r].rate,
                                                                    amount: parseFloat(t.toFixed(2))
                                                                });
                                                            }
                                                            else {
                                                                var t = amount - tax_on_amount;
                                                                base = base - t;
                                                                tax.push({
                                                                    tax: tax_info.tax, tax_rate: tax_info.rate,
                                                                    rate: tax_info.rate,
                                                                    amount: parseFloat(t.toFixed(2))
                                                                });
                                                            }
                                                        }

                                                        //base = base - discount_total;
                                                    }
                                                    total = total + amount;
                                                }

                                                var tax_details = {
                                                    tax: tax_info.tax,
                                                    rate: tax_info.rate,
                                                    amount: total,
                                                    detail: tax
                                                };

                                                if (!labour_list[l].customer_dep) {
                                                    customer_dep = 100
                                                }
                                                else {
                                                    customer_dep = labour_list[l].customer_dep;
                                                }


                                                if (!labour_list[l].insurance_dep) {
                                                    insurance_dep = 0
                                                }
                                                else {
                                                    insurance_dep = labour_list[l].insurance_dep;
                                                }


                                                labours.push({
                                                    item: labour_list[l].item,
                                                    source: labour_list[l].source,
                                                    rate: parseFloat(labour_list[l].rate),
                                                    quantity: parseFloat(labour_list[l].quantity),
                                                    base: parseFloat(base.toFixed(2)),
                                                    discount: parseFloat(discount_total.toFixed(2)),
                                                    amount: total,
                                                    customer_dep: customer_dep,
                                                    insurance_dep: insurance_dep,
                                                    tax_amount: parseFloat(_.sumBy(tax, x => x.amount).toFixed(2)),
                                                    amount_is_tax: labour_list[l].amount_is_tax,
                                                    tax: tax_info.tax, tax_rate: tax_info.rate,
                                                    tax_info: tax_details
                                                });

                                                // cconsole.logrs)
                                            }

                                            bookingService.push({
                                                part_cost: services[i].part_cost,
                                                labour_cost: _.sumBy(labours, x => x.amount),
                                                of_cost: services[i].of_cost,
                                                exceeded_cost: services[i].exceeded_cost,
                                                part_rate: services[i].part_rate,
                                                labour_rate: services[i].labour_rate,
                                                quantity: services[i].quantity,
                                                of_rate: services[i].of_rate,
                                                parts: services[i].parts,
                                                labour: labours,
                                                cost: services[i].part_cost + _.sumBy(labours, x => x.amount) + services[i].of_cost,
                                                discount: _.sumBy(labours, x => x.discount) + _.sumBy(services[i].opening_fitting, x => x.discount) + _.sumBy(services[i].parts, x => x.discount),
                                                opening_fitting: services[i].opening_fitting,
                                                part_cost_editable: services[i].part_cost_editable,
                                                labour_cost_editable: services[i].part_cost_editable,
                                                of_cost_editable: services[i].part_cost_editable,
                                                description: services[i].description,
                                                service: services[i].service,
                                                type: services[i].type,
                                                claim: services[i].claim,
                                                custom: services[i].custom,
                                                customer_approval: services[i].customer_approval, surveyor_approval: services[i].surveyor_approval,
                                                source: services[i].source,
                                            });
                                        }
                                    }
                                }
                            }

                            var policy_clause = 0
                            if (booking.payment.policy_clause) {
                                policy_clause = booking.payment.policy_clause;
                            }
                            var salvage = 0
                            if (booking.payment.salvage) {
                                salvage = booking.payment.salvage;
                            }

                            var approved = _.filter(bookingService, customer_approval => customer_approval.customer_approval == true);

                            var paid_total = booking.payment.paid_total;
                            var labour_cost = _.sumBy(bookingService, x => x.labour_cost);
                            var part_cost = _.sumBy(bookingService, x => x.part_cost);
                            var of_cost = _.sumBy(bookingService, x => x.of_cost);
                            var discount_total = _.sumBy(bookingService, x => x.discount);
                            var pick_up_charges = booking.payment.pick_up_charges;

                            var payment_total = labour_cost + part_cost + of_cost + discount_total + policy_clause + salvage + pick_up_charges;

                            var careager_cash = await q.all(fun.getBookingCarEagerCash(booking._id));

                            var estimate_cost = labour_cost + part_cost + of_cost + policy_clause + salvage + pick_up_charges - careager_cash;
                            var due_amount = _.sumBy(approved, x => x.labour_cost) + _.sumBy(approved, x => x.part_cost) + _.sumBy(approved, x => x.of_cost) + policy_clause + salvage + pick_up_charges - (paid_total + careager_cash);

                            var due = {
                                due: Math.ceil(due_amount.toFixed(2))
                            }

                            var payment = {
                                estimate_cost: estimate_cost,
                                total: payment_total,
                                careager_cash: careager_cash,
                                of_cost: of_cost,
                                labour_cost: labour_cost,
                                part_cost: part_cost,
                                payment_mode: booking.payment.payment_mode,
                                payment_status: booking.payment.payment_status,
                                coupon: "",
                                coupon_type: "",
                                discount_by: "",
                                discount: discount_total,
                                discount_total: discount_total,
                                policy_clause: booking.payment.policy_clause,
                                salvage: booking.payment.salvage,
                                terms: booking.payment.terms,
                                pick_up_limit: booking.payment.pick_up_limit,
                                pick_up_charges: booking.payment.pick_up_charges,
                                paid_total: parseFloat(booking.payment.paid_total),
                                discount_applied: booking.payment.discount_applied,
                                transaction_id: booking.payment.transaction_id,
                                transaction_date: booking.payment.transaction_date,
                                transaction_status: booking.payment.transaction_status,
                                transaction_response: booking.payment.transaction_response
                            };

                            Booking.findOneAndUpdate({ _id: req.body.booking }, { $set: { services: bookingService, payment: payment, due: due } }, { new: false }, async function (err, doc) {
                                if (err) {
                                    res.status(400).json({
                                        responseCode: 400,
                                        responseMessage: "Error",
                                        responseData: err
                                    });
                                }
                                else {
                                    var updated = await Booking.findById(req.body.booking).exec();



                                    res.status(200).json({
                                        responseCode: 200,
                                        responseMessage: "Package has been removed",
                                        responseData: updated
                                    });
                                }
                            });
                        }
                    });
                }
            }
            else {
                res.status(400).json({
                    responseCode: 400,
                    responseMessage: "Cannot add package to this service",
                    responseData: {}
                });
            }
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Booking not found",
                responseData: {}
            });
        }
    }
});

router.post('/new/service/add', xAccessToken.token, async function (req, res, next) {
    var rules = {
        booking: 'required',
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Validation Error",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var user = decoded.user;
        var business = req.headers['business'];
        var labour_cost = 0;
        var part_cost = 0;
        var of_cost = 0;
        var discount_total = 0;
        var due_amount = 0;
        var totalResult = 0;
        var bookingService = [];
        var parts = [];
        var labours = [];
        var opening_fitting = [];

        var customer_approval = false;

        if (req.body.customer_approval == true) {
            customer_approval = true
        }

        var booking = await Booking.findById(req.body.booking).exec();
        if (booking) {
            var part_list = req.body.parts;
            var labour_list = req.body.labour;
            var of_list = req.body.opening_fitting;

            var claim = false;
            if (req.body.claim == true) {
                claim = true
            }

            var getDiscount = {
                booking: booking._id,
                package: booking.package,
                car: booking.car,
                category: req.body.type,
                service: req.body.service,
                claim: req.body.claim,
                tz: req.headers['tz']
            };

            var package = await q.all(getPackageDiscount(getDiscount));

            if (part_list) {
                for (var p = 0; p < part_list.length; p++) {
                    var total = 0;
                    var tax_info = await Tax.findOne({ tax: part_list[p].tax }).exec();
                    var tax = [];
                    var rate = part_list[p].rate;
                    var amount = (parseFloat(part_list[p].rate) * parseFloat(part_list[p].quantity));
                    var tax_rate = tax_info.detail;
                    var discount_total = 0;
                    var base = amount;

                    if (parseFloat(part_list[p].discount)) {
                        discount_total = parseFloat(part_list[p].discount);
                        amount = amount - parseFloat(discount_total.toFixed(2))
                    }

                    if (part_list[p].amount_is_tax == "exclusive") {
                        var tax_on_amount = amount;
                        if (tax_rate.length > 0) {
                            for (var r = 0; r < tax_rate.length; r++) {
                                if (tax_rate[r].rate != tax_info.rate) {
                                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                                    amount = amount + t;
                                    tax.push({
                                        tax: tax_rate[r].tax,
                                        rate: tax_rate[r].rate,
                                        amount: parseFloat(t.toFixed(2))
                                    });
                                }
                                else {
                                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                                    amount = amount + t;
                                    tax.push({
                                        tax: tax_info.tax, tax_rate: tax_info.rate,
                                        rate: tax_info.rate,
                                        amount: parseFloat(t.toFixed(2))
                                    });
                                }
                            }
                        }
                        total = total + amount;
                    }

                    if (part_list[p].amount_is_tax == "inclusive") {
                        var x = (100 + tax_info.rate) / 100;
                        var tax_on_amount = amount / x;
                        if (tax_rate.length > 0) {
                            for (var r = 0; r < tax_rate.length; r++) {
                                if (tax_rate[r].rate != tax_info.rate) {
                                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                                    base = base - t;
                                    tax.push({
                                        tax: tax_rate[r].tax,
                                        rate: tax_rate[r].rate,
                                        amount: parseFloat(t.toFixed(2))
                                    });
                                }
                                else {
                                    var t = amount - tax_on_amount;
                                    base = base - t;
                                    tax.push({
                                        tax: tax_info.tax, tax_rate: tax_info.rate,
                                        rate: tax_info.rate,
                                        amount: parseFloat(t.toFixed(2))
                                    });
                                }
                            }
                        }

                        //base = base - discount_total;
                        total = total + amount;
                    }

                    var tax_amount = total - parseFloat(base.toFixed(2));

                    var tax_details = {
                        tax: tax_info.tax,
                        tax_rate: tax_info.rate,
                        rate: tax_info.rate,
                        amount: total,
                        detail: tax
                    }

                    parts.push({
                        item: part_list[p].item,
                        source: part_list[p].source,
                        hsn_sac: part_list[p].hsn_sac,
                        part_no: part_list[p].part_no,
                        rate: parseFloat(part_list[p].rate),
                        quantity: parseFloat(part_list[p].quantity),
                        base: parseFloat(base.toFixed(2)),
                        amount: total,
                        discount: part_list[p].discount,
                        issued: part_list[p].issued,
                        customer_dep: parseFloat(part_list[p].customer_dep),
                        insurance_dep: parseFloat(part_list[p].insurance_dep),
                        tax_amount: parseFloat(_.sumBy(tax, x => x.amount).toFixed(2)),
                        amount_is_tax: part_list[p].amount_is_tax,
                        tax: tax_info.tax,
                        tax_rate: tax_info.rate,
                        tax_info: tax_details
                    });
                }
            }

            if (labour_list) {
                discount_eligible_labour_cost = _.sumBy(labour_list, x => x.rate * x.quantity);

                for (var l = 0; l < labour_list.length; l++) {
                    var total = 0;
                    var tax_info = await Tax.findOne({ tax: labour_list[l].tax }).exec();
                    var tax = [];
                    var rate = labour_list[l].rate;
                    var amount = parseFloat(labour_list[l].rate) * parseFloat(labour_list[l].quantity);
                    var tax_rate = tax_info.detail;
                    var discount_total = 0;
                    var base = amount;

                    if (package.discount_type == "percent") {
                        discount = parseFloat(package.discount);
                        if (!isNaN(discount) && package.discount > 0) {
                            discount_total = amount * (discount / 100);
                            amount = amount - parseFloat(discount_total.toFixed(2))
                        }
                    }
                    else if (package.discount_type == "fixed") {
                        discount_type = "value";
                        discount = parseFloat(package.discount);
                        discount_total = (amount / discount_eligible_labour_cost) * discount;
                        discount = amount - discount_total;
                        amount = parseFloat(discount_total.toFixed(2));
                    }
                    else if (package.discount_type == "price") {
                        discount_type = "value";
                        discount = parseFloat(package.discount);
                        if (!isNaN(discount) && discount > 0) {
                            discount_total = (amount / discount_eligible_labour_cost) * discount;
                            amount = amount - parseFloat(discount_total.toFixed(2))
                        }
                    }
                    else {
                        discount_total = parseFloat(labour_list[l].discount);
                        amount = amount - parseFloat(discount_total.toFixed(2))
                    }


                    if (labour_list[l].amount_is_tax == "exclusive") {
                        var tax_on_amount = amount;
                        if (tax_rate.length > 0) {
                            for (var r = 0; r < tax_rate.length; r++) {
                                if (tax_rate[r].rate != tax_info.rate) {
                                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                                    amount = amount + t; parseFloat
                                    tax.push({
                                        tax: tax_rate[r].tax,
                                        rate: tax_rate[r].rate,
                                        amount: parseFloat(t.toFixed(2))
                                    });
                                }
                                else {
                                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                                    amount = amount + t;
                                    tax.push({
                                        tax: tax_info.tax, tax_rate: tax_info.rate,
                                        rate: tax_info.rate,
                                        amount: parseFloat(t.toFixed(2))
                                    });
                                }
                            }
                        }
                        //total = total+amount;
                    }

                    if (labour_list[l].amount_is_tax == "inclusive") {
                        var x = (100 + tax_info.rate) / 100;
                        var tax_on_amount = amount / x;
                        if (tax_rate.length > 0) {
                            for (var r = 0; r < tax_rate.length; r++) {
                                if (tax_rate[r].rate != tax_info.rate) {
                                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                                    base = base - t;
                                    tax.push({
                                        tax: tax_rate[r].tax,
                                        rate: tax_rate[r].rate,
                                        amount: parseFloat(t.toFixed(2))
                                    });
                                }
                                else {
                                    var t = amount - tax_on_amount;
                                    base = base - t;
                                    tax.push({
                                        tax: tax_info.tax, tax_rate: tax_info.rate,
                                        rate: tax_info.rate,
                                        amount: parseFloat(t.toFixed(2))
                                    });
                                }
                            }
                        }
                        //base = base - discount_total;
                        total = total + amount;
                    }

                    var tax_amount = total - parseFloat(base.toFixed(2));

                    var tax_details = {
                        tax: tax_info.tax,
                        rate: tax_info.rate,
                        amount: total,
                        detail: tax
                    };

                    labours.push({
                        item: labour_list[l].item,
                        source: labour_list[l].source,
                        rate: parseFloat(labour_list[l].rate),
                        quantity: parseFloat(labour_list[l].quantity),
                        base: parseFloat(base.toFixed(2)),
                        amount: amount,
                        discount: discount_total,
                        customer_dep: parseFloat(labour_list[l].customer_dep),
                        insurance_dep: parseFloat(labour_list[l].insurance_dep),
                        tax_amount: parseFloat(_.sumBy(tax, x => x.amount).toFixed(2)),
                        amount_is_tax: labour_list[l].amount_is_tax,
                        tax: tax_info.tax, tax_rate: tax_info.rate,
                        tax_info: tax_details
                    });
                }
            }

            if (of_list) {
                for (var o = 0; o < of_list.length; o++) {
                    var total = 0;
                    var tax_info = await Tax.findOne({ tax: of_list[o].tax }).exec();
                    var tax = [];
                    var rate = of_list[o].rate;
                    var amount = (parseFloat(of_list[o].rate) * parseFloat(of_list[o].quantity));
                    var tax_rate = tax_info.detail;
                    var discount_total = 0;
                    var base = amount;

                    if (parseFloat(of_list[0].discount)) {
                        discount_total = parseFloat(of_list[o].discount);
                        amount = amount - parseFloat(discount_total.toFixed(2))
                    }


                    if (of_list[o].amount_is_tax == "exclusive") {
                        var tax_on_amount = amount;
                        if (tax_rate.length > 0) {
                            for (var r = 0; r < tax_rate.length; r++) {
                                if (tax_rate[r].rate != tax_info.rate) {
                                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                                    amount = amount + t; parseFloat
                                    tax.push({
                                        tax: tax_rate[r].tax,
                                        rate: tax_rate[r].rate,
                                        amount: parseFloat(t.toFixed(2))
                                    });
                                }
                                else {
                                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                                    amount = amount + t;
                                    tax.push({
                                        tax: tax_info.tax, tax_rate: tax_info.rate,
                                        rate: tax_info.rate,
                                        amount: parseFloat(t.toFixed(2))
                                    });
                                }
                            }
                        }
                        total = total + amount;
                    }

                    if (of_list[o].amount_is_tax == "inclusive") {
                        var x = (100 + tax_info.rate) / 100;
                        var tax_on_amount = amount / x;
                        if (tax_rate.length > 0) {
                            for (var r = 0; r < tax_rate.length; r++) {
                                if (tax_rate[r].rate != tax_info.rate) {
                                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                                    base = base - t;
                                    tax.push({
                                        tax: tax_rate[r].tax,
                                        rate: tax_rate[r].rate,
                                        amount: parseFloat(t.toFixed(2))
                                    });
                                }
                                else {
                                    var t = amount - tax_on_amount;
                                    base = base - t;
                                    tax.push({
                                        tax: tax_info.tax, tax_rate: tax_info.rate,
                                        rate: tax_info.rate,
                                        amount: parseFloat(t.toFixed(2))
                                    });
                                }
                            }
                        }
                        //base = base - discount_total;
                        total = total + amount;
                    }

                    var tax_details = {
                        tax: tax_info.tax,
                        rate: tax_info.rate,
                        amount: total,
                        detail: tax
                    }

                    var tax_amount = total - parseFloat(base.toFixed(2));

                    opening_fitting.push({
                        item: of_list[o].item,
                        source: of_list[o].source,
                        rate: parseFloat(of_list[o].rate),
                        quantity: parseFloat(of_list[o].quantity),
                        base: parseFloat(base.toFixed(2)),
                        amount: total,
                        discount: parseFloat(of_list[o].discount),
                        customer_dep: parseFloat(of_list[o].customer_dep),
                        insurance_dep: parseFloat(of_list[o].insurance_dep),
                        tax_amount: parseFloat(_.sumBy(tax, x => x.amount).toFixed(2)),
                        amount_is_tax: of_list[o].amount_is_tax,
                        tax: tax_info.tax, tax_rate: tax_info.rate,
                        tax_info: tax_details
                    });
                }
            }

            res.status(200).json({
                responseCode: 200,
                responseMessage: "",
                responseData: {
                    part_cost: _.sumBy(parts, x => x.amount),
                    labour_cost: parseFloat(_.sumBy(labours, x => x.amount).toFixed(2)),
                    of_cost: _.sumBy(opening_fitting, x => x.amount),
                    part_rate: _.sumBy(parts, x => x.base),
                    labour_rate: _.sumBy(labours, x => x.base),
                    of_rate: _.sumBy(opening_fitting, x => x.base),
                    parts: parts,
                    labour: labours,
                    opening_fitting: opening_fitting,
                    part_cost_editable: true,
                    labour_cost_editable: true,
                    of_cost_editable: true,
                    cost: _.sumBy(parts, x => x.amount) + _.sumBy(labours, x => x.amount) + _.sumBy(opening_fitting, x => x.amount),
                    description: req.body.description,
                    service: req.body.service,
                    type: req.body.type,
                    discount: _.sumBy(labours, x => x.discount) + _.sumBy(parts, x => x.discount) + _.sumBy(opening_fitting, x => x.discount),
                    customer_approval: customer_approval,
                    surveyor_approval: false,
                    custom: true,
                    exceeded_cost: 0,
                    claim: claim
                }
            });
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Booking not found",
                responseData: {}
            });
        }
    }
});

router.post('/manual/estimate/', xAccessToken.token, async function (req, res, next) {
    var rules = {
        booking: 'required',
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Validation Error",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var user = decoded.user;
        var business = req.headers['business'];
        var labour_cost = 0;
        var part_cost = 0;
        var of_cost = 0;
        var due_amount = 0;
        var totalResult = 0;
        var bookingService = [];

        var loggedInDetails = await User.findById(decoded.user).exec();
        var booking = await Booking.findById(req.body.booking).exec();
        if (booking) {
            labour_cost = booking.payment.labour_cost;
            part_cost = booking.payment.part_cost;
            if (booking.payment.of_cost) {
                var of_cost = booking.payment.of_cost;
            }
            var services = req.body.services;

            for (var i = 0; i < services.length; i++) {
                var parts_visible = true;
                var part_tax = [];
                var labour_tax = [];
                var fitting_tax = [];
                var tax_detail = {};
                if (typeof services[i].quantity != "number" || parseInt(services[i].quantity) <= 0) {
                    var quantity = 1
                }
                else {
                    var quantity = parseInt(services[i].quantity)
                }

                //var labour_cost_updated = services[i].service, parseFloat(se

                var parts = services[i].parts;
                var part = [];

                if (parts.length > 0) {
                    part = parts
                }
                else {
                    parts_visible = false;
                    var tax_info = await Tax.findOne({ tax: "0% GST" }).exec();
                    // cconsole.lognfo)
                    var tax_rate = tax_info.detail;
                    var service = services[i].service;
                    var amount = parseFloat(services[i].part_cost) * quantity;
                    var base = amount;
                    var part_tax = [];

                    var x = (100 + tax_info.rate) / 100;
                    var tax_on_amount = amount / x;
                    // cconsole.logn_amount)
                    if (tax_rate.length > 0) {
                        for (var r = 0; r < tax_rate.length; r++) {
                            if (tax_rate[r].rate != tax_info.rate) {
                                var t = tax_on_amount * (tax_rate[r].rate / 100);
                                // cconsole.log
                                if (t > 0) {
                                    base = base - t;
                                }
                                else {
                                    base = base;
                                }

                                part_tax.push({
                                    tax: tax_rate[r].tax,
                                    rate: tax_rate[r].rate,
                                    amount: parseFloat(t.toFixed(2))
                                });
                            }
                            else {
                                /*if(tax_info.rate>0)
                                {
                                    tax_on_amount = parseFloat(tax_on_amount.toFixed(2))
                                }
                                else
                                {
                                    tax_on_amount = 0;
                                }
                                part_tax.push({
                                    tax: tax_info.tax,tax_rate: tax_info.rate,
                                    rate: tax_info.rate,
                                    amount: 
                                });*/

                                var t = amount - tax_on_amount;
                                base = base - t;
                                part_tax.push({
                                    tax: tax_info.tax, tax_rate: tax_info.rate,
                                    rate: tax_info.rate,
                                    amount: parseFloat(t.toFixed(2))
                                });

                            }
                        }
                    }

                    tax_detail = {
                        tax: tax_info.tax, tax_rate: tax_info.rate,
                        rate: tax_info.rate,
                        base: parseFloat(base.toFixed(2)),
                        detail: part_tax
                    }

                    part.push({
                        item: services[i].service,
                        source: null,
                        quantity: quantity,
                        hsn_sac: "",
                        part_no: "",
                        rate: parseFloat(services[i].part_cost),
                        base: parseFloat(base.toFixed(2)),
                        amount: parseFloat(amount),
                        tax_amount: _.sumBy(part_tax, x => x.amount),
                        amount_is_tax: "inclusive",
                        discount: 0,
                        customer_dep: 100,
                        insurance_dep: 0,
                        tax: tax_info.tax,
                        tax_rate: tax_info.rate,
                        issued: false,
                        tax_info: tax_detail
                    })
                }

                var labour = services[i].labour;
                var labours = [];

                if (labour.length > 0) {
                    labours = labour
                }
                else {
                    var tax_info = await Tax.findOne({ tax: "18.0% GST" }).exec();
                    var tax_rate = tax_info.detail;
                    var service = services[i].service;
                    var amount = parseFloat(services[i].labour_cost) * quantity;
                    var base = amount;
                    var labour_tax = [];

                    var x = (100 + tax_info.rate) / 100;
                    var tax_on_amount = amount / x;
                    if (tax_rate.length > 0) {
                        for (var r = 0; r < tax_rate.length; r++) {
                            if (tax_rate[r].rate != tax_info.rate) {
                                var t = tax_on_amount * (tax_rate[r].rate / 100);
                                base = base - t
                                labour_tax.push({
                                    tax: tax_rate[r].tax,
                                    rate: parseFloat(tax_rate[r].rate.toFixed(2)),
                                    amount: parseFloat(t.toFixed(2))
                                })
                            }
                            else {
                                base = base - t
                                labour_tax.push({
                                    tax: tax_info.tax, tax_rate: tax_info.rate,
                                    rate: parseFloat(tax_info.rate.toFixed(2)),
                                    amount: parseFloat(tax_on_amount.toFixed(2))
                                })
                            }
                        }
                    }

                    labours.push({
                        item: services[i].service,
                        quantity: quantity,
                        rate: parseFloat(services[i].labour_cost),
                        base: parseFloat(base.toFixed(2)),
                        amount: parseFloat(amount),
                        discount: 0,
                        customer_dep: 100,
                        insurance_dep: 0,
                        amount_is_tax: "inclusive",
                        tax_amount: _.sumBy(labour_tax, x => x.amount),
                        tax: tax_info.tax, tax_rate: tax_info.rate,
                        tax_info: {
                            tax: tax_info.tax, tax_rate: tax_info.rate,
                            rate: tax_info.rate,
                            base: parseFloat(base.toFixed(2)),
                            detail: labour_tax
                        }
                    });
                }

                var opening_fittings = services[i].opening_fitting;
                var opening_fitting = [];

                if (opening_fittings.length > 0) {
                    opening_fitting = opening_fittings
                }
                else {
                    if (services[i].of_cost != 0) {
                        var tax_info = await Tax.findOne({ tax: "18.0% GST" }).exec();
                        var tax_rate = tax_info.detail;
                        var service = services[i].service;
                        var amount = parseFloat(services[i].of_cost) * quantity;
                        var base = amount;
                        var fitting_tax = [];

                        var x = (100 + tax_info.rate) / 100;
                        var tax_on_amount = amount / x;
                        if (tax_rate.length > 0) {
                            for (var r = 0; r < tax_rate.length; r++) {
                                if (tax_rate[r].rate != tax_info.rate) {
                                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                                    base = base - t
                                    fitting_tax.push({
                                        tax: tax_rate[r].tax,
                                        rate: tax_rate[r].rate,
                                        amount: parseFloat(t.toFixed(2))
                                    })
                                }
                                else {
                                    base = base - t
                                    fitting_tax.push({
                                        tax: tax_info.tax, tax_rate: tax_info.rate,
                                        rate: tax_info.rate,
                                        amount: parseFloat(tax_on_amount.toFixed(2))
                                    })
                                }
                            }
                        }

                        opening_fitting.push({
                            item: services[i].service,
                            quantity: quantity,
                            rate: parseFloat(services[i].of_cost),
                            base: parseFloat(base.toFixed(2)),
                            discount: 0,
                            amount: parseFloat(amount),
                            amount_is_tax: "inclusive",
                            customer_dep: 100,
                            insurance_dep: 0,
                            tax_amount: _.sumBy(fitting_tax, x => x.amount),
                            tax: tax_info.tax,
                            tax_rate: tax_info.rate,
                            tax_info: {
                                tax: tax_info.tax, tax_rate: tax_info.rate,
                                rate: tax_info.rate,
                                base: parseFloat(base.toFixed(2)),
                                detail: fitting_tax
                            }
                        });
                    }
                    else {
                        opening_fitting = [];
                    }
                }

                bookingService.push({
                    source: services[i].source,
                    service: services[i].service,
                    mileage: services[i].mileage,
                    parts: part,
                    labour: labours,
                    opening_fitting: opening_fitting,
                    hours: services[i].hours,
                    parts_visible: parts_visible,
                    quantity: quantity,
                    discount: _.sumBy(labours, x => x.discount) + _.sumBy(part, x => x.discount) + _.sumBy(opening_fitting, x => x.discount),
                    description: services[i].description,
                    cost: _.sumBy(labours, x => x.amount) + _.sumBy(part, x => x.amount) + _.sumBy(opening_fitting, x => x.amount),
                    labour_cost: parseFloat(services[i].labour_cost),
                    of_cost: parseFloat(services[i].of_cost),
                    part_cost: parseFloat(services[i].part_cost),
                    exceeded_cost: parseFloat(services[i].exceeded_cost),
                    part_cost_editable: services[i].part_cost_editable,
                    labour_cost_editable: services[i].labour_cost_editable,
                    of_cost_editable: services[i].of_cost_editable,
                    type: services[i].type,
                    customer_approval: services[i].customer_approval,
                    surveyor_approval: services[i].surveyor_approval,
                    claim: services[i].claim,
                    custom: services[i].custom,
                });
            }

            var policy_clause = booking.payment.policy_clause;
            if (req.body.policy_clause >= 0 && req.body.policy_clause != null) {
                policy_clause = req.body.policy_clause;
            }

            var salvage = booking.payment.salvage;
            if (req.body.salvage >= 0 && req.body.salvage != null) {
                salvage = req.body.salvage;
            }

            var pick_up_charges = booking.payment.pick_up_charges;
            if (req.body.pick_up_charge >= 0) {
                pick_up_charges = req.body.pick_up_charge;
            }

            var approved = _.filter(bookingService, customer_approval => customer_approval.customer_approval == true);

            var paid_total = booking.payment.paid_total;
            var labour_cost = _.sumBy(bookingService, x => x.labour_cost);
            var part_cost = _.sumBy(bookingService, x => x.part_cost);
            var of_cost = _.sumBy(bookingService, x => x.of_cost);
            var discount_total = _.sumBy(bookingService, x => x.discount);

            var payment_total = labour_cost + part_cost + of_cost + discount_total + policy_clause + salvage + pick_up_charges;

            var estimate_cost = labour_cost + part_cost + of_cost + policy_clause + salvage + pick_up_charges - careager_cash;
            var careager_cash = booking.payment.careager_cash;

            var due_amount = _.sumBy(approved, x => x.labour_cost) + _.sumBy(approved, x => x.part_cost) + _.sumBy(approved, x => x.of_cost) + policy_clause + salvage + pick_up_charges - (paid_total + careager_cash);

            var due = {
                due: Math.ceil(due_amount.toFixed(2))
            }


            var payment = {
                estimate_cost: estimate_cost,
                total: payment_total,
                careager_cash: careager_cash,
                of_cost: of_cost,
                labour_cost: labour_cost,
                part_cost: part_cost,
                payment_mode: booking.payment.payment_mode,
                payment_status: booking.payment.payment_status,
                discount_type: booking.payment.discount_type,
                coupon: booking.payment.coupon,
                coupon_type: booking.payment.coupon_type,
                discount_by: booking.payment.discount_by,
                discount: booking.payment.discount,
                discount_total: discount_total,
                policy_clause: policy_clause,
                salvage: salvage,
                terms: booking.payment.terms,
                pick_up_limit: booking.payment.pick_up_limit,
                pick_up_charges: pick_up_charges,
                paid_total: parseFloat(booking.payment.paid_total),
                discount_applied: booking.payment.discount_applied,
                transaction_id: booking.payment.transaction_id,
                transaction_date: booking.payment.transaction_date,
                transaction_status: booking.payment.transaction_status,
                transaction_response: booking.payment.transaction_response
            };

            var date = new Date();

            Booking.findOneAndUpdate({ _id: booking._id }, { $set: { package: req.body.package, services: bookingService, payment: payment, due: due, advance: req.body.advance, convenience: req.body.convenience, updated_at: date } }, { new: false }, async function (err, doc) {
                if (err) {
                    res.status(422).json({
                        responseCode: 422,
                        responseMessage: "Server Error",
                        responseData: err
                    });
                }
                else {
                    var updated = await Booking.findById(booking.id).exec();
                    event.zohoLead(updated._id);

                    var activity = {
                        user: loggedInDetails._id,
                        name: loggedInDetails.name,
                        stage: "Estimation",
                        activity: "Estimate Prepared",
                    };

                    fun.bookingLog(booking._id, activity);
                    event.zohoLead(booking._id);

                    res.status(200).json({
                        responseCode: 200,
                        responseMessage: "Service has been added...",
                        responseData: updated
                    });
                }
            });
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Booking not found",
                responseData: {}
            });
        }
    }
});

router.post('/approved/customer/services', xAccessToken.token, async function (req, res, next) {
    var rules = {
        booking: 'required',
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Validation Error",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var user = decoded.user;
        var business = req.headers['business'];
        var bookingService = [];
        var logged_remark = "";
        var loggedInDetails = await User.findById(decoded.user).exec();
        var booking = await Booking.findOne({ _id: req.body.booking, business: business }).exec();
        if (booking) {
            var services = req.body.services;
            for (var i = 0; i < services.length; i++) {
                var parts_visible = true;
                var part_tax = [];
                var labour_tax = [];
                var fitting_tax = [];
                var tax_detail = {};
                if (typeof services[i].quantity != "number" || parseInt(services[i].quantity) <= 0) {
                    var quantity = 1
                }
                else {
                    var quantity = parseInt(services[i].quantity)
                }

                var parts = services[i].parts;
                var part = [];
                if (parts.length > 0) {
                    part = services[i].parts
                    // console.log(services[i].parts)
                }
                else {
                    if (services[i].part_cost != 0) {
                        parts_visible = false;
                        var tax_info = await Tax.findOne({ tax: "0% GST" }).exec();
                        var tax_rate = tax_info.detail;
                        var service = services[i].service;
                        var amount = Math.ceil(services[i].part_cost) * quantity;
                        var base = amount;
                        var part_tax = [];

                        var x = (100 + tax_info.rate) / 100;
                        var tax_on_amount = amount / x;
                        if (tax_rate.length > 0) {
                            for (var r = 0; r < tax_rate.length; r++) {
                                if (tax_rate[r].rate != tax_info.rate) {
                                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                                    base = base - t;
                                    part_tax.push({
                                        tax: tax_rate[r].tax,
                                        rate: tax_rate[r].rate,
                                        amount: parseFloat(t.toFixed(2))
                                    });
                                }
                                else {
                                    base = base - t
                                    part_tax.push({
                                        tax: tax_info.tax, tax_rate: tax_info.rate,
                                        rate: tax_info.rate,
                                        amount: parseFloat(tax_on_amount.toFixed(2))
                                    });
                                }
                            }
                        }

                        tax_detail = {
                            tax: tax_info.tax, tax_rate: tax_info.rate,
                            rate: tax_info.rate,
                            base: parseFloat(base.toFixed(2)),
                            detail: part_tax
                        }

                        part.push({
                            item: services[i].service,
                            hsn_sac: "",
                            part_no: "",
                            quantity: quantity,
                            rate: parseFloat(services[i].part_cost),
                            base: parseFloat(base.toFixed(2)),
                            amount: parseFloat(amount),
                            customer_dep: 100,
                            insurance_dep: 0,
                            tax_amount: _.sumBy(part_tax, x => x.amount),
                            amount_is_tax: "inclusive",
                            discount: 0,
                            tax: tax_info.tax, tax_rate: tax_info.rate,
                            tax_info: tax_detail
                        })
                    }

                }

                var labours = services[i].labour;
                var labour = [];

                if (labours.length > 0) {
                    labour = labours
                }
                else {
                    var tax_info = await Tax.findOne({ tax: "18.0% GST" }).exec();
                    var tax_rate = tax_info.detail;
                    var service = services[i].service;
                    var amount = Math.ceil(services[i].labour_cost) * quantity;
                    var base = amount;
                    var labour_tax = [];

                    var x = (100 + tax_info.rate) / 100;
                    var tax_on_amount = amount / x;
                    if (tax_rate.length > 0) {
                        for (var r = 0; r < tax_rate.length; r++) {
                            if (tax_rate[r].rate != tax_info.rate) {
                                var t = tax_on_amount * (tax_rate[r].rate / 100);
                                base = base - t
                                labour_tax.push({
                                    tax: tax_rate[r].tax,
                                    rate: parseFloat(tax_rate[r].rate.toFixed(2)),
                                    amount: parseFloat(t.toFixed(2))
                                })
                            }
                            else {
                                base = base - t
                                labour_tax.push({
                                    tax: tax_info.tax, tax_rate: tax_info.rate,
                                    rate: parseFloat(tax_info.rate.toFixed(2)),
                                    amount: parseFloat(tax_on_amount.toFixed(2))
                                })
                            }
                        }
                    }

                    labour.push({
                        item: services[i].service,
                        quantity: quantity,
                        rate: parseFloat(services[i].labour_cost),
                        base: parseFloat(base.toFixed(2)),
                        amount: parseFloat(amount),
                        discount: 0,
                        customer_dep: 100,
                        insurance_dep: 0,
                        amount_is_tax: "inclusive",
                        tax_amount: _.sumBy(labour_tax, x => x.amount),
                        tax: tax_info.tax, tax_rate: tax_info.rate,
                        tax_info: {
                            tax: tax_info.tax, tax_rate: tax_info.rate,
                            rate: tax_info.rate,
                            base: parseFloat(base.toFixed(2)),
                            detail: labour_tax
                        }
                    })
                }

                var opening_fittings = services[i].opening_fitting;
                var opening_fitting = [];

                if (opening_fittings.length > 0) {
                    opening_fitting = opening_fittings
                }
                else {
                    if (services[i].of_cost != 0) {
                        var tax_info = await Tax.findOne({ tax: "18.0% GST" }).exec();
                        var tax_rate = tax_info.detail;
                        var service = services[i].service;
                        var amount = Math.ceil(services[i].of_cost) * quantity;
                        var base = amount;
                        var fitting_tax = [];

                        var x = (100 + tax_info.rate) / 100;
                        var tax_on_amount = amount / x;
                        if (tax_rate.length > 0) {
                            for (var r = 0; r < tax_rate.length; r++) {
                                if (tax_rate[r].rate != tax_info.rate) {
                                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                                    base = base - t
                                    fitting_tax.push({
                                        tax: tax_rate[r].tax,
                                        rate: tax_rate[r].rate,
                                        amount: parseFloat(t.toFixed(2))
                                    })
                                }
                                else {
                                    base = base - t
                                    fitting_tax.push({
                                        tax: tax_info.tax, tax_rate: tax_info.rate,
                                        rate: tax_info.rate,
                                        amount: parseFloat(tax_on_amount.toFixed(2))
                                    })
                                }
                            }
                        }

                        opening_fitting.push({
                            item: services[i].service,
                            quantity: quantity,
                            rate: parseFloat(services[i].of_cost),
                            base: parseFloat(base.toFixed(2)),
                            discount: 0,
                            amount: parseFloat(amount),
                            customer_dep: 100,
                            insurance_dep: 0,
                            amount_is_tax: "inclusive",
                            tax_amount: _.sumBy(fitting_tax, x => x.amount),
                            tax: tax_info.tax,
                            tax_rate: tax_info.rate,
                            tax_info: {
                                tax: tax_info.tax, tax_rate: tax_info.rate,
                                rate: tax_info.rate,
                                base: parseFloat(base.toFixed(2)),
                                detail: fitting_tax
                            }
                        })
                    }
                }

                if (services[i].customer_approval == true) {
                    var cost = _.sumBy(part, x => x.amount) + _.sumBy(labour, x => x.amount) + _.sumBy(opening_fitting, x => x.amount);
                    logged_remark = logged_remark + "-" + services[i].service + ": Rs/-" + cost + "\n";
                }

                bookingService.push({
                    source: services[i].source,
                    service: services[i].service,
                    mileage: services[i].mileage,
                    parts: part,
                    labour: labour,
                    opening_fitting: opening_fitting,
                    hours: services[i].hours,
                    parts_visible: parts_visible,
                    quantity: quantity,
                    description: services[i].description,
                    part_cost: _.sumBy(part, x => x.amount),
                    labour_cost: _.sumBy(labour, x => x.amount),
                    of_cost: _.sumBy(opening_fitting, x => x.amount),
                    exceeded_cost: services[i].exceeded_cost,
                    cost: _.sumBy(part, x => x.amount) + _.sumBy(labour, x => x.amount) + _.sumBy(opening_fitting, x => x.amount),
                    discount: _.sumBy(labour, x => x.discount) + _.sumBy(part, x => x.discount) + _.sumBy(opening_fitting, x => x.discount),
                    part_cost_editable: services[i].part_cost_editable,
                    labour_cost_editable: services[i].labour_cost_editable,
                    of_cost_editable: services[i].of_cost_editable,
                    type: services[i].type,
                    customer_approval: services[i].customer_approval,
                    surveyor_approval: services[i].surveyor_approval,
                    claim: services[i].claim,
                    custom: services[i].custom,
                });
            }

            var approved = _.filter(bookingService, customer_approval => customer_approval.customer_approval == true);

            var policy_clause = 0
            if (booking.payment.policy_clause) {
                policy_clause = booking.payment.policy_clause;
            }
            var salvage = 0
            if (booking.payment.salvage) {
                salvage = booking.payment.salvage;
            }

            var paid_total = booking.payment.paid_total;
            var labour_cost = _.sumBy(bookingService, x => x.labour_cost);
            var part_cost = _.sumBy(bookingService, x => x.part_cost);
            var of_cost = _.sumBy(bookingService, x => x.of_cost);
            var discount_total = _.sumBy(bookingService, x => x.discount);
            var pick_up_charges = booking.payment.pick_up_charges;

            var payment_total = labour_cost + part_cost + of_cost + discount_total + policy_clause + salvage + pick_up_charges;

            var estimate_cost = labour_cost + part_cost + of_cost + policy_clause + salvage + pick_up_charges - careager_cash;
            var careager_cash = booking.payment.careager_cash;

            var due_amount = _.sumBy(approved, x => x.labour_cost) + _.sumBy(approved, x => x.part_cost) + _.sumBy(approved, x => x.of_cost) + policy_clause + salvage + pick_up_charges - (paid_total + careager_cash);

            var due = {
                due: Math.ceil(due_amount.toFixed(2))
            };

            var payment = {
                estimate_cost: estimate_cost,
                total: parseFloat(payment_total.toFixed(2)),
                careager_cash: careager_cash,
                of_cost: parseFloat(of_cost.toFixed(2)),
                labour_cost: parseFloat(labour_cost.toFixed(2)),
                part_cost: parseFloat(part_cost.toFixed(2)),
                payment_mode: booking.payment.payment_mode,
                payment_status: booking.payment.payment_status,
                coupon: booking.payment.coupon,
                coupon_type: booking.payment.coupon_type,
                discount_by: booking.payment.discount_by,
                discount_type: booking.payment.discount_type,
                discount: booking.payment.discount,
                discount_total: discount_total,
                terms: booking.payment.terms,
                pick_up_limit: booking.payment.pick_up_limit,
                policy_clause: policy_clause,
                salvage: salvage,
                pick_up_charges: pick_up_charges,
                paid_total: booking.payment.paid_total,
                discount_applied: booking.payment.discount_applied,
                transaction_id: booking.payment.transaction_id,
                transaction_date: booking.payment.transaction_date,
                transaction_status: booking.payment.transaction_status,
                transaction_response: booking.payment.transaction_response
            };

            Booking.findOneAndUpdate({ _id: booking._id }, { $set: { services: bookingService, payment: payment, due: due, updated_at: new Date() } }, { new: false }, async function (err, doc) {
                if (err) {
                    res.status(400).json({
                        responseCode: 400,
                        responseMessage: "Error Occurred Try again",
                        responseData: err
                    });
                }
                else {
                    if (booking.status == "JobOpen") {
                        var stage = "In-Process";
                        var status = "In-Process";

                        Booking.findOneAndUpdate({ _id: booking._id }, { $set: { status: status, updated_at: new Date() } }, { new: false }, async function (err, doc) {
                            if (err) {
                                return res.status(400).json({
                                    responseCode: 400,
                                    responseMessage: "Error Occurred Try again",
                                    responseData: err
                                });
                            }
                        });
                    }

                    var activity = {
                        user: loggedInDetails._id,
                        name: loggedInDetails.name,
                        stage: "Approval",
                        activity: logged_remark,
                    }

                    fun.bookingLog(booking._id, activity);
                    event.zohoLead(booking._id);

                    var updated = await Booking.findById(booking.id).exec();

                    res.status(200).json({
                        responseCode: 200,
                        responseMessage: "Service has been added...",
                        responseData: updated
                    });
                }
            });
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Booking not found",
                responseData: {}
            });
        }
    }
});

router.post('/estimation/service/add', xAccessToken.token, async function (req, res, next) {
    var rules = {
        booking: 'required',
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Validation Error",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var user = decoded.user;
        var business = req.headers['business'];
        var labour_cost = 0;
        var part_cost = 0;
        var of_cost = 0;
        var due_amount = 0;
        var totalResult = 0;
        var bookingService = [];
        var services_added = "";
        var logged_remark = "";
        var loggedInDetails = await User.findById(decoded.user).exec();
        var booking = await Booking.findById(req.body.booking).exec();
        if (booking) {
            labour_cost = booking.payment.labour_cost;
            part_cost = booking.payment.part_cost;
            if (booking.payment.of_cost) {
                var of_cost = booking.payment.of_cost;
            }
            var services = req.body.services;

            for (var i = 0; i < services.length; i++) {
                var parts_visible = true;
                var part_tax = [];
                var labour_tax = [];
                var fitting_tax = [];
                var tax_detail = {};
                if (typeof services[i].quantity != "number" || parseInt(services[i].quantity) <= 0) {
                    var quantity = 1
                }
                else {
                    var quantity = parseInt(services[i].quantity)
                }

                var parts = services[i].parts;
                var part = [];

                if (parts.length > 0) {
                    part = parts
                }
                else {
                    if (services[i].part_cost > 0) {
                        parts_visible = false;
                        var tax_info = await Tax.findOne({ tax: "0% GST" }).exec();

                        var tax_rate = tax_info.detail;
                        var service = services[i].service;
                        var amount = parseFloat(services[i].part_cost) * quantity;
                        var base = amount;
                        var part_tax = [];

                        var x = (100 + tax_info.rate) / 100;
                        var tax_on_amount = amount / x;

                        if (tax_rate.length > 0) {
                            for (var r = 0; r < tax_rate.length; r++) {
                                if (tax_rate[r].rate != tax_info.rate) {
                                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                                    // cconsole.log
                                    if (t > 0) {
                                        base = base - t;
                                    }
                                    else {
                                        base = base;
                                    }

                                    part_tax.push({
                                        tax: tax_rate[r].tax,
                                        rate: tax_rate[r].rate,
                                        amount: parseFloat(t.toFixed(2))
                                    });
                                }
                                else {
                                    /*if(tax_info.rate>0)
                                    {
                                        tax_on_amount = parseFloat(tax_on_amount.toFixed(2))
                                    }
                                    else
                                    {
                                        tax_on_amount = 0;
                                    }
                                    part_tax.push({
                                        tax: tax_info.tax,tax_rate: tax_info.rate,
                                        rate: tax_info.rate,
                                        amount: 
                                    });*/

                                    var t = amount - tax_on_amount;
                                    base = base - t;
                                    part_tax.push({
                                        tax: tax_info.tax, tax_rate: tax_info.rate,
                                        rate: tax_info.rate,
                                        amount: parseFloat(t.toFixed(2))
                                    });

                                }
                            }
                        }

                        tax_detail = {
                            tax: tax_info.tax, tax_rate: tax_info.rate,
                            rate: tax_info.rate,
                            base: parseFloat(base.toFixed(2)),
                            detail: part_tax
                        }

                        part.push({
                            item: services[i].service,
                            source: null,
                            quantity: quantity,
                            hsn_sac: "",
                            part_no: "",
                            rate: parseFloat(services[i].part_cost),
                            base: parseFloat(base.toFixed(2)),
                            amount: parseFloat(amount),
                            customer_dep: 100,
                            insurance_dep: 0,
                            tax_amount: _.sumBy(part_tax, x => x.amount),
                            amount_is_tax: "inclusive",
                            discount: 0,
                            issued: false,
                            tax: tax_info.tax,
                            tax_rate: tax_info.rate,
                            tax_info: tax_detail
                        })
                    }
                    else {
                        part = []
                    }
                }

                var labour = services[i].labour;
                var labours = [];

                if (labour.length > 0) {
                    labours = labour
                }
                else {
                    if (services[i].labour_cost > 0) {
                        var tax_info = await Tax.findOne({ tax: "18.0% GST" }).exec();
                        var tax_rate = tax_info.detail;
                        var service = services[i].service;
                        var amount = parseFloat(services[i].labour_cost) * quantity;
                        var base = amount;
                        var labour_tax = [];

                        var x = (100 + tax_info.rate) / 100;
                        var tax_on_amount = amount / x;
                        if (tax_rate.length > 0) {
                            for (var r = 0; r < tax_rate.length; r++) {
                                if (tax_rate[r].rate != tax_info.rate) {
                                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                                    base = base - t
                                    labour_tax.push({
                                        tax: tax_rate[r].tax,
                                        rate: parseFloat(tax_rate[r].rate.toFixed(2)),
                                        amount: parseFloat(t.toFixed(2))
                                    })
                                }
                                else {
                                    base = base - t
                                    labour_tax.push({
                                        tax: tax_info.tax, tax_rate: tax_info.rate,
                                        rate: parseFloat(tax_info.rate.toFixed(2)),
                                        amount: parseFloat(tax_on_amount.toFixed(2))
                                    })
                                }
                            }
                        }

                        labours.push({
                            item: services[i].service,
                            quantity: quantity,
                            rate: parseFloat(services[i].labour_cost),
                            base: parseFloat(base.toFixed(2)),
                            amount: parseFloat(amount),
                            customer_dep: 100,
                            insurance_dep: 0,
                            discount: 0,
                            amount_is_tax: "inclusive",
                            tax_amount: _.sumBy(labour_tax, x => x.amount),
                            tax: tax_info.tax, tax_rate: tax_info.rate,
                            tax_info: {
                                tax: tax_info.tax, tax_rate: tax_info.rate,
                                rate: tax_info.rate,
                                base: parseFloat(base.toFixed(2)),
                                detail: labour_tax
                            }
                        })
                    }
                }

                var opening_fittings = services[i].opening_fitting;
                var opening_fitting = [];

                if (opening_fittings.length > 0) {
                    opening_fitting = opening_fittings
                }
                else {
                    if (services[i].of_cost != 0) {
                        var tax_info = await Tax.findOne({ tax: "18.0% GST" }).exec();
                        var tax_rate = tax_info.detail;
                        var service = services[i].service;
                        var amount = parseFloat(services[i].of_cost) * quantity;
                        var base = amount;
                        var fitting_tax = [];

                        var x = (100 + tax_info.rate) / 100;
                        var tax_on_amount = amount / x;
                        if (tax_rate.length > 0) {
                            for (var r = 0; r < tax_rate.length; r++) {
                                if (tax_rate[r].rate != tax_info.rate) {
                                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                                    base = base - t
                                    fitting_tax.push({
                                        tax: tax_rate[r].tax,
                                        rate: tax_rate[r].rate,
                                        amount: parseFloat(t.toFixed(2))
                                    })
                                }
                                else {
                                    base = base - t
                                    fitting_tax.push({
                                        tax: tax_info.tax, tax_rate: tax_info.rate,
                                        rate: tax_info.rate,
                                        amount: parseFloat(tax_on_amount.toFixed(2))
                                    })
                                }
                            }
                        }

                        opening_fitting.push({
                            item: services[i].service,
                            quantity: quantity,
                            rate: parseFloat(services[i].of_cost),
                            base: parseFloat(base.toFixed(2)),
                            discount: 0,
                            amount: parseFloat(amount),
                            customer_dep: 100,
                            insurance_dep: 0,
                            amount_is_tax: "inclusive",
                            tax_amount: _.sumBy(fitting_tax, x => x.amount),
                            tax: tax_info.tax,
                            tax_rate: tax_info.rate,
                            tax_info: {
                                tax: tax_info.tax, tax_rate: tax_info.rate,
                                rate: tax_info.rate,
                                base: parseFloat(base.toFixed(2)),
                                detail: fitting_tax
                            }
                        })
                    }
                }

                var cost = _.sumBy(part, x => x.amount) + _.sumBy(labour, x => x.amount) + _.sumBy(opening_fitting, x => x.amount);
                if (services[i].customer_approval == true) {
                    logged_remark = logged_remark + "-" + services[i].service + ": Rs/-" + cost + "\n";
                }

                services_added = services_added + "-" + services[i].service + ": Rs/-" + cost + "\n";

                bookingService.push({
                    source: services[i].source,
                    service: services[i].service,
                    mileage: services[i].mileage,
                    parts: part,
                    labour: labours,
                    opening_fitting: opening_fitting,
                    hours: services[i].hours,
                    parts_visible: parts_visible,
                    quantity: quantity,
                    discount: _.sumBy(labours, x => x.discount) + _.sumBy(part, x => x.discount) + _.sumBy(opening_fitting, x => x.discount),
                    description: services[i].description,
                    cost: _.sumBy(part, x => x.amount) + _.sumBy(labours, x => x.amount) + services[i].of_cost,
                    labour_cost: parseFloat(services[i].labour_cost),
                    of_cost: parseFloat(services[i].of_cost),
                    part_cost: parseFloat(services[i].part_cost),
                    exceeded_cost: parseFloat(services[i].exceeded_cost),
                    part_cost_editable: services[i].part_cost_editable,
                    labour_cost_editable: services[i].labour_cost_editable,
                    of_cost_editable: services[i].of_cost_editable,
                    type: services[i].type,
                    customer_approval: services[i].customer_approval,
                    surveyor_approval: services[i].surveyor_approval,
                    claim: services[i].claim,
                    custom: services[i].custom,
                });
            }

            var policy_clause = booking.payment.policy_clause;
            if (req.body.policy_clause >= 0 && req.body.policy_clause != null) {
                policy_clause = req.body.policy_clause;
            }

            var salvage = booking.payment.salvage;
            if (req.body.salvage >= 0 && req.body.salvage != null) {
                salvage = req.body.salvage;
            }

            var pick_up_charges = booking.payment.pick_up_charges;
            if (req.body.pick_up_charge >= 0) {
                pick_up_charges = req.body.pick_up_charge;
            }

            var approved = _.filter(bookingService, customer_approval => customer_approval.customer_approval == true);

            var paid_total = booking.payment.paid_total;
            var labour_cost = _.sumBy(bookingService, x => x.labour_cost);
            var part_cost = _.sumBy(bookingService, x => x.part_cost);
            var of_cost = _.sumBy(bookingService, x => x.of_cost);
            var discount_total = _.sumBy(bookingService, x => x.discount);

            var careager_cash = booking.payment.careager_cash;

            var payment_total = labour_cost + part_cost + of_cost + discount_total + policy_clause + salvage + pick_up_charges;

            var estimate_cost = labour_cost + part_cost + of_cost + policy_clause + salvage + pick_up_charges - careager_cash;

            var due_amount = _.sumBy(approved, x => x.labour_cost) + _.sumBy(approved, x => x.part_cost) + _.sumBy(approved, x => x.of_cost) + policy_clause + salvage + pick_up_charges - (paid_total + careager_cash);

            var due = {
                due: Math.ceil(due_amount.toFixed(2))
            }

            var payment = {
                total: parseFloat(payment_total.toFixed(2)),
                estimate_cost: parseFloat(estimate_cost.toFixed(2)),
                careager_cash: careager_cash,
                of_cost: of_cost,
                labour_cost: labour_cost,
                part_cost: part_cost,
                payment_mode: booking.payment.payment_mode,
                payment_status: booking.payment.payment_status,
                discount_type: booking.payment.discount_type,
                coupon: booking.payment.coupon,
                coupon_type: booking.payment.coupon_type,
                discount_by: booking.payment.discount_by,
                discount: booking.payment.discount,
                discount_total: discount_total,
                policy_clause: policy_clause,
                salvage: salvage,
                terms: booking.payment.terms,
                pick_up_limit: booking.payment.pick_up_limit,
                pick_up_charges: pick_up_charges,
                paid_total: parseFloat(booking.payment.paid_total),
                discount_applied: booking.payment.discount_applied,
                transaction_id: booking.payment.transaction_id,
                transaction_date: booking.payment.transaction_date,
                transaction_status: booking.payment.transaction_status,
                transaction_response: booking.payment.transaction_response
            };

            var date = new Date();

            Booking.findOneAndUpdate({ _id: booking._id }, { $set: { services: bookingService, convenience: req.body.convenience, payment: payment, due: due, advance: req.body.advance, updated_at: date } }, { new: false }, async function (err, doc) {
                if (err) {
                    // cconsole.log
                }
                else {
                    var activity = {
                        user: loggedInDetails._id,
                        name: loggedInDetails.name,
                        stage: "Estimation",
                        activity: services_added,
                    }

                    fun.bookingLog(booking._id, activity);

                    if (logged_remark) {
                        var activity = {
                            user: loggedInDetails._id,
                            name: loggedInDetails.name,
                            stage: "Approval",
                            activity: logged_remark,
                        }

                        fun.bookingLog(booking._id, activity);
                    }

                    event.zohoLead(booking._id);

                    var updated = await Booking.findById(booking.id).exec();
                    res.status(200).json({
                        responseCode: 200,
                        responseMessage: "Service has been added...",
                        responseData: updated
                    });
                }
            });
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Booking not found",
                responseData: {}
            });
        }
    }
});

router.post('/intimation/send', xAccessToken.token, async function (req, res, next) {
    var rules = {
        booking: 'required',
        email: 'required'
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Validation Error",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var loggedInDetails = await User.findById(decoded.user).exec();
        var user = decoded.user;
        var business = req.headers['business'];
        var labour_cost = 0;
        var part_cost = 0;
        var of_cost = 0;
        var due_amount = 0;
        var totalResult = 0;
        var bookingService = [];

        var booking = await Booking.findById(req.body.booking).exec();
        if (booking) {
            if (booking.insurance_info.claim == true) {

                var services = booking.services;
                var claim = _.filter(services, claim => claim.claim == true);
                var labour_cost = _.sumBy(claim, x => x.labour_cost * x.quantity);
                var part_cost = _.sumBy(claim, x => x.part_cost * x.quantity);
                var of_cost = _.sumBy(claim, x => x.of_cost * x.quantity);


                var payment = {
                    total: labour_cost + part_cost + of_cost,
                    of_cost: of_cost,
                    labour_cost: labour_cost,
                    part_cost: part_cost,
                    payment_mode: booking.payment.payment_mode,
                    payment_status: booking.payment.payment_status,
                    coupon: "",
                    coupon_type: "",
                    discount_by: "",
                    discount_type: "",
                    discount: 0,
                    discount_total: 0,
                    policy_clause: booking.payment.policy_clause,
                    salvage: booking.payment.salvage,
                    terms: booking.payment.terms,
                    pick_up_limit: 0,
                    pick_up_charges: 0,
                    paid_total: 0,
                    discount_applied: booking.payment.discount_applied,
                    transaction_id: booking.payment.transaction_id,
                    transaction_date: booking.payment.transaction_date,
                    transaction_status: booking.payment.transaction_status,
                    transaction_response: booking.payment.transaction_response
                };

                var due = {
                    due: part_cost + labour_cost + of_cost
                };

                if (claim.length > 0) {
                    Booking.findOneAndUpdate({ _id: booking._id }, { $set: { status: "ClaimIntimated", claimed: services, insurance_payment: payment, insurance_due: due } }, { new: false }, async function (err, doc) {
                        if (err) {
                            return res.status(400).json({
                                responseCode: 400,
                                responseMessage: "Error",
                                responseData: err
                            });
                        }
                        else {
                            var activity = {
                                user: loggedInDetails._id,
                                name: loggedInDetails.name,
                                stage: "Estimation",
                                activity: "ClaimIntimated",
                            };

                            fun.bookingLog(booking._id, activity);
                            event.intimateMail(booking._id, req.body.email, req.headers['tz']);
                            return res.status(200).json({
                                responseCode: 200,
                                responseMessage: "Claim has been intimated",
                                responseData: {}
                            });
                        }
                    });
                }
                else {
                    return res.status(400).json({
                        responseCode: 400,
                        responseMessage: "There is no service under claim!",
                        responseData: {}
                    });
                }
            }
            else {
                return res.status(400).json({
                    responseCode: 400,
                    responseMessage: "Seems Jobcard is not open with insurance claim.",
                    responseData: {}
                });
            }
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Booking not found",
                responseData: {}
            });
        }
    }
});

router.post('/approved/services/add', xAccessToken.token, async function (req, res, next) {
    var rules = {
        booking: 'required',
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Validation Error",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var user = decoded.user;
        var business = req.headers['business'];
        var bookingService = [];

        var booking = await Booking.findById(req.body.booking).exec();
        if (booking) {
            var services = req.body.services;

            for (var i = 0; i < services.length; i++) {
                var parts_visible = true;
                var part_tax = [];
                var labour_tax = [];
                var fitting_tax = [];
                var tax_detail = {};
                if (typeof services[i].quantity != "number" || parseInt(services[i].quantity) <= 0) {
                    var quantity = 1
                }
                else {
                    var quantity = parseInt(services[i].quantity)
                }

                var parts = services[i].parts;
                var part = [];

                if (parts.length > 0) {
                    part = parts
                }
                else {
                    if (services[i].part_cost != 0) {
                        parts_visible = false;
                        var tax_info = await Tax.findOne({ tax: "0% GST" }).exec();
                        var tax_rate = tax_info.detail;
                        var service = services[i].service;
                        var amount = parseFloat(services[i].part_cost) * quantity;
                        var base = amount;
                        var part_tax = [];

                        var x = (100 + tax_info.rate) / 100;
                        var tax_on_amount = amount / x;
                        if (tax_rate.length > 0) {
                            for (var r = 0; r < tax_rate.length; r++) {
                                if (tax_rate[r].rate != tax_info.rate) {
                                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                                    base = base - t;
                                    part_tax.push({
                                        tax: tax_rate[r].tax,
                                        rate: tax_rate[r].rate,
                                        amount: parseFloat(t.toFixed(2))
                                    });
                                }
                                else {
                                    base = base - t
                                    part_tax.push({
                                        tax: tax_info.tax, tax_rate: tax_info.rate,
                                        rate: tax_info.rate,
                                        amount: parseFloat(tax_on_amount.toFixed(2))
                                    });
                                }
                            }
                        }

                        tax_detail = {
                            tax: tax_info.tax, tax_rate: tax_info.rate,
                            rate: tax_info.rate,
                            base: parseFloat(base.toFixed(2)),
                            detail: part_tax
                        }

                        part.push({
                            item: services[i].service,
                            source: null,
                            quantity: quantity,
                            hsn_sac: "",
                            part_no: "",
                            rate: parseFloat(services[i].part_cost),
                            base: parseFloat(base.toFixed(2)),
                            amount: parseFloat(amount),
                            customer_dep: 100,
                            insurance_dep: 0,
                            tax_amount: _.sumBy(part_tax, x => x.amount),
                            amount_is_tax: "inclusive",
                            discount: 0,
                            issued: false,
                            tax: tax_info.tax, tax_rate: tax_info.rate,
                            tax_info: tax_detail
                        })
                    }
                    else {
                        part = []
                    }
                }

                var labour = services[i].labour;
                var labours = [];

                if (labour.length > 0) {
                    labours = labour
                }
                else {
                    var tax_info = await Tax.findOne({ tax: "18.0% GST" }).exec();
                    var tax_rate = tax_info.detail;
                    var service = services[i].service;
                    var amount = parseFloat(services[i].labour_cost) * quantity;
                    var base = amount;
                    var labour_tax = [];

                    var x = (100 + tax_info.rate) / 100;
                    var tax_on_amount = amount / x;
                    if (tax_rate.length > 0) {
                        for (var r = 0; r < tax_rate.length; r++) {
                            if (tax_rate[r].rate != tax_info.rate) {
                                var t = tax_on_amount * (tax_rate[r].rate / 100);
                                base = base - t
                                labour_tax.push({
                                    tax: tax_rate[r].tax,
                                    rate: parseFloat(tax_rate[r].rate.toFixed(2)),
                                    amount: parseFloat(t.toFixed(2))
                                })
                            }
                            else {
                                base = base - t
                                labour_tax.push({
                                    tax: tax_info.tax, tax_rate: tax_info.rate,
                                    rate: parseFloat(tax_info.rate.toFixed(2)),
                                    amount: parseFloat(tax_on_amount.toFixed(2))
                                })
                            }
                        }
                    }

                    labours.push({
                        item: services[i].service,
                        quantity: quantity,
                        rate: parseFloat(services[i].labour_cost),
                        base: parseFloat(base.toFixed(2)),
                        amount: parseFloat(amount),
                        customer_dep: 100,
                        insurance_dep: 0,
                        discount: 0,
                        amount_is_tax: "inclusive",
                        tax_amount: _.sumBy(labour_tax, x => x.amount),
                        tax: tax_info.tax, tax_rate: tax_info.rate,
                        tax_info: {
                            tax: tax_info.tax, tax_rate: tax_info.rate,
                            rate: tax_info.rate,
                            base: parseFloat(base.toFixed(2)),
                            detail: labour_tax
                        }
                    })
                }

                var opening_fittings = services[i].opening_fitting;
                var opening_fitting = [];

                if (opening_fittings.length > 0) {
                    opening_fitting = opening_fittings
                }
                else {
                    if (services[i].of_cost != 0) {
                        var tax_info = await Tax.findOne({ tax: "18.0% GST" }).exec();
                        var tax_rate = tax_info.detail;
                        var service = services[i].service;
                        var amount = parseFloat(services[i].of_cost) * quantity;
                        var base = amount;
                        var fitting_tax = [];

                        var x = (100 + tax_info.rate) / 100;
                        var tax_on_amount = amount / x;
                        if (tax_rate.length > 0) {
                            for (var r = 0; r < tax_rate.length; r++) {
                                if (tax_rate[r].rate != tax_info.rate) {
                                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                                    base = base - t
                                    fitting_tax.push({
                                        tax: tax_rate[r].tax,
                                        rate: tax_rate[r].rate,
                                        amount: parseFloat(t.toFixed(2))
                                    })
                                }
                                else {
                                    base = base - t
                                    fitting_tax.push({
                                        tax: tax_info.tax, tax_rate: tax_info.rate,
                                        rate: tax_info.rate,
                                        amount: parseFloat(tax_on_amount.toFixed(2))
                                    })
                                }
                            }
                        }

                        opening_fitting.push({
                            item: services[i].service,
                            quantity: quantity,
                            rate: parseFloat(services[i].of_cost),
                            base: parseFloat(base.toFixed(2)),
                            discount: 0,
                            amount: parseFloat(amount),
                            customer_dep: 100,
                            insurance_dep: 0,
                            amount_is_tax: "inclusive",
                            tax_amount: _.sumBy(fitting_tax, x => x.amount),
                            tax: tax_info.tax,
                            tax_rate: tax_info.rate,
                            tax_info: {
                                tax: tax_info.tax, tax_rate: tax_info.rate,
                                rate: tax_info.rate,
                                base: parseFloat(base.toFixed(2)),
                                detail: fitting_tax
                            }
                        })
                    }
                    else {
                        opening_fitting = [];
                    }
                }

                bookingService.push({
                    source: services[i].source,
                    service: services[i].service,
                    mileage: services[i].mileage,
                    parts: part,
                    labour: labours,
                    opening_fitting: opening_fitting,
                    hours: services[i].hours,
                    parts_visible: parts_visible,
                    quantity: quantity,
                    discount: _.sumBy(labours, x => x.discount) + _.sumBy(opening_fitting, x => x.discount) + _.sumBy(part, x => x.discount),
                    description: services[i].description,
                    cost: services[i].part_cost + _.sumBy(labours, x => x.amount) + services[i].of_cost,
                    labour_cost: parseFloat(services[i].labour_cost),
                    of_cost: parseFloat(services[i].of_cost),
                    part_cost: parseFloat(services[i].part_cost),
                    part_cost_editable: services[i].part_cost_editable,
                    labour_cost_editable: services[i].labour_cost_editable,
                    of_cost_editable: services[i].of_cost_editable,
                    type: services[i].type,
                    customer_approval: services[i].customer_approval,
                    surveyor_approval: services[i].claim,
                    claim: services[i].claim,
                    custom: services[i].custom,
                });
            }

            var claim = _.filter(bookingService, claim => claim.claim == true);
            var labour_cost = _.sumBy(claim, x => x.labour_cost * x.quantity);
            var part_cost = _.sumBy(claim, x => x.part_cost * x.quantity);
            var of_cost = _.sumBy(claim, x => x.of_cost * x.quantity);

            var insurance_payment = {
                total: labour_cost + part_cost + of_cost,
                of_cost: of_cost,
                labour_cost: labour_cost,
                part_cost: part_cost,
                payment_mode: booking.payment.payment_mode,
                payment_status: booking.payment.payment_status,
                coupon: "",
                coupon_type: "",
                discount_by: "",
                discount_type: "",
                discount: 0,
                discount_total: 0,
                policy_clause: 0,
                salvage: 0,
                terms: "",
                pick_up_limit: 0,
                pick_up_charges: 0,
                paid_total: 0,
                transaction_id: "",
                transaction_date: "",
                transaction_status: "",
                transaction_response: ""
            };

            var insurance_due = {
                due: part_cost + labour_cost + of_cost
            };

            var date = new Date();
            Booking.findOneAndUpdate({ _id: booking._id }, { $set: { claimed: bookingService, services: bookingService, insurance_payment: insurance_payment, insurance_due: insurance_due, updated_at: new Date() } }, { new: false }, async function (err, doc) {
                if (err) {
                    res.status(400).json({
                        responseCode: 400,
                        responseMessage: "Error Occurred Try again",
                        responseData: err
                    });
                }
                else {
                    var activity = {
                        user: user,
                        model: "Booking",
                        activity: "Surveyor Approved",
                    }

                    fun.bookingLog(booking._id, activity);

                    var updated = await Booking.findById(booking.id).exec();
                    res.status(200).json({
                        responseCode: 200,
                        responseMessage: "Service has been added...",
                        responseData: updated
                    });
                }
            });
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Booking not found",
                responseData: {}
            });
        }
    }
});

router.post('/estimate/settlement', xAccessToken.token, async function (req, res, next) {
    var rules = {
        booking: 'required',
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Validation Error",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var user = decoded.user;
        var business = req.headers['business'];

        var labour_cost = 0;
        var part_cost = 0;
        var of_cost = 0;
        var due_amount = 0;
        var totalResult = 0;
        var bookingService = [];

        var booking = await Booking.findById(req.body.booking).exec();
        var loggedInDetails = await User.findById(decoded.user).exec();


        if (booking) {
            if (booking.sub_status == "") {
                Booking.findOneAndUpdate({ _id: booking._id }, { $set: { updated_at: new Date() } }, { new: false }, async function (err, doc) {
                    if (err) {
                        res.status(400).json({
                            responseCode: 400,
                            responseMessage: "Error Occurred",
                            responseData: err
                        });
                    }
                    else {
                        var activity = {
                            user: loggedInDetails._id,
                            name: loggedInDetails.name,
                            stage: "Estimation",
                            activity: "Approval",
                        }

                        fun.bookingLog(booking._id, activity);

                        if (booking.manager) {
                            var notify = {
                                receiver: [booking.manager],
                                activity: "booking",
                                tag: "EstimateSendManager",
                                source: booking._id,
                                sender: loggedInDetails._id,
                                points: 0
                            };
                            fun.newNotification(notify);
                        }

                        var notify = {
                            receiver: [booking.user],
                            activity: "booking",
                            tag: "EstimateSendUser",
                            source: booking._id,
                            sender: loggedInDetails._id,
                            points: 0
                        };

                        fun.newNotification(notify);
                        event.estimateMail(booking._id, req.headers['tz']);
                        event.jobSms(notify);

                        res.status(200).json({
                            responseCode: 200,
                            responseMessage: "Estimation has been sent",
                            responseData: {}
                        });
                    }
                });
            }
            else {
                Booking.findOneAndUpdate({ _id: booking._id }, { $set: { updated_at: new Date() } }, { new: false }, async function (err, doc) {

                    if (err) {
                        return res.status(400).json({
                            responseCode: 400,
                            responseMessage: "Error",
                            responseData: err
                        });
                    }
                    else {
                        var activity = {
                            user: loggedInDetails._id,
                            name: loggedInDetails.name,
                            stage: "Estimation",
                            activity: "CustomerApproval",
                        };

                        fun.bookingLog(booking._id, activity);
                        event.zohoLead(booking._id);


                        var notify = {
                            receiver: [booking.user],
                            activity: "booking",
                            tag: "ApprovalAwaited",
                            source: booking._id,
                            sender: loggedInDetails._id,
                            points: 0
                        };
                        fun.newNotification(notify);
                        event.estimateMail(booking._id, req.headers['tz']);
                        event.jobSms(notify);



                        res.status(200).json({
                            responseCode: 200,
                            responseMessage: "Estimation has been sent",
                            responseData: {}
                        });
                    }
                });
            }
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Booking not found",
                responseData: {}
            });
        }
    }
})

router.get('/booking/coupon/list', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var data = [];
    var business = req.headers['business'];

    await Coupon.findOne({ is_product: false, business: business })
        .cursor().eachAsync(async (coupon) => {
            if (coupon) {
                var used = await CouponUsed.findOne({ code: coupon.code, user: user }).count().exec();
                if (used < coupon.usage_limit) {
                    var serverTime = moment.tz(new Date(), req.headers['tz']);
                    var bar = moment.tz(coupon.expired_at, req.headers['tz']);
                    var baz = bar.diff(serverTime);
                    // console.log(baz);
                    if (baz > 0) {

                        var limit = await CouponUsed.findOne({ code: coupon.code }).count().exec();
                        if (limit < coupon.limit) {
                            data.push({
                                _id: coupon._id,
                                id: coupon.id,
                                code: coupon.code,
                                limit: coupon.limit,
                                description: coupon.description
                            });
                        }
                    }
                }
            }
        })
    res.status(200).json({
        responseCode: 200,
        responseMessage: "Coupons",
        responseData: data
    })
});

router.post('/booking/coupon/add', xAccessToken.token, async function (req, res, next) {
    var rules = {
        id: 'required',
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Booking is required",
            responseData: {
                res: validation.errors.all()
            }
        });
    }
    else {
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var user = decoded.user;

        if (req.headers['business']) {
            user = req.headers['business'];
        }

        var data = new Object();
        var discount = 0;
        var code = "";
        var discount_type = "";
        var discount_by = "";


        var booking = await Booking.findOne({ _id: req.body.id }).exec();

        if (booking) {
            var careager_cash = await q.all(fun.getCarEagerCash(booking._id));
            // console.log("careager_cash: " + careager_cash)
            var services = booking.services;
            if (booking.payment.total != 0 && booking.package == null) {
                type = req.body.type;

                if (type == "coupon") {
                    discount_by = "coupon";
                    discount_type = "coupon";
                    var discount_eligible = [];
                    var coupon = await Coupon.findOne({ code: req.body.coupon.toUpperCase(), is_product: false }).exec();
                    var used = await CouponUsed.findOne({ code: req.body.coupon.toUpperCase(), user: booking.user }).count().exec();

                    if (coupon) {
                        if (used < coupon.usage_limit) {
                            var serverTime = moment.tz(new Date(), req.headers['tz']);
                            var bar = moment.tz(coupon.expired_at, req.headers['tz']);
                            var baz = bar.diff(serverTime);
                            if (baz > 0) {
                                var limit = await CouponUsed.findOne({ code: req.body.coupon.toUpperCase() }).count().exec();
                                if (limit <= coupon.limit) {
                                    code = req.body.coupon.toUpperCase();
                                    discount_type = "coupon";
                                    if (coupon.coupon_on == "total") {
                                        if (coupon.for == "category") {
                                            var filter = _.filter(booking.services, claim => claim.claim == false)
                                            discount_eligible = _.filter(filter, type => type.type == coupon.label);
                                            if (discount_eligible.length > 0) {
                                                var discount_eligible_labour = _.map(discount_eligible, 'labour');
                                                var discount_eligible_labour_cost = 0;
                                                for (var k = 0; k < discount_eligible_labour.length; k++) {
                                                    discount_eligible_labour_cost = _.sumBy(discount_eligible_labour[k], x => x.rate * x.quantity) + discount_eligible_labour_cost;
                                                }
                                            }
                                            else {
                                                return res.status(400).json({
                                                    responseCode: 400,
                                                    responseMessage: "Coupon not valid for this services",
                                                    responseData: {}
                                                });
                                            }
                                        }
                                        else if (coupon.for == "specific") {
                                            var filter = _.filter(booking.services, claim => claim.claim == false)
                                            discount_eligible = _.filter(filter, service => service.service == coupon.label);
                                            if (discount_eligible.length > 0) {
                                                var discount_eligible_labour = _.map(discount_eligible, 'labour');
                                                var discount_eligible_labour_cost = 0;
                                                for (var k = 0; k < discount_eligible_labour.length; k++) {
                                                    discount_eligible_labour_cost = _.sumBy(discount_eligible_labour[k], x => x.rate * x.quantity) + discount_eligible_labour_cost;
                                                }
                                            }
                                            else {
                                                return res.status(400).json({
                                                    responseCode: 400,
                                                    responseMessage: "Coupon not valid for this services",
                                                    responseData: {}
                                                });
                                            }
                                        }
                                    }
                                    else {
                                        if (coupon.for == "general") {
                                            discount_eligible = _.filter(booking.services, claim => claim.claim == false);
                                            if (discount_eligible.length > 0) {
                                                var discount_eligible_labour = _.map(discount_eligible, 'labour');
                                                var discount_eligible_labour_cost = 0;
                                                for (var k = 0; k < discount_eligible_labour.length; k++) {
                                                    discount_eligible_labour_cost = _.sumBy(discount_eligible_labour[k], x => x.rate * x.quantity) + discount_eligible_labour_cost;
                                                }
                                            }
                                            else {
                                                return res.status(400).json({
                                                    responseCode: 400,
                                                    responseMessage: "Coupon not valid for this services",
                                                    responseData: {}
                                                });
                                            }
                                        }
                                        else if (coupon.for == "category") {
                                            var filter = _.filter(booking.services, claim => claim.claim == false)
                                            discount_eligible = _.filter(filter, type => type.type == coupon.label);

                                            if (discount_eligible.length > 0) {
                                                var discount_eligible_labour = _.map(discount_eligible, 'labour');
                                                var discount_eligible_labour_cost = 0;
                                                for (var k = 0; k < discount_eligible_labour.length; k++) {
                                                    discount_eligible_labour_cost = _.sumBy(discount_eligible_labour[k], x => x.rate * x.quantity) + discount_eligible_labour_cost;
                                                }
                                            }
                                            else {
                                                return res.status(400).json({
                                                    responseCode: 400,
                                                    responseMessage: "Coupon not valid for this services",
                                                    responseData: {}
                                                });
                                            }
                                        }
                                        else if (coupon.for == "specific") {
                                            var filter = _.filter(booking.services, claim => claim.claim == false)
                                            discount_eligible = _.filter(filter, service => service.service == coupon.label);
                                            if (discount_eligible.length > 0) {
                                                var discount_eligible_labour = _.map(discount_eligible, 'labour');
                                                var discount_eligible_labour_cost = 0;
                                                for (var k = 0; k < discount_eligible_labour.length; k++) {
                                                    discount_eligible_labour_cost = _.sumBy(discount_eligible_labour[k], x => x.rate * x.quantity) + discount_eligible_labour_cost;
                                                }
                                            }
                                            else {
                                                return res.status(400).json({
                                                    responseCode: 400,
                                                    responseMessage: "Coupon not valid for this services",
                                                    responseData: {}
                                                });
                                            }
                                        }
                                    }
                                }
                                else {
                                    return res.status(400).json({
                                        responseCode: 400,
                                        responseMessage: "Coupon has been expired",
                                        responseData: {}
                                    });
                                }
                            }
                            else {
                                return res.status(400).json({
                                    responseCode: 400,
                                    responseMessage: "Coupon has been expired",
                                    responseData: {}
                                });
                            }
                        }
                        else {
                            return res.status(400).json({
                                responseCode: 400,
                                responseMessage: "Coupon has been used",
                                responseData: {}
                            });
                        }
                    }
                    else {
                        return res.status(400).json({
                            responseCode: 400,
                            responseMessage: "Coupon doesn't Exist",
                            responseData: {}
                        });
                    }


                    var total_labour_cost = _.sumBy(services, x => x.labour_cost);

                    if (total_labour_cost < careager_cash) {
                        discount_total = 0;
                    }

                    for (var i = 0; i < services.length; i++) {
                        if (services[i].claim == true) {
                            bookingService.push(services[i])
                        }
                        else {
                            var labour_list = services[i].labour;

                            var labours = [];

                            if (labour_list) {
                                for (var l = 0; l < labour_list.length; l++) {
                                    var discount_total = 0;
                                    var total = 0;
                                    var tax_info = await Tax.findOne({ tax: labour_list[l].tax }).exec();

                                    var tax = [];
                                    var rate = labour_list[l].rate;
                                    var amount = parseFloat(labour_list[l].rate) * parseFloat(labour_list[l].quantity);
                                    var tax_rate = tax_info.detail;
                                    var base = amount;

                                    if (coupon.coupon_on == "total") {
                                        if (coupon.for == "category") {
                                            if (services[i].type == coupon.label) {
                                                if (coupon.type == "percent") {

                                                    discount_by = "percent";
                                                    discount = parseFloat(coupon.discount);
                                                    if (total_labour_cost < careager_cash) {
                                                        discount_total = 0;
                                                    }

                                                    if (!isNaN(discount) && discount > 0) {
                                                        discount_total = amount * (discount / 100);
                                                        amount = amount - parseFloat(discount_total.toFixed(2))
                                                        if (amount < 0) {
                                                            amount = 0
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        else if (coupon.for == "specific") {
                                            if (services[i].service == coupon.label) {
                                                if (coupon.type == "percent") {
                                                    discount_by = "percent";
                                                    discount = parseFloat(coupon.discount);
                                                    if (total_labour_cost < careager_cash) {
                                                        discount_total = 0;
                                                    }

                                                    if (!isNaN(discount) && discount > 0) {
                                                        discount_total = amount * (discount / 100);
                                                        amount = amount - parseFloat(discount_total.toFixed(2))
                                                        if (amount < 0) {
                                                            amount = 0
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    else {
                                        if (coupon.for == "general") {
                                            if (coupon.type == "percent") {
                                                discount_by = "percent";
                                                discount = parseFloat(coupon.discount);


                                                if (!isNaN(discount) && discount > 0) {
                                                    discount_total = amount * (discount / 100);
                                                    amount = amount - parseFloat(discount_total.toFixed(2))
                                                    if (amount < 0) {
                                                        amount = 0
                                                    }
                                                }
                                            }
                                            else if (coupon.type == "price") {
                                                discount_by = "value";
                                                discount = parseFloat(coupon.discount);


                                                if (!isNaN(discount) && discount > 0) {
                                                    discount_total = (amount / discount_eligible_labour_cost) * discount;
                                                    amount = amount - parseFloat(discount_total.toFixed(2))
                                                    if (amount < 0) {
                                                        amount = 0
                                                    }
                                                }
                                            }
                                        }
                                        else if (coupon.for == "category") {
                                            if (services[i].type == coupon.label) {
                                                if (coupon.type == "percent") {
                                                    discount_by = "percent";
                                                    discount = parseFloat(coupon.discount);
                                                    if (total_labour_cost < careager_cash) {
                                                        discount_total = 0;
                                                    }
                                                    if (!isNaN(discount) && discount > 0) {
                                                        discount_total = amount * (discount / 100);
                                                        amount = amount - parseFloat(discount_total.toFixed(2))
                                                        if (amount < 0) {
                                                            amount = 0
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        else if (coupon.for == "specific") {
                                            if (services[i].service == coupon.label) {
                                                if (coupon.type == "percent") {
                                                    discount_by = "percent";
                                                    discount = parseFloat(coupon.discount);
                                                    if (total_labour_cost < careager_cash) {
                                                        discount_total = 0;
                                                    }
                                                    if (!isNaN(discount) && discount > 0) {
                                                        discount_total = amount * (discount / 100);
                                                        amount = amount - parseFloat(discount_total.toFixed(2))
                                                        if (amount < 0) {
                                                            amount = 0
                                                        }
                                                    }
                                                }
                                                if (coupon.type == "fixed") {
                                                    labour_list[l].amount_is_tax = "inclusive";
                                                    discount_by = "value";
                                                    discount = parseFloat(coupon.discount);
                                                    if (total_labour_cost < careager_cash) {
                                                        discount_total = 0;
                                                    }
                                                    discount_total = (amount / discount_eligible_labour_cost) * discount;
                                                    discount = amount - discount_total;
                                                    amount = parseFloat(discount_total.toFixed(2));
                                                    discount_total = discount
                                                    if (amount < 0) {
                                                        amount = 0
                                                    }
                                                }

                                                else if (coupon.type == "price") {
                                                    discount_by = "value";
                                                    discount = parseFloat(coupon.discount);
                                                    if (total_labour_cost < careager_cash) {
                                                        discount_total = 0;
                                                    }
                                                    if (!isNaN(discount) && discount > 0) {
                                                        discount_total = (amount / discount_eligible_labour_cost) * discount;
                                                        amount = amount - parseFloat(discount_total.toFixed(2))
                                                        if (amount < 0) {
                                                            amount = 0
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }

                                    if (labour_list[l].amount_is_tax == "exclusive") {
                                        var tax_on_amount = amount;
                                        if (tax_rate.length > 0) {
                                            for (var r = 0; r < tax_rate.length; r++) {
                                                if (tax_rate[r].rate != tax_info.rate) {
                                                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                                                    amount = amount + t;
                                                    tax.push({
                                                        tax: tax_rate[r].tax,
                                                        rate: tax_rate[r].rate,
                                                        amount: parseFloat(t.toFixed(2))
                                                    });
                                                }
                                                else {
                                                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                                                    amount = amount + t;
                                                    tax.push({
                                                        tax: tax_info.tax, tax_rate: tax_info.rate,
                                                        rate: tax_info.rate,
                                                        amount: parseFloat(t.toFixed(2))
                                                    });
                                                }
                                            }
                                        }
                                        total = total + amount;
                                    }

                                    if (labour_list[l].amount_is_tax == "inclusive") {
                                        var x = (100 + tax_info.rate) / 100;
                                        var tax_on_amount = amount / x;
                                        if (tax_rate.length > 0) {
                                            for (var r = 0; r < tax_rate.length; r++) {
                                                if (tax_rate[r].rate != tax_info.rate) {
                                                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                                                    base = base - t;
                                                    tax.push({
                                                        tax: tax_rate[r].tax,
                                                        rate: tax_rate[r].rate,
                                                        amount: parseFloat(t.toFixed(2))
                                                    });
                                                }
                                                else {
                                                    var t = amount - tax_on_amount;
                                                    base = base - t;
                                                    tax.push({
                                                        tax: tax_info.tax, tax_rate: tax_info.rate,
                                                        rate: tax_info.rate,
                                                        amount: parseFloat(t.toFixed(2))
                                                    });
                                                }
                                            }

                                            //base = base - discount_total;
                                        }
                                        total = total + amount;
                                    }

                                    var tax_details = {
                                        tax: tax_info.tax,
                                        rate: tax_info.rate,
                                        amount: total,
                                        detail: tax
                                    }

                                    labours.push({
                                        item: labour_list[l].item,
                                        source: labour_list[l].source,
                                        rate: parseFloat(labour_list[l].rate),
                                        quantity: parseFloat(labour_list[l].quantity),
                                        base: parseFloat(base.toFixed(2)),
                                        discount: parseFloat(discount_total.toFixed(2)),
                                        amount: total,
                                        customer_dep: parseFloat(labour_list[l].customer_dep),
                                        insurance_dep: parseFloat(labour_list[l].insurance_dep),
                                        tax_amount: parseFloat(_.sumBy(tax, x => x.amount).toFixed(2)),
                                        amount_is_tax: labour_list[l].amount_is_tax,
                                        tax: tax_info.tax,
                                        tax_rate: tax_info.rate,
                                        tax_info: tax_details
                                    });
                                }

                                bookingService.push({
                                    quantity: services[i].quantity,
                                    part_cost: services[i].part_cost,
                                    labour_cost: _.sumBy(labours, x => x.amount),
                                    of_cost: services[i].of_cost,
                                    exceeded_cost: services[i].exceeded_cost,
                                    part_rate: services[i].part_rate,
                                    labour_rate: services[i].labour_rate,
                                    of_rate: services[i].of_rate,
                                    parts: services[i].parts,
                                    labour: labours,
                                    cost: services[i].part_cost + _.sumBy(labours, x => x.amount) + services[i].of_cost,
                                    opening_fitting: services[i].opening_fitting,
                                    part_cost_editable: services[i].part_cost_editable,
                                    labour_cost_editable: services[i].part_cost_editable,
                                    of_cost_editable: services[i].part_cost_editable,
                                    description: services[i].description,
                                    service: services[i].service,
                                    type: services[i].type,
                                    claim: services[i].claim,
                                    custom: services[i].custom,
                                    discount: _.sumBy(labours, x => x.discount) + _.sumBy(services[i].parts, x => x.discount) + _.sumBy(services[i].opening_fitting, x => x.discount),
                                    customer_approval: services[i].customer_approval, surveyor_approval: services[i].surveyor_approval,
                                    source: services[i].source
                                });
                            }
                        }
                    }
                }
                else {
                    bookingService = services;
                }
            }
            else {
                bookingService = services;
            }


            var paid_total = booking.payment.paid_total;
            var pick_up_charges = booking.payment.pick_up_charges;
            var labour_cost = _.sumBy(bookingService, x => x.labour_cost);
            var part_cost = _.sumBy(bookingService, x => x.part_cost);
            var of_cost = _.sumBy(bookingService, x => x.of_cost);
            var discount_total = _.sumBy(bookingService, x => x.discount);

            var policy_clause = 0
            if (booking.payment.policy_clause) {
                policy_clause = booking.payment.policy_clause;
            }
            var salvage = 0
            if (booking.payment.salvage) {
                salvage = booking.payment.salvage;
            }

            var total = labour_cost + part_cost + of_cost + discount_total + policy_clause + salvage + pick_up_charges;
            var due = part_cost + labour_cost + of_cost + policy_clause + salvage + pick_up_charges - careager_cash;

            var payment = {
                estimate_cost: due,
                careager_cash: careager_cash,
                total: parseFloat(total.toFixed(2)),
                of_cost: parseFloat(of_cost.toFixed(2)),
                labour_cost: parseFloat(labour_cost.toFixed(2)),
                part_cost: parseFloat(part_cost.toFixed(2)),
                payment_mode: booking.payment.payment_mode,
                payment_status: booking.payment.payment_status,
                coupon: code,
                coupon_type: "",
                discount_by: discount_by,
                discount_type: discount_type,
                discount: discount,
                discount_total: discount_total,
                policy_clause: booking.payment.policy_clause,
                salvage: booking.payment.salvage,
                terms: booking.payment.terms,
                pick_up_limit: booking.payment.pick_up_limit,
                pick_up_charges: booking.payment.pick_up_charges,
                paid_total: 0,
                discount_applied: booking.payment.discount_applied,
                transaction_id: booking.payment.transaction_id,
                transaction_date: booking.payment.transaction_date,
                transaction_status: booking.payment.transaction_status,
                transaction_response: booking.payment.transaction_response
            };

            var due = {
                due: Math.ceil(due.toFixed(2))
            };

            Booking.findOneAndUpdate({ _id: booking._id }, { $set: { services: bookingService, payment: payment, due: due, updated_at: new Date() } }, { new: false }, async function (err, doc) {
                if (err) {
                    res.status(400).json({
                        responseCode: 400,
                        responseMessage: "Error",
                        responseData: err
                    });
                }
                else {
                    var update = await Booking.findById(booking.id).exec();
                    res.status(200).json({
                        responseCode: 200,
                        responseMessage: "Discount has been applied",
                        responseData: {
                            payment: payment,
                            due: due
                        }
                    });
                }
            });
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Unauthorized",
                responseData: {}
            });
        }
    }
});

router.post('/booking/discount/add', xAccessToken.token, async function (req, res, next) {
    var rules = {
        booking: 'required',
        type: 'required',
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Booking is required",
            responseData: {
                res: validation.errors.all()
            }
        });
    }
    else {
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var user = decoded.user;
        var data = new Object();
        var discount = 0;
        var code = "";
        var discount_type = "";
        var discount_by = "";


        var booking = await Booking.findOne({ _id: req.body.booking }).exec();

        if (booking) {
            if (booking.payment.total != 0 && booking.package == null) {
                var bookingService = [];
                var services = booking.services;
                var type = req.body.type;

                if (type == "special") {
                    discount_by = req.body.discount_type;
                    discount_type = "special";

                    var discount_eligible = _.filter(booking.services, claim => claim.claim == false);

                    var discount_eligible_labour = _.map(discount_eligible, 'labour');
                    var discount_eligible_labour_cost = 0;

                    for (var k = 0; k < discount_eligible_labour.length; k++) {
                        discount_eligible_labour_cost = _.sumBy(discount_eligible_labour[k], x => x.rate * x.quantity) + discount_eligible_labour_cost;
                    }

                    for (var i = 0; i < services.length; i++) {
                        if (services[i].claim == true) {
                            bookingService.push(services[i])
                        }
                        else {
                            var labour_list = services[i].labour;

                            var labours = [];

                            if (labour_list) {
                                for (var l = 0; l < labour_list.length; l++) {
                                    var discount = req.body.discount;

                                    var total = 0;
                                    var tax_info = await Tax.findOne({ tax: labour_list[l].tax }).exec();

                                    var tax = [];
                                    var rate = labour_list[l].rate;
                                    var amount = parseFloat(labour_list[l].rate) * parseFloat(labour_list[l].quantity);
                                    var tax_rate = tax_info.detail;
                                    var base = amount;

                                    if (req.body.discount_type == "percent") {
                                        discount = parseFloat(discount);
                                        if (!isNaN(discount) && discount > 0) {
                                            var discount_total = amount * (discount / 100);
                                            amount = amount - parseFloat(discount_total.toFixed(2))
                                            if (amount < 0) {
                                                amount = 0
                                            }
                                        }
                                    }
                                    else {
                                        discount = parseFloat(discount);
                                        if (!isNaN(discount) && discount > 0) {
                                            var discount_total = (amount / discount_eligible_labour_cost) * discount;
                                            amount = amount - parseFloat(discount_total.toFixed(2))
                                            if (amount < 0) {
                                                amount = 0
                                            }
                                        }
                                    }

                                    if (labour_list[l].amount_is_tax == "exclusive") {
                                        var tax_on_amount = amount;
                                        if (tax_rate.length > 0) {
                                            for (var r = 0; r < tax_rate.length; r++) {
                                                if (tax_rate[r].rate != tax_info.rate) {
                                                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                                                    amount = amount + t;
                                                    tax.push({
                                                        tax: tax_rate[r].tax,
                                                        rate: tax_rate[r].rate,
                                                        amount: parseFloat(t.toFixed(2))
                                                    });
                                                }
                                                else {
                                                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                                                    amount = amount + t;
                                                    tax.push({
                                                        tax: tax_info.tax, tax_rate: tax_info.rate,
                                                        rate: tax_info.rate,
                                                        amount: parseFloat(t.toFixed(2))
                                                    });
                                                }
                                            }
                                        }
                                        total = total + amount;
                                    }

                                    if (labour_list[l].amount_is_tax == "inclusive") {
                                        var x = (100 + tax_info.rate) / 100;
                                        var tax_on_amount = amount / x;
                                        if (tax_rate.length > 0) {
                                            for (var r = 0; r < tax_rate.length; r++) {
                                                if (tax_rate[r].rate != tax_info.rate) {
                                                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                                                    base = base - t;
                                                    tax.push({
                                                        tax: tax_rate[r].tax,
                                                        rate: tax_rate[r].rate,
                                                        amount: parseFloat(t.toFixed(2))
                                                    });
                                                }
                                                else {
                                                    var t = amount - tax_on_amount;
                                                    base = base - t;
                                                    tax.push({
                                                        tax: tax_info.tax, tax_rate: tax_info.rate,
                                                        rate: tax_info.rate,
                                                        amount: parseFloat(t.toFixed(2))
                                                    });
                                                }
                                            }

                                            //base = base - discount_total;
                                        }
                                        total = total + amount;
                                    }

                                    var tax_details = {
                                        tax: tax_info.tax,
                                        rate: tax_info.rate,
                                        amount: total,
                                        detail: tax
                                    }


                                    labours.push({
                                        item: labour_list[l].item,
                                        source: labour_list[l].source,
                                        rate: parseFloat(labour_list[l].rate),
                                        quantity: parseFloat(labour_list[l].quantity),
                                        base: parseFloat(base.toFixed(2)),
                                        discount: parseFloat(discount_total.toFixed(2)),
                                        amount: total,
                                        customer_dep: parseFloat(labour_list[l].customer_dep),
                                        insurance_dep: parseFloat(labour_list[l].insurance_dep),
                                        tax_amount: parseFloat(_.sumBy(tax, x => x.amount).toFixed(2)),
                                        amount_is_tax: labour_list[l].amount_is_tax,
                                        tax: tax_info.tax,
                                        tax_rate: tax_info.rate,
                                        tax_info: tax_details
                                    });

                                    // cconsole.logrs)
                                }

                                bookingService.push({
                                    part_cost: services[i].part_cost,
                                    labour_cost: _.sumBy(labours, x => x.amount),
                                    of_cost: services[i].of_cost,
                                    exceeded_cost: services[i].exceeded_cost,
                                    part_rate: services[i].part_rate,
                                    labour_rate: services[i].labour_rate,
                                    quantity: services[i].quantity,
                                    of_rate: services[i].of_rate,
                                    parts: services[i].parts,
                                    labour: labours,
                                    cost: services[i].part_cost + _.sumBy(labours, x => x.amount) + services[i].of_cost,
                                    discount: _.sumBy(labours, x => x.discount) + _.sumBy(services[i].parts, x => x.discount) + _.sumBy(services[i].opening_fitting, x => x.discount),
                                    opening_fitting: services[i].opening_fitting,
                                    part_cost_editable: services[i].part_cost_editable,
                                    labour_cost_editable: services[i].part_cost_editable,
                                    of_cost_editable: services[i].part_cost_editable,
                                    description: services[i].description,
                                    service: services[i].service,
                                    type: services[i].type,
                                    claim: services[i].claim,
                                    custom: services[i].custom,
                                    customer_approval: services[i].customer_approval, surveyor_approval: services[i].surveyor_approval,
                                    source: services[i].source,
                                });
                            }
                        }
                    }
                }

                if (type == "coupon") {
                    discount_type = "coupon"
                    var discount_eligible = [];
                    var coupon_code = req.body.coupon;
                    var coupon = await Coupon.findOne({ code: coupon_code.toUpperCase(), is_product: false }).exec();
                    var used = await CouponUsed.findOne({ code: coupon_code.toUpperCase(), user: booking.user }).count().exec();

                    if (coupon) {
                        if (used < coupon.usage_limit) {
                            var serverTime = moment.tz(new Date(), req.headers['tz']);
                            var bar = moment.tz(coupon.expired_at, req.headers['tz']);
                            var baz = bar.diff(serverTime);
                            if (baz > 0) {
                                var limit = await CouponUsed.findOne({ code: coupon_code.toUpperCase() }).count().exec();
                                if (limit <= coupon.limit) {
                                    code = coupon_code.toUpperCase();
                                    discount_by = "coupon";
                                    if (coupon.coupon_on == "total") {
                                        if (coupon.for == "category") {
                                            var filter = _.filter(booking.services, claim => claim.claim == false)
                                            discount_eligible = _.filter(filter, type => type.type == coupon.label);
                                            var discount_eligible_labour = _.map(discount_eligible, 'labour');
                                            var discount_eligible_labour_cost = 0;
                                            for (var k = 0; k < discount_eligible_labour.length; k++) {
                                                discount_eligible_labour_cost = _.sumBy(discount_eligible_labour[k], x => x.rate * x.quantity) + discount_eligible_labour_cost;
                                            }
                                        }
                                        else if (coupon.for == "specific") {
                                            var filter = _.filter(booking.services, claim => claim.claim == false)
                                            discount_eligible = _.filter(filter, service => service.service == coupon.label);
                                            var discount_eligible_labour = _.map(discount_eligible, 'labour');
                                            var discount_eligible_labour_cost = 0;
                                            for (var k = 0; k < discount_eligible_labour.length; k++) {
                                                discount_eligible_labour_cost = _.sumBy(discount_eligible_labour[k], x => x.rate * x.quantity) + discount_eligible_labour_cost;
                                            }
                                        }
                                    }
                                    else {
                                        if (coupon.for == "general") {
                                            discount_eligible = _.filter(booking.services, claim => claim.claim == false);
                                            var discount_eligible_labour = _.map(discount_eligible, 'labour');
                                            var discount_eligible_labour_cost = 0;
                                            for (var k = 0; k < discount_eligible_labour.length; k++) {
                                                discount_eligible_labour_cost = _.sumBy(discount_eligible_labour[k], x => x.rate * x.quantity) + discount_eligible_labour_cost;
                                            }
                                        }
                                        else if (coupon.for == "category") {
                                            var filter = _.filter(booking.services, claim => claim.claim == false)
                                            discount_eligible = _.filter(filter, type => type.type == coupon.label);
                                            var discount_eligible_labour = _.map(discount_eligible, 'labour');
                                            var discount_eligible_labour_cost = 0;
                                            for (var k = 0; k < discount_eligible_labour.length; k++) {
                                                discount_eligible_labour_cost = _.sumBy(discount_eligible_labour[k], x => x.rate * x.quantity) + discount_eligible_labour_cost;
                                            }
                                        }
                                        else if (coupon.for == "specific") {
                                            var filter = _.filter(booking.services, claim => claim.claim == false)
                                            discount_eligible = _.filter(filter, service => service.service == coupon.label);
                                            var discount_eligible_labour = _.map(discount_eligible, 'labour');
                                            var discount_eligible_labour_cost = 0;
                                            for (var k = 0; k < discount_eligible_labour.length; k++) {
                                                discount_eligible_labour_cost = _.sumBy(discount_eligible_labour[k], x => x.rate * x.quantity) + discount_eligible_labour_cost;
                                            }
                                        }
                                    }
                                }
                                else {
                                    return res.status(400).json({
                                        responseCode: 400,
                                        responseMessage: "Coupon has been expired",
                                        responseData: {}
                                    });
                                }
                            }
                            else {
                                return res.status(400).json({
                                    responseCode: 400,
                                    responseMessage: "Coupon has been expired",
                                    responseData: {}
                                });
                            }
                        }
                        else {
                            return res.status(400).json({
                                responseCode: 400,
                                responseMessage: "Coupon has been used",
                                responseData: {}
                            });
                        }
                    }
                    else {
                        return res.status(400).json({
                            responseCode: 400,
                            responseMessage: "Coupon Not Exist",
                            responseData: {}
                        });
                    }


                    for (var i = 0; i < services.length; i++) {
                        if (services[i].claim == true) {
                            bookingService.push(services[i])
                        }
                        else {
                            var labour_list = services[i].labour;

                            var labours = [];

                            if (labour_list) {
                                for (var l = 0; l < labour_list.length; l++) {
                                    var discount_total = 0;
                                    var total = 0;
                                    var tax_info = await Tax.findOne({ tax: labour_list[l].tax }).exec();

                                    var tax = [];
                                    var rate = labour_list[l].rate;
                                    var amount = parseFloat(labour_list[l].rate) * parseFloat(labour_list[l].quantity);
                                    var tax_rate = tax_info.detail;
                                    var base = amount;


                                    if (coupon.coupon_on == "total") {
                                        if (coupon.for == "category") {
                                            if (services[i].type == coupon.label) {
                                                if (coupon.type == "percent") {
                                                    discount_by = "percent";
                                                    discount = parseFloat(coupon.discount);
                                                    if (!isNaN(discount) && discount > 0) {
                                                        discount_total = amount * (discount / 100);
                                                        amount = amount - parseFloat(discount_total.toFixed(2))
                                                        if (amount < 0) {
                                                            amount = 0
                                                        }
                                                    }
                                                }
                                            }
                                            else {
                                                var discount_total = labour_list[l].discount;
                                                amount = amount - parseFloat(discount_total.toFixed(2))
                                            }
                                        }
                                        else if (coupon.for == "specific") {
                                            if (services[i].service == coupon.label) {
                                                if (coupon.type == "percent") {
                                                    discount_by = "percent";
                                                    discount = parseFloat(coupon.discount);
                                                    if (!isNaN(discount) && discount > 0) {
                                                        discount_total = amount * (discount / 100);
                                                        amount = amount - parseFloat(discount_total.toFixed(2))
                                                        if (amount < 0) {
                                                            amount = 0
                                                        }
                                                    }
                                                }
                                            }
                                            else {
                                                // console.log("no coupon discount")
                                                var discount_total = labour_list[l].discount;
                                                amount = amount - parseFloat(discount_total.toFixed(2))
                                            }
                                        }
                                        else {
                                            // console.log("no coupon discount")
                                            var discount_total = labour_list[l].discount;
                                            amount = amount - parseFloat(discount_total.toFixed(2))
                                        }
                                    }
                                    else {
                                        if (coupon.for == "general") {
                                            if (coupon.type == "percent") {
                                                discount_by = "percent";
                                                discount = parseFloat(coupon.discount);
                                                if (!isNaN(discount) && discount > 0) {
                                                    discount_total = amount * (discount / 100);
                                                    amount = amount - parseFloat(discount_total.toFixed(2))
                                                    if (amount < 0) {
                                                        amount = 0
                                                    }
                                                }
                                            }
                                            else if (coupon.type == "price") {
                                                discount_by = "percent";
                                                discount = parseFloat(coupon.discount);
                                                if (!isNaN(discount) && discount > 0) {
                                                    discount_total = (amount / discount_eligible_labour_cost) * discount;
                                                    amount = amount - parseFloat(discount_total.toFixed(2))
                                                    if (amount < 0) {
                                                        amount = 0
                                                    }
                                                }
                                            }
                                            else {
                                                var discount_total = labour_list[l].discount;
                                                amount = amount - parseFloat(discount_total.toFixed(2))
                                            }
                                        }
                                        else if (coupon.for == "category") {
                                            if (services[i].type == coupon.label) {
                                                if (coupon.type == "percent") {
                                                    discount_by = "percent";
                                                    discount = parseFloat(coupon.discount);
                                                    if (!isNaN(discount) && discount > 0) {
                                                        discount_total = amount * (discount / 100);
                                                        amount = amount - parseFloat(discount_total.toFixed(2))
                                                        if (amount < 0) {
                                                            amount = 0
                                                        }
                                                    }
                                                }
                                            }
                                            else {
                                                var discount_total = labour_list[l].discount;
                                                amount = amount - parseFloat(discount_total.toFixed(2))
                                            }
                                        }
                                        else if (coupon.for == "specific") {
                                            if (services[i].service == coupon.label) {
                                                if (coupon.type == "percent") {
                                                    discount_by = "percent";
                                                    discount = parseFloat(coupon.discount);
                                                    if (!isNaN(discount) && discount > 0) {
                                                        discount_total = amount * (discount / 100);
                                                        amount = amount - parseFloat(discount_total.toFixed(2))
                                                        if (amount < 0) {
                                                            amount = 0
                                                        }
                                                    }
                                                }
                                                if (coupon.type == "fixed") {
                                                    labour_list[l].amount_is_tax = "inclusive";
                                                    discount_by = "value";
                                                    discount = parseFloat(coupon.discount);
                                                    discount_total = (amount / discount_eligible_labour_cost) * discount;
                                                    discount = amount - discount_total;
                                                    amount = parseFloat(discount_total.toFixed(2));
                                                    discount_total = discount
                                                    if (amount < 0) {
                                                        amount = 0
                                                    }
                                                }

                                                else if (coupon.type == "price") {
                                                    discount_by = "value";
                                                    discount = parseFloat(coupon.discount);
                                                    if (!isNaN(discount) && discount > 0) {
                                                        discount_total = (amount / discount_eligible_labour_cost) * discount;
                                                        amount = amount - parseFloat(discount_total.toFixed(2))
                                                        if (amount < 0) {
                                                            amount = 0
                                                        }
                                                    }
                                                }
                                            }
                                            else {
                                                // console.log("no coupon discount")
                                                var discount_total = labour_list[l].discount;
                                                amount = amount - parseFloat(discount_total.toFixed(2))
                                            }
                                        }
                                        else {
                                            // console.log("no coupon discount")
                                            var discount_total = labour_list[l].discount;
                                            amount = amount - parseFloat(discount_total.toFixed(2))
                                        }
                                    }

                                    if (labour_list[l].amount_is_tax == "exclusive") {
                                        var tax_on_amount = amount;
                                        if (tax_rate.length > 0) {
                                            for (var r = 0; r < tax_rate.length; r++) {
                                                if (tax_rate[r].rate != tax_info.rate) {
                                                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                                                    amount = amount + t;
                                                    tax.push({
                                                        tax: tax_rate[r].tax,
                                                        rate: tax_rate[r].rate,
                                                        amount: parseFloat(t.toFixed(2))
                                                    });
                                                }
                                                else {
                                                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                                                    amount = amount + t;
                                                    tax.push({
                                                        tax: tax_info.tax, tax_rate: tax_info.rate,
                                                        rate: tax_info.rate,
                                                        amount: parseFloat(t.toFixed(2))
                                                    });
                                                }
                                            }
                                        }
                                        total = total + amount;
                                    }

                                    if (labour_list[l].amount_is_tax == "inclusive") {
                                        var x = (100 + tax_info.rate) / 100;
                                        var tax_on_amount = amount / x;
                                        if (tax_rate.length > 0) {
                                            for (var r = 0; r < tax_rate.length; r++) {
                                                if (tax_rate[r].rate != tax_info.rate) {
                                                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                                                    base = base - t;
                                                    tax.push({
                                                        tax: tax_rate[r].tax,
                                                        rate: tax_rate[r].rate,
                                                        amount: parseFloat(t.toFixed(2))
                                                    });
                                                }
                                                else {
                                                    var t = amount - tax_on_amount;
                                                    base = base - t;
                                                    tax.push({
                                                        tax: tax_info.tax, tax_rate: tax_info.rate,
                                                        rate: tax_info.rate,
                                                        amount: parseFloat(t.toFixed(2))
                                                    });
                                                }
                                            }

                                            //base = base - discount_total;
                                        }
                                        total = total + amount;
                                    }

                                    var tax_details = {
                                        tax: tax_info.tax,
                                        rate: tax_info.rate,
                                        amount: total,
                                        detail: tax
                                    }

                                    labours.push({
                                        item: labour_list[l].item,
                                        source: labour_list[l].source,
                                        rate: parseFloat(labour_list[l].rate),
                                        quantity: parseFloat(labour_list[l].quantity),
                                        base: parseFloat(base.toFixed(2)),
                                        discount: parseFloat(discount_total.toFixed(2)),
                                        amount: total,
                                        customer_dep: parseFloat(labour_list[l].customer_dep),
                                        insurance_dep: parseFloat(labour_list[l].insurance_dep),
                                        tax_amount: parseFloat(_.sumBy(tax, x => x.amount).toFixed(2)),
                                        amount_is_tax: labour_list[l].amount_is_tax,
                                        tax: tax_info.tax,
                                        tax_rate: tax_info.rate,
                                        tax_info: tax_details
                                    });
                                }

                                bookingService.push({
                                    quantity: services[i].quantity,
                                    part_cost: services[i].part_cost,
                                    labour_cost: _.sumBy(labours, x => x.amount),
                                    of_cost: services[i].of_cost,
                                    exceeded_cost: services[i].exceeded_cost,
                                    part_rate: services[i].part_rate,
                                    labour_rate: services[i].labour_rate,
                                    of_rate: services[i].of_rate,
                                    parts: services[i].parts,
                                    labour: labours,
                                    cost: services[i].part_cost + _.sumBy(labours, x => x.amount) + services[i].of_cost,
                                    opening_fitting: services[i].opening_fitting,
                                    part_cost_editable: services[i].part_cost_editable,
                                    labour_cost_editable: services[i].part_cost_editable,
                                    of_cost_editable: services[i].part_cost_editable,
                                    description: services[i].description,
                                    service: services[i].service,
                                    type: services[i].type,
                                    claim: services[i].claim,
                                    custom: services[i].custom,
                                    discount: _.sumBy(labours, x => x.discount) + _.sumBy(services[i].parts, x => x.discount) + _.sumBy(services[i].opening_fitting, x => x.discount),
                                    customer_approval: services[i].customer_approval, surveyor_approval: services[i].surveyor_approval,
                                    source: services[i].source,
                                });
                            }
                        }
                    }
                }

                var policy_clause = 0
                if (booking.payment.policy_clause) {
                    policy_clause = booking.payment.policy_clause;
                }
                var salvage = 0
                if (booking.payment.salvage) {
                    salvage = booking.payment.salvage;
                }

                var approved = _.filter(bookingService, customer_approval => customer_approval.customer_approval == true);

                var labour_cost = _.sumBy(bookingService, x => x.labour_cost);
                var part_cost = _.sumBy(bookingService, x => x.part_cost);
                var of_cost = _.sumBy(bookingService, x => x.of_cost);
                var discount_total = _.sumBy(bookingService, x => x.discount);
                var pick_up_charges = booking.payment.pick_up_charges;

                var careager_cash = booking.payment.careager_cash;

                var paid_total = booking.payment.paid_total;

                var payment_total = labour_cost + part_cost + of_cost + discount_total + policy_clause + salvage + pick_up_charges;

                var estimate_cost = labour_cost + part_cost + of_cost + policy_clause + salvage + pick_up_charges - careager_cash;
                var due_amount = _.sumBy(approved, x => x.labour_cost) + _.sumBy(approved, x => x.part_cost) + _.sumBy(approved, x => x.of_cost) + policy_clause + salvage + pick_up_charges - (paid_total + careager_cash);

                var due = {
                    due: Math.ceil(due_amount.toFixed(2))
                }

                var payment = {
                    total: payment_total,
                    estimate_cost: estimate_cost,
                    of_cost: of_cost,
                    labour_cost: labour_cost,
                    part_cost: part_cost,
                    careager_cash: careager_cash,
                    payment_mode: booking.payment.payment_mode,
                    payment_status: booking.payment.payment_status,
                    coupon: code,
                    coupon_type: "",
                    discount_by: discount_by,
                    discount_type: discount_type,
                    discount: discount,
                    discount_total: discount_total,
                    policy_clause: booking.payment.policy_clause,
                    salvage: booking.payment.salvage,
                    terms: booking.payment.terms,
                    pick_up_limit: booking.payment.pick_up_limit,
                    pick_up_charges: booking.payment.pick_up_charges,
                    paid_total: parseFloat(booking.payment.paid_total),
                    discount_applied: booking.payment.discount_applied,
                    transaction_id: booking.payment.transaction_id,
                    transaction_date: booking.payment.transaction_date,
                    transaction_status: booking.payment.transaction_status,
                    transaction_response: booking.payment.transaction_response
                };


                Booking.findOneAndUpdate({ _id: booking._id }, { $set: { services: bookingService, payment: payment, due: due, updated_at: new Date() } }, { new: false }, async function (err, doc) {
                    if (err) {
                        res.status(400).json({
                            responseCode: 400,
                            responseMessage: "Error",
                            responseData: err
                        });
                    }
                    else {
                        var update = await Booking.findById(booking.id).exec();
                        res.status(200).json({
                            responseCode: 200,
                            responseMessage: "Discount has been applied",
                            responseData: update
                        });
                    }
                });
            }
            else {
                res.status(200).json({
                    responseCode: 200,
                    responseMessage: "Not eligible for discount",
                    responseData: {}
                });
            }
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Unauthorized",
                responseData: {}
            });
        }
    }
});

router.post('/booking/discount/remove', xAccessToken.token, async function (req, res, next) {
    var rules = {
        booking: 'required',
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Booking is required",
            responseData: {
                res: validation.errors.all()
            }
        });
    }
    else {
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var user = decoded.user;
        var data = new Object();
        var discount = 0;
        var discount_total = 0;
        var code = "";
        var discount_type = "";
        var discount_by = "";

        var booking = await Booking.findOne({ _id: req.body.booking }).exec();

        if (booking) {
            var bookingService = [];

            if (booking.payment.discount_type == "special") {
                var discount_services = booking.services;
            }
            else if (booking.payment.discount_type == "coupon") {
                var coupon = await Coupon.findOne({ code: booking.payment.coupon }).exec();
                if (coupon) {
                    if (coupon.for == "category") {
                        var discount_services = _.filter(booking.services, type => type.type == coupon.label);
                        var bookingService = _.filter(booking.services, type => type.type != coupon.label);
                    }
                    else if (coupon.for == "specific") {
                        var discount_services = _.filter(booking.services, service => service.service == coupon.label);
                        var bookingService = _.filter(booking.services, service => service.service != coupon.label);
                    }
                    else if (coupon.for == "general") {
                        var discount_services = booking.services;
                    }
                }
                else {
                    var discount_services = []
                }
            }
            else {
                var discount_services = []
            }


            if (discount_services.length > 0) {
                for (var i = 0; i < discount_services.length; i++) {
                    if (discount_services[i].claim == true) {
                        bookingService.push(discount_services[i])
                    }
                    else {
                        var labour_list = discount_services[i].labour;

                        var labours = [];

                        if (labour_list) {
                            for (var l = 0; l < labour_list.length; l++) {
                                var total = 0;
                                var tax_info = await Tax.findOne({ tax: labour_list[l].tax }).exec();

                                var tax = [];
                                var rate = labour_list[l].rate;
                                var amount = parseFloat(labour_list[l].rate) * parseFloat(labour_list[l].quantity);
                                var tax_rate = tax_info.detail;
                                var base = amount;

                                if (labour_list[l].amount_is_tax == "exclusive") {
                                    var tax_on_amount = amount;
                                    if (tax_rate.length > 0) {
                                        for (var r = 0; r < tax_rate.length; r++) {
                                            if (tax_rate[r].rate != tax_info.rate) {
                                                var t = tax_on_amount * (tax_rate[r].rate / 100);
                                                amount = amount + t;
                                                tax.push({
                                                    tax: tax_rate[r].tax,
                                                    rate: tax_rate[r].rate,
                                                    amount: parseFloat(t.toFixed(2))
                                                });
                                            }
                                            else {
                                                var t = tax_on_amount * (tax_rate[r].rate / 100);
                                                amount = amount + t;
                                                tax.push({
                                                    tax: tax_info.tax, tax_rate: tax_info.rate,
                                                    rate: tax_info.rate,
                                                    amount: parseFloat(t.toFixed(2))
                                                });
                                            }
                                        }
                                    }
                                    total = total + amount;
                                }

                                if (labour_list[l].amount_is_tax == "inclusive") {
                                    var x = (100 + tax_info.rate) / 100;
                                    var tax_on_amount = amount / x;
                                    if (tax_rate.length > 0) {
                                        for (var r = 0; r < tax_rate.length; r++) {
                                            if (tax_rate[r].rate != tax_info.rate) {
                                                var t = tax_on_amount * (tax_rate[r].rate / 100);
                                                base = base - t;
                                                tax.push({
                                                    tax: tax_rate[r].tax,
                                                    rate: tax_rate[r].rate,
                                                    amount: parseFloat(t.toFixed(2))
                                                });
                                            }
                                            else {
                                                var t = amount - tax_on_amount;
                                                base = base - t;
                                                tax.push({
                                                    tax: tax_info.tax, tax_rate: tax_info.rate,
                                                    rate: tax_info.rate,
                                                    amount: parseFloat(t.toFixed(2))
                                                });
                                            }
                                        }

                                        //base = base - discount_total;
                                    }
                                    total = total + amount;
                                }

                                var tax_amount = total - parseFloat(base.toFixed(2));

                                var tax_details = {
                                    tax: tax_info.tax,
                                    rate: tax_info.rate,
                                    amount: total,
                                    detail: tax
                                }

                                labours.push({
                                    item: labour_list[l].item,
                                    source: labour_list[l].source,
                                    rate: parseFloat(labour_list[l].rate),
                                    quantity: parseFloat(labour_list[l].quantity),
                                    base: parseFloat(base.toFixed(2)),
                                    discount: parseFloat(discount_total.toFixed(2)),
                                    amount: total,
                                    customer_dep: parseFloat(labour_list[l].customer_dep),
                                    insurance_dep: parseFloat(labour_list[l].insurance_dep),
                                    tax_amount: parseFloat(_.sumBy(tax, x => x.amount).toFixed(2)),
                                    amount_is_tax: labour_list[l].amount_is_tax,
                                    tax: tax_info.tax,
                                    tax_rate: tax_info.rate,
                                    tax_info: tax_details
                                });
                            }

                            bookingService.push({
                                quantity: discount_services[i].quantity,
                                part_cost: discount_services[i].part_cost,
                                labour_cost: _.sumBy(labours, x => x.amount),
                                of_cost: discount_services[i].of_cost,
                                exceeded_cost: discount_services[i].exceeded_cost,
                                part_rate: discount_services[i].part_rate,
                                labour_rate: discount_services[i].labour_rate,
                                of_rate: discount_services[i].of_rate,
                                parts: discount_services[i].parts,
                                labour: labours,
                                cost: discount_services[i].part_cost + _.sumBy(labours, x => x.amount) + discount_services[i].of_cost,
                                opening_fitting: discount_services[i].opening_fitting,
                                part_cost_editable: discount_services[i].part_cost_editable,
                                labour_cost_editable: discount_services[i].part_cost_editable,
                                of_cost_editable: discount_services[i].part_cost_editable,
                                description: discount_services[i].description,
                                service: discount_services[i].service,
                                type: discount_services[i].type,
                                claim: discount_services[i].claim,
                                custom: discount_services[i].custom,
                                customer_approval: discount_services[i].customer_approval, surveyor_approval: discount_services[i].surveyor_approval,
                                discount: _.sumBy(labours, x => x.discount) + _.sumBy(discount_services[i].parts, x => x.discount) + _.sumBy(discount_services[i].opening_fitting, x => x.discount),
                                source: discount_services[i].source,
                            });
                        }
                    }
                }

                var policy_clause = 0
                if (booking.payment.policy_clause) {
                    policy_clause = booking.payment.policy_clause;
                }

                var salvage = 0
                if (booking.payment.salvage) {
                    salvage = booking.payment.salvage;
                }

                var careager_cash = await q.all(fun.getBookingCarEagerCash(booking._id))

                var approved = _.filter(bookingService, customer_approval => customer_approval.customer_approval == true);

                var paid_total = booking.payment.paid_total;
                var labour_cost = _.sumBy(bookingService, x => x.labour_cost);
                var part_cost = _.sumBy(bookingService, x => x.part_cost);
                var of_cost = _.sumBy(bookingService, x => x.of_cost);
                var discount_total = _.sumBy(bookingService, x => x.discount);
                var pick_up_charges = booking.payment.pick_up_charges;

                var payment_total = labour_cost + part_cost + of_cost + discount_total + policy_clause + salvage + pick_up_charges;

                var estimate_cost = labour_cost + part_cost + of_cost + policy_clause + salvage + pick_up_charges - careager_cash;


                var due_amount = _.sumBy(approved, x => x.labour_cost) + _.sumBy(approved, x => x.part_cost) + _.sumBy(approved, x => x.of_cost) + policy_clause + salvage + pick_up_charges - (paid_total + careager_cash);

                var due = {
                    due: Math.ceil(due_amount.toFixed(2))
                }

                var payment = {
                    total: payment_total,
                    estimate_cost: estimate_cost,
                    of_cost: of_cost,
                    careager_cash: careager_cash,
                    labour_cost: labour_cost,
                    part_cost: part_cost,
                    payment_mode: booking.payment.payment_mode,
                    payment_status: booking.payment.payment_status,
                    coupon: "",
                    coupon_type: "",
                    discount_by: "",
                    discount_type: "",
                    discount: 0,
                    discount_total: 0,
                    policy_clause: booking.payment.policy_clause,
                    salvage: booking.payment.salvage,
                    terms: booking.payment.terms,
                    pick_up_limit: booking.payment.pick_up_limit,
                    pick_up_charges: booking.payment.pick_up_charges,
                    paid_total: parseFloat(booking.payment.paid_total),
                    discount_applied: false,
                    transaction_id: booking.payment.transaction_id,
                    transaction_date: booking.payment.transaction_date,
                    transaction_status: booking.payment.transaction_status,
                    transaction_response: booking.payment.transaction_response
                };

                Booking.findOneAndUpdate({ _id: booking._id }, { $set: { services: bookingService, payment: payment, due: due, updated_at: new Date() } }, { new: false }, async function (err, doc) {
                    if (err) {
                        res.status(400).json({
                            responseCode: 400,
                            responseMessage: "Error",
                            responseData: err
                        });
                    }
                    else {
                        await CouponUsed.remove({ booking: booking._id }).exec();
                        var update = await Booking.findById(booking.id).exec();

                        res.status(200).json({
                            responseCode: 200,
                            responseMessage: "Discount has been removed",
                            responseData: update
                        });
                    }
                });
            }
            else {
                res.status(400).json({
                    responseCode: 400,
                    responseMessage: "Coupon not found",
                    responseData: {}
                });
            }
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Booking not found",
                responseData: {}
            });
        }
    }
});

router.get('/insurance/invoice', xAccessToken.token, async function (req, res, next) {
    var rules = {
        booking: 'required',
    };

    var validation = new Validator(req.query, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Validation Error",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var user = decoded.user;
        var business = req.headers['business'];
        var labour_cost = 0;
        var part_cost = 0;
        var of_cost = 0;
        var due_amount = 0;
        var totalResult = 0;
        var bookingService = [];

        var loggedInDetails = await User.findById(decoded.user).exec();
        var booking = await Booking.findById(req.query.booking).populate('address').populate('business').exec();
        var invoices_count = await Invoice.findOne({ business: business }).count().exec();
        var limit = await q.all(businessPlanLimit(business, req.headers['tz']));
        if (limit.invoices > invoices_count) {
            if (booking) {
                var tax_type = "GST";

                var policy_clause = 0;
                var salvage = 0;
                var pick_up_charges = 0;
                var careager_cash = 0;
                var paid_total = 0;

                if (booking.insurance_info.state) {
                    if (booking.insurance_info.state.toLowerCase() == booking.business.address.state.toLowerCase()) {
                        var tax_type = "GST";
                    }
                    else {
                        var tax_type = "IGST";
                    }
                }

                var services = _.filter(booking.services, customer_approval => customer_approval.customer_approval == true && customer_approval.claim == true);

                for (var i = 0; i < services.length; i++) {
                    var part = [];
                    var labours = [];
                    var opening_fitting = [];

                    var part_list = services[i].parts;
                    var labour_list = services[i].labour;
                    var of_list = services[i].opening_fitting;

                    if (part_list) {
                        for (var p = 0; p < part_list.length; p++) {
                            var total = 0;
                            var tax_info = await Tax.findOne({ rate: part_list[p].tax_rate, type: tax_type }).exec();
                            var tax = [];
                            var rate = part_list[p].rate;
                            var amount = (parseFloat(part_list[p].rate) * parseFloat(part_list[p].quantity));
                            var tax_rate = tax_info.detail;
                            var base = amount;

                            var dep = 0;

                            if (parseFloat(part_list[p].insurance_dep) <= 0 && parseFloat(part_list[p].customer_dep) <= 0) {
                                dep = 100
                            }
                            else {
                                if (parseFloat(part_list[p].insurance_dep) <= 0 && parseFloat(part_list[p].customer_dep <= 100)) {
                                    dep = 100
                                }
                                else {
                                    dep = 100 - parseFloat(part_list[p].insurance_dep);
                                }
                            }

                            amount = amount - (amount * dep / 100);
                            dep = base - amount;


                            if (part_list[p].amount_is_tax == "exclusive") {
                                var tax_on_amount = amount;
                                if (tax_rate.length > 0) {
                                    for (var r = 0; r < tax_rate.length; r++) {
                                        if (tax_rate[r].rate != tax_info.rate) {
                                            var t = tax_on_amount * (tax_rate[r].rate / 100);
                                            amount = amount + t; parseFloat
                                            tax.push({
                                                tax: tax_rate[r].tax,
                                                rate: tax_rate[r].rate,
                                                amount: parseFloat(t.toFixed(2))
                                            });
                                        }
                                        else {
                                            var t = tax_on_amount * (tax_rate[r].rate / 100);
                                            amount = amount + t;
                                            tax.push({
                                                tax: tax_info.tax, tax_rate: tax_info.rate,
                                                rate: tax_info.rate,
                                                amount: parseFloat(t.toFixed(2))
                                            });
                                        }
                                    }
                                }
                                total = total + amount;
                            }

                            if (part_list[p].amount_is_tax == "inclusive") {
                                var x = (100 + tax_info.rate) / 100;
                                var tax_on_amount = amount / x;
                                if (tax_rate.length > 0) {
                                    for (var r = 0; r < tax_rate.length; r++) {
                                        if (tax_rate[r].rate != tax_info.rate) {
                                            var t = tax_on_amount * (tax_rate[r].rate / 100);
                                            base = base - t;
                                            tax.push({
                                                tax: tax_rate[r].tax,
                                                rate: tax_rate[r].rate,
                                                amount: parseFloat(t.toFixed(2))
                                            });
                                        }
                                        else {
                                            var t = amount - tax_on_amount;
                                            base = base - t;
                                            tax.push({
                                                tax: tax_info.tax, tax_rate: tax_info.rate,
                                                rate: tax_info.rate,
                                                amount: parseFloat(t.toFixed(2))
                                            });
                                        }
                                    }
                                }

                                base = base - dep;
                                total = total + amount;
                            }

                            var tax_amount = total - parseFloat(base.toFixed(2));

                            var tax_details = {
                                tax: tax_info.tax,
                                tax_rate: tax_info.rate,
                                rate: tax_info.rate,
                                amount: total,
                                detail: tax
                            }

                            part.push({
                                item: part_list[p].item,
                                source: part_list[p].source,
                                hsn_sac: part_list[p].hsn_sac,
                                part_no: part_list[p].part_no,
                                rate: parseFloat(part_list[p].rate),
                                quantity: parseFloat(part_list[p].quantity),
                                base: parseFloat(base.toFixed(2)),
                                amount: total,
                                discount: 0,
                                //discount: part_list[p].discount,
                                issued: part_list[p].issued,
                                customer_dep: parseFloat(part_list[p].customer_dep),
                                insurance_dep: parseFloat(part_list[p].insurance_dep),
                                tax_amount: parseFloat(_.sumBy(tax, x => x.amount).toFixed(2)),
                                amount_is_tax: part_list[p].amount_is_tax,
                                tax: tax_info.tax,
                                tax_rate: tax_info.rate,
                                tax_info: tax_details
                            });
                        }
                    }

                    if (labour_list) {
                        discount_eligible_labour_cost = _.sumBy(labour_list, x => x.rate * x.quantity);

                        for (var l = 0; l < labour_list.length; l++) {
                            var total = 0;
                            var tax_info = await Tax.findOne({ rate: labour_list[l].tax_rate, type: tax_type }).exec();
                            var tax = [];
                            var rate = labour_list[l].rate;
                            var amount = parseFloat(labour_list[l].rate) * parseFloat(labour_list[l].quantity);
                            var tax_rate = tax_info.detail;
                            var base = amount;
                            var dep = 0;


                            if (parseFloat(labour_list[l].insurance_dep) <= 0 && parseFloat(labour_list[l].customer_dep) <= 0) {
                                dep = 100
                            }
                            else {
                                if (parseFloat(labour_list[l].insurance_dep) <= 0 && parseFloat(labour_list[l].customer_dep <= 100)) {
                                    dep = 100
                                }
                                else {
                                    dep = 100 - parseFloat(labour_list[l].insurance_dep);
                                }
                            }


                            amount = amount - (amount * dep / 100);
                            dep = base - amount;


                            if (labour_list[l].amount_is_tax == "exclusive") {
                                var tax_on_amount = amount;
                                if (tax_rate.length > 0) {
                                    for (var r = 0; r < tax_rate.length; r++) {
                                        if (tax_rate[r].rate != tax_info.rate) {
                                            var t = tax_on_amount * (tax_rate[r].rate / 100);
                                            amount = amount + t; parseFloat
                                            tax.push({
                                                tax: tax_rate[r].tax,
                                                rate: tax_rate[r].rate,
                                                amount: parseFloat(t.toFixed(2))
                                            });
                                        }
                                        else {
                                            var t = tax_on_amount * (tax_rate[r].rate / 100);
                                            amount = amount + t;
                                            tax.push({
                                                tax: tax_info.tax, tax_rate: tax_info.rate,
                                                rate: tax_info.rate,
                                                amount: parseFloat(t.toFixed(2))
                                            });
                                        }
                                    }
                                }
                                //total = total+amount;
                            }

                            if (labour_list[l].amount_is_tax == "inclusive") {
                                var x = (100 + tax_info.rate) / 100;
                                var tax_on_amount = amount / x;
                                if (tax_rate.length > 0) {
                                    for (var r = 0; r < tax_rate.length; r++) {
                                        if (tax_rate[r].rate != tax_info.rate) {
                                            var t = tax_on_amount * (tax_rate[r].rate / 100);
                                            base = base - t;
                                            tax.push({
                                                tax: tax_rate[r].tax,
                                                rate: tax_rate[r].rate,
                                                amount: parseFloat(t.toFixed(2))
                                            });
                                        }
                                        else {
                                            var t = amount - tax_on_amount;
                                            base = base - t;
                                            tax.push({
                                                tax: tax_info.tax, tax_rate: tax_info.rate,
                                                rate: tax_info.rate,
                                                amount: parseFloat(t.toFixed(2))
                                            });
                                        }
                                    }
                                }

                                base = base - dep;
                                total = total + amount;
                            }

                            var tax_amount = total - parseFloat(base.toFixed(2));

                            var tax_details = {
                                tax: tax_info.tax,
                                rate: tax_info.rate,
                                amount: total,
                                detail: tax
                            };

                            labours.push({
                                item: labour_list[l].item,
                                source: labour_list[l].source,
                                rate: parseFloat(labour_list[l].rate),
                                quantity: parseFloat(labour_list[l].quantity),
                                base: parseFloat(base.toFixed(2)),
                                amount: amount,
                                discount: 0,
                                //discount: labour_list[l].discount,
                                customer_dep: parseFloat(labour_list[l].customer_dep),
                                insurance_dep: parseFloat(labour_list[l].insurance_dep),
                                tax_amount: parseFloat(_.sumBy(tax, x => x.amount).toFixed(2)),
                                amount_is_tax: labour_list[l].amount_is_tax,
                                tax: tax_info.tax,
                                tax_rate: tax_info.rate,
                                tax_info: tax_details
                            });
                        }
                    }

                    if (of_list) {
                        for (var o = 0; o < of_list.length; o++) {
                            var total = 0;
                            var tax_info = await Tax.findOne({ rate: of_list[o].tax_rate, type: tax_type }).exec();
                            var tax = [];
                            var rate = of_list[o].rate;
                            var amount = (parseFloat(of_list[o].rate) * parseFloat(of_list[o].quantity));
                            var tax_rate = tax_info.detail;
                            var base = amount;
                            var dep = 0;


                            if (parseFloat(of_list[o].insurance_dep) <= 0 && parseFloat(of_list[o].customer_dep) <= 0) {
                                dep = 100
                            }
                            else {
                                if (parseFloat(of_list[o].insurance_dep) <= 0 && parseFloat(of_list[o].customer_dep <= 100)) {
                                    dep = 100
                                }
                                else {
                                    dep = 100 - parseFloat(of_list[o].insurance_dep);
                                }
                            }

                            amount = amount - (amount * dep / 100);
                            dep = base - amount;

                            if (of_list[o].amount_is_tax == "exclusive") {
                                var tax_on_amount = amount;
                                if (tax_rate.length > 0) {
                                    for (var r = 0; r < tax_rate.length; r++) {
                                        if (tax_rate[r].rate != tax_info.rate) {
                                            var t = tax_on_amount * (tax_rate[r].rate / 100);
                                            amount = amount + t; parseFloat
                                            tax.push({
                                                tax: tax_rate[r].tax,
                                                rate: tax_rate[r].rate,
                                                amount: parseFloat(t.toFixed(2))
                                            });
                                        }
                                        else {
                                            var t = tax_on_amount * (tax_rate[r].rate / 100);
                                            amount = amount + t;
                                            tax.push({
                                                tax: tax_info.tax, tax_rate: tax_info.rate,
                                                rate: tax_info.rate,
                                                amount: parseFloat(t.toFixed(2))
                                            });
                                        }
                                    }
                                }
                                total = total + amount;
                            }

                            if (of_list[o].amount_is_tax == "inclusive") {
                                var x = (100 + tax_info.rate) / 100;
                                var tax_on_amount = amount / x;
                                if (tax_rate.length > 0) {
                                    for (var r = 0; r < tax_rate.length; r++) {
                                        if (tax_rate[r].rate != tax_info.rate) {
                                            var t = tax_on_amount * (tax_rate[r].rate / 100);
                                            base = base - t;
                                            tax.push({
                                                tax: tax_rate[r].tax,
                                                rate: tax_rate[r].rate,
                                                amount: parseFloat(t.toFixed(2))
                                            });
                                        }
                                        else {
                                            var t = amount - tax_on_amount;
                                            base = base - t;
                                            tax.push({
                                                tax: tax_info.tax, tax_rate: tax_info.rate,
                                                rate: tax_info.rate,
                                                amount: parseFloat(t.toFixed(2))
                                            });
                                        }
                                    }
                                }

                                base = base - dep;
                                total = total + amount;
                            }

                            var tax_details = {
                                tax: tax_info.tax,
                                rate: tax_info.rate,
                                amount: total,
                                detail: tax
                            }

                            var tax_amount = total - parseFloat(base.toFixed(2));

                            opening_fitting.push({
                                item: of_list[o].item,
                                source: of_list[o].source,
                                rate: parseFloat(of_list[o].rate),
                                quantity: parseFloat(of_list[o].quantity),
                                base: parseFloat(base.toFixed(2)),
                                amount: total,
                                discount: 0,
                                //discount: parseFloat(of_list[o].discount),
                                customer_dep: parseFloat(of_list[o].customer_dep),
                                insurance_dep: parseFloat(of_list[o].insurance_dep),
                                tax_amount: parseFloat(_.sumBy(tax, x => x.amount).toFixed(2)),
                                amount_is_tax: of_list[o].amount_is_tax,
                                tax: tax_info.tax, tax_rate: tax_info.rate,
                                tax_info: tax_details
                            });
                        }
                    }

                    var parts_visible = true;

                    bookingService.push({
                        source: services[i].source,
                        service: services[i].service,
                        mileage: services[i].mileage,
                        parts: part,
                        labour: labours,
                        opening_fitting: opening_fitting,
                        hours: services[i].hours,
                        parts_visible: parts_visible,
                        quantity: services[i].quantity,
                        discount: 0,
                        //discount: _.sumBy(labours, x => x.discount)+_.sumBy(part, x => x.discount)+_.sumBy(opening_fitting, x => x.discount),
                        description: services[i].description,
                        cost: _.sumBy(part, x => x.amount) + _.sumBy(labours, x => x.amount) + services[i].of_cost,
                        labour_cost: _.sumBy(labours, x => x.amount),
                        of_cost: _.sumBy(opening_fitting, x => x.amount),
                        part_cost: _.sumBy(part, x => x.amount),
                        exceeded_cost: parseFloat(services[i].exceeded_cost),
                        part_cost_editable: services[i].part_cost_editable,
                        labour_cost_editable: services[i].labour_cost_editable,
                        of_cost_editable: services[i].of_cost_editable,
                        type: services[i].type,
                        customer_approval: services[i].customer_approval,
                        surveyor_approval: services[i].surveyor_approval,
                        claim: services[i].claim,
                        custom: services[i].custom,
                    });

                    // console.log(bookingService)
                }

                var labour_cost = _.sumBy(bookingService, x => x.labour_cost);
                var part_cost = _.sumBy(bookingService, x => x.part_cost);
                var of_cost = _.sumBy(bookingService, x => x.of_cost);
                var discount_total = _.sumBy(bookingService, x => x.discount);

                var payment_total = labour_cost + part_cost + of_cost + discount_total + policy_clause + salvage + pick_up_charges;

                var estimate_cost = labour_cost + part_cost + of_cost + policy_clause + salvage + pick_up_charges - careager_cash;

                var due_amount = _.sumBy(bookingService, x => x.labour_cost) + _.sumBy(bookingService, x => x.part_cost) + _.sumBy(bookingService, x => x.of_cost) + policy_clause + salvage + pick_up_charges - (paid_total + careager_cash);

                var due = {
                    due: Math.ceil(due_amount.toFixed(2))
                }

                var payment = {
                    total: parseFloat(payment_total.toFixed(2)),
                    estimate_cost: parseFloat(estimate_cost.toFixed(2)),
                    careager_cash: 0,
                    of_cost: of_cost,
                    labour_cost: labour_cost,
                    part_cost: part_cost,
                    payment_mode: "",
                    payment_status: "",
                    discount_type: "",
                    coupon: "",
                    coupon_type: "",
                    discount_by: "",
                    discount: 0,
                    discount_total: discount_total,
                    policy_clause: policy_clause,
                    salvage: salvage,
                    terms: booking.payment.terms,
                    pick_up_limit: booking.payment.pick_up_limit,
                    pick_up_charges: pick_up_charges,
                    paid_total: paid_total,
                    discount_applied: booking.payment.discount_applied,
                    transaction_id: "",
                    transaction_date: "",
                    transaction_status: "",
                    transaction_response: "",
                };

                var data = {
                    booking: booking._id,
                    user: booking.user,
                    car: booking.car,
                    business: booking.business._id,
                    advisor: booking.advisor,
                    address: booking.address._id,
                    job_no: booking.job_no,
                    with_tax: booking.with_tax,
                    booking_no: booking.booking_no,
                    insurance_info: booking.insurance_info,
                    delivery_date: booking.delivery_date,
                    note: booking.note,
                    due: due,
                    odometer: booking.odometer,
                    services: bookingService,
                    payment: payment,
                    invoice_type: "Insurance",
                    status: "Active",
                    tax_type: tax_type,
                    started_at: booking.started_at,
                    created_at: new Date(),
                    updated_at: new Date()
                };


                var invoice = await Invoice.findOne({ booking: req.query.booking, invoice_type: "Insurance", status: "Active" }).exec()
                if (invoice) {
                    Invoice.findOneAndUpdate({ _id: invoice._id }, { $set: data }, { new: true }, async function (err, doc) {
                        if (err) {
                            res.status(422).json({
                                responseCode: 422,
                                responseMessage: "Server Error",
                                responseData: err
                            });
                        }
                        else {
                            var updated = await q.all(fun.invoice(invoice._id, req.headers['tz']));
                            res.status(200).json({
                                responseCode: 200,
                                responseMessage: "",
                                responseData: updated
                            })
                        }
                    });
                }
                else {
                    Invoice.create(data).then(async function (inv) {
                        var count = await Invoice.find({ _id: { $lt: inv._id }, invoice_type: "Insurance", business: business }).count();
                        if (count == 0) {
                            var last_invoice = "";
                            var position = 1;
                        }
                        else {
                            var lv = await Invoice.findOne({ _id: { $lt: inv._id }, invoice_type: "Insurance", business: business }).sort({ _id: -1 }).exec();
                            var ls = lv.invoice_no.split('INS');
                            var last_invoice = ls[1];
                            position = count + 1
                        }

                        var fy = {
                            with_tax: true,
                            last_invoice: last_invoice,
                            position: position,
                        };

                        var assigned_invoice_no = await q.all(fun.fiscalyear(fy));

                        if (assigned_invoice_no) {
                            if (assigned_invoice_no.invoice) {
                                Invoice.findOneAndUpdate({ _id: inv._id }, { $set: { invoice_no: "INS" + assigned_invoice_no.invoice } }, { new: true }, async function (err, doc) {
                                    if (err) {
                                        res.status(422).json({
                                            responseCode: 422,
                                            responseMessage: "Server Error",
                                            responseData: err
                                        });
                                    }
                                    else {
                                        var updated = await q.all(fun.invoice(inv._id, req.headers['tz']));
                                        res.status(200).json({
                                            responseCode: 200,
                                            responseMessage: "",
                                            responseInfo: {
                                                fy: fy,
                                                assigned_invoice_no: assigned_invoice_no,
                                            },
                                            responseData: updated
                                        })
                                    }
                                })
                            }
                            else {
                                res.status(422).json({
                                    responseCode: 422,
                                    responseMessage: "Server Error",
                                    responseData: {}
                                });
                            }
                        }
                        else {
                            res.status(422).json({
                                responseCode: 422,
                                responseMessage: "Server Error",
                                responseData: {}
                            });
                        }
                    })
                }
            }
            else {
                res.status(400).json({
                    responseCode: 400,
                    responseMessage: "Booking not found",
                    responseData: {}
                });
            }
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: 'Invoices Limit Exceeded. Upgrade Your Plan',
                responseData: {}
            });
        }
    }
});

router.get('/booking/invoice/generate', xAccessToken.token, async function (req, res, next) {
    var rules = {
        booking: 'required',
    };

    var validation = new Validator(req.query, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Booking is required",
            responseData: {
                res: validation.errors.all()
            }
        });
    }
    else {
        var token = req.headers['x-access-token'];
        var business = req.headers['business'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var user = decoded.user;
        var data = new Object();
        var discount = 0;
        var code = "";
        var discount_type = "";
        var bookingService = [];

        var booking = await Booking.findOne({ '_id': req.query.booking }).populate('address').populate('car').populate('business').populate('user').exec();

        var invoices_count = await Invoice.findOne({ business: business }).count().exec();
        var limit = await q.all(businessPlanLimit(business, req.headers['tz']));
        if (limit.invoices > invoices_count) {
            if (booking) {
                var invoice = await Invoice.findOne({ booking: booking._id, invoice_type: "Booking", status: "Active" }).exec();

                if (invoice) {
                    res.status(422).json({
                        responseCode: 422,
                        responseMessage: 'Booking already generated #Invoice No' + invoice.invoice_no,
                        responseData: {},
                    });
                }
                else {
                    var tax_type = "GST";

                    if (booking.address != null) {
                        if (booking.address.state == booking.business.address.state) {
                            tax_type = "GST";
                        }
                        else {
                            tax_type = "IGST";
                        }
                    }
                    else {
                        return res.status(422).json({
                            responseCode: 422,
                            responseMessage: "Select an address",
                            responseData: {},
                        });
                    }


                    var services = _.filter(booking.services, customer_approval => customer_approval.customer_approval == true);

                    for (var i = 0; i < services.length; i++) {
                        var part = [];
                        var labours = [];
                        var opening_fitting = [];

                        var part_list = services[i].parts;
                        var labour_list = services[i].labour;
                        var of_list = services[i].opening_fitting;

                        if (part_list) {
                            for (var p = 0; p < part_list.length; p++) {
                                var total = 0;
                                var tax_info = await Tax.findOne({ rate: part_list[p].tax_rate, type: tax_type }).exec();
                                var tax = [];
                                var rate = part_list[p].rate;
                                var amount = (parseFloat(part_list[p].rate) * parseFloat(part_list[p].quantity));
                                var tax_rate = tax_info.detail;
                                var discount_total = 0;
                                var base = amount;

                                if (parseFloat(part_list[p].customer_dep) != null && parseFloat(part_list[p].insurance_dep) != null) {
                                    var customer_dep = parseFloat(part_list[p].customer_dep);
                                    var insurance_dep = parseFloat(part_list[p].insurance_dep)
                                }
                                else {
                                    var customer_dep = 100;
                                    var insurance_dep = 0;

                                    part_list[p].customer_dep = 100;
                                    part_list[p].insurance_dep = 0;
                                }

                                var dep = 0;

                                if (services[i].claim == true) {
                                    if (parseFloat(part_list[p].insurance_dep) <= 0 && parseFloat(part_list[p].customer_dep) <= 0) {
                                        dep = 0
                                    }
                                    else {
                                        if (parseFloat(part_list[p].customer_dep) <= 0 && parseFloat(part_list[p].insurance_dep <= 100)) {
                                            dep = 100
                                        }
                                        else {
                                            dep = 100 - parseFloat(part_list[p].customer_dep);
                                        }
                                    }

                                    amount = amount - (amount * dep / 100);
                                    dep = base - amount;
                                }

                                if (part_list[p].discount) {
                                    discount_total = part_list[p].discount;
                                    amount = amount - parseFloat(discount_total.toFixed(2))
                                }


                                if (part_list[p].amount_is_tax == "exclusive") {
                                    var tax_on_amount = amount;
                                    if (tax_rate.length > 0) {
                                        for (var r = 0; r < tax_rate.length; r++) {
                                            if (tax_rate[r].rate != tax_info.rate) {
                                                var t = tax_on_amount * (tax_rate[r].rate / 100);
                                                amount = amount + t; parseFloat
                                                tax.push({
                                                    tax: tax_rate[r].tax,
                                                    rate: tax_rate[r].rate,
                                                    amount: parseFloat(t.toFixed(2))
                                                });
                                            }
                                            else {
                                                var t = tax_on_amount * (tax_rate[r].rate / 100);
                                                amount = amount + t;
                                                tax.push({
                                                    tax: tax_info.tax, tax_rate: tax_info.rate,
                                                    rate: tax_info.rate,
                                                    amount: parseFloat(t.toFixed(2))
                                                });
                                            }
                                        }
                                    }
                                    total = total + amount;
                                }

                                if (part_list[p].amount_is_tax == "inclusive") {
                                    var x = (100 + tax_info.rate) / 100;
                                    var tax_on_amount = amount / x;
                                    if (tax_rate.length > 0) {
                                        for (var r = 0; r < tax_rate.length; r++) {
                                            if (tax_rate[r].rate != tax_info.rate) {
                                                var t = tax_on_amount * (tax_rate[r].rate / 100);
                                                base = base - t;
                                                tax.push({
                                                    tax: tax_rate[r].tax,
                                                    rate: tax_rate[r].rate,
                                                    amount: parseFloat(t.toFixed(2))
                                                });
                                            }
                                            else {
                                                var t = amount - tax_on_amount;
                                                base = base - t;
                                                tax.push({
                                                    tax: tax_info.tax, tax_rate: tax_info.rate,
                                                    rate: tax_info.rate,
                                                    amount: parseFloat(t.toFixed(2))
                                                });
                                            }
                                        }
                                    }
                                    base = base - dep;
                                    total = total + amount;
                                }

                                var tax_amount = total - parseFloat(base.toFixed(2));

                                var tax_details = {
                                    tax: tax_info.tax,
                                    tax_rate: tax_info.rate,
                                    rate: tax_info.rate,
                                    amount: total,
                                    detail: tax
                                }

                                part.push({
                                    item: part_list[p].item,
                                    source: part_list[p].source,
                                    hsn_sac: part_list[p].hsn_sac,
                                    part_no: part_list[p].part_no,
                                    rate: parseFloat(part_list[p].rate),
                                    quantity: parseFloat(part_list[p].quantity),
                                    base: parseFloat(base.toFixed(2)),
                                    amount: total,
                                    discount: part_list[p].discount,
                                    issued: part_list[p].issued,
                                    customer_dep: parseFloat(part_list[p].customer_dep),
                                    insurance_dep: parseFloat(part_list[p].insurance_dep),
                                    tax_amount: parseFloat(_.sumBy(tax, x => x.amount).toFixed(2)),
                                    amount_is_tax: part_list[p].amount_is_tax,
                                    tax: tax_info.tax,
                                    tax_rate: tax_info.rate,
                                    tax_info: tax_details
                                });
                            }
                        }

                        if (labour_list) {
                            for (var l = 0; l < labour_list.length; l++) {
                                var total = 0;
                                var tax_info = await Tax.findOne({ rate: labour_list[l].tax_rate, type: tax_type }).exec();
                                var tax = [];
                                var rate = labour_list[l].rate;
                                var amount = parseFloat(labour_list[l].rate) * parseFloat(labour_list[l].quantity);
                                var tax_rate = tax_info.detail;
                                var discount_total = 0;
                                var base = amount;

                                if (parseFloat(labour_list[l].customer_dep) != null && parseFloat(labour_list[l].insurance_dep) != null) {
                                    var customer_dep = parseFloat(labour_list[l].customer_dep);
                                    var insurance_dep = parseFloat(labour_list[l].insurance_dep)
                                }
                                else {
                                    var customer_dep = 100;
                                    var insurance_dep = 0;

                                    labour_list[l].customer_dep = 100;
                                    labour_list[l].insurance_dep = 0;
                                }


                                var dep = 0;

                                if (services[i].claim == true) {
                                    if (parseFloat(labour_list[l].insurance_dep) <= 0 && parseFloat(labour_list[l].customer_dep) <= 0) {
                                        dep = 0
                                    }
                                    else {
                                        if (parseFloat(labour_list[l].customer_dep) <= 0 && parseFloat(labour_list[l].insurance_dep <= 100)) {
                                            dep = 100
                                        }
                                        else {
                                            dep = 100 - parseFloat(labour_list[l].customer_dep);
                                        }
                                    }

                                    amount = amount - (amount * dep / 100);
                                    dep = base - amount;
                                }

                                if (labour_list[l].discount) {
                                    discount_total = labour_list[l].discount;
                                    amount = amount - parseFloat(discount_total.toFixed(2))
                                }

                                if (labour_list[l].amount_is_tax == "exclusive") {
                                    var tax_on_amount = amount;
                                    if (tax_rate.length > 0) {
                                        for (var r = 0; r < tax_rate.length; r++) {
                                            if (tax_rate[r].rate != tax_info.rate) {
                                                var t = tax_on_amount * (tax_rate[r].rate / 100);
                                                amount = amount + t; parseFloat
                                                tax.push({
                                                    tax: tax_rate[r].tax,
                                                    rate: tax_rate[r].rate,
                                                    amount: parseFloat(t.toFixed(2))
                                                });
                                            }
                                            else {
                                                var t = tax_on_amount * (tax_rate[r].rate / 100);
                                                amount = amount + t;
                                                tax.push({
                                                    tax: tax_info.tax, tax_rate: tax_info.rate,
                                                    rate: tax_info.rate,
                                                    amount: parseFloat(t.toFixed(2))
                                                });
                                            }
                                        }
                                    }
                                    //total = total+amount;
                                }

                                if (labour_list[l].amount_is_tax == "inclusive") {
                                    var x = (100 + tax_info.rate) / 100;
                                    var tax_on_amount = amount / x;
                                    if (tax_rate.length > 0) {
                                        for (var r = 0; r < tax_rate.length; r++) {
                                            if (tax_rate[r].rate != tax_info.rate) {
                                                var t = tax_on_amount * (tax_rate[r].rate / 100);
                                                base = base - t;
                                                tax.push({
                                                    tax: tax_rate[r].tax,
                                                    rate: tax_rate[r].rate,
                                                    amount: parseFloat(t.toFixed(2))
                                                });
                                            }
                                            else {
                                                var t = amount - tax_on_amount;
                                                base = base - t;
                                                tax.push({
                                                    tax: tax_info.tax, tax_rate: tax_info.rate,
                                                    rate: tax_info.rate,
                                                    amount: parseFloat(t.toFixed(2))
                                                });
                                            }
                                        }
                                    }
                                    base = base - dep;
                                    total = total + amount;
                                }

                                var tax_amount = total - parseFloat(base.toFixed(2));

                                var tax_details = {
                                    tax: tax_info.tax,
                                    rate: tax_info.rate,
                                    amount: total,
                                    detail: tax
                                };

                                labours.push({
                                    item: labour_list[l].item,
                                    source: labour_list[l].source,
                                    rate: parseFloat(labour_list[l].rate),
                                    quantity: parseFloat(labour_list[l].quantity),
                                    base: parseFloat(base.toFixed(2)),
                                    amount: amount,
                                    discount: labour_list[l].discount,
                                    customer_dep: parseFloat(labour_list[l].customer_dep),
                                    insurance_dep: parseFloat(labour_list[l].insurance_dep),
                                    tax_amount: parseFloat(_.sumBy(tax, x => x.amount).toFixed(2)),
                                    amount_is_tax: labour_list[l].amount_is_tax,
                                    tax: tax_info.tax,
                                    tax_rate: tax_info.rate,
                                    tax_info: tax_details
                                });
                            }
                        }

                        if (of_list) {
                            for (var o = 0; o < of_list.length; o++) {
                                var total = 0;
                                var tax_info = await Tax.findOne({ rate: of_list[o].tax_rate, type: tax_type }).exec();
                                var tax = [];
                                var rate = of_list[o].rate;
                                var amount = (parseFloat(of_list[o].rate) * parseFloat(of_list[o].quantity));
                                var tax_rate = tax_info.detail;
                                var base = amount;

                                if (parseFloat(of_list[o].customer_dep) != null && parseFloat(of_list[o].insurance_dep) != null) {
                                    var customer_dep = parseFloat(of_list[o].customer_dep);
                                    var insurance_dep = parseFloat(of_list[o].insurance_dep)
                                }
                                else {
                                    var customer_dep = 100;
                                    var insurance_dep = 0;

                                    of_list[o].customer_dep = 100;
                                    of_list[o].insurance_dep = 0;
                                }

                                var dep = 0;

                                if (services[i].claim == true) {
                                    if (parseFloat(of_list[o].insurance_dep) <= 0 && parseFloat(of_list[o].customer_dep) <= 0) {
                                        dep = 0
                                    }
                                    else {
                                        if (parseFloat(of_list[o].customer_dep) <= 0 && parseFloat(of_list[o].insurance_dep <= 100)) {
                                            dep = 100
                                        }
                                        else {
                                            dep = 100 - parseFloat(of_list[o].customer_dep);
                                        }
                                    }

                                    amount = amount - (amount * dep / 100);

                                    dep = base - amount;
                                }

                                if (of_list[o].discount) {
                                    discount_total = of_list[o].discount;
                                    amount = amount - parseFloat(discount_total.toFixed(2))
                                }


                                if (of_list[o].amount_is_tax == "exclusive") {
                                    var tax_on_amount = amount;
                                    if (tax_rate.length > 0) {
                                        for (var r = 0; r < tax_rate.length; r++) {
                                            if (tax_rate[r].rate != tax_info.rate) {
                                                var t = tax_on_amount * (tax_rate[r].rate / 100);
                                                amount = amount + t; parseFloat
                                                tax.push({
                                                    tax: tax_rate[r].tax,
                                                    rate: tax_rate[r].rate,
                                                    amount: parseFloat(t.toFixed(2))
                                                });
                                            }
                                            else {
                                                var t = tax_on_amount * (tax_rate[r].rate / 100);
                                                amount = amount + t;
                                                tax.push({
                                                    tax: tax_info.tax, tax_rate: tax_info.rate,
                                                    rate: tax_info.rate,
                                                    amount: parseFloat(t.toFixed(2))
                                                });
                                            }
                                        }
                                    }
                                    total = total + amount;
                                }

                                if (of_list[o].amount_is_tax == "inclusive") {
                                    var x = (100 + tax_info.rate) / 100;
                                    var tax_on_amount = amount / x;
                                    if (tax_rate.length > 0) {
                                        for (var r = 0; r < tax_rate.length; r++) {
                                            if (tax_rate[r].rate != tax_info.rate) {
                                                var t = tax_on_amount * (tax_rate[r].rate / 100);
                                                base = base - t;
                                                tax.push({
                                                    tax: tax_rate[r].tax,
                                                    rate: tax_rate[r].rate,
                                                    amount: parseFloat(t.toFixed(2))
                                                });
                                            }
                                            else {
                                                var t = amount - tax_on_amount;
                                                base = base - t;
                                                tax.push({
                                                    tax: tax_info.tax, tax_rate: tax_info.rate,
                                                    rate: tax_info.rate,
                                                    amount: parseFloat(t.toFixed(2))
                                                });
                                            }
                                        }
                                    }

                                    base = base - dep;
                                    total = total + amount;
                                }

                                var tax_details = {
                                    tax: tax_info.tax,
                                    rate: tax_info.rate,
                                    amount: total,
                                    detail: tax
                                }

                                var tax_amount = total - parseFloat(base.toFixed(2));

                                opening_fitting.push({
                                    item: of_list[o].item,
                                    source: of_list[o].source,
                                    rate: parseFloat(of_list[o].rate),
                                    quantity: parseFloat(of_list[o].quantity),
                                    base: parseFloat(base.toFixed(2)),
                                    amount: total,
                                    discount: parseFloat(of_list[o].discount),
                                    customer_dep: parseFloat(of_list[o].customer_dep),
                                    insurance_dep: parseFloat(of_list[o].insurance_dep),
                                    tax_amount: parseFloat(_.sumBy(tax, x => x.amount).toFixed(2)),
                                    amount_is_tax: of_list[o].amount_is_tax,
                                    tax: tax_info.tax, tax_rate: tax_info.rate,
                                    tax_info: tax_details
                                });
                            }
                        }

                        var parts_visible = true;

                        bookingService.push({
                            source: services[i].source,
                            service: services[i].service,
                            mileage: services[i].mileage,
                            parts: part,
                            labour: labours,
                            opening_fitting: opening_fitting,
                            hours: services[i].hours,
                            parts_visible: parts_visible,
                            quantity: services[i].quantity,
                            discount: _.sumBy(labours, x => x.discount) + _.sumBy(part, x => x.discount) + _.sumBy(opening_fitting, x => x.discount),
                            description: services[i].description,
                            cost: _.sumBy(part, x => x.amount) + _.sumBy(labours, x => x.amount) + services[i].of_cost,
                            labour_cost: _.sumBy(labours, x => x.amount),
                            of_cost: _.sumBy(opening_fitting, x => x.amount),
                            part_cost: _.sumBy(part, x => x.amount),
                            exceeded_cost: parseFloat(services[i].exceeded_cost),
                            part_cost_editable: services[i].part_cost_editable,
                            labour_cost_editable: services[i].labour_cost_editable,
                            of_cost_editable: services[i].of_cost_editable,
                            type: services[i].type,
                            customer_approval: services[i].customer_approval,
                            surveyor_approval: services[i].surveyor_approval,
                            claim: services[i].claim,
                            custom: services[i].custom,
                        });
                    }


                    var policy_clause = 0
                    if (booking.payment.policy_clause) {
                        policy_clause = booking.payment.policy_clause;
                    }
                    var salvage = 0
                    if (booking.payment.salvage) {
                        salvage = booking.payment.salvage;
                    }

                    var paid_total = booking.payment.paid_total;
                    var labour_cost = _.sumBy(bookingService, x => x.labour_cost);
                    var part_cost = _.sumBy(bookingService, x => x.part_cost);
                    var of_cost = _.sumBy(bookingService, x => x.of_cost);
                    var discount_total = _.sumBy(bookingService, x => x.discount);
                    var pick_up_charges = booking.payment.pick_up_charges;
                    var careager_cash = booking.payment.careager_cash;
                    var payment_total = labour_cost + part_cost + of_cost + discount_total + policy_clause + salvage + pick_up_charges;

                    var estimate_cost = labour_cost + part_cost + of_cost + policy_clause + salvage + pick_up_charges - careager_cash;

                    var due_amount = _.sumBy(bookingService, x => x.labour_cost) + _.sumBy(bookingService, x => x.part_cost) + _.sumBy(bookingService, x => x.of_cost) + policy_clause + salvage + pick_up_charges - (paid_total + careager_cash);

                    var due = {
                        due: Math.ceil(due_amount.toFixed(2))
                    }

                    var payment = {
                        estimate_cost: estimate_cost,
                        total: payment_total,
                        careager_cash: careager_cash,
                        of_cost: of_cost,
                        labour_cost: labour_cost,
                        part_cost: part_cost,
                        payment_mode: booking.payment.payment_mode,
                        payment_status: booking.payment.payment_status,
                        coupon: booking.payment.coupon,
                        coupon_type: booking.payment.coupon_type,
                        discount_by: booking.payment.discount_by,
                        discount_type: booking.payment.discount_type,
                        discount: booking.payment.discount,
                        discount_total: discount_total,
                        policy_clause: policy_clause,
                        salvage: salvage,
                        terms: booking.payment.terms,
                        pick_up_limit: booking.payment.pick_up_limit,
                        pick_up_charges: pick_up_charges,
                        paid_total: parseFloat(booking.payment.paid_total),
                        discount_applied: booking.payment.discount_applied,
                        transaction_id: booking.payment.transaction_id,
                        transaction_date: booking.payment.transaction_date,
                        transaction_status: booking.payment.transaction_status,
                        transaction_response: booking.payment.transaction_response
                    };

                    var data = {
                        booking: booking._id,
                        user: booking.user,
                        car: booking.car._id,
                        business: booking.business,
                        advisor: booking.advisor,
                        address: booking.address,
                        job_no: booking.job_no,
                        booking_no: booking.booking_no,
                        delivery_date: booking.delivery_date,
                        delivery_date: booking.delivery_date,
                        delivery_time: booking.delivery_time,
                        with_tax: booking.with_tax,
                        odometer: booking.odometer,
                        note: booking.note,
                        insurance_info: booking.insurance_info,
                        due: due,
                        services: bookingService,
                        payment: payment,
                        invoice_type: "Booking",
                        status: "Active",
                        started_at: booking.started_at,
                        created_at: new Date(),
                        updated_at: new Date()
                    };

                    Invoice.create(data).then(async function (inv) {
                        var status = "Completed";
                        if (booking.insurance_info) {
                            if (booking.insurance_info.claim == true) {
                                status = booking.status;
                            }
                        }

                        Booking.findOneAndUpdate({ _id: booking._id }, { $set: { status: status, updated_at: new Date() } }, { new: false }, async function (err, doc) {
                            if (err) {
                                res.status(400).json({
                                    responseCode: 400,
                                    responseMessage: "Error",
                                    responseData: err
                                });
                            }
                            else {
                                if (booking.business.isCarEager == true) {
                                    var partner = await q.all(fun.partnerCommission(booking._id));
                                }
                                event.zohoLead(booking._id);

                                if (booking.package) {
                                    packageDeduction(booking._id)
                                }


                                var count = await Invoice.find({ _id: { $lt: inv._id }, invoice_type: "Booking", with_tax: inv.with_tax, business: business }).count();

                                if (count == 0) {
                                    var last_invoice = "";
                                    var position = 1;
                                }
                                else {
                                    var lv = await Invoice.findOne({ _id: { $lt: inv._id }, invoice_type: "Booking", with_tax: inv.with_tax, business: business }).sort({ _id: -1 }).exec();

                                    var last_invoice = lv.invoice_no;
                                    position = count + 1
                                }

                                var fy = {
                                    with_tax: inv.with_tax,
                                    last_invoice: last_invoice,
                                    position: position,
                                };

                                var assigned_invoice_no = await q.all(fun.fiscalyear(fy));

                                if (assigned_invoice_no) {
                                    if (assigned_invoice_no.invoice) {
                                        Invoice.findOneAndUpdate({ _id: inv._id }, { $set: { invoice_no: assigned_invoice_no.invoice } }, { new: true }, async function (err, doc) {
                                            if (err) {
                                                res.status(422).json({
                                                    responseCode: 422,
                                                    responseMessage: 'Server Error',
                                                    responseData: err,
                                                });
                                            }
                                            else {
                                                var updated = await q.all(fun.invoice(inv._id, req.headers['tz']));
                                                res.status(200).json({
                                                    responseCode: 200,
                                                    responseMessage: 'Success',
                                                    responseData: updated,
                                                });
                                            }
                                        })
                                    }
                                    else {
                                        res.status(422).json({
                                            responseCode: 422,
                                            responseMessage: "Server Error",
                                            responseData: {}
                                        });
                                    }
                                }
                                else {
                                    res.status(422).json({
                                        responseCode: 422,
                                        responseMessage: "Server Error",
                                        responseData: {}
                                    });
                                }
                            }
                        });
                    })

                }
            }
            else {
                res.status(400).json({
                    responseCode: 400,
                    responseMessage: "Booking not found",
                    responseData: {}
                });
            }
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: 'Invoices Limit Exceeded. Upgrade Your Plan',
                responseData: {}
            });
        }
    }
});

router.get('/booking/invoices/get', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers['business'];
    var invoices = [];
    var filters = [];
    var totalResult = 0;

    var role = await Management.findOne({ user: user, business: business }).exec();
    if (req.query.page == undefined) {
        var page = 0;
    }
    else {
        var page = req.query.page;
    }

    var date = new Date();
    var to = new Date();
    to.setDate(date.getDate() - 1);
    to.setHours(23, 59, 58)

    var page = Math.max(0, parseInt(page));
    var queries = new Object();
    var sortBy = new Object();

    var thumbnail = [];

    var specification = {};
    specification['$lookup'] = {
        from: "User",
        localField: "user",
        foreignField: "_id",
        as: "user",
    };
    filters.push(specification);

    var specification = {};
    specification['$unwind'] = {
        path: "$user",
        preserveNullAndEmptyArrays: false
    };
    filters.push(specification);

    var specification = {};
    specification['$lookup'] = {
        from: "Car",
        localField: "car",
        foreignField: "_id",
        as: "car",
    };
    filters.push(specification);

    var specification = {};
    specification['$unwind'] = {
        path: "$car",
        preserveNullAndEmptyArrays: true
    };

    var specification = {};
    specification['$lookup'] = {
        from: "Advisor",
        localField: "advisor",
        foreignField: "_id",
        as: "advisor",
    };
    filters.push(specification);

    var specification = {};
    specification['$unwind'] = {
        path: "$advisor",
        preserveNullAndEmptyArrays: true
    };
    filters.push(specification);

    if (req.query.query) {
        var specification = {};
        specification['$match'] = {
            business: mongoose.Types.ObjectId(business),
            $or: [
                { 'status': { $regex: req.query.query, $options: 'i' } },
                { 'booking_no': { $eq: req.query.query } },
                { 'invoice_no': { $regex: req.query.query, $options: 'i' } },
                { 'user.name': { $regex: req.query.query, $options: 'i' } },
                { 'user.contact_no': { $regex: req.query.query, $options: 'i' } },
                { 'car.title': { $regex: req.query.query, $options: 'i' } },
                { 'car.registration_no': { $regex: req.query.query, $options: 'i' } },
                { 'advisor.name': { $regex: req.query.query, $options: 'i' } },
                { 'insurance_info.insurance_company': { $regex: req.query.query, $options: 'i' } },
                { 'insurance_info.branch': { $regex: req.query.query, $options: 'i' } },
                { 'advisor.contact_no': { $regex: req.query.query, $options: 'i' } },
            ]
        };
        filters.push(specification);
    }
    else {
        var specification = {};
        specification['$match'] = {
            business: mongoose.Types.ObjectId(business),
        };
        filters.push(specification);
    }

    var specification = {};
    specification['$sort'] = {
        _id: -1,
    };
    filters.push(specification);


    totalResult = await Invoice.aggregate(filters);

    var all = _.filter(totalResult, x => x.status == "Active");
    var map_due = _.map(all, 'due');

    var due = parseFloat(_.sumBy(map_due, x => x.due).toFixed(2));

    var specification = {};
    specification['$skip'] = config.perPage * page;
    filters.push(specification);

    var specification = {};
    specification['$limit'] = config.perPage;
    filters.push(specification);

    await Invoice.aggregate(filters)
        .allowDiskUse(true)
        .cursor({ batchSize: 10 })
        .exec()
        .eachAsync(async function (invoice) {
            invoices.push({
                _id: invoice._id,
                id: invoice._id,
                car: {
                    _id: invoice.car[0]._id,
                    id: invoice.car[0]._id,
                    title: invoice.car[0].title,
                    registration_no: invoice.car[0].registration_no,
                },
                user: {
                    _id: invoice.user._id,
                    id: invoice.user._id,
                    name: invoice.user.name,
                    contact_no: invoice.user.contact_no,
                    email: invoice.user.email,
                    account_info: invoice.user.account_info,
                    business_info: invoice.user.business_info,
                },
                business: {
                    _id: invoice.business._id,
                    id: invoice.business._id,
                    name: invoice.business.name,
                    contact_no: invoice.business.contact_no,
                    email: invoice.business.email,
                    account_info: invoice.business.account_info,
                    business_info: invoice.business.business_info,
                    address: invoice.business.address,
                },
                /*advisor: {
                    _id: invoice.advisor._id,
                    id: invoice.advisor._id,
                    name: invoice.advisor.name,
                    contact_no: invoice.advisor.contact_no,
                    email: invoice.advisor.email
                },*/
                advisor: invoice.advisor,
                booking: invoice.booking,
                services: invoice.services,
                status: _.startCase(invoice.status),
                invoice_no: invoice.invoice_no,
                job_no: invoice.job_no,
                booking_no: invoice.booking_no,
                address: invoice.address,
                payment: invoice.payment,
                due: invoice.due,
                odometer: invoice.odometer,
                insurance_info: invoice.insurance_info,
                invoice_type: invoice.invoice_type,
                started_at: moment(invoice.started_at).tz(req.headers['tz']).format('lll'),
                delivery_date: moment(invoice.delivery_date).tz(req.headers['tz']).format('ll'),
                delivery_time: invoice.delivery_time,
                status: invoice.status,
                started_at: moment(invoice.started_at).tz(req.headers['tz']).format('lll'),
                created_at: moment(invoice.created_at).tz(req.headers['tz']).format('lll'),
                updated_at: moment(invoice.updated_at).tz(req.headers['tz']).format('lll'),
            });
        });


    res.status(200).json({
        responseCode: 200,
        responseMessage: to,
        responseInfo: {
            due: due,
            totalResult: totalResult.length
        },
        responseData: invoices
    });
});

router.delete('/booking/invoice/cancel', xAccessToken.token, async function (req, res, next) {
    var rules = {
        invoice: 'required',
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Invoice is required",
            responseData: {
                res: validation.errors.all()
            }
        });
    }
    else {
        var token = req.headers['x-access-token'];
        var business = req.headers['business'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var user = decoded.user;
        var data = new Object();

        var loggedInDetails = await User.findById(user).exec();

        var invoice = await Invoice.findOne({ _id: req.body.invoice, status: "Active" }).exec();
        if (invoice) {
            Invoice.findOneAndUpdate({ _id: invoice._id }, { $set: { status: "Cancelled" } }, { new: true }, async function (err, doc) {
                if (err) {
                    res.status(422).json({
                        responseCode: 422,
                        responseMessage: "Server Error",
                        responseData: err,
                    });
                }
                else {
                    Booking.findOneAndUpdate({ _id: invoice.booking }, { $set: { status: "Ready" } }, { new: true }, async function (err, doc) {
                        if (err) {
                            res.status(422).json({
                                responseCode: 422,
                                responseMessage: "Server Error",
                                responseData: err,
                            });
                        }
                        else {
                            var activity = {
                                user: loggedInDetails._id,
                                name: loggedInDetails.name,
                                stage: "Invoice",
                                activity: "Invoice Cancelled #(" + invoice.invoice_no + ")",
                            }

                            fun.bookingLog(invoice.booking, activity);

                            res.status(200).json({
                                responseCode: 200,
                                responseMessage: "Invoice Cancelled",
                                responseData: {},
                            });
                        }
                    });
                }
            });
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Invoice not found",
                responseData: {}
            });
        }

    }
});

router.get('/invoice/get', xAccessToken.token, async function (req, res, next) {
    var rules = {
        invoice: 'required',
    };
    var validation = new Validator(req.query, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Invoice is required",
            responseData: {
                res: validation.errors.all()
            }
        });
    }
    else {
        var token = req.headers['x-access-token'];
        var business = req.headers['business'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var user = decoded.user;
        var data = new Object();
        var discount = 0;
        var code = "";
        var discount_type = "";
        var bookingService = [];


        var invoice = await Invoice.findOne({ _id: req.query.invoice })
            .populate({ path: 'booking' })
            .populate({ path: 'address' })
            .populate({ path: 'advisor', select: "_id id name contact_no email" })
            .populate({ path: 'user', select: "_id id name contact_no email business_info" })
            .populate({ path: 'business', select: "_id id name contact_no email business_info bank_details address" })
            .populate({ path: 'car', select: '_id id title registration_no ic rc vin engine_no insurance_info' })
            .exec();

        if (invoice) {
            var booking = invoice.booking;
            var tax_type = invoice.tax_type;
            var services = invoice.services;
            if (invoice.invoice_type == "Insurance") {
                if (invoice.insurance_info.insurance_company && invoice.insurance_info.branch && invoice.insurance_info.state && invoice.insurance_info.gstin) {
                    if (booking.insurance_info.state.toLowerCase() == booking.business.address.state.toLowerCase()) {
                        tax_type = "GST";
                    }
                    else {
                        tax_type = "IGST";
                    }
                }

                for (var i = 0; i < services.length; i++) {
                    var part = [];
                    var labours = [];
                    var opening_fitting = [];

                    var part_list = services[i].parts;
                    var labour_list = services[i].labour;
                    var of_list = services[i].opening_fitting;

                    if (part_list) {
                        for (var p = 0; p < part_list.length; p++) {
                            var total = 0;
                            var tax_info = await Tax.findOne({ rate: part_list[p].tax_rate, type: tax_type }).exec();
                            var tax = [];
                            var rate = part_list[p].rate;
                            var amount = (parseFloat(part_list[p].rate) * parseFloat(part_list[p].quantity));
                            var tax_rate = tax_info.detail;
                            var discount_total = 0;
                            var base = amount;

                            var dep = 0;

                            if (parseFloat(part_list[p].insurance_dep) <= 0 && parseFloat(part_list[p].customer_dep) <= 0) {
                                dep = 100
                            }
                            else {
                                if (parseFloat(part_list[p].insurance_dep) <= 0 && parseFloat(part_list[p].customer_dep <= 100)) {
                                    dep = 100
                                }
                                else {
                                    dep = 100 - parseFloat(part_list[p].insurance_dep);

                                }
                            }

                            amount = amount - (amount * dep / 100);

                            var dep = base - amount;

                            if (part_list[p].amount_is_tax == "exclusive") {
                                var tax_on_amount = amount;
                                if (tax_rate.length > 0) {
                                    for (var r = 0; r < tax_rate.length; r++) {
                                        if (tax_rate[r].rate != tax_info.rate) {
                                            var t = tax_on_amount * (tax_rate[r].rate / 100);
                                            amount = amount + t; parseFloat
                                            tax.push({
                                                tax: tax_rate[r].tax,
                                                rate: tax_rate[r].rate,
                                                amount: parseFloat(t.toFixed(2))
                                            });
                                        }
                                        else {
                                            var t = tax_on_amount * (tax_rate[r].rate / 100);
                                            amount = amount + t;
                                            tax.push({
                                                tax: tax_info.tax, tax_rate: tax_info.rate,
                                                rate: tax_info.rate,
                                                amount: parseFloat(t.toFixed(2))
                                            });
                                        }
                                    }
                                }
                                total = total + amount;
                            }

                            if (part_list[p].amount_is_tax == "inclusive") {
                                var x = (100 + tax_info.rate) / 100;
                                var tax_on_amount = amount / x;
                                if (tax_rate.length > 0) {
                                    for (var r = 0; r < tax_rate.length; r++) {
                                        if (tax_rate[r].rate != tax_info.rate) {
                                            var t = tax_on_amount * (tax_rate[r].rate / 100);
                                            base = base - t;
                                            tax.push({
                                                tax: tax_rate[r].tax,
                                                rate: tax_rate[r].rate,
                                                amount: parseFloat(t.toFixed(2))
                                            });
                                        }
                                        else {
                                            var t = amount - tax_on_amount;
                                            base = base - t;
                                            tax.push({
                                                tax: tax_info.tax, tax_rate: tax_info.rate,
                                                rate: tax_info.rate,
                                                amount: parseFloat(t.toFixed(2))
                                            });
                                        }
                                    }
                                }

                                base = base - dep;
                                total = total + amount;
                            }

                            var tax_amount = total - parseFloat(base.toFixed(2));

                            var tax_details = {
                                tax: tax_info.tax,
                                tax_rate: tax_info.rate,
                                rate: tax_info.rate,
                                amount: total,
                                detail: tax
                            }

                            part.push({
                                item: part_list[p].item,
                                source: part_list[p].source,
                                hsn_sac: part_list[p].hsn_sac,
                                part_no: part_list[p].part_no,
                                rate: parseFloat(part_list[p].rate),
                                quantity: parseFloat(part_list[p].quantity),
                                base: parseFloat(base.toFixed(2)),
                                amount: total,
                                discount: 0,
                                //discount: part_list[p].discount,
                                issued: part_list[p].issued,
                                customer_dep: parseFloat(part_list[p].customer_dep),
                                insurance_dep: parseFloat(part_list[p].insurance_dep),
                                tax_amount: parseFloat(_.sumBy(tax, x => x.amount).toFixed(2)),
                                amount_is_tax: part_list[p].amount_is_tax,
                                tax: tax_info.tax,
                                tax_rate: tax_info.rate,
                                tax_info: tax_details
                            });
                        }
                    }

                    if (labour_list) {
                        for (var l = 0; l < labour_list.length; l++) {
                            var total = 0;
                            var tax_info = await Tax.findOne({ rate: labour_list[l].tax_rate, type: tax_type }).exec();
                            var tax = [];
                            var rate = labour_list[l].rate;
                            var amount = parseFloat(labour_list[l].rate) * parseFloat(labour_list[l].quantity);
                            var tax_rate = tax_info.detail;
                            var discount_total = 0;
                            var base = amount;
                            var dep = 0;


                            if (parseFloat(labour_list[l].insurance_dep) <= 0 && parseFloat(labour_list[l].customer_dep) <= 0) {
                                dep = 100
                            }
                            else {
                                if (parseFloat(labour_list[l].insurance_dep) <= 0 && parseFloat(labour_list[l].customer_dep <= 100)) {
                                    dep = 100
                                }
                                else {
                                    dep = 100 - parseFloat(labour_list[l].insurance_dep);
                                }
                            }

                            amount = amount - (amount * dep / 100);
                            var dep = base - amount;

                            if (labour_list[l].amount_is_tax == "exclusive") {
                                var tax_on_amount = amount;
                                if (tax_rate.length > 0) {
                                    for (var r = 0; r < tax_rate.length; r++) {
                                        if (tax_rate[r].rate != tax_info.rate) {
                                            var t = tax_on_amount * (tax_rate[r].rate / 100);
                                            amount = amount + t; parseFloat
                                            tax.push({
                                                tax: tax_rate[r].tax,
                                                rate: tax_rate[r].rate,
                                                amount: parseFloat(t.toFixed(2))
                                            });
                                        }
                                        else {
                                            var t = tax_on_amount * (tax_rate[r].rate / 100);
                                            amount = amount + t;
                                            tax.push({
                                                tax: tax_info.tax, tax_rate: tax_info.rate,
                                                rate: tax_info.rate,
                                                amount: parseFloat(t.toFixed(2))
                                            });
                                        }
                                    }
                                }
                                //total = total+amount;
                            }

                            if (labour_list[l].amount_is_tax == "inclusive") {
                                var x = (100 + tax_info.rate) / 100;
                                var tax_on_amount = amount / x;
                                if (tax_rate.length > 0) {
                                    for (var r = 0; r < tax_rate.length; r++) {
                                        if (tax_rate[r].rate != tax_info.rate) {
                                            var t = tax_on_amount * (tax_rate[r].rate / 100);
                                            base = base - t;
                                            tax.push({
                                                tax: tax_rate[r].tax,
                                                rate: tax_rate[r].rate,
                                                amount: parseFloat(t.toFixed(2))
                                            });
                                        }
                                        else {
                                            var t = amount - tax_on_amount;
                                            base = base - t;
                                            tax.push({
                                                tax: tax_info.tax,
                                                tax_rate: tax_info.rate,
                                                rate: tax_info.rate,
                                                amount: parseFloat(t.toFixed(2))
                                            });
                                        }
                                    }
                                }

                                base = base - dep;

                                total = total + amount;
                            }

                            var tax_amount = total - parseFloat(base.toFixed(2));

                            var tax_details = {
                                tax: tax_info.tax,
                                rate: tax_info.rate,
                                amount: total,
                                detail: tax
                            };

                            labours.push({
                                item: labour_list[l].item,
                                source: labour_list[l].source,
                                rate: parseFloat(labour_list[l].rate),
                                quantity: parseFloat(labour_list[l].quantity),
                                base: parseFloat(base.toFixed(2)),
                                amount: amount,
                                discount: 0,
                                //discount: labour_list[l].discount,
                                customer_dep: parseFloat(labour_list[l].customer_dep),
                                insurance_dep: parseFloat(labour_list[l].insurance_dep),
                                tax_amount: parseFloat(_.sumBy(tax, x => x.amount).toFixed(2)),
                                amount_is_tax: labour_list[l].amount_is_tax,
                                tax: tax_info.tax,
                                tax_rate: tax_info.rate,
                                tax_info: tax_details
                            });
                        }
                    }

                    if (of_list) {
                        for (var o = 0; o < of_list.length; o++) {
                            var total = 0;
                            var tax_info = await Tax.findOne({ rate: of_list[o].tax_rate, type: tax_type }).exec();
                            var tax = [];
                            var rate = of_list[o].rate;
                            var amount = (parseFloat(of_list[o].rate) * parseFloat(of_list[o].quantity));
                            var tax_rate = tax_info.detail;
                            var discount_total = 0;
                            var base = amount;
                            var dep = 0;


                            if (parseFloat(of_list[o].insurance_dep) <= 0 && parseFloat(of_list[o].customer_dep) <= 0) {
                                dep = 100
                            }
                            else {
                                if (parseFloat(of_list[o].insurance_dep) <= 0 && parseFloat(of_list[o].customer_dep <= 100)) {
                                    dep = 100
                                }
                                else {
                                    dep = 100 - parseFloat(of_list[o].insurance_dep);
                                }
                            }

                            amount = amount - (amount * dep / 100);
                            var dep = base - amount;

                            if (of_list[o].amount_is_tax == "exclusive") {
                                var tax_on_amount = amount;
                                if (tax_rate.length > 0) {
                                    for (var r = 0; r < tax_rate.length; r++) {
                                        if (tax_rate[r].rate != tax_info.rate) {
                                            var t = tax_on_amount * (tax_rate[r].rate / 100);
                                            amount = amount + t; parseFloat
                                            tax.push({
                                                tax: tax_rate[r].tax,
                                                rate: tax_rate[r].rate,
                                                amount: parseFloat(t.toFixed(2))
                                            });
                                        }
                                        else {
                                            var t = tax_on_amount * (tax_rate[r].rate / 100);
                                            amount = amount + t;
                                            tax.push({
                                                tax: tax_info.tax, tax_rate: tax_info.rate,
                                                rate: tax_info.rate,
                                                amount: parseFloat(t.toFixed(2))
                                            });
                                        }
                                    }
                                }
                                total = total + amount;
                            }

                            if (of_list[o].amount_is_tax == "inclusive") {
                                var x = (100 + tax_info.rate) / 100;
                                var tax_on_amount = amount / x;
                                if (tax_rate.length > 0) {
                                    for (var r = 0; r < tax_rate.length; r++) {
                                        if (tax_rate[r].rate != tax_info.rate) {
                                            var t = tax_on_amount * (tax_rate[r].rate / 100);
                                            base = base - t;
                                            tax.push({
                                                tax: tax_rate[r].tax,
                                                rate: tax_rate[r].rate,
                                                amount: parseFloat(t.toFixed(2))
                                            });
                                        }
                                        else {
                                            var t = amount - tax_on_amount;
                                            base = base - t;
                                            tax.push({
                                                tax: tax_info.tax, tax_rate: tax_info.rate,
                                                rate: tax_info.rate,
                                                amount: parseFloat(t.toFixed(2))
                                            });
                                        }
                                    }
                                }
                                base = base - dep;
                                total = total + amount;
                            }

                            var tax_details = {
                                tax: tax_info.tax,
                                rate: tax_info.rate,
                                amount: total,
                                detail: tax
                            }

                            var tax_amount = total - parseFloat(base.toFixed(2));

                            opening_fitting.push({
                                item: of_list[o].item,
                                source: of_list[o].source,
                                rate: parseFloat(of_list[o].rate),
                                quantity: parseFloat(of_list[o].quantity),
                                base: parseFloat(base.toFixed(2)),
                                amount: total,
                                discount: 0,
                                //discount: parseFloat(of_list[o].discount),
                                customer_dep: parseFloat(of_list[o].customer_dep),
                                insurance_dep: parseFloat(of_list[o].insurance_dep),
                                tax_amount: parseFloat(_.sumBy(tax, x => x.amount).toFixed(2)),
                                amount_is_tax: of_list[o].amount_is_tax,
                                tax: tax_info.tax, tax_rate: tax_info.rate,
                                tax_info: tax_details
                            });
                        }
                    }

                    var parts_visible = true;

                    bookingService.push({
                        source: services[i].source,
                        service: services[i].service,
                        mileage: services[i].mileage,
                        parts: part,
                        labour: labours,
                        opening_fitting: opening_fitting,
                        hours: services[i].hours,
                        parts_visible: parts_visible,
                        quantity: services[i].quantity,
                        discount: 0,
                        //discount: _.sumBy(labours, x => x.discount)+_.sumBy(part, x => x.discount)+_.sumBy(opening_fitting, x => x.discount),
                        description: services[i].description,
                        cost: _.sumBy(part, x => x.amount) + _.sumBy(labours, x => x.amount) + services[i].of_cost,
                        labour_cost: _.sumBy(labours, x => x.amount),
                        of_cost: _.sumBy(opening_fitting, x => x.amount),
                        part_cost: _.sumBy(part, x => x.amount),
                        exceeded_cost: parseFloat(services[i].exceeded_cost),
                        part_cost_editable: services[i].part_cost_editable,
                        labour_cost_editable: services[i].labour_cost_editable,
                        of_cost_editable: services[i].of_cost_editable,
                        type: services[i].type,
                        customer_approval: services[i].customer_approval,
                        surveyor_approval: services[i].surveyor_approval,
                        claim: services[i].claim,
                        custom: services[i].custom,
                    });
                }
            }
            else {
                if (invoice.address) {
                    if (invoice.address.state.toLowerCase() == invoice.business.address.state.toLowerCase()) {
                        tax_type = "GST";
                    }
                    else {
                        tax_type = "IGST";
                    }
                }

                for (var i = 0; i < services.length; i++) {
                    var part = [];
                    var labours = [];
                    var opening_fitting = [];

                    var part_list = services[i].parts;
                    var labour_list = services[i].labour;
                    var of_list = services[i].opening_fitting;

                    if (part_list) {
                        for (var p = 0; p < part_list.length; p++) {
                            var total = 0;
                            var tax_info = await Tax.findOne({ rate: part_list[p].tax_rate, type: tax_type }).exec();
                            var tax = [];
                            var rate = part_list[p].rate;
                            var amount = (parseFloat(part_list[p].rate) * parseFloat(part_list[p].quantity));
                            var tax_rate = tax_info.detail;
                            var discount_total = 0;
                            var base = amount;

                            var dep = 0;

                            if (services[i].claim == true) {
                                if (parseFloat(part_list[p].insurance_dep) <= 0 && parseFloat(part_list[p].customer_dep) <= 0) {
                                    dep = 0
                                }
                                else {
                                    if (parseFloat(part_list[p].customer_dep) <= 0 && parseFloat(part_list[p].insurance_dep <= 100)) {
                                        dep = 100
                                    }
                                    else {
                                        dep = 100 - parseFloat(part_list[p].customer_dep);
                                    }
                                }

                                amount = amount - (amount * dep / 100);
                                dep = base - amount;
                            }

                            if (part_list[p].discount) {
                                discount_total = part_list[p].discount;
                                amount = amount - parseFloat(discount_total.toFixed(2))
                            }

                            if (part_list[p].amount_is_tax == "exclusive") {
                                var tax_on_amount = amount;
                                if (tax_rate.length > 0) {
                                    for (var r = 0; r < tax_rate.length; r++) {
                                        if (tax_rate[r].rate != tax_info.rate) {
                                            var t = tax_on_amount * (tax_rate[r].rate / 100);
                                            amount = amount + t; parseFloat
                                            tax.push({
                                                tax: tax_rate[r].tax,
                                                rate: tax_rate[r].rate,
                                                amount: parseFloat(t.toFixed(2))
                                            });
                                        }
                                        else {
                                            var t = tax_on_amount * (tax_rate[r].rate / 100);
                                            amount = amount + t;
                                            tax.push({
                                                tax: tax_info.tax, tax_rate: tax_info.rate,
                                                rate: tax_info.rate,
                                                amount: parseFloat(t.toFixed(2))
                                            });
                                        }
                                    }
                                }
                                total = total + amount;
                            }

                            if (part_list[p].amount_is_tax == "inclusive") {
                                var x = (100 + tax_info.rate) / 100;
                                var tax_on_amount = amount / x;
                                if (tax_rate.length > 0) {
                                    for (var r = 0; r < tax_rate.length; r++) {
                                        if (tax_rate[r].rate != tax_info.rate) {
                                            var t = tax_on_amount * (tax_rate[r].rate / 100);
                                            base = base - t;
                                            tax.push({
                                                tax: tax_rate[r].tax,
                                                rate: tax_rate[r].rate,
                                                amount: parseFloat(t.toFixed(2))
                                            });
                                        }
                                        else {
                                            var t = amount - tax_on_amount;
                                            base = base - t;
                                            tax.push({
                                                tax: tax_info.tax, tax_rate: tax_info.rate,
                                                rate: tax_info.rate,
                                                amount: parseFloat(t.toFixed(2))
                                            });
                                        }
                                    }
                                }

                                base = base - dep;
                                total = total + amount;
                            }

                            var tax_amount = total - parseFloat(base.toFixed(2));

                            var tax_details = {
                                tax: tax_info.tax,
                                tax_rate: tax_info.rate,
                                rate: tax_info.rate,
                                amount: total,
                                detail: tax
                            }

                            part.push({
                                item: part_list[p].item,
                                source: part_list[p].source,
                                hsn_sac: part_list[p].hsn_sac,
                                part_no: part_list[p].part_no,
                                rate: parseFloat(part_list[p].rate),
                                quantity: parseFloat(part_list[p].quantity),
                                base: parseFloat(base.toFixed(2)),
                                amount: total,
                                discount: part_list[p].discount,
                                issued: part_list[p].issued,
                                customer_dep: parseFloat(part_list[p].customer_dep),
                                insurance_dep: parseFloat(part_list[p].insurance_dep),
                                tax_amount: parseFloat(_.sumBy(tax, x => x.amount).toFixed(2)),
                                amount_is_tax: part_list[p].amount_is_tax,
                                tax: tax_info.tax,
                                tax_rate: tax_info.rate,
                                tax_info: tax_details
                            });
                        }
                    }

                    if (labour_list) {
                        for (var l = 0; l < labour_list.length; l++) {
                            var total = 0;
                            var tax_info = await Tax.findOne({ rate: labour_list[l].tax_rate, type: tax_type }).exec();
                            var tax = [];
                            var rate = labour_list[l].rate;
                            var amount = parseFloat(labour_list[l].rate) * parseFloat(labour_list[l].quantity);
                            var tax_rate = tax_info.detail;
                            var discount_total = 0;
                            var base = amount;
                            var dep = 0;

                            if (services[i].claim == true) {
                                if (parseFloat(labour_list[l].insurance_dep) <= 0 && parseFloat(labour_list[l].customer_dep) <= 0) {
                                    dep = 0
                                }
                                else {
                                    if (parseFloat(labour_list[l].customer_dep) <= 0 && parseFloat(labour_list[l].insurance_dep <= 100)) {
                                        dep = 100
                                    }
                                    else {
                                        dep = 100 - parseFloat(labour_list[l].customer_dep);
                                    }
                                }

                                amount = amount - (amount * dep / 100);
                                dep = base - amount;
                            }

                            if (labour_list[l].discount) {
                                discount_total = labour_list[l].discount;
                                amount = amount - parseFloat(discount_total.toFixed(2))
                            }


                            if (labour_list[l].amount_is_tax == "exclusive") {
                                var tax_on_amount = amount;
                                if (tax_rate.length > 0) {
                                    for (var r = 0; r < tax_rate.length; r++) {
                                        if (tax_rate[r].rate != tax_info.rate) {
                                            var t = tax_on_amount * (tax_rate[r].rate / 100);
                                            amount = amount + t; parseFloat
                                            tax.push({
                                                tax: tax_rate[r].tax,
                                                rate: tax_rate[r].rate,
                                                amount: parseFloat(t.toFixed(2))
                                            });
                                        }
                                        else {
                                            var t = tax_on_amount * (tax_rate[r].rate / 100);
                                            amount = amount + t;
                                            tax.push({
                                                tax: tax_info.tax, tax_rate: tax_info.rate,
                                                rate: tax_info.rate,
                                                amount: parseFloat(t.toFixed(2))
                                            });
                                        }
                                    }
                                }
                                //total = total+amount;
                            }

                            if (labour_list[l].amount_is_tax == "inclusive") {
                                var x = (100 + tax_info.rate) / 100;
                                var tax_on_amount = amount / x;
                                if (tax_rate.length > 0) {
                                    for (var r = 0; r < tax_rate.length; r++) {
                                        if (tax_rate[r].rate != tax_info.rate) {
                                            var t = tax_on_amount * (tax_rate[r].rate / 100);
                                            base = base - t;
                                            tax.push({
                                                tax: tax_rate[r].tax,
                                                rate: tax_rate[r].rate,
                                                amount: parseFloat(t.toFixed(2))
                                            });
                                        }
                                        else {
                                            var t = amount - tax_on_amount;
                                            base = base - t;
                                            tax.push({
                                                tax: tax_info.tax,
                                                tax_rate: tax_info.rate,
                                                rate: tax_info.rate,
                                                amount: parseFloat(t.toFixed(2))
                                            });
                                        }
                                    }
                                }

                                base = base - dep;

                                total = total + amount;
                            }

                            var tax_amount = total - parseFloat(base.toFixed(2));

                            var tax_details = {
                                tax: tax_info.tax,
                                rate: tax_info.rate,
                                amount: total,
                                detail: tax
                            };

                            labours.push({
                                item: labour_list[l].item,
                                source: labour_list[l].source,
                                rate: parseFloat(labour_list[l].rate),
                                quantity: parseFloat(labour_list[l].quantity),
                                base: parseFloat(base.toFixed(2)),
                                amount: amount,
                                discount: labour_list[l].discount,
                                customer_dep: parseFloat(labour_list[l].customer_dep),
                                insurance_dep: parseFloat(labour_list[l].insurance_dep),
                                tax_amount: parseFloat(_.sumBy(tax, x => x.amount).toFixed(2)),
                                amount_is_tax: labour_list[l].amount_is_tax,
                                tax: tax_info.tax,
                                tax_rate: tax_info.rate,
                                tax_info: tax_details
                            });
                        }
                    }

                    if (of_list) {
                        for (var o = 0; o < of_list.length; o++) {
                            var total = 0;
                            var tax_info = await Tax.findOne({ rate: of_list[o].tax_rate, type: tax_type }).exec();
                            var tax = [];
                            var rate = of_list[o].rate;
                            var amount = (parseFloat(of_list[o].rate) * parseFloat(of_list[o].quantity));
                            var tax_rate = tax_info.detail;
                            var discount_total = 0;
                            var base = amount;
                            var dep = 0;


                            if (services[i].claim == true) {
                                if (parseFloat(of_list[o].insurance_dep) <= 0 && parseFloat(of_list[o].customer_dep) <= 0) {
                                    dep = 0
                                }
                                else {
                                    if (parseFloat(of_list[o].customer_dep) <= 0 && parseFloat(of_list[o].insurance_dep <= 100)) {
                                        dep = 100
                                    }
                                    else {
                                        dep = 100 - parseFloat(of_list[o].customer_dep);
                                    }
                                }

                                amount = amount - (amount * dep / 100);
                                dep = base - amount;
                            }

                            if (of_list[o].discount) {
                                var discount_total = of_list[o].discount;
                                amount = amount - parseFloat(discount_total.toFixed(2))
                            }



                            if (of_list[o].amount_is_tax == "exclusive") {
                                var tax_on_amount = amount;
                                if (tax_rate.length > 0) {
                                    for (var r = 0; r < tax_rate.length; r++) {
                                        if (tax_rate[r].rate != tax_info.rate) {
                                            var t = tax_on_amount * (tax_rate[r].rate / 100);
                                            amount = amount + t; parseFloat
                                            tax.push({
                                                tax: tax_rate[r].tax,
                                                rate: tax_rate[r].rate,
                                                amount: parseFloat(t.toFixed(2))
                                            });
                                        }
                                        else {
                                            var t = tax_on_amount * (tax_rate[r].rate / 100);
                                            amount = amount + t;
                                            tax.push({
                                                tax: tax_info.tax, tax_rate: tax_info.rate,
                                                rate: tax_info.rate,
                                                amount: parseFloat(t.toFixed(2))
                                            });
                                        }
                                    }
                                }
                                total = total + amount;
                            }

                            if (of_list[o].amount_is_tax == "inclusive") {
                                var x = (100 + tax_info.rate) / 100;
                                var tax_on_amount = amount / x;
                                if (tax_rate.length > 0) {
                                    for (var r = 0; r < tax_rate.length; r++) {
                                        if (tax_rate[r].rate != tax_info.rate) {
                                            var t = tax_on_amount * (tax_rate[r].rate / 100);
                                            base = base - t;
                                            tax.push({
                                                tax: tax_rate[r].tax,
                                                rate: tax_rate[r].rate,
                                                amount: parseFloat(t.toFixed(2))
                                            });
                                        }
                                        else {
                                            var t = amount - tax_on_amount;
                                            base = base - t;
                                            tax.push({
                                                tax: tax_info.tax, tax_rate: tax_info.rate,
                                                rate: tax_info.rate,
                                                amount: parseFloat(t.toFixed(2))
                                            });
                                        }
                                    }
                                }

                                base = base - dep;
                                total = total + amount;
                            }

                            var tax_details = {
                                tax: tax_info.tax,
                                rate: tax_info.rate,
                                amount: total,
                                detail: tax
                            }

                            var tax_amount = total - parseFloat(base.toFixed(2));

                            opening_fitting.push({
                                item: of_list[o].item,
                                source: of_list[o].source,
                                rate: parseFloat(of_list[o].rate),
                                quantity: parseFloat(of_list[o].quantity),
                                base: parseFloat(base.toFixed(2)),
                                amount: total,
                                discount: parseFloat(of_list[o].discount),
                                customer_dep: parseFloat(of_list[o].customer_dep),
                                insurance_dep: parseFloat(of_list[o].insurance_dep),
                                tax_amount: parseFloat(_.sumBy(tax, x => x.amount).toFixed(2)),
                                amount_is_tax: of_list[o].amount_is_tax,
                                tax: tax_info.tax, tax_rate: tax_info.rate,
                                tax_info: tax_details
                            });
                        }
                    }

                    var parts_visible = true;

                    bookingService.push({
                        source: services[i].source,
                        service: services[i].service,
                        mileage: services[i].mileage,
                        parts: part,
                        labour: labours,
                        opening_fitting: opening_fitting,
                        hours: services[i].hours,
                        parts_visible: parts_visible,
                        quantity: services[i].quantity,
                        discount: _.sumBy(labours, x => x.discount) + _.sumBy(part, x => x.discount) + _.sumBy(opening_fitting, x => x.discount),
                        description: services[i].description,
                        cost: _.sumBy(part, x => x.amount) + _.sumBy(labours, x => x.amount) + services[i].of_cost,
                        labour_cost: _.sumBy(labours, x => x.amount),
                        of_cost: _.sumBy(opening_fitting, x => x.amount),
                        part_cost: _.sumBy(part, x => x.amount),
                        exceeded_cost: parseFloat(services[i].exceeded_cost),
                        part_cost_editable: services[i].part_cost_editable,
                        labour_cost_editable: services[i].labour_cost_editable,
                        of_cost_editable: services[i].of_cost_editable,
                        type: services[i].type,
                        customer_approval: services[i].customer_approval,
                        surveyor_approval: services[i].surveyor_approval,
                        claim: services[i].claim,
                        custom: services[i].custom,
                    });
                }
            }

            var approved = invoice.services;

            var paid_total = invoice.payment.paid_total;
            var labour_cost = _.sumBy(approved, x => x.labour_cost);
            var part_cost = _.sumBy(approved, x => x.part_cost);
            var of_cost = _.sumBy(approved, x => x.of_cost);
            var discount_total = _.sumBy(approved, x => x.discount);

            var pick_up_charges = invoice.payment.pick_up_charges;
            var policy_clause = invoice.payment.policy_clause;
            var salvage = invoice.payment.salvage;

            var careager_cash = invoice.payment.careager_cash;

            var payment_total = labour_cost + part_cost + of_cost + discount_total + policy_clause + salvage + pick_up_charges;

            var estimate_cost = labour_cost + part_cost + of_cost + policy_clause + salvage + pick_up_charges;

            var due_amount = _.sumBy(approved, x => x.labour_cost) + _.sumBy(approved, x => x.part_cost) + _.sumBy(approved, x => x.of_cost) + policy_clause + salvage + pick_up_charges - (paid_total + careager_cash);

            var due = {
                due: Math.ceil(due_amount.toFixed(2))
            }

            var payment = {
                estimate_cost: estimate_cost,
                total: payment_total,
                careager_cash: careager_cash,
                of_cost: of_cost,
                labour_cost: labour_cost,
                part_cost: part_cost,
                payment_mode: invoice.payment.payment_mode,
                payment_status: invoice.payment.payment_status,
                coupon: invoice.payment.coupon,
                coupon_type: invoice.payment.coupon_type,
                discount_by: invoice.payment.discount_by,
                discount_type: invoice.payment.discount_type,
                discount: invoice.payment.discount,
                discount_total: discount_total,
                policy_clause: policy_clause,
                salvage: salvage,
                terms: invoice.payment.terms,
                pick_up_limit: invoice.payment.pick_up_limit,
                pick_up_charges: pick_up_charges,
                paid_total: parseFloat(invoice.payment.paid_total),
                discount_applied: invoice.payment.discount_applied,
                transaction_id: invoice.payment.transaction_id,
                transaction_date: invoice.payment.transaction_date,
                transaction_status: invoice.payment.transaction_status,
                transaction_response: invoice.payment.transaction_response
            };



            var show = {
                _id: invoice._id,
                id: invoice._id,
                car: invoice.car,
                user: invoice.user,
                business: invoice.business,
                advisor: invoice.advisor,
                services: bookingService,
                status: _.startCase(invoice.status),
                invoice_no: invoice.invoice_no,
                job_no: invoice.job_no,
                booking: invoice.booking,
                booking_no: invoice.booking_no,
                address: invoice.address,
                payment: payment,
                due: invoice.due,
                odometer: invoice.odometer,
                insurance_info: invoice.insurance_info,
                invoice_type: invoice.invoice_type,
                with_tax: invoice.with_tax,
                note: invoice.note,
                started_at: moment(invoice.started_at).tz(req.headers['tz']).format('lll'),
                delivery_date: moment(invoice.delivery_date).tz(req.headers['tz']).format('ll'),
                delivery_time: invoice.delivery_time,
                started_at: moment(invoice.started_at).tz(req.headers['tz']).format('lll'),
                created_at: moment(invoice.created_at).tz(req.headers['tz']).format('lll'),
                updated_at: moment(invoice.updated_at).tz(req.headers['tz']).format('lll'),
            };

            res.status(200).json({
                responseCode: 200,
                responseMessage: 'Success',
                responseData: show,
            });


        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Unauthorized",
                responseData: {}
            });
        }
    }
});

router.get('/my/booking/invoice/get', xAccessToken.token, async function (req, res, next) {
    var rules = {
        invoice: 'required',
    };
    var validation = new Validator(req.query, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Invoice is required",
            responseData: {
                res: validation.errors.all()
            }
        });
    }
    else {
        var token = req.headers['x-access-token'];
        var business = req.headers['business'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var user = decoded.user;
        var data = new Object();
        var discount = 0;
        var code = "";
        var discount_type = "";


        var invoice = await Invoice.findOne({ booking: req.query.invoice })
            .populate({ path: 'advisor', populate: { path: 'user', select: "_id id name contact_no email" } })
            .populate({ path: 'user', populate: { path: 'user', select: "_id id name contact_no email business_info" } })
            .populate({ path: 'business', populate: { path: 'user', select: "_id id name contact_no email business_info" } })
            .populate({ path: 'car', select: '_id id title registration_no ic rc vin engine_no insurance_info' })
            .exec();

        if (invoice) {
            var car = null;
            var advisor = null;
            var customer_requirements = [];
            var address = null;
            var recording = ""
            if (invoice.car) {
                car = {
                    title: invoice.car.title,
                    _id: invoice.car._id,
                    id: invoice.car.id,
                    vin: invoice.car.vin,
                    engine_no: invoice.car.engine_no,
                    registration_no: invoice.car.registration_no,
                    ic_address: invoice.car.ic_address,
                    rc_address: invoice.car.rc_address,
                }
            }



            if (invoice.advisor) {
                var email = "";
                if (invoice.advisor.email) {
                    email = invoice.advisor.email;
                }
                advisor = {
                    name: invoice.advisor.name,
                    _id: invoice.advisor._id,
                    id: invoice.advisor.id,
                    contact_no: invoice.advisor.contact_no,
                    email: email,
                }
            }

            if (invoice.customer_requirements) {
                customer_requirements = invoice.customer_requirements;
            }

            if (invoice.address) {
                var address = await Address.findOne({ _id: invoice.address }).exec();
            }

            var show = {
                _id: invoice._id,
                id: invoice._id,
                car: car,
                user: {
                    name: invoice.user.name,
                    _id: invoice.user._id,
                    id: invoice.user.id,
                    contact_no: invoice.user.contact_no,
                    email: invoice.user.email,
                    business_info: invoice.user.business_info
                },
                business: {
                    name: invoice.business.name,
                    _id: invoice.business._id,
                    id: invoice.business.id,
                    contact_no: invoice.business.contact_no,
                    email: invoice.business.email,
                    business_info: invoice.business.business_info
                },
                advisor: advisor,
                services: invoice.services,
                status: _.startCase(invoice.status),
                invoice_no: invoice.invoice_no,
                job_no: invoice.job_no,
                booking: invoice.booking,
                booking_no: invoice.booking_no,
                address: address,
                payment: invoice.payment,
                due: invoice.due,
                odometer: invoice.odometer,
                started_at: moment(invoice.started_at).tz(req.headers['tz']).format('lll'),
                delivery_date: moment(invoice.delivery_date).tz(req.headers['tz']).format('ll'),
                delivery_time: invoice.delivery_time,
                started_at: moment(invoice.started_at).tz(req.headers['tz']).format('lll'),
                created_at: moment(invoice.created_at).tz(req.headers['tz']).format('lll'),
                updated_at: moment(invoice.updated_at).tz(req.headers['tz']).format('lll'),
            };

            res.status(200).json({
                responseCode: 200,
                responseMessage: 'Success',
                responseData: show,
            });
        }

        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Unauthorized",
                responseData: {}
            });
        }
    }
});

router.get('/search/all', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers['business'];
    var bookings = [];
    var totalResult = 0;

    if (req.query.page == undefined) {
        var page = 0;
    }
    else {
        var page = req.query.page;
    }

    var page = Math.max(0, parseInt(page));
    var result = [];
    var data = {};
    var query = req.query.query;
    var type = req.query.type;

    if (query) {
        if (type == "user") {
            var users = [];
            await User.find({ "account_info.status": "Active" })
                .or([
                    { $or: [{ name: new RegExp(query, "i") }] },
                    { $or: [{ contact_no: new RegExp(query, "i") }] },
                ])
                .cursor()
                .eachAsync(async (user) => {
                    var b = await Booking.find({ business: business, user: user._id }).count();
                    var l = await Lead.find({ business: business, user: user._id }).count();
                    var o = await BusinessOrder.find({ business: business, user: user._id }).count();
                    if (b > 0 || l > 0 || o > 0) {
                        result.push({
                            name: user.name,
                            email: user.email,
                            contact_no: user.contact_no,
                            _id: user._id,
                            id: user._id,
                            type: "user"
                        });
                    }
                })

            data = {
                user: result
            }
        }

        else if (type == "booking") {
            var customer = await User.findOne({ contact_no: query }).exec();
            if (customer) {
                var search = {};
                search["user"] = mongoose.Types.ObjectId(customer._id)
                bookings.push(search);
            }

            var car = await Car.findOne({ reg_no_copy: query.replace(/\s/g, '') }).exec();
            if (car) {
                var search = {};
                search["car"] = mongoose.Types.ObjectId(car._id)
                bookings.push(search)
            }

            var search = {};
            if (!parseInt(query)) {
                query = 0;
            }

            search["booking_no"] = parseInt(query);
            bookings.push(search);

            var thumbnail = [];

            await Booking.find({
                business: business,
                status: {
                    $in: ["Pending", "Confirmed", "EstimateRequested", "Approved", "Approval", "Completed"]
                },
                $or: bookings
            })
                .populate({ path: 'user', populate: { path: 'user', select: "_id id name contact_no" } })
                .populate({ path: 'manager', populate: { path: 'user', select: "_id id name contact_no" } })
                .populate({ path: 'car', select: '_id id title registration_no ic rc', populate: { path: 'thumbnails' } })
                .cursor().eachAsync(async (booking) => {
                    var address = await Address.findOne({ _id: booking.address }).exec();
                    if (booking.car) {
                        if (booking.car.thumbnails[0]) {
                            var thumbnail = [booking.car.thumbnails[0]];
                        }
                        else {
                            var thumbnail = []
                        }

                        var car = {
                            title: booking.car.title,
                            _id: booking.car._id,
                            id: booking.car.id,
                            rc_address: booking.car.rc_address,
                            ic_address: booking.car.ic_address,
                            ic: booking.car.ic,
                            rc: booking.car.rc,
                            registration_no: booking.car.registration_no,
                        }
                    }
                    else {
                        var car = null
                    }

                    var manager = null;
                    if (booking.manager) {
                        manager = {
                            name: booking.manager.name,
                            _id: booking.manager._id,
                            id: booking.manager.id,
                            contact_no: booking.manager.contact_no,
                            email: booking.manager.email
                        }
                    }

                    result.push({
                        _id: booking._id,
                        id: booking._id,
                        car: car,
                        user: {
                            name: booking.user.name,
                            _id: booking.user._id,
                            id: booking.user.id,
                            contact_no: booking.user.contact_no
                        },
                        manager: manager,
                        services: booking.services,
                        convenience: booking.convenience,
                        date: moment(booking.date).tz(req.headers['tz']).format('ll'),
                        time_slot: booking.time_slot,
                        status: booking.status,
                        booking_no: booking.booking_no,
                        address: address,
                        payment: booking.payment,
                        customer_requirements: booking.customer_requirements,
                        estimation_requested: booking.estimation_requested,
                        txnid: booking.txnid,
                        __v: booking.__v,
                        updated_at: booking.updated_at,
                        updated_at: booking.updated_at,
                        type: "Booking"
                    });
                });

            data = {
                booking: result
            }
        }

        else if (type == "order") {
            var customer = await User.findOne({ contact_no: query }).exec();
            if (customer) {
                var search = {};
                search["user"] = mongoose.Types.ObjectId(customer._id)
                bookings.push(search);
            }

            var search = {};
            search["order_no"] = query;
            bookings.push(search);

            // cconsole.logngs)

            await OrderLine.aggregate([
                {
                    "$match": {
                        "business": { $eq: mongoose.Types.ObjectId(business) },
                        "$or": bookings
                    }
                },
                { "$unwind": "$user" },
                {
                    "$lookup": {
                        "from": "User",
                        "localField": "user",
                        "foreignField": "_id",
                        "as": "user"
                    }
                },
                { "$unwind": "$order" },
                {
                    "$lookup": {
                        "from": "Order",
                        "localField": "order",
                        "foreignField": "_id",
                        "as": "order"
                    }
                },
                { "$unwind": "$product" },
                {
                    "$lookup": {
                        "from": "BusinessProduct",
                        "localField": "product",
                        "foreignField": "_id",
                        "as": "product"
                    }
                },
                { $group: { _id: '$order._id', data: { $push: '$$ROOT' } } },
                { $skip: config.perPage * page },
                { $limit: config.perPage }
            ])
                .allowDiskUse(true)
                .cursor({ batchSize: 10 })
                .exec()
                .eachAsync(async function (doc) {
                    var data = doc.data;
                    var stock = true;
                    data.forEach(async function (d) {
                        if (d.product[0].stock.available <= 0) {
                            stock = false
                        }
                    })

                    var address = await Address.findById(doc.data[0].order[0].address).exec();
                    var time_left = moment(doc.data[0].date).endOf('day').fromNow();

                    if (time_left.includes("ago")) {
                        time_left = time_left;
                    }
                    else {
                        time_left = time_left.replace("in ", "") + " left";
                    }

                    result.push({
                        _id: doc.data[0].order[0]._id,
                        id: doc.data[0].order[0]._id,
                        order_no: doc.data[0].order[0].order_no,
                        name: doc.data[0].user[0].name,
                        contact_no: doc.data[0].user[0].contact_no,
                        stock: stock,
                        address: address,
                        convenience: doc.data[0].convenience,
                        time_left: time_left,
                        status: doc.data[0].order[0].status,
                        created_at: moment(doc.data[0].order[0].created_at).tz(req.headers['tz']).format('lll'),
                        delivered_by: moment(doc.data[0].date).tz(req.headers['tz']).format('ll'),
                        time_slot: doc.data[0].time_slot,
                    });
                });

            data = {
                order: result
            }
        }

        else if (type == "lead") {
            await Lead.find({ "remark.status": { $in: ["Open", "Follow-Up", "PSF"] } })
                .or([
                    { $or: [{ lead_id: new RegExp(query, "i") }] },
                    { $or: [{ name: new RegExp(query, "i") }] },
                    { $or: [{ contact_no: new RegExp(query, "i") }] },
                ])
                .populate({ path: 'assignee', select: 'id name contact_no email' })
                .sort({ updated_at: -1 }).skip(config.perPage * page).limit(config.perPage)
                .cursor().eachAsync(async (lead) => {
                    if (lead) {
                        var remark = await LeadRemark.findOne({ lead: lead._id }).sort({ created_at: -1 }).exec();
                        result.push({
                            user: lead.user,
                            name: lead.name,
                            contact_no: lead.contact_no,
                            email: lead.email,
                            _id: lead._id,
                            id: lead.id,
                            type: lead.type,
                            date: moment(lead.updated_at).tz(req.headers['tz']).format('lll'),
                            status: lead.status,
                            important: lead.important,
                            follow_up: lead.follow_up,
                            remark: lead.remark,
                            assignee: lead.assignee,
                            created_at: moment(lead.created_at).tz(req.headers['tz']).format('lll'),
                            updated_at: moment(lead.updated_at).tz(req.headers['tz']).format('lll'),
                        });
                    }
                });

            data = {
                lead: result
            }
        }
        res.status(200).json({
            responseCode: 200,
            responseMessage: "",
            responseData: data
        })
    }
    else {
        res.status(200).json({
            responseCode: 200,
            responseMessage: "",
            responseData: data
        })
    }
});

router.get('/postal/get', xAccessToken.token, async function (req, res, next) {
    var rules = {
        zip: 'required'
    };

    var validation = new Validator(req.query, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Error",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var user = decoded.user;
        var data = {};

        request.get({ url: 'http://postalpincode.in/api/pincode/' + req.query.zip }, function (err, httpResponse, body) {
            if (!err) {
                var resBody = JSON.parse(body);

                if (resBody) {
                    var po = resBody.PostOffice;
                    if (po != null) {
                        data = {
                            city: resBody.PostOffice[0].Division,
                            state: resBody.PostOffice[0].State,
                        }
                    }
                }

                res.status(200).json({
                    responseCode: 200,
                    responseMessage: "",
                    responseData: data
                })
            }
        });
    }
});

router.get('/postals/get', async function (req, res, next) {
    var rules = {
        zip: 'required'
    };

    var validation = new Validator(req.query, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Error",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        console.time('looper')
        /*var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var user = decoded.user;*/
        var data = [];

        await Location.find({ zip: req.query.zip })
            .cursor()
            .eachAsync(async function (o) {
                data.push({
                    _id: o._id,
                    id: o._id,
                    zip: o.zip,
                    city: o.city,
                    region: o.region,
                    state: o.state,
                    latitude: o.latitude,
                    longitude: o.longitude,
                    country: o.country,
                })
            });

        console.timeEnd('looper')

        res.status(200).json({
            responseCode: 200,
            responseMessage: "",
            responseData: data
        })
    }
});

router.post('/address/add', xAccessToken.token, async function (req, res, next) {
    var rules = {
        user: 'required',
        address: 'required',
        zip: 'required',
        city: 'required',
        state: 'required'
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Error",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var user = await User.findById(req.body.user);
        if (user) {
            var data = {
                user: user._id,
                address: req.body.address,
                area: req.body.area,
                landmark: req.body.landmark,
                zip: req.body.zip,
                city: req.body.city,
                state: req.body.state,
                created_at: new Date(),
                updated_at: new Date()
            };

            Address.create(data).then(async function (address) {
                res.status(200).json({
                    responseCode: 200,
                    responseMessage: "Address Updated",
                    responseData: address
                })
            });
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "User not found",
                responseData: {}
            });
        }
    }
});

router.get('/address/get', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = await User.findById(req.query.user);
    if (user) {
        res.status(200).json({
            responseCode: 200,
            responseMessage: "Address",
            responseData: await Address.find({ user: user._id }).exec()
        })
    }
    else {
        res.status(400).json({
            responseCode: 400,
            responseMessage: "User not found",
            responseData: {}
        })
    }
});

router.get('/parts/get/', xAccessToken.token, async function (req, res, next) {
    var rules = {
        query: 'required',
        quantity: 'required',
    };

    var validation = new Validator(req.query, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Part/Part No & quantity required",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        if (parseFloat(req.query.quantity) > 0) {
            var business = req.headers['business'];
            var token = req.headers['x-access-token'];
            var secret = config.secret;
            var decoded = jwt.verify(token, secret);
            var data = [];
            await BusinessProduct.find({ business: business/*,"stock.available":{$gt: 0},list_type: {$in: ["Offline"]}*/, $or: [{ part_no: new RegExp(req.query.query, "i") }, { title: new RegExp(req.query.query, "i") },/*{models: {$in:new RegExp(req.query.query, "i")}}*/] })
                .cursor().eachAsync(async (p) => {
                    var quantity = parseFloat(req.query.quantity);
                    if (p.stock.available >= quantity) {
                        var rate = p.price.sell_price;
                        var base = p.price.sell_price * quantity;
                        var amount = p.price.sell_price * quantity;

                        var tax_info = await Tax.findOne({ tax: p.tax_info.tax }).exec();
                        var tax_rate = tax_info.detail;
                        var tax = [];

                        var x = (100 + p.tax_info.rate) / 100;
                        var tax_on_amount = amount / x;
                        if (tax_rate.length > 0) {
                            for (var r = 0; r < tax_rate.length; r++) {
                                if (tax_rate[r].rate != tax_info.rate) {
                                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                                    base = base - t
                                    tax.push({
                                        tax: tax_rate[r].tax,
                                        rate: tax_rate[r].rate,
                                        amount: parseFloat(t.toFixed(2))
                                    });
                                }
                                else {
                                    var t = amount - tax_on_amount;
                                    base = base - t
                                    tax.push({
                                        tax: tax_info.tax,
                                        rate: tax_info.rate,
                                        amount: parseFloat(t.toFixed(2))
                                    });
                                }
                            }
                        }

                        var tax_details = {
                            tax: tax_info.tax,
                            rate: tax_info.rate,
                            amount: p.price.sell_price,
                            detail: tax
                        }

                        data.push({
                            _id: mongoose.Types.ObjectId(),
                            item: p.title,
                            sku: p.sku,
                            part_no: p.part_no,
                            hsn_sac: p.hsn_sac,
                            source: p._id,
                            unit: p.unit,
                            issued: false,
                            quantity: parseFloat(quantity.toFixed(2)),
                            mrp: parseFloat(rate.toFixed(2)),
                            selling_price: parseFloat(rate.toFixed(2)),
                            rate: parseFloat(rate.toFixed(2)),
                            base: parseFloat(base.toFixed(2)),
                            amount: parseFloat(amount.toFixed(2)),
                            discount: 0,
                            amount_is_tax: p.amount_is_tax,
                            tax_amount: parseFloat(_.sumBy(tax, x => x.amount).toFixed(2)),
                            tax: p.tax_info.tax,
                            tax_rate: p.tax_info.rate,
                            tax_info: tax_details,
                            out_of_stock: false,
                            stock_available: parseFloat(p.stock.available.toFixed(2)),
                            business: p.business,
                            customer_dep: 100,
                            insurance_dep: 0,
                        });
                    }
                    else if (p.stock.available < quantity && p.stock.available > 0) {
                        quantity = p.stock.available;
                        var rate = p.price.sell_price;
                        var base = p.price.sell_price * quantity;
                        var amount = p.price.sell_price * quantity;

                        var tax_info = await Tax.findOne({ tax: p.tax_info.tax }).exec();
                        var tax_rate = tax_info.detail;
                        var tax = [];

                        var x = (100 + p.tax_info.rate) / 100;
                        var tax_on_amount = amount / x;
                        if (tax_rate.length > 0) {
                            for (var r = 0; r < tax_rate.length; r++) {
                                if (tax_rate[r].rate != tax_info.rate) {
                                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                                    base = base - t
                                    tax.push({
                                        tax: tax_rate[r].tax,
                                        rate: tax_rate[r].rate,
                                        amount: parseFloat(t.toFixed(2))
                                    });
                                }
                                else {
                                    var t = amount - tax_on_amount;
                                    base = base - t
                                    tax.push({
                                        tax: tax_info.tax,
                                        rate: tax_info.rate,
                                        amount: parseFloat(t.toFixed(2))
                                    });
                                }
                            }
                        }

                        var tax_details = {
                            tax: tax_info.tax,
                            rate: tax_info.rate,
                            amount: p.price.sell_price,
                            detail: tax
                        }

                        data.push({
                            _id: mongoose.Types.ObjectId(),
                            sku: p.sku,
                            item: p.title,
                            part_no: p.part_no,
                            hsn_sac: p.hsn_sac,
                            source: p._id,
                            quantity: parseFloat(quantity.toFixed(2)),
                            mrp: parseFloat(rate.toFixed(2)),
                            selling_price: parseFloat(rate.toFixed(2)),
                            rate: parseFloat(rate.toFixed(2)),
                            base: parseFloat(base.toFixed(2)),
                            amount: parseFloat(amount.toFixed(2)),
                            issued: false,
                            discount: 0,
                            unit: p.unit,
                            amount_is_tax: p.amount_is_tax,
                            tax_amount: parseFloat(_.sumBy(tax, x => x.amount).toFixed(2)),
                            tax: p.tax_info.tax,
                            tax_rate: p.tax_info.rate,
                            tax_info: tax_details,
                            out_of_stock: false,
                            stock_available: parseFloat(p.stock.available.toFixed(2)),
                            business: p.business,
                            customer_dep: 100,
                            insurance_dep: 0,
                        });
                    }
                    else if (p.stock.available <= 0) {
                        var rate = p.price.sell_price;
                        var base = p.price.sell_price * quantity;
                        var amount = p.price.sell_price * quantity;

                        var tax_info = await Tax.findOne({ tax: p.tax_info.tax }).exec();
                        var tax_rate = tax_info.detail;
                        var tax = [];

                        var x = (100 + p.tax_info.rate) / 100;
                        var tax_on_amount = amount / x;
                        if (tax_rate.length > 0) {
                            for (var r = 0; r < tax_rate.length; r++) {
                                if (tax_rate[r].rate != tax_info.rate) {
                                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                                    base = base - t
                                    tax.push({
                                        tax: tax_rate[r].tax,
                                        rate: tax_rate[r].rate,
                                        amount: parseFloat(t.toFixed(2))
                                    });
                                }
                                else {
                                    var t = amount - tax_on_amount;
                                    //base = base - discount_total
                                    tax.push({
                                        tax: tax_info.tax,
                                        rate: tax_info.rate,
                                        amount: parseFloat(t.toFixed(2))
                                    });
                                }
                            }
                        }

                        var tax_details = {
                            tax: tax_info.tax,
                            rate: tax_info.rate,
                            amount: p.price.sell_price,
                            detail: tax
                        }

                        data.push({
                            _id: mongoose.Types.ObjectId(),
                            sku: p.sku,
                            item: p.title,
                            part_no: p.part_no,
                            hsn_sac: p.hsn_sac,
                            source: p._id,
                            quantity: parseFloat(quantity.toFixed(2)),
                            mrp: parseFloat(rate.toFixed(2)),
                            selling_price: parseFloat(rate.toFixed(2)),
                            rate: parseFloat(rate.toFixed(2)),
                            base: parseFloat(base.toFixed(2)),
                            amount: parseFloat(amount.toFixed(2)),
                            discount: 0,
                            issued: false,
                            unit: p.unit,
                            tax_amount: parseFloat(_.sumBy(tax, x => x.amount).toFixed(2)),
                            amount_is_tax: p.amount_is_tax,
                            tax: p.tax_info.tax,
                            tax_rate: p.tax_info.rate,
                            tax_info: tax_details,
                            out_of_stock: true,
                            stock_available: 0,
                            business: p.business,
                            customer_dep: 100,
                            insurance_dep: 0,
                        });
                    }
                });

            res.status(200).json({
                responseCode: 200,
                responseMessage: "",
                responseData: data
            })
        }
        else {
            res.status(422).json({
                responseCode: 422,
                responseMessage: "Part/Part No & quantity required",
                responseData: {}
            })
        }
    }
});

router.post('/job/parts/add/', xAccessToken.token, async function (req, res, next) {
    var business = req.headers['business'];
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var data = [];
    var loggedInDetails = await User.findById(decoded.user).exec();
    var booking = await Booking.findById(req.body.booking).exec();
    if (booking) {
        var updated_parts = [];
        var exceeded_cost = 0;
        var services = req.body.service;
        var bookingService = {};
        if (services) {
            var service_part = services.parts;
            if (service_part.length > 0) {
                for (var p = 0; p < service_part.length; p++) {
                    parts_visible = false;
                    var tax_info = await Tax.findOne({ tax: service_part[p].tax }).exec();
                    var quantity = service_part[p].quantity;
                    var tax_rate = tax_info.detail;
                    var amount = service_part[p].amount;
                    var discount_total = 0;
                    var base = amount;
                    var part_tax = [];


                    if (service_part[p].discount) {
                        discount_total = service_part[p].discount;
                        amount = amount - parseFloat(discount_total.toFixed(2))
                    }

                    if (service_part[p].amount_is_tax == "exclusive") {
                        var tax_on_amount = amount;
                        if (tax_rate.length > 0) {
                            for (var r = 0; r < tax_rate.length; r++) {
                                if (tax_rate[r].rate != tax_info.rate) {
                                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                                    amount = amount + t; parseFloat
                                    part_tax.push({
                                        tax: tax_rate[r].tax,
                                        rate: tax_rate[r].rate,
                                        amount: parseFloat(t.toFixed(2))
                                    });
                                }
                                else {
                                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                                    amount = amount + t;
                                    part_tax.push({
                                        tax: tax_info.tax, tax_rate: tax_info.rate,
                                        rate: tax_info.rate,
                                        amount: parseFloat(t.toFixed(2))
                                    });
                                }
                            }
                        }
                    }

                    if (service_part[p].amount_is_tax == "inclusive") {
                        var x = (100 + tax_info.rate) / 100;
                        var tax_on_amount = amount / x;
                        if (tax_rate.length > 0) {
                            for (var r = 0; r < tax_rate.length; r++) {
                                if (tax_rate[r].rate != tax_info.rate) {
                                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                                    base = base - t;
                                    part_tax.push({
                                        tax: tax_rate[r].tax,
                                        rate: tax_rate[r].rate,
                                        amount: parseFloat(t.toFixed(2))
                                    });
                                }
                                else {
                                    var t = amount - tax_on_amount;
                                    base = base - t;
                                    part_tax.push({
                                        tax: tax_info.tax, tax_rate: tax_info.rate,
                                        rate: tax_info.rate,
                                        amount: parseFloat(t.toFixed(2))
                                    });
                                }
                            }
                        }

                        //base = base - discount_total; 
                    }

                    var tax_detail = {
                        tax: tax_info.tax,
                        tax_rate: tax_info.rate,
                        rate: tax_info.rate,
                        base: parseFloat(base.toFixed(2)),
                        detail: part_tax
                    }



                    updated_parts.push({
                        _id: service_part[p]._id,
                        item: service_part[p].item,
                        source: service_part[p].source,
                        quantity: service_part[p].quantity,
                        hsn_sac: service_part[p].hsn_sac,
                        part_no: service_part[p].part_no,
                        rate: parseFloat(service_part[p].rate),
                        base: parseFloat(base.toFixed(2)),
                        amount: parseFloat(amount),
                        customer_dep: parseFloat(service_part[p].customer_dep),
                        insurance_dep: parseFloat(service_part[p].insurance_dep),
                        tax_amount: _.sumBy(part_tax, x => x.amount),
                        amount_is_tax: service_part[p].amount_is_tax,
                        discount: service_part[p].discount,
                        tax: tax_info.tax,
                        tax_rate: tax_info.rate,
                        issued: service_part[p].issued,
                        tax_info: tax_detail
                    });
                }
            }



            var issue_part_cost = _.sumBy(updated_parts, x => x.amount);
            var issue_labour_cost = _.sumBy(services.labour, x => x.amount);
            if (services.source != null) {
                bookingService = {
                    source: services.source,
                    part_cost: issue_part_cost,
                    labour_cost: services.labour_cost,
                    exceeded_cost: exceeded_cost,
                    of_cost: services.of_cost,
                    part_rate: services.part_rate,
                    cost: issue_part_cost + services.labour_cost + services.of_cost,
                    labour_rate: services.labour_rate,
                    quantity: services.quantity,
                    of_rate: services.of_rate,
                    parts: updated_parts,
                    labour: services.labour,
                    discount: _.sumBy(services.labour, x => x.discount) + _.sumBy(updated_parts, x => x.discount) + _.sumBy(services.opening_fitting, x => x.discount),
                    opening_fitting: services.opening_fitting,
                    part_cost_editable: services.part_cost_editable,
                    labour_cost_editable: services.part_cost_editable,
                    of_cost_editable: services.part_cost_editable,
                    description: services.description,
                    service: services.service,
                    type: services.type,
                    claim: services.claim,
                    custom: services.custom,
                    customer_approval: services.customer_approval,
                    surveyor_approval: services.claim,
                }
            }
            else {
                bookingService = {
                    source: services.source,
                    part_cost: issue_part_cost,
                    labour_cost: services.labour_cost,
                    exceeded_cost: exceeded_cost,
                    of_cost: services.of_cost,
                    part_rate: services.part_rate,
                    cost: issue_part_cost + services.labour_cost + services.of_cost,
                    labour_rate: services.labour_rate,
                    quantity: services.quantity,
                    of_rate: services.of_rate,
                    parts: updated_parts,
                    labour: services.labour,
                    discount: _.sumBy(services.labour, x => x.discount) + _.sumBy(updated_parts, x => x.discount) + _.sumBy(services.opening_fitting, x => x.discount),
                    opening_fitting: services.opening_fitting,
                    part_cost_editable: services.part_cost_editable,
                    labour_cost_editable: services.part_cost_editable,
                    of_cost_editable: services.part_cost_editable,
                    description: services.description,
                    service: services.service,
                    type: services.type,
                    claim: services.claim,
                    custom: services.custom,
                    customer_approval: services.customer_approval,
                    surveyor_approval: services.claim,
                }
            }

            serviceAdd(bookingService, booking._id);
            res.status(200).json({
                responseCode: 200,
                responseMessage: "",
                responseData: bookingService
            })
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "No Service found",
                responseData: {}
            });
        }
    }
    else {
        res.status(400).json({
            responseCode: 400,
            responseMessage: "Booking not found",
            responseData: {}
        });
    }
});

router.post('/job/parts/issue/', xAccessToken.token, async function (req, res, next) {
    var business = req.headers['business'];
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var data = [];
    var loggedInDetails = await User.findById(decoded.user).exec();
    var booking = await Booking.findById(req.body.booking).exec();
    if (booking) {
        var bookingService = [];
        var services = req.body.services;
        if (services.length > 0) {
            for (var i = 0; i < services.length; i++) {
                var update_parts = [];
                var parts = services[i].parts;
                if (parts.length > 0) {
                    for (var k = 0; k < parts.length; k++) {
                        if (parseFloat(parts[k].customer_dep) == 0 && parseFloat(parts[k].insurance_dep) == 0) {
                            var customer_dep = 100;
                            var insurance_dep = 0;
                        }
                        else {
                            var customer_dep = parseFloat(parts[k].customer_dep);
                            var insurance_dep = parseFloat(parts[k].insurance_dep);
                        }

                        if (parts[k].source != null && parts[k].issued == false) {
                            var businessProduct = await BusinessProduct.findById(parts[k].source).exec();

                            if (businessProduct.stock.available >= parts[k].quantity) {
                                var stockTotal = parseFloat(businessProduct.stock.total);
                                var stockAvailable = parseFloat(businessProduct.stock.available) - parts[k].quantity;
                                var stockConsumed = parseFloat(businessProduct.stock.consumed) + parts[k].quantity;

                                if (stockAvailable < 0) {
                                    stockAvailable = 0
                                }

                                if (stockConsumed < 0) {
                                    stockConsumed = 0
                                }

                                var stock = {
                                    total: stockTotal,
                                    available: stockAvailable,
                                    consumed: stockConsumed
                                };

                                update_parts.push({
                                    _id: parts[k]._id,
                                    source: parts[k].source,
                                    quantity: parts[k].quantity,
                                    issued: true,
                                    item: parts[k].item,
                                    hsn_sac: parts[k].hsn_sac,
                                    part_no: parts[k].part_no,
                                    quantity: parts[k].quantity,
                                    rate: parts[k].rate,
                                    base: parts[k].base,
                                    amount: parts[k].amount,
                                    customer_dep: customer_dep,
                                    insurance_dep: insurance_dep,
                                    tax_amount: parts[k].tax_amount,
                                    amount_is_tax: parts[k].amount_is_tax,
                                    discount: parts[k].discount,
                                    tax_rate: parts[k].tax_rate,
                                    tax: parts[k].tax,
                                    tax_info: parts[k].tax_info,
                                });

                                var activity = {
                                    user: loggedInDetails._id,
                                    name: loggedInDetails.name,
                                    stage: "Parts Updates",
                                    activity: parts[k].item + "(" + parts[k].part_no + ") has been issued.\n" + parts[k].quantity + "" + businessProduct.unit + "/ Price: " + parts[k].amount,
                                }

                                fun.bookingLog(booking._id, activity);

                                BusinessProduct.findOneAndUpdate({ _id: parts[k].source }, { $set: { stock: stock } }, { new: false }, async function (err, doc) {
                                    if (err) {
                                        // console.log(err)
                                    }
                                    else {

                                    }
                                });
                            }
                            else {
                                update_parts.push({
                                    _id: parts[k]._id,
                                    source: parts[k].source,
                                    quantity: parts[k].quantity,
                                    issued: parts[k].issued,
                                    item: parts[k].item,
                                    hsn_sac: parts[k].hsn_sac,
                                    part_no: parts[k].part_no,
                                    quantity: parts[k].quantity,
                                    rate: parts[k].rate,
                                    base: parts[k].base,
                                    amount: parts[k].amount,
                                    customer_dep: customer_dep,
                                    insurance_dep: insurance_dep,
                                    tax_amount: parts[k].tax_amount,
                                    amount_is_tax: parts[k].amount_is_tax,
                                    discount: parts[k].discount,
                                    tax_rate: parts[k].tax_rate,
                                    tax: parts[k].tax,
                                    tax_info: parts[k].tax_info,
                                });
                            }
                        }
                        else {
                            update_parts.push({
                                _id: parts[k]._id,
                                source: parts[k].source,
                                quantity: parts[k].quantity,
                                issued: parts[k].issued,
                                item: parts[k].item,
                                hsn_sac: parts[k].hsn_sac,
                                part_no: parts[k].part_no,
                                quantity: parts[k].quantity,
                                rate: parts[k].rate,
                                base: parts[k].base,
                                amount: parts[k].amount,
                                customer_dep: customer_dep,
                                insurance_dep: insurance_dep,
                                tax_amount: parts[k].tax_amount,
                                amount_is_tax: parts[k].amount_is_tax,
                                discount: parts[k].discount,
                                tax_rate: parts[k].tax_rate,
                                tax: parts[k].tax,
                                tax_info: parts[k].tax_info,
                            })
                        }
                    }
                }
                else {
                    update_parts = parts;
                }

                bookingService.push({
                    part_cost: services[i].part_cost,
                    labour_cost: services[i].labour_cost,
                    of_cost: services[i].of_cost,
                    exceeded_cost: services[i].exceeded_cost,
                    quantity: services[i].quantity,
                    parts: update_parts,
                    labour: services[i].labour,
                    cost: _.sumBy(services[i].labour, x => x.amount) + _.sumBy(update_parts, x => x.amount) + _.sumBy(services[i].opening_fitting, x => x.amount),
                    discount: _.sumBy(services[i].labour, x => x.discount) + _.sumBy(update_parts, x => x.discount) + _.sumBy(services[i].opening_fitting, x => x.discount),
                    opening_fitting: services[i].opening_fitting,
                    part_cost_editable: services[i].part_cost_editable,
                    labour_cost_editable: services[i].part_cost_editable,
                    of_cost_editable: services[i].part_cost_editable,
                    description: services[i].description,
                    service: services[i].service,
                    type: services[i].type,
                    claim: services[i].claim,
                    custom: services[i].custom,
                    customer_approval: services[i].customer_approval,
                    surveyor_approval: services[i].surveyor_approval,
                    source: services[i].source,
                });
            }

            var approved = _.filter(bookingService, customer_approval => customer_approval.customer_approval == true);

            var policy_clause = 0
            if (booking.payment.policy_clause) {
                policy_clause = booking.payment.policy_clause;
            }
            var salvage = 0
            if (booking.payment.salvage) {
                salvage = booking.payment.salvage;
            }

            var paid_total = booking.payment.paid_total;
            var labour_cost = _.sumBy(bookingService, x => x.labour_cost);
            var part_cost = _.sumBy(bookingService, x => x.part_cost);
            var of_cost = _.sumBy(bookingService, x => x.of_cost);
            var discount_total = _.sumBy(bookingService, x => x.discount);
            var pick_up_charges = booking.payment.pick_up_charges;
            var careager_cash = await q.all(fun.getBookingCarEagerCash(booking._id));
            var payment_total = labour_cost + part_cost + of_cost + discount_total + policy_clause + salvage + pick_up_charges;

            var estimate_cost = labour_cost + part_cost + of_cost + policy_clause + salvage + pick_up_charges - careager_cash;
            var due_amount = _.sumBy(approved, x => x.labour_cost) + _.sumBy(approved, x => x.part_cost) + _.sumBy(approved, x => x.of_cost) + policy_clause + salvage + pick_up_charges - (paid_total + careager_cash);

            var due = {
                due: Math.ceil(due_amount.toFixed(2))
            }

            var payment = {
                estimate_cost: estimate_cost,
                total: payment_total,
                careager_cash: careager_cash,
                of_cost: of_cost,
                labour_cost: labour_cost,
                part_cost: part_cost,
                payment_mode: booking.payment.payment_mode,
                payment_status: booking.payment.payment_status,
                coupon: booking.payment.coupon,
                coupon_type: booking.payment.coupon_type,
                discount_by: booking.payment.discount_by,
                discount_type: booking.payment.discount_type,
                discount: booking.payment.discount,
                discount_total: discount_total,
                policy_clause: policy_clause,
                salvage: salvage,
                terms: booking.payment.terms,
                pick_up_limit: booking.payment.pick_up_limit,
                pick_up_charges: pick_up_charges,
                paid_total: parseFloat(booking.payment.paid_total),
                discount_applied: booking.payment.discount_applied,
                transaction_id: booking.payment.transaction_id,
                transaction_date: booking.payment.transaction_date,
                transaction_status: booking.payment.transaction_status,
                transaction_response: booking.payment.transaction_response
            };

            Booking.findOneAndUpdate({ _id: booking._id }, { $set: { services: bookingService, payment: payment, due: due, updated_at: new Date() } }, { new: false }, async function (err, doc) {
                if (err) {
                    res.status(400).json({
                        responseCode: 400,
                        responseMessage: "Error",
                        responseData: err
                    });
                }
                else {
                    var update = await Booking.findById(booking.id).exec();

                    res.status(200).json({
                        responseCode: 200,
                        responseMessage: "Parts has been added",
                        responseData: update
                    });
                }
            });
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Services not found",
                responseData: {}
            });
        }
    }
    else {
        res.status(400).json({
            responseCode: 400,
            responseMessage: "Booking not found",
            responseData: {}
        });
    }
});

router.put('/job/part/return/', xAccessToken.token, async function (req, res, next) {
    var business = req.headers['business'];
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    var loggedInDetails = await User.findById(decoded.user).exec();
    var booking = await Booking.findById(req.body.booking).exec();
    if (booking) {
        var product = await BusinessProduct.findById(req.body.source).exec();
        if (product) {
            var stockTotal = parseFloat(product.stock.total)
            var stockConsumed = parseFloat(product.stock.consumed) - parseFloat(req.body.quantity);
            var stockAvailable = parseFloat(product.stock.available) + parseFloat(req.body.quantity);

            if (stockConsumed < 0) {
                stockConsumed = 0;
            }

            if (stockAvailable > stockTotal) {
                stockAvailable = stockTotal;
            }

            var stock = {
                total: stockTotal,
                consumed: stockTotal - stockAvailable,
                available: stockAvailable,
            };

            BusinessProduct.findOneAndUpdate({ _id: product._id, business: business }, { $set: { stock: stock } }, { new: false }, async function (err, doc) {

                if (err) {
                    res.status(422).json({
                        responseCode: 422,
                        responseMessage: "Server Error",
                        responseData: err
                    });
                }
                else {
                    var bookingServices = [];
                    var services = booking.services;

                    for (var i = 0; i < services.length; i++) {
                        var update_parts = [];
                        var parts = services[i].parts;
                        if (parts.length > 0) {
                            for (var k = 0; k < parts.length; k++) {
                                if (parts[k]._id.equals(req.body._id)) {
                                    // console.log(req.body._id + 'Return')
                                    update_parts.push({
                                        _id: parts[k]._id,
                                        source: null,
                                        quantity: parts[k].quantity,
                                        issued: false,
                                        item: parts[k].item,
                                        hsn_sac: parts[k].hsn_sac,
                                        part_no: parts[k].part_no,
                                        quantity: parts[k].quantity,
                                        rate: parts[k].rate,
                                        base: parts[k].base,
                                        amount: parts[k].amount,
                                        customer_dep: parts[k].customer_dep,
                                        insurance_dep: parts[k].insurance_dep,
                                        tax_amount: parts[k].tax_amount,
                                        amount_is_tax: parts[k].amount_is_tax,
                                        discount: parts[k].discount,
                                        tax_rate: parts[k].tax_rate,
                                        tax: parts[k].tax,
                                        tax_info: parts[k].tax_info,
                                    })
                                }
                                else {
                                    update_parts.push({
                                        _id: parts[k]._id,
                                        source: parts[k].source,
                                        quantity: parts[k].quantity,
                                        issued: parts[k].issued,
                                        item: parts[k].item,
                                        hsn_sac: parts[k].hsn_sac,
                                        part_no: parts[k].part_no,
                                        quantity: parts[k].quantity,
                                        rate: parts[k].rate,
                                        base: parts[k].base,
                                        amount: parts[k].amount,
                                        customer_dep: parts[k].customer_dep,
                                        insurance_dep: parts[k].insurance_dep,
                                        tax_amount: parts[k].tax_amount,
                                        amount_is_tax: parts[k].amount_is_tax,
                                        discount: parts[k].discount,
                                        tax_rate: parts[k].tax_rate,
                                        tax: parts[k].tax,
                                        tax_info: parts[k].tax_info,
                                    })
                                }
                            }
                        }

                        bookingServices.push({
                            part_cost: services[i].part_cost,
                            labour_cost: services[i].labour_cost,
                            of_cost: services[i].of_cost,
                            exceeded_cost: services[i].exceeded_cost,
                            part_rate: services[i].part_rate,
                            labour_rate: services[i].labour_rate,
                            quantity: services[i].quantity,
                            of_rate: services[i].of_rate,
                            parts: update_parts,
                            labour: services[i].labour,
                            cost: services[i].cost,
                            discount: _.sumBy(services[i].labour, x => x.discount) + _.sumBy(services[i].opening_fitting, x => x.discount) + _.sumBy(update_parts, x => x.discount),
                            opening_fitting: services[i].opening_fitting,
                            part_cost_editable: services[i].part_cost_editable,
                            labour_cost_editable: services[i].part_cost_editable,
                            of_cost_editable: services[i].part_cost_editable,
                            description: services[i].description,
                            service: services[i].service,
                            type: services[i].type,
                            claim: services[i].claim,
                            custom: services[i].custom,
                            customer_approval: services[i].customer_approval,
                            surveyor_approval: services[i].surveyor_approval,
                            source: services[i].source,
                        });
                    }

                    Booking.findOneAndUpdate({ _id: booking._id }, { $set: { services: bookingServices, updated_at: new Date() } }, { new: false }, async function (err, doc) {
                        if (err) {
                            res.status(400).json({
                                responseCode: 400,
                                responseMessage: "Error",
                                responseData: err
                            });
                        }
                        else {
                            if (req.body.remark) {
                                var remarks = [];
                                remarks = booking.remarks;

                                remarks.push({
                                    remark: req.body.remark,
                                    added_by: loggedInDetails._id,
                                    date: moment().format('YYYY-MM-DD'),
                                    created_at: new Date(),
                                    updated_at: new Date()
                                })

                                Booking.findOneAndUpdate({ _id: booking._id }, { $set: { remarks: remarks, updated_at: new Date() } }, { new: false }, async function (err, doc) {
                                })
                            }

                            var activity = {
                                user: loggedInDetails._id,
                                name: loggedInDetails.name,
                                stage: "Parts Updates",
                                activity: product.title + "(" + product.part_no + ") has been returned",
                            }

                            fun.bookingLog(booking._id, activity);

                            var update = await Booking.findById(booking.id).exec();

                            res.status(200).json({
                                responseCode: 200,
                                responseMessage: "Part return successfully",
                                responseData: update
                            });
                        }
                    });
                }
            });
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Part not found",
                responseData: {}
            });
        }
    }
    else {
        res.status(400).json({
            responseCode: 400,
            responseMessage: "Booking not found",
            responseData: {}
        });
    }
});

router.get('/payment/mode', xAccessToken.token, async function (req, res, next) {
    res.status(200).json({
        responseCode: 200,
        responseMessage: "Booking not found",
        responseData: ["Cash", "Cheque", "Paytm", "PhonePe", "Google Pay", "UPI", "Debit Card", "Credit Card", "Account Transfer"]
    });
});

router.post('/job/payment/receive', xAccessToken.token, async function (req, res, next) {
    var rules = {
        booking: 'required',
        amount: 'required',
        date: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Amount and date are mandatory",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var business = req.headers['business'];
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var data = [];
        var loggedInDetails = await User.findById(decoded.user).exec();
        var booking = await Booking.findById(req.body.booking).exec();
        if (booking) {
            TransactionLog.create({
                user: booking.user,
                activity: "Booking",
                source: booking._id,
                paid_by: req.body.paid_by,
                paid_total: req.body.amount,
                total: booking.payment.total,
                payment_mode: req.body.payment_mode,
                payment_status: "Success",
                order_id: null,
                transaction_id: req.body.transaction_id,
                transaction_date: new Date(req.body.date).toISOString(),
                transaction_status: "Success",
                transaction_response: "Success",
                created_at: booking.updated_at,
                updated_at: booking.updated_at,
            }).then(async function (transaction) {

                var claim = false;
                if (booking.insurance_info) {
                    if (booking.insurance_info.claim == true) {
                        claim = true
                    }
                }

                var transactions = await TransactionLog.find({ source: booking._id, payment_status: { $ne: "Failure" } }).exec();

                var insurance_log = _.filter(transactions, paid_by => paid_by.paid_by == "Insurance");
                var insurance_payment = parseFloat(_.sumBy(insurance_log, x => x.paid_total));

                var customer_log = _.filter(transactions, paid_by => paid_by.paid_by != "Insurance");
                var customer_payment = parseFloat(_.sumBy(customer_log, x => x.paid_total));

                var paid_total = insurance_payment + customer_payment;


                var insurance_invoice = await Invoice.findOne({ booking: booking._id, invoice_type: "Insurance", status: "Active" }).exec();

                if (insurance_invoice) {
                    var bookingService = insurance_invoice.services;
                    var discount_total = 0;
                    var policy_clause = 0;
                    var salvage = 0;
                    var pick_up_charges = 0;
                    var careager_cash = 0;

                    var due_amount = _.sumBy(bookingService, x => x.labour_cost) + _.sumBy(bookingService, x => x.part_cost) + _.sumBy(bookingService, x => x.of_cost) + policy_clause + salvage + pick_up_charges - (insurance_payment + careager_cash);


                    Invoice.findOneAndUpdate({ _id: insurance_invoice._id }, { $set: { "due.due": due_amount, "payment.paid_total": insurance_payment } }, { new: false }, async function (err, doc) {
                        if (err) {
                            return res.status(422).json({
                                responseCode: 422,
                                responseMessage: "Server Error",
                                responseData: err
                            });
                        }
                    });
                }

                var customer_invoice = await Invoice.findOne({ booking: booking._id, invoice_type: "Booking", status: "Active" }).exec();

                if (customer_invoice) {
                    // console.log(customer_invoice._id)
                    var bookingService = customer_invoice.services;

                    var policy_clause = customer_invoice.payment.policy_clause;

                    var salvage = customer_invoice.payment.salvage;

                    var pick_up_charges = customer_invoice.payment.pick_up_charges;

                    var careager_cash = await q.all(fun.getBookingCarEagerCash(booking._id));

                    var due_amount = _.sumBy(bookingService, x => x.labour_cost) + _.sumBy(bookingService, x => x.part_cost) + _.sumBy(bookingService, x => x.of_cost) + policy_clause + salvage + pick_up_charges - (customer_payment + careager_cash);


                    Invoice.findOneAndUpdate({ _id: customer_invoice._id }, { $set: { "due.due": due_amount, "payment.paid_total": customer_payment } }, { new: false }, async function (err, doc) {
                        if (err) {
                            return res.status(422).json({
                                responseCode: 422,
                                responseMessage: "Server Error",
                                responseData: err
                            });
                        }
                    });
                }


                var bookingService = booking.services;
                var policy_clause = booking.payment.policy_clause;

                var salvage = booking.payment.salvage;

                var pick_up_charges = booking.payment.pick_up_charges;

                var careager_cash = await q.all(fun.getBookingCarEagerCash(booking._id));

                var due_amount = _.sumBy(bookingService, x => x.labour_cost) + _.sumBy(bookingService, x => x.part_cost) + _.sumBy(bookingService, x => x.of_cost) + policy_clause + salvage + pick_up_charges - (customer_payment + insurance_payment + careager_cash);

                Booking.findOneAndUpdate({ _id: booking._id }, { $set: { "payment.paid_total": customer_payment + insurance_payment, "due.due": due_amount, updated_at: new Date() } }, { new: false }, async function (err, doc) {
                    if (err) {
                        res.status(422).json({
                            responseCode: 422,
                            responseMessage: "Server Error",
                            responseData: err
                        });
                    }
                    else {
                        var activity = {
                            user: loggedInDetails._id,
                            name: loggedInDetails.name,
                            stage: "Payment",
                            activity: "Payment Recieved " + req.body.amount,
                        };

                        fun.bookingLog(booking._id, activity);

                        var updated = await Booking.findById(booking._id).exec();
                        res.status(200).json({
                            responseCode: 200,
                            responseMessage: "",
                            responseData: updated
                        });
                    }
                });
            });
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Booking not found",
                responseData: {}
            });
        }
    }
});

router.delete('/job/payment/remove', xAccessToken.token, async function (req, res, next) {
    var business = req.headers['business'];
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var data = [];
    var loggedInDetails = await User.findById(decoded.user).exec();

    var transaction = await TransactionLog.findById(req.query.id).exec();
    if (transaction) {


        var booking = await Booking.findById(transaction.source).exec();

        TransactionLog.remove({ _id: transaction._id }, async function (err) {
            if (err) {
                res.status(422).json({
                    responseCode: 422,
                    responseMessage: "Server Error",
                    responseData: err
                });
            }
            else {
                var transactions = await TransactionLog.find({ source: booking._id, payment_status: { $ne: "Failure" } }).exec();
                var insurance_log = _.filter(transactions, paid_by => paid_by.paid_by == "Insurance");
                var insurance_payment = parseFloat(_.sumBy(insurance_log, x => x.paid_total));

                var customer_log = _.filter(transactions, paid_by => paid_by.paid_by != "Insurance");
                var customer_payment = parseFloat(_.sumBy(customer_log, x => x.paid_total));

                var paid_total = insurance_payment + customer_payment;

                var claim = false;
                if (booking.insurance_info) {
                    if (booking.insurance_info.claim == true) {
                        claim == true
                    }
                }

                if (claim == true) {
                    var insurance_invoice = await Invoice.findOne({ booking: booking._id, invoice_type: "Insurance", status: "Active" }).exec();

                    if (insurance_invoice) {
                        var bookingService = insurance_invoice.services;
                        var discount_total = 0;
                        var policy_clause = 0;
                        var salvage = 0;
                        var pick_up_charges = 0;
                        var careager_cash = 0;

                        var due_amount = _.sumBy(bookingService, x => x.labour_cost) + _.sumBy(bookingService, x => x.part_cost) + _.sumBy(bookingService, x => x.of_cost) + policy_clause + salvage + pick_up_charges - (insurance_payment + careager_cash);


                        Invoice.findOneAndUpdate({ _id: insurance_invoice._id }, { $set: { "due.due": due_amount, "payment.paid_total": insurance_payment } }, { new: false }, async function (err, doc) {
                            if (err) {
                                return res.status(422).json({
                                    responseCode: 422,
                                    responseMessage: "Server Error",
                                    responseData: err
                                });
                            }
                        });
                    }
                }
                else {
                    var customer_invoice = await Invoice.findOne({ booking: booking._id, invoice_type: "Booking", status: "Active" }).exec();

                    if (customer_invoice) {
                        var bookingService = customer_invoice.services;

                        var policy_clause = customer_invoice.payment.policy_clause;

                        var salvage = customer_invoice.payment.salvage;

                        var pick_up_charges = customer_invoice.payment.pick_up_charges;

                        var careager_cash = await q.all(fun.getBookingCarEagerCash(booking._id));

                        var due_amount = _.sumBy(bookingService, x => x.labour_cost) + _.sumBy(bookingService, x => x.part_cost) + _.sumBy(bookingService, x => x.of_cost) + policy_clause + salvage + pick_up_charges - (customer_payment + careager_cash);


                        Invoice.findOneAndUpdate({ _id: customer_invoice._id }, { $set: { "due.due": due_amount, "payment.paid_total": customer_payment } }, { new: false }, async function (err, doc) {
                            if (err) {
                                return res.status(422).json({
                                    responseCode: 422,
                                    responseMessage: "Server Error",
                                    responseData: err
                                });
                            }
                        });
                    }
                }


                var bookingService = booking.services;

                var policy_clause = booking.payment.policy_clause;

                var salvage = booking.payment.salvage;

                var pick_up_charges = booking.payment.pick_up_charges;

                var careager_cash = await q.all(fun.getBookingCarEagerCash(booking._id));

                var due_amount = _.sumBy(bookingService, x => x.labour_cost) + _.sumBy(bookingService, x => x.part_cost) + _.sumBy(bookingService, x => x.of_cost) + policy_clause + salvage + pick_up_charges - (customer_payment + insurance_payment + careager_cash);

                Booking.findOneAndUpdate({ _id: booking._id }, { $set: { "payment.paid_total": customer_payment + insurance_payment, "due.due": due_amount, updated_at: new Date() } }, { new: false }, async function (err, doc) {
                    if (err) {
                        res.status(422).json({
                            responseCode: 422,
                            responseMessage: "Server Error",
                            responseData: err
                        });
                    }
                    else {
                        var activity = {
                            user: loggedInDetails._id,
                            name: loggedInDetails.name,
                            stage: "Payment",
                            activity: "Payment Removed " + transaction.paid_total,
                        };

                        fun.bookingLog(booking._id, activity);

                        var updated = await Booking.findById(booking._id).exec();
                        res.status(200).json({
                            responseCode: 200,
                            responseMessage: "",
                            responseData: updated
                        });
                    }
                });
            }
        });
    }
    else {
        res.status(400).json({
            responseCode: 400,
            responseMessage: "Transaction not found",
            responseData: {}
        });
    }
});

router.get('/job/payment/logs', xAccessToken.token, async function (req, res, next) {
    var business = req.headers['business'];
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    var booking = await Booking.findById(req.query.booking).exec();
    if (booking) {
        var logs = [];
        await TransactionLog.find({ source: req.query.booking })
            .sort({ updated_at: -1 })
            .cursor().eachAsync(async (log) => {
                logs.push({
                    _id: log._id,
                    id: log._id,
                    activity: log.activity,
                    payment_mode: log.payment_mode,
                    paid_total: log.paid_total,
                    payment_status: log.payment_status,
                    transaction_id: log.transaction_id,
                    transaction_date: log.transaction_date,
                    transaction_status: log.transaction_status,
                    transaction_response: log.transaction_response,
                    user: log.user,
                    source: log.source,
                    paid_total: log.paid_total,
                    total: log.total,
                    created_at: moment(log.created_at).tz(req.headers['tz']).format('lll'),
                    updated_at: moment(log.updated_at).tz(req.headers['tz']).format('lll'),
                });
            });
        res.status(200).json({
            responseCode: 200,
            responseMessage: "Transaction Log",
            responseData: logs
        });
    }
    else {
        res.status(400).json({
            responseCode: 400,
            responseMessage: "Booking not found",
            responseData: {}
        });
    }
});

router.get('/job/qc/', xAccessToken.token, async function (req, res, next) {
    var business = req.headers['business'];
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var data = [];
    var booking = await Booking.findById(req.query.booking).exec();
    if (booking) {
        var body = booking.services;

        var category = ["general"];
        body = _.uniqBy(body, "type");

        for (var i = 0; i < body.length; i++) {
            if (body[i].type == "addOn") {
                category.push("services")
            }
            else {
                category.push(body[i].type)
            }
        }

        var qc = [];

        await QualityCheck.find({ category: { $in: category } }).sort({ position: 1 })
            .cursor().eachAsync(async (p) => {
                var category = p.category;
                qc.push({
                    _id: p._id,
                    id: p._id,
                    position: p.position,
                    point: p.point,
                    category: category.toString(),
                })
            })

        res.status(200).json({
            responseCode: 200,
            responseMessage: "",
            responseData: qc
        });
    }
    else {
        res.status(400).json({
            responseCode: 400,
            responseMessage: "Booking not found",
            responseData: {}
        });
    }
});

router.put('/job/qc/update', xAccessToken.token, async function (req, res, next) {
    var business = req.headers['business'];
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var data = [];
    var loggedInDetails = await User.findById(decoded.user).exec();
    var booking = await Booking.findById(req.body.booking).exec();
    if (booking) {
        var qc = _.orderBy(req.body.qc, 'position', 'asc');
        var status = req.body.status;

        var logs = _.filter(booking.logs, status => status.status == status);

        if (logs.length > 0) {
            status = logs[logs.length - 1].status
        }


        Booking.findOneAndUpdate({ _id: booking._id }, { $set: { qc: qc, status: status, updated_at: new Date() } }, { new: false }, async function (err, doc) {
            if (err) {
                res.status(400).json({
                    responseCode: 400,
                    responseMessage: "Error",
                    responseData: err
                });
            }
            else {
                var activity = {
                    user: loggedInDetails._id,
                    name: loggedInDetails.name,
                    stage: req.body.stage,
                    activity: req.body.status,
                };

                fun.bookingLog(booking._id, activity);

                var update = await Booking.findById(booking.id).exec();

                res.status(200).json({
                    responseCode: 200,
                    responseMessage: "Status has been updated",
                    responseData: update
                });
            }
        });

    }
    else {
        res.status(400).json({
            responseCode: 400,
            responseMessage: "Booking not found",
            responseData: {}
        });
    }
});

router.put('/job/status/update', xAccessToken.token, async function (req, res, next) {
    var business = req.headers['business'];
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var data = [];
    var loggedInDetails = await User.findById(decoded.user).exec();
    var booking = await Booking.findById(req.body.booking).exec();
    if (booking) {
        var status = req.body.status;
        if (status == "CompleteWork") {
            status = "QC"
        }

        Booking.findOneAndUpdate({ _id: booking._id }, { $set: { status: status, updated_at: new Date() } }, { new: false }, async function (err, doc) {
            if (err) {
                res.status(400).json({
                    responseCode: 400,
                    responseMessage: "Error",
                    responseData: err
                });
            }
            else {

                var activity = {
                    user: loggedInDetails._id,
                    name: loggedInDetails.name,
                    stage: req.body.stage,
                    activity: req.body.status,
                };

                //event.zohoLead(booking._id)

                fun.bookingLog(booking._id, activity);

                if (req.body.back != "enable") {
                    var notify = {
                        receiver: [booking.user],
                        activity: "jobcard",
                        tag: req.body.status,
                        source: booking._id,
                        sender: booking.business,
                        points: 0
                    }

                    fun.newNotification(notify);
                    event.jobSms(notify);
                }

                var update = await Booking.findById(booking.id).exec();

                res.status(200).json({
                    responseCode: 200,
                    responseMessage: "Status has been updated",
                    responseData: update
                });
            }
        });

    }
    else {
        res.status(400).json({
            responseCode: 400,
            responseMessage: "Booking not found",
            responseData: {}
        });
    }
});

router.get('/job/convenience', xAccessToken.token, async function (req, res, next) {
    var business = req.headers['business'];
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var data = [];
    var booking = await Booking.findById(req.query.booking).exec();
    if (booking) {
        var addresses = [];
        await Address.find({ user: booking.user })
            .cursor().eachAsync(async (address) => {
                if (address._id.equals(booking.address)) {
                    var checked = true
                }
                else {
                    var checked = false
                }

                addresses.push({
                    _id: address._id,
                    id: address.id,
                    user: address.user,
                    address: address.address,
                    area: address.area,
                    landmark: address.landmark,
                    zip: address.zip,
                    city: address.city,
                    state: address.state,
                    checked: false
                });
            });

        var conveniences = [];

        await BusinessConvenience.find({ business: booking.business })
            .cursor().eachAsync(async (convenience) => {
                if (convenience.convenience == booking.convenience) {
                    var checked = true
                }
                else {
                    var checked = false
                }

                conveniences.push({
                    _id: convenience._id,
                    id: convenience.id,
                    convenience: convenience.convenience,
                    charges: convenience.charges,
                    business: convenience.business,
                    checked: false
                });
            });

        res.status(200).json({
            responseCode: 200,
            responseMessage: "",
            responseData: {
                address: addresses,
                convenience: conveniences
            }
        });
    }
    else {
        res.status(400).json({
            responseCode: 400,
            responseMessage: "Booking not found",
            responseData: {}
        });
    }
});

router.post('/booking/convenience/add', xAccessToken.token, async function (req, res, next) {
    var business = req.headers['business'];
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var data = [];

    var loggedInDetails = await User.findById(decoded.user).exec();
    if (loggedInDetails) {
        var management = await Management.findOne({ user: decoded.user, business: business, role: "Admin" }).populate('user').exec();
        if (management) {
            var body = req.body;
            if (body.length > 0) {
                for (var i = 0; i < body.length; i++) {
                    var businessConvenience = await BusinessConvenience.findOne({ business: business, convenience: body[i].convenience }).exec();
                    if (businessConvenience) {
                        var data = {
                            charges: body[i].charges,
                            updated_at: new Date()
                        }

                        BusinessConvenience.findOneAndUpdate({ _id: businessConvenience._id }, { $set: data }, { new: false }, async function (err, doc) {
                            if (err) {
                                return res.status(422).json({
                                    responseCode: 422,
                                    responseMessage: "Server Error",
                                    responseData: err
                                });
                            }
                        });
                    }
                    else {
                        var data = {
                            business: business,
                            convenience: body[i].convenience,
                            charges: body[i].charges,
                            created_at: new Date(),
                            updated_at: new Date()
                        }


                        BusinessConvenience.create(data)
                            .then(async function (e) {
                            });
                    }
                }

                var businessConvenience = await BusinessConvenience.find({ business: business }).exec();

                res.status(200).json({
                    responseCode: 200,
                    responseMessage: "Conveniences",
                    responseData: businessConvenience
                });
            }
            else {
                res.status(400).json({
                    responseCode: 400,
                    responseMessage: "Convenience Required",
                    responseData: {}
                });
            }
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Authorization Error",
                responseData: {}
            });
        }
    }
    else {
        res.status(400).json({
            responseCode: 400,
            responseMessage: "User not found",
            responseData: {}
        });
    }
});

router.get('/booking/conveniences/get', xAccessToken.token, async function (req, res, next) {
    var business = req.headers['business'];
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var data = [];


    var businessConvenience = await BusinessConvenience.find({ business: business }).exec();
    if (businessConvenience.length > 0) {
        res.status(200).json({
            responseCode: 200,
            responseMessage: "Conveniences",
            responseData: businessConvenience
        });
    }
    else {
        var businessConvenience = await BusinessConvenience.find({ business: null }).exec();
        res.status(200).json({
            responseCode: 200,
            responseMessage: "Conveniences",
            responseData: businessConvenience
        });
    }
});

router.post('/order/convenience/add', xAccessToken.token, async function (req, res, next) {
    var business = req.headers['business'];
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var data = [];

    var loggedInDetails = await User.findById(decoded.user).exec();
    if (loggedInDetails) {
        var management = await Management.findOne({ user: decoded.user, business: business, role: "Admin" }).populate('user').exec();
        if (management) {
            var body = req.body;
            if (body.length > 0) {
                for (var i = 0; i < body.length; i++) {
                    var orderConvenience = await OrderConvenience.findOne({ business: business, convenience: body[i].convenience }).exec();
                    if (orderConvenience) {
                        var data = {
                            charges: body[i].charges,
                            updated_at: new Date()
                        }

                        OrderConvenience.findOneAndUpdate({ _id: orderConvenience._id }, { $set: data }, { new: false }, async function (err, doc) {
                            if (err) {
                                return res.status(422).json({
                                    responseCode: 422,
                                    responseMessage: "Server Error",
                                    responseData: err
                                });
                            }
                        });
                    }
                    else {
                        var data = {
                            business: business,
                            convenience: body[i].convenience,
                            charges: body[i].charges,
                            created_at: new Date(),
                            updated_at: new Date()
                        }


                        OrderConvenience.create(data)
                            .then(async function (e) {
                            });
                    }
                }

                var orderConvenience = await OrderConvenience.find({ business: business }).exec();

                res.status(200).json({
                    responseCode: 200,
                    responseMessage: "Conveniences",
                    responseData: orderConvenience
                });
            }
            else {
                res.status(400).json({
                    responseCode: 400,
                    responseMessage: "Convenience Required",
                    responseData: {}
                });
            }
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Authorization Error",
                responseData: {}
            });
        }
    }
    else {
        res.status(400).json({
            responseCode: 400,
            responseMessage: "User not found",
            responseData: {}
        });
    }
});

router.post('/order/create', xAccessToken.token, async function (req, res, next) {
    var business = req.headers['business'];
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var date = new Date();
    var loggedInDetails = decoded.user;
    var car = null;
    var address = null;
    var items = [];
    var data = [];

    var item_total = 0;
    var discount = 0;
    var item_total = 0;
    var total = 0;
    var due = {
        due: 0
    };

    var user = await User.findById(req.body.user).exec();
    var loggedInDetails = await User.findById(decoded.user).exec();
    if (user) {
        if (req.body.address) {
            var checkAddress = await Address.findOne({ _id: req.body.address, user: user._id }).exec();
            if (checkAddress) {
                address = checkAddress._id;
            }
            else {
                return res.status(400).json({
                    responseCode: 400,
                    responseMessage: "Address not found",
                    responseData: {}
                });
            }
        }
        /*else
        {
            return res.status(400).json({
                responseCode: 400,
                responseMessage: "Address not found",
                responseData: {}
            });
        }*/

        if (req.body.car) {
            var checkCar = await Car.findOne({ _id: req.body.car, user: user._id }).exec();
            if (checkCar) {
                car = checkCar._id;
            }
            else {
                return res.status(400).json({
                    responseCode: 400,
                    responseMessage: "Car not found",
                    responseData: {}
                });
            }
        }



        var date = new Date();
        var payment = {
            payment_mode: "",
            payment_status: "",
            extra_charges_limit: 0,
            convenience_charges: 0,
            discount_type: "",
            coupon_type: "",
            coupon: "",
            discount_applied: false,
            transaction_id: "",
            transaction_date: "",
            transaction_status: "",
            transaction_response: "",
            total: total,
            discount_total: discount,
            paid_total: 0,
        };



        Order.create({
            convenience: req.body.convenience,
            time_slot: req.body.time_slot,
            user: user._id,
            car: car,
            address: address,
            items: items,
            business: business,
            payment: payment,
            due: due,
            status: "Ordered",
            created_at: date,
            updated_at: date,
        }).then(async function (o) {
            var count = await Order.find({ _id: { $lt: o._id } }).count();

            var order_no = Math.round(+new Date() / 1000) + "-" + Math.ceil((Math.random() * 90000) + 10000) + "-" + Math.ceil(count + 1);

            Order.findOneAndUpdate({ _id: o._id }, { $set: { order_no: order_no } }, { new: true }, async function (err, doc) {
                if (err) {
                    res.status(422).json({
                        responseCode: 422,
                        responseMessage: "Server Errro",
                        responseData: err
                    });
                }
                else {
                    var businessOrder = {
                        order: o._id,
                        _order: order_no,
                        due_date: null,
                        delivery_date: null,
                        convenience: req.body.convenience,
                        time_slot: req.body.time_slot,
                        user: user._id,
                        items: items,
                        business: business,
                        payment: payment,
                        status: "Confirmed",
                        created_at: date,
                        updated_at: date,
                        due: due
                    };

                    BusinessOrder.create(businessOrder).then(async function (bo) {
                        var count = await BusinessOrder.find({ _id: { $lt: bo._id }, business: business }).count();
                        var order_no = count + 1;

                        BusinessOrder.findOneAndUpdate({ _id: bo._id }, { $set: { order_no: order_no } }, { new: true }, async function (err, doc) {

                            var order = await BusinessOrder.findById(bo._id)
                                .populate({ path: 'order', populate: [{ path: 'user', select: 'name contact_no username email account_info ' }, { path: 'car', select: 'title variant registration_no _automaker _model' }, { path: 'address' }] })
                                .exec();

                            var items = await OrderLine.find({ order: order.order._id, business: business }).exec();

                            res.status(200).json({
                                responseCode: 200,
                                responseMessage: "",
                                responseData: {
                                    _id: order._id,
                                    id: order._id,
                                    order_no: order.order_no,
                                    order: order.order._id,
                                    _order: order._order,
                                    convenience: order.order.convenience,
                                    car: order.order.car,
                                    user: order.order.user,
                                    address: order.order.address,
                                    items: items,
                                }
                            });
                        });
                    });
                }
            });
        });
    }
    else {
        res.status(400).json({
            responseCode: 400,
            responseMessage: "User not found",
            responseData: {}
        });
    }
});

router.get('/order/items/search/', xAccessToken.token, async function (req, res, next) {
    var rules = {
        query: 'required',
        quantity: 'required',
    };

    var validation = new Validator(req.query, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Part/Part No & quantity required",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var id = mongoose.Types.ObjectId();

        if (parseFloat(req.query.quantity) > 0) {
            var business = req.headers['business'];
            var token = req.headers['x-access-token'];
            var secret = config.secret;
            var decoded = jwt.verify(token, secret);
            var data = [];
            await BusinessProduct.find({ business: business, list_type: { $in: ["Offline"] }, $or: [{ part_no: new RegExp(req.query.query, "i") }, { title: new RegExp(req.query.query, "i") }, { models: { $in: new RegExp(req.query.query, "i") } }] })
                .cursor().eachAsync(async (p) => {
                    var quantity = parseFloat(req.query.quantity);
                    if (p.stock.available >= quantity) {
                        var rate = p.price.sell_price;
                        var base = p.price.sell_price * quantity;
                        var amount = p.price.sell_price * quantity;

                        var tax_info = await Tax.findOne({ tax: p.tax_info.tax }).exec();
                        var tax_rate = tax_info.detail;
                        var tax = [];

                        var x = (100 + p.tax_info.rate) / 100;
                        var tax_on_amount = amount / x;
                        if (tax_rate.length > 0) {
                            for (var r = 0; r < tax_rate.length; r++) {
                                if (tax_rate[r].rate != tax_info.rate) {
                                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                                    base = base - t
                                    tax.push({
                                        tax: tax_rate[r].tax,
                                        rate: tax_rate[r].rate,
                                        amount: parseFloat(t.toFixed(2))
                                    });
                                }
                                else {
                                    var t = amount - tax_on_amount;
                                    base = base - t
                                    tax.push({
                                        tax: tax_info.tax,
                                        rate: tax_info.rate,
                                        amount: parseFloat(t.toFixed(2))
                                    });
                                }
                            }
                        }

                        var tax_details = {
                            tax: tax_info.tax,
                            rate: tax_info.rate,
                            amount: p.price.sell_price,
                            detail: tax
                        };

                        data.push({
                            _id: id,
                            id: id,
                            title: p.title,
                            sku: p.sku,
                            part_no: p.part_no,
                            hsn_sac: p.hsn_sac,
                            product: p._id,
                            unit: p.unit,
                            issued: false,
                            quantity: quantity,
                            mrp: parseFloat(rate.toFixed(2)),
                            selling_price: parseFloat(rate.toFixed(2)),
                            rate: parseFloat(rate.toFixed(2)),
                            base: parseFloat(base.toFixed(2)),
                            amount: parseFloat(amount.toFixed(2)),
                            discount: 0,
                            amount_is_tax: p.amount_is_tax,
                            tax_amount: parseFloat(_.sumBy(tax, x => x.amount).toFixed(2)),
                            tax: p.tax_info.tax,
                            tax_rate: p.tax_info.rate,
                            tax_info: tax_details,
                            out_of_stock: false,
                            available: p.stock.available,
                            business: p.business,
                        });
                    }
                    else if (p.stock.available < quantity && p.stock.available > 0) {
                        var rate = p.price.sell_price;
                        var base = p.price.sell_price * quantity;
                        var amount = p.price.sell_price * quantity;

                        var tax_info = await Tax.findOne({ tax: p.tax_info.tax }).exec();
                        var tax_rate = tax_info.detail;
                        var tax = [];

                        var x = (100 + p.tax_info.rate) / 100;
                        var tax_on_amount = amount / x;
                        if (tax_rate.length > 0) {
                            for (var r = 0; r < tax_rate.length; r++) {
                                if (tax_rate[r].rate != tax_info.rate) {
                                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                                    base = base - t
                                    tax.push({
                                        tax: tax_rate[r].tax,
                                        rate: tax_rate[r].rate,
                                        amount: parseFloat(t.toFixed(2))
                                    });
                                }
                                else {
                                    var t = amount - tax_on_amount;
                                    base = base - t
                                    tax.push({
                                        tax: tax_info.tax,
                                        rate: tax_info.rate,
                                        amount: parseFloat(t.toFixed(2))
                                    });
                                }
                            }
                        }

                        var tax_details = {
                            tax: tax_info.tax,
                            rate: tax_info.rate,
                            amount: p.price.sell_price,
                            detail: tax
                        }

                        data.push({
                            _id: id,
                            sku: p.sku,
                            title: p.title,
                            part_no: p.part_no,
                            hsn_sac: p.hsn_sac,
                            product: p._id,
                            quantity: quantity,
                            mrp: parseFloat(rate.toFixed(2)),
                            selling_price: parseFloat(rate.toFixed(2)),
                            rate: parseFloat(rate.toFixed(2)),
                            base: parseFloat(base.toFixed(2)),
                            amount: parseFloat(amount.toFixed(2)),
                            issued: false,
                            discount: 0,
                            unit: p.unit,
                            amount_is_tax: p.amount_is_tax,
                            tax_amount: parseFloat(_.sumBy(tax, x => x.amount).toFixed(2)),
                            tax: p.tax_info.tax,
                            tax_rate: p.tax_info.rate,
                            tax_info: tax_details,
                            out_of_stock: false,
                            stock_available: p.stock.available,
                            business: p.business,
                        });
                    }
                    else if (p.stock.available <= 0) {
                        var rate = p.price.sell_price;
                        var base = p.price.sell_price * quantity;
                        var amount = p.price.sell_price * quantity;

                        var tax_info = await Tax.findOne({ tax: p.tax_info.tax }).exec();
                        var tax_rate = tax_info.detail;
                        var tax = [];

                        var x = (100 + p.tax_info.rate) / 100;
                        var tax_on_amount = amount / x;
                        if (tax_rate.length > 0) {
                            for (var r = 0; r < tax_rate.length; r++) {
                                if (tax_rate[r].rate != tax_info.rate) {
                                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                                    base = base - t
                                    tax.push({
                                        tax: tax_rate[r].tax,
                                        rate: tax_rate[r].rate,
                                        amount: parseFloat(t.toFixed(2))
                                    });
                                }
                                else {
                                    var t = amount - tax_on_amount;
                                    //base = base - discount_total;
                                    tax.push({
                                        tax: tax_info.tax,
                                        rate: tax_info.rate,
                                        amount: parseFloat(t.toFixed(2))
                                    });
                                }
                            }
                        }

                        var tax_details = {
                            tax: tax_info.tax,
                            rate: tax_info.rate,
                            amount: p.price.sell_price,
                            detail: tax
                        }

                        data.push({
                            _id: id,
                            id: id,
                            sku: p.sku,
                            title: p.title,
                            part_no: p.part_no,
                            hsn_sac: p.hsn_sac,
                            product: p._id,
                            quantity: quantity,
                            mrp: parseFloat(rate.toFixed(2)),
                            selling_price: parseFloat(rate.toFixed(2)),
                            rate: parseFloat(rate.toFixed(2)),
                            base: parseFloat(base.toFixed(2)),
                            amount: parseFloat(amount.toFixed(2)),
                            discount: 0,
                            issued: false,
                            unit: p.unit,
                            tax_amount: parseFloat(_.sumBy(tax, x => x.amount).toFixed(2)),
                            amount_is_tax: p.amount_is_tax,
                            tax: p.tax_info.tax,
                            tax_rate: p.tax_info.rate,
                            tax_info: tax_details,
                            out_of_stock: true,
                            stock_available: 0,
                            business: p.business,
                        });
                    }
                });

            res.status(200).json({
                responseCode: 200,
                responseMessage: "",
                responseData: data
            })
        }
        else {
            res.status(422).json({
                responseCode: 422,
                responseMessage: "Part/Part No & quantity required",
                responseData: {}
            })
        }
    }
});

router.post('/order/item/add', xAccessToken.token, async function (req, res, next) {
    var business = req.headers['business'];
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var date = new Date();
    var loggedInDetails = decoded.user;
    var items = [];
    var data = [];
    var convenience_charges = 0;
    var item_total = 0;
    var discount = 0;
    var item_total = 0;
    var total = 0;

    var order = await Order.findById(req.body.order).exec();
    var loggedInDetails = await User.findById(decoded.user).exec();
    if (order) {
        var products = req.body.items;
        if (products.title != "") {
            var businessOrder = await BusinessOrder.findOne({ order: order._id, business: business }).exec();

            var log = {
                status: "Confirmed",
                type: "Counter",
                activity: "Confirmed",
                user: loggedInDetails._id,
                name: loggedInDetails.name,
                created_at: date,
                updated_at: date,
            }
            var id = mongoose.Types.ObjectId();
            if (products.id != null) {
                id = products.id
            }
            if (products) {
                var tax_info = await Tax.findOne({ tax: products.tax }).exec();
                if (products.product) {
                    var product = await BusinessProduct.findOne({ _id: products.product, business: business }).exec();
                    if (product) {
                        var tax = [];
                        var rate = products.rate;
                        var amount = products.rate * products.quantity;
                        var tax_rate = tax_info.detail;
                        var discount_total = 0;
                        var base = amount

                        var discount = products.discount;

                        if (discount.indexOf("%") >= 0) {
                            discount = parseFloat(discount);
                            if (!isNaN(discount) && discount > 0) {
                                discount_total = amount * (discount / 100);
                                amount = amount - parseFloat(discount_total.toFixed(2))
                            }
                        }
                        else {
                            if (discount == "") {
                                discount = "0"
                            }

                            discount_total = parseFloat(discount);

                            if (!isNaN(discount_total) && discount_total > 0) {
                                amount = amount - parseFloat(discount_total.toFixed(2))
                            }
                        }

                        if (products.amount_is_tax == "exclusive") {
                            var tax_on_amount = amount;
                            if (tax_rate.length > 0) {
                                for (var r = 0; r < tax_rate.length; r++) {
                                    if (tax_rate[r].rate != tax_info.rate) {
                                        var t = tax_on_amount * (tax_rate[r].rate / 100);
                                        amount = amount + t;
                                        tax.push({
                                            tax: tax_rate[r].tax,
                                            rate: tax_rate[r].rate,
                                            amount: parseFloat(t.toFixed(2))
                                        })
                                    }
                                    else {
                                        var t = tax_on_amount * (tax_info.rate / 100);
                                        amount = amount + t;
                                        tax.push({
                                            tax: tax_info.tax, tax_rate: tax_info.rate,
                                            rate: tax_info.rate,
                                            amount: parseFloat(t.toFixed(2))
                                        })
                                    }
                                }
                            }
                        }

                        if (products.amount_is_tax == "inclusive") {
                            var x = (100 + tax_info.rate) / 100;
                            var tax_on_amount = amount / x;
                            if (tax_rate.length > 0) {
                                for (var r = 0; r < tax_rate.length; r++) {
                                    if (tax_rate[r].rate != tax_info.rate) {
                                        var t = tax_on_amount * (tax_rate[r].rate / 100);
                                        base = base - t;
                                        tax.push({
                                            tax: tax_rate[r].tax,
                                            rate: tax_rate[r].rate,
                                            amount: parseFloat(t.toFixed(2))
                                        });
                                    }
                                    else {
                                        var t = amount - tax_on_amount;
                                        base = base - t;
                                        tax.push({
                                            tax: tax_info.tax,
                                            rate: tax_info.rate,
                                            amount: parseFloat(t.toFixed(2))
                                        });
                                    }
                                }
                            }
                            //base = base - discount_total;
                        }

                        var tax_details = {
                            tax: tax_info.tax,
                            rate: tax_info.rate,
                            amount: total,
                            detail: tax
                        }

                        items = {
                            _id: id,
                            order: order._id,
                            product: product._id,
                            category: product.category,
                            _category: product._category,
                            subcategory: product.subcategory,
                            _subcategory: product._subcategory,
                            product_brand: product.product_brand,
                            _brand: product.product_brand,
                            product_model: product.product_model,
                            _model: product.product_model,
                            source: product.source,
                            part_no: products.part_no,
                            hsn_sac: products.hsn_sac,
                            unit: products.unit,
                            title: products.title,
                            sku: products.sku,
                            mrp: products.mrp,
                            selling_price: products.selling_price,
                            rate: products.rate,
                            quantity: products.quantity,
                            base: parseFloat(base.toFixed(2)),
                            amount: amount,
                            discount: products.discount,
                            discount_total: parseFloat(discount_total.toFixed(2)),
                            amount_is_tax: products.amount_is_tax,
                            tax_amount: parseFloat(_.sumBy(tax, x => x.amount).toFixed(2)),
                            amount: parseFloat(amount.toFixed(2)),
                            tax: tax_info.tax,
                            tax_rate: tax_info.rate,
                            tax_info: tax,
                            issued: false,
                            added_by_customer: false,
                            delivery_date: businessOrder.delivery_date,
                            tracking_no: Math.round(+new Date() / 1000) + "-" + Math.ceil((Math.random() * 90000) + 10000),
                            business: products.business,
                            created_at: new Date(),
                            updated_at: new Date()
                        }
                    }
                    else {
                        return res.status(400).json({
                            responseCode: 400,
                            responseMessage: "Items not found",
                            responseData: {}
                        });
                    }
                }
                else {
                    var tax = [];
                    var rate = products.rate;
                    var amount = products.rate * products.quantity;
                    var tax_rate = tax_info.detail;
                    var discount_total = 0
                    var base = amount;
                    var discount = products.discount;

                    if (discount.indexOf("%") >= 0) {
                        discount = parseFloat(discount);
                        if (!isNaN(discount) && discount > 0) {
                            discount_total = amount * (discount / 100);
                            if (parseFloat(discount_total.toFixed(2)) > amount) {
                                products.discount = amount.toString();
                                discount_total = amount;
                            }

                            amount = amount - parseFloat(discount_total.toFixed(2))
                        }
                    }
                    else {
                        discount_total = parseFloat(discount);
                        if (!isNaN(discount_total) && discount_total > 0) {
                            if (parseFloat(discount_total.toFixed(2)) > amount) {
                                products.discount = amount.toString();
                                discount_total = amount;
                            }

                            amount = amount - parseFloat(discount_total.toFixed(2))
                        }
                    }

                    if (products.amount_is_tax == "exclusive") {
                        var tax_on_amount = amount;
                        if (tax_rate.length > 0) {
                            for (var r = 0; r < tax_rate.length; r++) {
                                if (tax_rate[r].rate != tax_info.rate) {
                                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                                    amount = amount + t;
                                    tax.push({
                                        tax: tax_rate[r].tax,
                                        rate: tax_rate[r].rate,
                                        amount: parseFloat(t.toFixed(2))
                                    })
                                }
                                else {
                                    var t = tax_on_amount * (tax_info.rate / 100);
                                    amount = amount + t;
                                    tax.push({
                                        tax: tax_info.tax, tax_rate: tax_info.rate,
                                        rate: tax_info.rate,
                                        amount: parseFloat(t.toFixed(2))
                                    })
                                }
                            }
                        }
                    }

                    if (products.amount_is_tax == "inclusive") {
                        amount = amount;
                        var x = (100 + tax_info.rate) / 100;
                        var tax_on_amount = amount / x;
                        if (tax_rate.length > 0) {
                            for (var r = 0; r < tax_rate.length; r++) {
                                if (tax_rate[r].rate != tax_info.rate) {
                                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                                    base = base - t;
                                    tax.push({
                                        tax: tax_rate[r].tax,
                                        rate: tax_rate[r].rate,
                                        amount: parseFloat(t.toFixed(2))
                                    });
                                }
                                else {
                                    var t = amount - tax_on_amount;
                                    base = base - t;
                                    tax.push({
                                        tax: tax_info.tax,
                                        rate: tax_info.rate,
                                        amount: parseFloat(t.toFixed(2))
                                    });
                                }
                            }
                        }

                        //base = base - discount_total;
                    }

                    var tax_details = {
                        tax: tax_info.tax,
                        rate: tax_info.rate,
                        amount: total,
                        detail: tax
                    }

                    items = {
                        _id: id,
                        order: order._id,
                        product: products.product,
                        category: null,
                        _category: "",
                        subcategory: null,
                        _subcategory: "",
                        product_brand: null,
                        _brand: "",
                        product_model: null,
                        _model: "",
                        source: products.source,
                        part_no: products.part_no,
                        hsn_sac: products.hsn_sac,
                        unit: products.unit,
                        title: products.title,
                        quantity: products.quantity,
                        unit: products.unit,
                        sku: products.sku,
                        mrp: products.mrp,
                        selling_price: products.selling_price,
                        rate: products.rate,
                        base: parseFloat(base.toFixed(2)),
                        discount: products.discount,
                        discount_total: parseFloat(discount_total.toFixed(2)),
                        amount_is_tax: products.amount_is_tax,
                        tax_amount: parseFloat(_.sumBy(tax, x => x.amount).toFixed(2)),
                        amount: parseFloat(amount.toFixed(2)),
                        tax: tax_info.tax,
                        tax_rate: tax_info.rate,
                        tax_info: tax,
                        issued: false,
                        added_by_customer: false,
                        delivery_date: businessOrder.delivery_date,
                        tracking_no: Math.round(+new Date() / 1000) + "-" + Math.ceil((Math.random() * 90000) + 10000),
                        business: products.business,
                        created_at: new Date(),
                        updated_at: new Date()
                    };
                }
            }

            OrderLine.create(items).then(async function (ol) {
                var items = await OrderLine.find({ order: order._id, business: business, status: { $nin: ["Cancelled"] } }).exec();

                if (businessOrder.payment.convenience_charges) {
                    convenience_charges = Math.ceil(businessOrder.payment.convenience_charges);
                }

                var discount = parseFloat(_.sumBy(items, x => x.discount_total).toFixed(2));
                var amount = parseFloat(_.sumBy(items, x => x.amount).toFixed(2));
                var total = amount + discount + convenience_charges;

                var transaction_log = await q.all(fun.getOrderTransaction(order, business));
                var paid_total = transaction_log.paid_total;

                var data = {
                    updated_at: new Date(),
                    "payment.paid_total": paid_total,
                    "payment.amount": parseFloat(amount.toFixed(2)),
                    "payment.discount_total": parseFloat(discount.toFixed(2)),
                    "payment.total": parseFloat(total.toFixed(2)),
                    due: {
                        due: Math.ceil(amount) + convenience_charges - paid_total
                    }
                }

                Order.findOneAndUpdate({ _id: order._id }, { $set: data }, { new: false }, async function (err, doc) {
                    if (err) {
                        res.status(422).json({
                            responseCode: 422,
                            responseMessage: "Server Error",
                            responseData: err
                        });
                    }
                    else {
                        BusinessOrder.findOneAndUpdate({ order: order._id, business: business }, { $set: data }, { new: false }, async function (err, doc) {
                            if (err) {
                                res.status(422).json({
                                    responseCode: 422,
                                    responseMessage: "Server Error",
                                    responseData: err
                                });
                            }
                            else {
                                await BusinessOrder.find({ order: businessOrder.order, business: business })
                                    .populate({ path: 'order', populate: [{ path: 'user', select: 'name contact_no username email account_info ' }, { path: 'car', select: 'title variant registration_no _automaker _model' }, { path: 'address' }] })
                                    .cursor().eachAsync(async (p) => {

                                        var has_invoice = false;
                                        var invoices = await OrderInvoice.find({ order: p.order._id, business: business }).select('status invoice_no').exec();

                                        if (invoices.length > 0) {
                                            has_invoice = true;
                                        }

                                        var orders = {
                                            _id: p.order._id,
                                            id: p.order._id,
                                            items: await q.all(fun.getBusinessOrderItems(p.order._id, business, req.headers['tz'])),
                                            user: p.order.user,
                                            car: p.order.car,
                                            address: p.order.address,
                                            due_date: moment(p.due_date).tz(req.headers['tz']).format('lll'),
                                            delivery_date: moment(p.delivery_date).tz(req.headers['tz']).format('lll'),
                                            time_slot: p.time_slot,
                                            convenience: p.order.convenience,
                                            order_no: p.order.order_no,
                                            address: p.order.address,
                                            payment: p.payment,
                                            due: p.due,
                                            log: p.log,
                                            status: p.status,
                                            has_invoice: has_invoice,
                                            invoices: invoices,
                                            created_at: moment(p.created_at).tz(req.headers['tz']).format('lll'),
                                            updated_at: moment(p.updated_at).tz(req.headers['tz']).format('lll'),
                                        };

                                        res.status(200).json({
                                            responseCode: 200,
                                            responseMessage: "success",
                                            responseData: orders
                                        });
                                    });
                            }
                        });
                    }
                });
            });
        }
        else {
            res.status(200).json({
                responseCode: 200,
                responseMessage: "Add New Item",
                responseData: {}
            });
        }
    }
    else {
        res.status(400).json({
            responseCode: 400,
            responseMessage: "Order not found",
            responseData: {}
        });
    }
});

router.delete('/order/item/remove/', xAccessToken.token, async function (req, res, next) {
    var rules = {
        id: 'required',
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Item required",
            responseData: {
                res: validation.errors.all()
            }
        });
    }
    else {
        var business = req.headers['business'];
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);

        var loggedInDetails = await User.findById(decoded.user).exec();
        var order = await Order.findById(req.body.order).exec();
        if (order) {
            var item = await OrderLine.findOne({ _id: req.body.id, order: order._id }).exec();
            if (item) {
                if (item.issued == false) {
                    if (item.added_by_customer == false) {
                        OrderLine.remove({ _id: item._id }, async function (err) {
                            if (err) {
                                res.status(422).json({
                                    responseCode: 422,
                                    responseMessage: "Server Error",
                                    responseData: err
                                });
                            }
                            else {
                                var businessOrder = await BusinessOrder.findOne({ order: order._id, business: business }).exec();

                                var items = await OrderLine.find({ order: order._id, business: business, status: { $nin: ["Cancelled"] } }).exec();

                                var convenience_charges = 0
                                if (businessOrder.payment.convenience_charges) {
                                    convenience_charges = Math.ceil(businessOrder.payment.convenience_charges);
                                }

                                var discount = parseFloat(_.sumBy(items, x => x.discount_total).toFixed(2));
                                var amount = parseFloat(_.sumBy(items, x => x.amount).toFixed(2));
                                var total = amount + discount + convenience_charges;

                                var transaction_log = await q.all(fun.getOrderTransaction(order, business));
                                var paid_total = transaction_log.paid_total;

                                var data = {
                                    updated_at: new Date(),
                                    "payment.paid_total": paid_total,
                                    "payment.amount": parseFloat(amount.toFixed(2)),
                                    "payment.discount_total": parseFloat(discount.toFixed(2)),
                                    "payment.total": parseFloat(total.toFixed(2)),
                                    due: {
                                        due: Math.ceil(amount) + convenience_charges - paid_total
                                    }
                                }

                                Order.findOneAndUpdate({ _id: businessOrder.order }, { $set: data }, { new: false }, async function (err, doc) {
                                    if (err) {
                                        res.status(422).json({
                                            responseCode: 422,
                                            responseMessage: "Server Error",
                                            responseData: err
                                        });
                                    }
                                    else {
                                        BusinessOrder.findOneAndUpdate({ order: businessOrder.order, business: business }, { $set: data }, { new: false }, async function (err, doc) {
                                            if (err) {
                                                res.status(422).json({
                                                    responseCode: 422,
                                                    responseMessage: "Server Error",
                                                    responseData: err
                                                });
                                            }
                                            else {
                                                await BusinessOrder.find({ order: businessOrder.order, business: business })
                                                    .populate({ path: 'order', populate: [{ path: 'user', select: 'name contact_no username email account_info ' }, { path: 'car', select: 'title variant registration_no _automaker _model' }, { path: 'address' }] })
                                                    .cursor().eachAsync(async (p) => {

                                                        var has_invoice = false;
                                                        var invoices = await OrderInvoice.find({ order: p.order._id, business: business }).select('status invoice_no').exec();

                                                        if (invoices.length > 0) {
                                                            has_invoice = true;
                                                        }

                                                        var orders = {
                                                            _id: p.order._id,
                                                            id: p.order._id,
                                                            items: await q.all(fun.getBusinessOrderItems(p.order._id, business, req.headers['tz'])),
                                                            user: p.order.user,
                                                            car: p.order.car,
                                                            address: p.order.address,
                                                            due_date: moment(p.due_date).tz(req.headers['tz']).format('lll'),
                                                            delivery_date: moment(p.delivery_date).tz(req.headers['tz']).format('lll'),
                                                            time_slot: p.time_slot,
                                                            convenience: p.order.convenience,
                                                            order_no: p.order.order_no,
                                                            address: p.order.address,
                                                            payment: p.payment,
                                                            due: p.due,
                                                            log: p.log,
                                                            status: p.status,
                                                            has_invoice: has_invoice,
                                                            invoices: invoices,
                                                            created_at: moment(p.created_at).tz(req.headers['tz']).format('lll'),
                                                            updated_at: moment(p.updated_at).tz(req.headers['tz']).format('lll'),
                                                        };

                                                        res.status(200).json({
                                                            responseCode: 200,
                                                            responseMessage: "success",
                                                            responseData: orders
                                                        });
                                                    });
                                            }
                                        });
                                    }
                                });
                            }
                        });
                    }
                    else {
                        res.status(400).json({
                            responseCode: 400,
                            responseMessage: "Cannot delete item added by customer",
                            responseData: {}
                        });
                    }
                }
                else {
                    res.status(400).json({
                        responseCode: 400,
                        responseMessage: "Error! This item has been issued from inventory",
                        responseData: {}
                    });
                }
            }
            else {
                res.status(400).json({
                    responseCode: 400,
                    responseMessage: "Item not found",
                    responseData: {}
                });
            }
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Order not found",
                responseData: {}
            });
        }
    }
});

router.delete('/order/item/return', xAccessToken.token, async function (req, res, next) {
    var business = req.headers['business'];
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var date = new Date();
    var loggedInDetails = decoded.user;
    var items = [];
    var data = [];
    var convenience_charges = 0;
    var amount = 0;
    var discount = 0;
    var total = 0;

    var item = await OrderLine.findOne({ _id: req.body.id, status: { $nin: ["Cancelled"] } }).exec();
    var loggedInDetails = await User.findById(decoded.user).exec();
    if (item) {
        var businessOrder = await BusinessOrder.findOne({ order: item.order, business: business }).exec();

        if (item.issued == true) {
            var r = await q.all(orderItemReturn(item));
        }

        var items = await OrderLine.find({ order: item.order, business: business, status: { $nin: ["Cancelled"] } }).exec();
        if (businessOrder.payment.convenience_charges) {
            convenience_charges = Math.ceil(businessOrder.payment.convenience_charges);
        }

        var discount = parseFloat(_.sumBy(items, x => x.discount_total).toFixed(2));
        var amount = parseFloat(_.sumBy(items, x => x.amount).toFixed(2));
        var total = amount + discount + convenience_charges;

        var transaction_log = await q.all(fun.getOrderTransaction(item.order, business));
        var paid_total = transaction_log.paid_total;

        var data = {
            updated_at: new Date(),
            "payment.paid_total": paid_total,
            "payment.amount": parseFloat(amount.toFixed(2)),
            "payment.discount_total": parseFloat(discount.toFixed(2)),
            "payment.total": parseFloat(total.toFixed(2)),
            due: {
                due: Math.ceil(amount) + convenience_charges - paid_total
            }
        }

        Order.findOneAndUpdate({ _id: businessOrder.order }, { $set: data }, { new: false }, async function (err, doc) {
            if (err) {
                res.status(422).json({
                    responseCode: 422,
                    responseMessage: "Server Error",
                    responseData: err
                });
            }
            else {
                BusinessOrder.findOneAndUpdate({ order: businessOrder.order, business: business }, { $set: data }, { new: false }, async function (err, doc) {
                    if (err) {
                        res.status(422).json({
                            responseCode: 422,
                            responseMessage: "Server Error",
                            responseData: err
                        });
                    }
                    else {
                        await BusinessOrder.find({ order: businessOrder.order, business: business })
                            .populate({ path: 'order', populate: [{ path: 'user', select: 'name contact_no username email account_info ' }, { path: 'car', select: 'title variant registration_no _automaker _model' }, { path: 'address' }] })
                            .cursor().eachAsync(async (p) => {

                                var has_invoice = false;
                                var invoices = await OrderInvoice.find({ order: p.order._id, business: business }).select('status invoice_no').exec();

                                if (invoices.length > 0) {
                                    has_invoice = true;
                                }

                                var orders = {
                                    _id: p.order._id,
                                    id: p.order._id,
                                    items: await q.all(fun.getBusinessOrderItems(p.order._id, business, req.headers['tz'])),
                                    user: p.order.user,
                                    car: p.order.car,
                                    address: p.order.address,
                                    due_date: moment(p.due_date).tz(req.headers['tz']).format('lll'),
                                    delivery_date: moment(p.delivery_date).tz(req.headers['tz']).format('lll'),
                                    time_slot: p.time_slot,
                                    convenience: p.order.convenience,
                                    order_no: p.order.order_no,
                                    address: p.order.address,
                                    payment: p.payment,
                                    due: p.due,
                                    log: p.log,
                                    status: p.status,
                                    has_invoice: has_invoice,
                                    invoices: invoices,
                                    created_at: moment(p.created_at).tz(req.headers['tz']).format('lll'),
                                    updated_at: moment(p.updated_at).tz(req.headers['tz']).format('lll'),
                                };

                                res.status(200).json({
                                    responseCode: 200,
                                    responseMessage: "success",
                                    responseData: orders
                                });
                            });
                    }
                });
            }
        });

    }
    else {
        res.status(400).json({
            responseCode: 400,
            responseMessage: "Item not found",
            responseData: {}
        });
    }
});

router.put('/order/item/product/update', xAccessToken.token, async function (req, res, next) {
    var business = req.headers['business'];
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var date = new Date();
    var loggedInDetails = decoded.user;
    var items = [];
    var data = [];

    var item_total = 0;
    var discount = 0;
    var item_total = 0;
    var total = 0;

    var order = await Order.findById(req.body.order).exec();
    var loggedInDetails = await User.findById(decoded.user).exec();
    if (order) {
        var date = new Date();
        var log = {
            status: "Confirmed",
            type: "Counter",
            activity: "Confirmed",
            user: loggedInDetails._id,
            name: loggedInDetails.name,
            created_at: date,
            updated_at: date,
        };

        var products = req.body.item;

        if (products) {
            var tax_info = await Tax.findOne({ tax: products.tax }).exec();
            var orderLine = await OrderLine.findOne({ _id: products.id }).exec();
            if (orderLine) {
                var businessProduct = await BusinessProduct.findOne({ _id: products.product }).exec();
                if (businessProduct) {
                    var tax = [];
                    var rate = products.rate;
                    var amount = products.rate * products.quantity;
                    var tax_rate = tax_info.detail;
                    var discount_total = 0
                    var base = amount

                    var discount = products.discount;

                    if (discount.indexOf("%") >= 0) {
                        discount = parseFloat(discount);
                        if (!isNaN(discount) && discount > 0) {
                            discount_total = amount * (discount / 100);
                            amount = amount - parseFloat(discount_total.toFixed(2))
                        }
                    }
                    else {
                        if (discount == "") {
                            discount = "0"
                        }

                        discount_total = parseFloat(discount);
                        if (!isNaN(discount_total) && discount_total > 0) {
                            amount = amount - parseFloat(discount_total.toFixed(2))
                        }
                    }

                    if (products.amount_is_tax == "exclusive") {
                        var tax_on_amount = amount;
                        if (tax_rate.length > 0) {
                            for (var r = 0; r < tax_rate.length; r++) {
                                if (tax_rate[r].rate != tax_info.rate) {
                                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                                    amount = amount + t;
                                    tax.push({
                                        tax: tax_rate[r].tax,
                                        rate: tax_rate[r].rate,
                                        amount: parseFloat(t.toFixed(2))
                                    })
                                }
                                else {
                                    var t = tax_on_amount * (tax_info.rate / 100);
                                    amount = amount + t;
                                    tax.push({
                                        tax: tax_info.tax, tax_rate: tax_info.rate,
                                        rate: tax_info.rate,
                                        amount: parseFloat(t.toFixed(2))
                                    })
                                }
                            }
                        }
                    }

                    if (products.amount_is_tax == "inclusive") {
                        var x = (100 + tax_info.rate) / 100;
                        var tax_on_amount = amount / x;
                        if (tax_rate.length > 0) {
                            for (var r = 0; r < tax_rate.length; r++) {
                                if (tax_rate[r].rate != tax_info.rate) {
                                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                                    base = base - t;
                                    tax.push({
                                        tax: tax_rate[r].tax,
                                        rate: tax_rate[r].rate,
                                        amount: parseFloat(t.toFixed(2))
                                    });
                                }
                                else {
                                    var t = amount - tax_on_amount;
                                    base = base - t;
                                    tax.push({
                                        tax: tax_info.tax,
                                        rate: tax_info.rate,
                                        amount: parseFloat(t.toFixed(2))
                                    });
                                }
                            }
                        }

                        //base =base- discount_total;
                    }

                    var tax_details = {
                        tax: tax_info.tax,
                        rate: tax_info.rate,
                        amount: total,
                        detail: tax
                    }

                    var item = {
                        order: order._id,
                        product: businessProduct._id,
                        category: businessProduct.category,
                        _category: businessProduct._category,
                        subcategory: businessProduct.subcategory,
                        _subcategory: businessProduct._subcategory,
                        product_brand: businessProduct.product_brand,
                        _brand: businessProduct.product_brand,
                        product_model: businessProduct.product_model,
                        _model: businessProduct.product_model,
                        source: businessProduct.source,
                        status: orderLine.status,
                        part_no: products.part_no,
                        hsn_sac: products.hsn_sac,
                        unit: products.unit,
                        title: products.title,
                        sku: products.sku,
                        mrp: products.mrp,
                        selling_price: products.selling_price,
                        rate: products.rate,
                        quantity: products.quantity,
                        base: parseFloat(base.toFixed(2)),
                        amount: amount,
                        discount: products.discount,
                        discount_total: parseFloat(discount_total.toFixed(2)),
                        amount_is_tax: products.amount_is_tax,
                        tax_amount: parseFloat(_.sumBy(tax, x => x.amount).toFixed(2)),
                        amount: parseFloat(amount.toFixed(2)),
                        tax: tax_info.tax,
                        tax_rate: tax_info.rate,
                        tax_info: tax,
                        issued: products.issued,
                        business: business,
                        updated_at: new Date()
                    };

                    OrderLine.findOneAndUpdate({ _id: orderLine._id }, { $set: item }, { new: false }, async function (err, doc) {
                        if (err) {
                            return res.status(422).json({
                                responseCode: 422,
                                responseMessage: "Server Error",
                                responseData: err
                            });
                        }
                    });
                }
                else {
                    return res.status(400).json({
                        responseCode: 400,
                        responseMessage: "Product not found",
                        responseData: {}
                    });
                }
            }
            else {
                return res.status(400).json({
                    responseCode: 400,
                    responseMessage: "Item not found",
                    responseData: {}
                });
            }
        }
        else {
            return res.status(400).json({
                responseCode: 400,
                responseMessage: "Items not found",
                responseData: {}
            });
        }

        var businessOrder = await BusinessOrder.findOne({ order: order._id, business: business }).exec();
        var items = await OrderLine.find({ order: order._id, business: business, status: { $nin: ['Cancelled'] } }).exec();

        var convenience_charges = 0;
        if (businessOrder.payment.convenience_charges) {
            convenience_charges = Math.ceil(businessOrder.payment.convenience_charges)
        }

        var amount = _.sumBy(items, x => x.amount);
        var discount = _.sumBy(items, x => x.discount_total);
        var total = amount + discount + convenience_charges;

        var transaction_log = await q.all(fun.getOrderTransaction(order, business));
        var paid_total = transaction_log.paid_total;

        var data = {
            updated_at: new Date(),
            "payment.paid_total": paid_total,
            "payment.amount": parseFloat(amount.toFixed(2)),
            "payment.discount_total": parseFloat(discount.toFixed(2)),
            "payment.total": parseFloat(total.toFixed(2)),
            "due": {
                due: Math.ceil(amount) + Math.ceil(convenience_charges) - paid_total
            }
        }

        Order.findOneAndUpdate({ _id: businessOrder.order }, { $set: data }, { new: false }, async function (err, doc) {
            if (err) {
                res.status(422).json({
                    responseCode: 422,
                    responseMessage: "Server Error",
                    responseData: err
                });
            }
            else {
                BusinessOrder.findOneAndUpdate({ order: businessOrder.order, business: business }, { $set: data }, { new: false }, async function (err, doc) {
                    if (err) {
                        res.status(422).json({
                            responseCode: 422,
                            responseMessage: "Server Error",
                            responseData: err
                        });
                    }
                    else {
                        await BusinessOrder.find({ order: businessOrder.order, business: business })
                            .populate({ path: 'order', populate: [{ path: 'user', select: 'name contact_no username email account_info ' }, { path: 'car', select: 'title variant registration_no _automaker _model' }, { path: 'address' }] })
                            .cursor().eachAsync(async (p) => {
                                var has_invoice = false;
                                var invoices = await OrderInvoice.find({ order: p.order._id, business: business }).select('status invoice_no').exec();

                                if (invoices.length > 0) {
                                    has_invoice = true;
                                }
                                var orders = {
                                    _id: p.order._id,
                                    id: p.order._id,
                                    items: await q.all(fun.getBusinessOrderItems(p.order._id, business, req.headers['tz'])),
                                    user: p.order.user,
                                    car: p.order.car,
                                    address: p.order.address,
                                    due_date: moment(p.due_date).tz(req.headers['tz']).format('lll'),
                                    delivery_date: moment(p.delivery_date).tz(req.headers['tz']).format('lll'),
                                    time_slot: p.time_slot,
                                    convenience: p.order.convenience,
                                    order_no: p.order.order_no,
                                    address: p.order.address,
                                    payment: p.payment,
                                    due: p.due,
                                    log: p.log,
                                    status: p.status,
                                    has_invoice: has_invoice,
                                    invoices: invoices,
                                    created_at: moment(p.created_at).tz(req.headers['tz']).format('lll'),
                                    updated_at: moment(p.updated_at).tz(req.headers['tz']).format('lll'),
                                };

                                res.status(200).json({
                                    responseCode: 200,
                                    responseMessage: "success",
                                    responseData: orders
                                });
                            });
                    }
                });
            }
        });
    }
    else {
        res.status(400).json({
            responseCode: 400,
            responseMessage: "Order not found",
            responseData: {}
        });
    }
});

router.put('/order/update', xAccessToken.token, async function (req, res, next) {
    var business = req.headers['business'];
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var date = new Date();
    var loggedInDetails = decoded.user;
    var items = [];
    var data = [];

    var item_total = 0;
    var discount = 0;
    var item_total = 0;
    var total = 0;

    var order = await Order.findById(req.body.order).exec();
    var loggedInDetails = await User.findById(decoded.user).exec();
    if (order) {
        var date = new Date();

        var log = {
            status: "Confirmed",
            type: "Counter",
            activity: "Confirmed",
            user: loggedInDetails._id,
            name: loggedInDetails.name,
            created_at: date,
            updated_at: date,
        }

        var products = req.body.items;

        if (products.length > 0) {
            for (var p = 0; p < products.length; p++) {
                var category = null;
                var _category = "";
                var subcategory = null;
                var _subcategory = "";
                var product_brand = null;
                var _brand = "";
                var product_model = null;
                var _model = "";
                var source = null;

                var tax_info = await Tax.findOne({ tax: products[p].tax }).exec();
                if (products[p].product) {
                    var businessProduct = await BusinessProduct.findById(products[p].product).exec();
                    if (businessProduct) {
                        category = businessProduct.category;
                        _category = businessProduct._category;
                        subcategory = businessProduct.subcategory;
                        _subcategory = businessProduct._subcategory;
                        product_brand = businessProduct.product_brand;
                        _brand = businessProduct._product_brand;
                        product_model = businessProduct.product_model;
                        _model = businessProduct._product_model;
                        source = businessProduct.product;
                    }
                }


                var orderLine = await OrderLine.findOne({ _id: products[p].id }).exec();
                if (orderLine) {
                    var tax = [];
                    var rate = products[p].rate;
                    var amount = products[p].rate * products[p].quantity;
                    var tax_rate = tax_info.detail;
                    var discount_total = 0;
                    var base = amount

                    var discount = products[p].discount;

                    if (discount.indexOf("%") >= 0) {
                        discount = parseFloat(discount);
                        if (!isNaN(discount) && discount > 0) {
                            var discount_total = amount * (discount / 100);
                            amount = amount - parseFloat(discount_total.toFixed(2))
                        }
                    }
                    else {
                        if (discount == "") {
                            discount = "0"
                        }

                        discount_total = parseFloat(discount);
                        if (!isNaN(discount_total) && discount_total > 0) {
                            amount = amount - parseFloat(discount_total.toFixed(2))
                        }
                    }

                    if (products[p].amount_is_tax == "exclusive") {
                        var tax_on_amount = amount;
                        if (tax_rate.length > 0) {
                            for (var r = 0; r < tax_rate.length; r++) {
                                if (tax_rate[r].rate != tax_info.rate) {
                                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                                    amount = amount + t;
                                    tax.push({
                                        tax: tax_rate[r].tax,
                                        rate: tax_rate[r].rate,
                                        amount: parseFloat(t.toFixed(2))
                                    })
                                }
                                else {
                                    var t = tax_on_amount * (tax_info.rate / 100);
                                    amount = amount + t;
                                    tax.push({
                                        tax: tax_info.tax, tax_rate: tax_info.rate,
                                        rate: tax_info.rate,
                                        amount: parseFloat(t.toFixed(2))
                                    })
                                }
                            }
                        }
                    }

                    if (products[p].amount_is_tax == "inclusive") {
                        var x = (100 + tax_info.rate) / 100;
                        var tax_on_amount = amount / x;
                        if (tax_rate.length > 0) {
                            for (var r = 0; r < tax_rate.length; r++) {
                                if (tax_rate[r].rate != tax_info.rate) {
                                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                                    base = base - t;
                                    tax.push({
                                        tax: tax_rate[r].tax,
                                        rate: tax_rate[r].rate,
                                        amount: parseFloat(t.toFixed(2))
                                    });
                                }
                                else {
                                    var t = amount - tax_on_amount;
                                    base = base - t;
                                    tax.push({
                                        tax: tax_info.tax,
                                        rate: tax_info.rate,
                                        amount: parseFloat(t.toFixed(2))
                                    });
                                }
                            }
                        }

                        //base = base - discount_total;
                    }

                    var tax_details = {
                        tax: tax_info.tax,
                        rate: tax_info.rate,
                        amount: total,
                        detail: tax
                    }

                    var item = {
                        order: order._id,
                        product: products[p].product,
                        category: category,
                        _category: _category,
                        subcategory: subcategory,
                        _subcategory: _subcategory,
                        product_brand: product_brand,
                        _brand: _brand,
                        product_model: product_model,
                        _model: _model,
                        source: source,
                        status: orderLine.status,
                        part_no: products[p].part_no,
                        unit: products[p].unit,
                        hsn_sac: products[p].hsn_sac,
                        title: products[p].title,
                        sku: products[p].sku,
                        mrp: products[p].mrp,
                        selling_price: products[p].selling_price,
                        rate: products[p].rate,
                        quantity: products[p].quantity,
                        base: parseFloat(base.toFixed(2)),
                        amount: amount,
                        discount: products[p].discount,
                        discount_total: parseFloat(discount_total.toFixed(2)),
                        amount_is_tax: products[p].amount_is_tax,
                        tax_amount: parseFloat(_.sumBy(tax, x => x.amount).toFixed(2)),
                        amount: parseFloat(amount.toFixed(2)),
                        tax: tax_info.tax,
                        tax_rate: tax_info.rate,
                        tax_info: tax,
                        issued: products[p].issued,
                        business: business,
                        updated_at: new Date()
                    };

                    OrderLine.findOneAndUpdate({ _id: products[p].id }, { $set: item }, { new: false }, async function (err, doc) {
                    });
                }
                else {
                    return res.status(400).json({
                        responseCode: 400,
                        responseMessage: "Item not found",
                        responseData: {}
                    });
                }
            }
        }
        else {
            return res.status(400).json({
                responseCode: 400,
                responseMessage: "Items not found",
                responseData: {}
            });
        }

        var businessOrder = await BusinessOrder.findOne({ order: order._id, business: business }).exec();
        var items = await OrderLine.find({ order: order._id, business: business, status: { $nin: ['Cancelled'] } }).exec();

        var convenience_charges = 0;
        if (req.body.convenience_charges) {
            convenience_charges = Math.ceil(req.body.convenience_charges)
        }
        else {
            if (businessOrder.payment.convenience_charges) {
                convenience_charges = Math.ceil(businessOrder.payment.convenience_charges)
            }
        }

        var amount = _.sumBy(items, x => x.amount);
        var discount = _.sumBy(items, x => x.discount_total);
        var total = amount + discount + convenience_charges;

        var transaction_log = await q.all(fun.getOrderTransaction(order, business));
        var paid_total = transaction_log.paid_total;

        var data = {
            convenience: req.body.convenience,
            updated_at: new Date(),
            "payment.paid_total": paid_total,
            "payment.convenience_charges": convenience_charges,
            "payment.amount": parseFloat(amount.toFixed(2)),
            "payment.discount_total": parseFloat(discount.toFixed(2)),
            "payment.total": parseFloat(total.toFixed(2)),
            "due": {
                due: Math.ceil(amount) + Math.ceil(convenience_charges) - paid_total
            }
        }

        Order.findOneAndUpdate({ _id: businessOrder.order }, { $set: data }, { new: false }, async function (err, doc) {
            if (err) {
                res.status(422).json({
                    responseCode: 422,
                    responseMessage: "Server Error",
                    responseData: err
                });
            }
            else {
                BusinessOrder.findOneAndUpdate({ order: businessOrder.order, business: business }, { $set: data }, { new: false }, async function (err, doc) {
                    if (err) {
                        res.status(422).json({
                            responseCode: 422,
                            responseMessage: "Server Error",
                            responseData: err
                        });
                    }
                    else {
                        await BusinessOrder.find({ order: businessOrder.order, business: business })
                            .populate({ path: 'order', populate: [{ path: 'user', select: 'name contact_no username email account_info ' }, { path: 'car', select: 'title variant registration_no _automaker _model' }, { path: 'address' }] })
                            .cursor().eachAsync(async (p) => {
                                var has_invoice = false;
                                var invoices = await OrderInvoice.find({ order: p.order._id, business: business }).select('status invoice_no').exec();

                                if (invoices.length > 0) {
                                    has_invoice = true;
                                }
                                var orders = {
                                    _id: p.order._id,
                                    id: p.order._id,
                                    items: await q.all(fun.getBusinessOrderItems(p.order._id, business, req.headers['tz'])),
                                    user: p.order.user,
                                    car: p.order.car,
                                    address: p.order.address,
                                    due_date: moment(p.due_date).tz(req.headers['tz']).format('lll'),
                                    delivery_date: moment(p.delivery_date).tz(req.headers['tz']).format('lll'),
                                    time_slot: p.time_slot,
                                    convenience: p.order.convenience,
                                    order_no: p.order.order_no,
                                    address: p.order.address,
                                    payment: p.payment,
                                    due: p.due,
                                    log: p.log,
                                    has_invoice: has_invoice,
                                    invoices: invoices,
                                    status: p.status,
                                    created_at: moment(p.created_at).tz(req.headers['tz']).format('lll'),
                                    updated_at: moment(p.updated_at).tz(req.headers['tz']).format('lll'),
                                };

                                res.status(200).json({
                                    responseCode: 200,
                                    responseMessage: "success",
                                    responseData: orders
                                });
                            });
                    }
                });
            }
        });
    }
    else {
        res.status(400).json({
            responseCode: 400,
            responseMessage: "Order not found",
            responseData: {}
        });
    }
});

router.put('/order/items/dispatch', xAccessToken.token, async function (req, res, next) {
    var business = req.headers['business'];
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var date = new Date();
    var loggedInDetails = decoded.user;
    var items = [];
    var data = [];

    var item_total = 0;
    var discount = 0;
    var item_total = 0;
    var total = 0;

    var order = await Order.findById(req.body.order).exec();
    var loggedInDetails = await User.findById(decoded.user).exec();
    if (order) {
        var date = new Date();
        var availablity = false;
        var log = {
            status: "Confirmed",
            type: "Counter",
            activity: "Confirmed",
            user: loggedInDetails._id,
            name: loggedInDetails.name,
            created_at: date,
            updated_at: date,
        }


        var products = req.body.items;

        var oids = _.map(products, 'product');
        var productCount = 0;
        for (var o = 0; o < oids.length; o++) {
            var checkExist = await BusinessProduct.find({ _id: oids[o], business: business }).exec();
            if (checkExist) {
                productCount = productCount + 1;
            }
        }

        if (products.length == productCount) {
            for (var p = 0; p < products.length; p++) {
                var tax_info = await Tax.findOne({ tax: products[p].tax }).exec();
                var orderLine = await OrderLine.findOne({ _id: products[p].id, status: { $nin: ["Cancelled"] } }).exec();
                if (orderLine) {
                    if (orderLine.issued == false) {
                        var available = await BusinessProduct.findOne({ _id: products[p].product, "stock.available": { $gte: products[p].quantity } }).exec();
                        if (available) {
                            availablity = true;
                        }
                        else {
                            availablity = false;
                        }
                    }
                    else {
                        availablity = true;
                    }


                    var tax = [];
                    var rate = products[p].rate;
                    var amount = products[p].rate * products[p].quantity;
                    var tax_rate = tax_info.detail;
                    var discount_total = 0;
                    var base = amount

                    var discount = products[p].discount;

                    if (discount.indexOf("%") >= 0) {
                        discount = parseFloat(discount);
                        if (!isNaN(discount) && discount > 0) {
                            var discount_total = amount * (discount / 100);
                            amount = amount - parseFloat(discount_total.toFixed(2))
                        }
                    }
                    else {
                        if (discount == "") {
                            discount = "0"
                        }

                        discount_total = parseFloat(discount);
                        if (!isNaN(discount_total) && discount_total > 0) {
                            amount = amount - parseFloat(discount_total.toFixed(2))
                        }
                    }

                    if (products[p].amount_is_tax == "exclusive") {
                        var tax_on_amount = amount;
                        if (tax_rate.length > 0) {
                            for (var r = 0; r < tax_rate.length; r++) {
                                if (tax_rate[r].rate != tax_info.rate) {
                                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                                    amount = amount + t;
                                    tax.push({
                                        tax: tax_rate[r].tax,
                                        rate: tax_rate[r].rate,
                                        amount: parseFloat(t.toFixed(2))
                                    })
                                }
                                else {
                                    var t = tax_on_amount * (tax_info.rate / 100);
                                    amount = amount + t;
                                    tax.push({
                                        tax: tax_info.tax, tax_rate: tax_info.rate,
                                        rate: tax_info.rate,
                                        amount: parseFloat(t.toFixed(2))
                                    })
                                }
                            }
                        }
                    }

                    if (products[p].amount_is_tax == "inclusive") {
                        var x = (100 + tax_info.rate) / 100;
                        var tax_on_amount = amount / x;
                        if (tax_rate.length > 0) {
                            for (var r = 0; r < tax_rate.length; r++) {
                                if (tax_rate[r].rate != tax_info.rate) {
                                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                                    base = base - t;
                                    tax.push({
                                        tax: tax_rate[r].tax,
                                        rate: tax_rate[r].rate,
                                        amount: parseFloat(t.toFixed(2))
                                    });
                                }
                                else {
                                    var t = amount - tax_on_amount;
                                    base = base - t;
                                    tax.push({
                                        tax: tax_info.tax,
                                        rate: tax_info.rate,
                                        amount: parseFloat(t.toFixed(2))
                                    });
                                }
                            }
                        }
                        //base = base - discount_total;
                    }

                    var tax_details = {
                        tax: tax_info.tax,
                        rate: tax_info.rate,
                        amount: total,
                        detail: tax
                    }

                    var item = {
                        order: order._id,
                        product: orderLine.product,
                        category: orderLine.category,
                        _category: orderLine._category,
                        subcategory: orderLine.subcategory,
                        _subcategory: orderLine._subcategory,
                        product_brand: orderLine.product_brand,
                        _brand: orderLine.product_brand,
                        product_model: orderLine.product_model,
                        _model: orderLine.product_model,
                        source: orderLine.source,
                        status: orderLine.status,
                        part_no: orderLine.part_no,
                        hsn_sac: products[p].hsn_sac,
                        title: products[p].title,
                        sku: products[p].sku,
                        mrp: products[p].mrp,
                        selling_price: products[p].selling_price,
                        rate: products[p].rate,
                        unit: products[p].unit,
                        quantity: products[p].quantity,
                        base: parseFloat(base.toFixed(2)),
                        discount: products[p].discount,
                        discount_total: parseFloat(discount_total.toFixed(2)),
                        amount_is_tax: products[p].amount_is_tax,
                        tax_amount: parseFloat(_.sumBy(tax, x => x.amount).toFixed(2)),
                        amount: parseFloat(amount.toFixed(2)),
                        tax: tax_info.tax,
                        tax_rate: tax_info.rate,
                        tax_info: tax,
                        issued: products[p].issued,
                        business: business,
                        updated_at: new Date()
                    };

                    OrderLine.findOneAndUpdate({ _id: products[p].id }, { $set: item }, { new: false }, async function (err, doc) {
                        if (err) {
                            return res.status(422).json({
                                responseCode: 422,
                                responseMessage: "Server Error",
                                responseData: err
                            });
                        }
                    });
                }
                else {
                    return res.status(400).json({
                        responseCode: 400,
                        responseMessage: "Items not found",
                        responseData: {}
                    });
                }
            }
        }
        else {
            return res.status(400).json({
                responseCode: 400,
                responseInfo: {
                    0: products.length,
                    1: checkExist.length
                },
                responseMessage: "Please check all items availablity before dispatching them",
                responseData: {}
            });
        }


        var businessOrder = await BusinessOrder.findOne({ order: order._id, business: business }).exec();

        var items = await OrderLine.find({ order: order._id, business: business, status: { $nin: ['Cancelled'] } }).exec();
        var convenience_charges = 0;
        if (businessOrder.payment.convenience_charges) {
            convenience_charges = Math.ceil(businessOrder.payment.convenience_charges)
        }

        var amount = _.sumBy(items, x => x.amount);
        var discount = _.sumBy(items, x => x.discount_total);
        var total = amount + discount + convenience_charges;

        var transaction_log = await q.all(fun.getOrderTransaction(order, business));
        var paid_total = transaction_log.paid_total;

        if (availablity == true) {
            var a = await q.all(orderItemDeduct(order._id, business));
            if (a == true) {
                var message = "Items dispatched";
                var status = "Dispatched";
                var status_code = 200;
                OrderLine.update({ order: order._id, business: business }, { $set: { status: status } }, { multi: true }, async function (err, doc) {
                    if (err) {
                        return res.status(422).json({
                            responseCode: 422,
                            responseMessage: "Server Error",
                            responseData: err
                        });
                    }
                });
            }
            else {
                var message = "Please check all items availablity before dispatching them";
                var status = "Confirmed";
                var status_code = 422;
            }
        }
        else {
            var message = "Please check all items availablity before dispatching them";
            var status = "Confirmed";
            var status_code = 422;
        }

        var data = {
            updated_at: new Date(),
            "payment.paid_total": paid_total,
            "payment.amount": parseFloat(amount.toFixed(2)),
            "payment.discount_total": parseFloat(discount.toFixed(2)),
            "payment.total": parseFloat(total.toFixed(2)),
            "status": status,
            "due": {
                due: Math.ceil(amount) + Math.ceil(convenience_charges) - paid_total
            }
        }

        Order.findOneAndUpdate({ _id: order._id }, { $set: data }, { new: false }, async function (err, doc) {
            if (err) {
                res.status(422).json({
                    responseCode: 422,
                    responseMessage: "Server Error",
                    responseData: err
                });
            }
            else {
                BusinessOrder.findOneAndUpdate({ order: order._id, business: business }, { $set: data }, { new: false }, async function (err, doc) {
                    if (err) {
                        res.status(422).json({
                            responseCode: 422,
                            responseMessage: "Server Error",
                            responseData: err
                        });
                    }
                    else {
                        await BusinessOrder.find({ order: businessOrder.order, business: business })
                            .populate({ path: 'order', populate: [{ path: 'user', select: 'name contact_no username email account_info ' }, { path: 'car', select: 'title variant registration_no _automaker _model' }, { path: 'address' }] })
                            .cursor().eachAsync(async (p) => {
                                var has_invoice = false;
                                var invoices = await OrderInvoice.find({ order: p.order._id, business: business }).select('status invoice_no').exec();

                                if (invoices.length > 0) {
                                    has_invoice = true;
                                }
                                var orders = {
                                    _id: p.order._id,
                                    id: p.order._id,
                                    items: await q.all(fun.getBusinessOrderItems(p.order._id, business, req.headers['tz'])),
                                    user: p.order.user,
                                    car: p.order.car,
                                    address: p.order.address,
                                    due_date: moment(p.due_date).tz(req.headers['tz']).format('lll'),
                                    delivery_date: moment(p.delivery_date).tz(req.headers['tz']).format('lll'),
                                    time_slot: p.time_slot,
                                    convenience: p.order.convenience,
                                    order_no: p.order.order_no,
                                    address: p.order.address,
                                    payment: p.payment,
                                    due: p.due,
                                    log: p.log,
                                    has_invoice: has_invoice,
                                    invoices: invoices,
                                    status: p.status,
                                    created_at: moment(p.created_at).tz(req.headers['tz']).format('lll'),
                                    updated_at: moment(p.updated_at).tz(req.headers['tz']).format('lll'),
                                };

                                res.status(status_code).json({
                                    responseCode: status_code,
                                    responseMessage: message,
                                    responseData: orders
                                });
                            });
                    }
                });
            }
        });
    }
    else {
        res.status(400).json({
            responseCode: 400,
            responseMessage: "Order not found",
            responseData: {}
        });
    }
});

router.put('/order/due-date/update', xAccessToken.token, async function (req, res, next) {
    var rules = {
        order: 'required',
        due_date: 'required',
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Due Date required",
            responseData: {
                res: validation.errors.all()
            }
        });
    }
    else {
        var business = req.headers['business'];
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var date = new Date();
        var loggedInDetails = decoded.user;
        var items = [];
        var data = [];

        var item_total = 0;
        var discount = 0;
        var item_total = 0;
        var total = 0;

        var order = await Order.findById(req.body.order).exec();
        var loggedInDetails = await User.findById(decoded.user).exec();
        if (order) {
            var due_date = new Date(req.body.due_date).toISOString();

            BusinessOrder.findOneAndUpdate({ order: order._id, business: business }, { $set: { due_date: due_date } }, { new: false }, async function (err, doc) {
                if (err) {
                    res.status(422).json({
                        responseCode: 422,
                        responseMessage: "Server Error",
                        responseData: err
                    });
                }
                else {
                    res.status(200).json({
                        responseCode: 200,
                        responseMessage: "Saved",
                        responseData: {
                            due_date: moment(due_date).tz(req.headers['tz']).format("YYYY-MM-DD")
                        }
                    });
                }
            });
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Order not found",
                responseData: {}
            });
        }
    }
});

router.put('/order/delivery-date/update', xAccessToken.token, async function (req, res, next) {
    var rules = {
        order: 'required',
        delivery_date: 'required',
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Due Date required",
            responseData: {
                res: validation.errors.all()
            }
        });
    }
    else {
        var business = req.headers['business'];
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var date = new Date();
        var loggedInDetails = decoded.user;
        var items = [];
        var data = [];

        var item_total = 0;
        var discount = 0;
        var item_total = 0;
        var total = 0;

        var order = await Order.findById(req.body.order).exec();
        var loggedInDetails = await User.findById(decoded.user).exec();
        if (order) {
            var delivery_date = new Date(req.body.delivery_date).toISOString();

            BusinessOrder.findOneAndUpdate({ order: order._id, business: business }, { $set: { delivery_date: delivery_date } }, { new: false }, async function (err, doc) {
                if (err) {
                    res.status(422).json({
                        responseCode: 422,
                        responseMessage: "Server Error",
                        responseData: err
                    });
                }
                else {
                    OrderLine.update({ order: order._id, business: business }, { $set: { delivery_date: delivery_date } }, { multi: true }, async function (err, doc) {
                        if (err) {
                            res.status(422).json({
                                responseCode: 422,
                                responseMessage: "Server Error",
                                responseData: err
                            });
                        }
                        else {
                            res.status(200).json({
                                responseCode: 200,
                                responseMessage: "Saved",
                                responseData: {
                                    delivery_date: moment(delivery_date).tz(req.headers['tz']).format("YYYY-MM-DD")
                                }
                            });
                        }
                    });
                }
            });
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Order not found",
                responseData: {}
            });
        }
    }
});

router.put('/order/car/update', xAccessToken.token, async function (req, res, next) {
    var rules = {
        order: 'required',
        car: 'required',
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Due Date required",
            responseData: {
                res: validation.errors.all()
            }
        });
    }
    else {
        var business = req.headers['business'];
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var date = new Date();
        var loggedInDetails = decoded.user;
        var items = [];
        var data = [];

        var item_total = 0;
        var discount = 0;
        var item_total = 0;
        var total = 0;

        var order = await Order.findById(req.body.order).exec();
        var loggedInDetails = await User.findById(decoded.user).exec();
        if (order) {
            var car = await Variant.findOne({ _id: req.body.car }).exec();
            if (car) {
                Order.findOneAndUpdate({ _id: order._id }, { $set: { car: car._id } }, { new: false }, async function (err, doc) {
                    if (err) {
                        res.status(422).json({
                            responseCode: 422,
                            responseMessage: "Server Error",
                            responseData: err
                        });
                    }
                    else {
                        res.status(200).json({
                            responseCode: 200,
                            responseMessage: "Saved",
                            responseData: {
                                car: car
                            }
                        });
                    }
                });
            }
            else {
                res.status(400).json({
                    responseCode: 400,
                    responseMessage: "Car not found",
                    responseData: {}
                });
            }
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Order not found",
                responseData: {}
            });
        }
    }
});

router.put('/order/address/update', xAccessToken.token, async function (req, res, next) {
    var rules = {
        order: 'required',
        address: 'required',
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Due Date required",
            responseData: {
                res: validation.errors.all()
            }
        });
    }
    else {
        var business = req.headers['business'];
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var date = new Date();
        var loggedInDetails = decoded.user;
        var items = [];
        var data = [];

        var item_total = 0;
        var discount = 0;
        var item_total = 0;
        var total = 0;

        var order = await Order.findById(req.body.order).exec();
        var loggedInDetails = await User.findById(decoded.user).exec();
        if (order) {
            var address = await Address.findOne({ _id: req.body.address, user: order.user }).exec();
            if (address) {
                Order.findOneAndUpdate({ _id: order._id }, { $set: { address: address._id } }, { new: false }, async function (err, doc) {
                    if (err) {
                        res.status(422).json({
                            responseCode: 422,
                            responseMessage: "Server Error",
                            responseData: err
                        });
                    }
                    else {
                        res.status(200).json({
                            responseCode: 200,
                            responseMessage: "Saved",
                            responseData: {
                                address: address
                            }
                        });
                    }
                });
            }
            else {
                res.status(400).json({
                    responseCode: 400,
                    responseMessage: "Address not found",
                    responseData: {

                    }
                });
            }
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Order not found",
                responseData: {}
            });
        }
    }
});

router.get('/order/convenience/get', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var business = req.headers['business'];
    var conveniences = [];

    var check = await OrderConvenience.find({ business: business }).count().exec();
    if (check > 0) {
        await OrderConvenience.find({ business: business })
            .cursor()
            .eachAsync(async function (p) {
                conveniences.push({
                    _id: p._id,
                    _id: p._id,
                    convenience: p.convenience,
                    chargeable: p.chargeable,
                    charges: p.charges,
                });
            });
    }
    else {
        await OrderConvenience.find({ business: null })
            .cursor()
            .eachAsync(async function (p) {
                conveniences.push({
                    _id: p._id,
                    _id: p._id,
                    convenience: p.convenience,
                    chargeable: p.chargeable,
                    charges: p.charges,
                });
            });
    }

    res.status(200).json({
        responseCode: 200,
        responseMessage: "",
        responseData: conveniences
    })
});

router.put('/order/convenience/update', xAccessToken.token, async function (req, res, next) {
    var rules = {
        order: 'required',
        convenience: 'required',
        convenience_charges: 'required',
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Due Date required",
            responseData: {
                res: validation.errors.all()
            }
        });
    }
    else {
        var business = req.headers['business'];
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var date = new Date();
        var loggedInDetails = decoded.user;
        var items = [];
        var data = [];

        var item_total = 0;
        var discount = 0;
        var item_total = 0;
        var total = 0;

        var order = await Order.findById(req.body.order).exec();
        var loggedInDetails = await User.findById(decoded.user).exec();
        if (order) {
            var convenience_charges = 0;
            var items = await OrderLine.find({ order: order._id, business: business, status: { $nin: ["Cancelled"] } }).exec();
            if (req.body.convenience_charges) {
                convenience_charges = Math.ceil(req.body.convenience_charges);
            }

            var discount = parseFloat(_.sumBy(items, x => x.discount_total).toFixed(2));
            var amount = parseFloat(_.sumBy(items, x => x.amount).toFixed(2));
            var total = amount + discount + convenience_charges;

            var transaction_log = await q.all(fun.getOrderTransaction(order._id, business));
            var paid_total = transaction_log.paid_total;

            var data = {
                updated_at: new Date(),
                "payment.paid_total": paid_total,
                "payment.amount": parseFloat(amount.toFixed(2)),
                "payment.discount_total": parseFloat(discount.toFixed(2)),
                "payment.convenience_charges": parseFloat(convenience_charges.toFixed(2)),
                "payment.total": parseFloat(total.toFixed(2)),
                "convenience": req.body.convenience,
                due: {
                    due: Math.ceil(amount) + convenience_charges - paid_total
                }
            }

            Order.findOneAndUpdate({ _id: order._id }, { $set: data }, { new: false }, async function (err, doc) {
                if (err) {
                    res.status(422).json({
                        responseCode: 422,
                        responseMessage: "Server Error",
                        responseData: err
                    });
                }
                else {

                    BusinessOrder.findOneAndUpdate({ order: order._id, business: business }, { $set: data }, { new: false }, async function (err, doc) {
                        if (err) {
                            res.status(422).json({
                                responseCode: 422,
                                responseMessage: "Server Error",
                                responseData: err
                            });
                        }
                        else {
                            var p = await BusinessOrder.findOne({ order: order._id, business: business })
                                .populate({
                                    path: 'order',
                                    populate: [
                                        { path: 'user', select: 'name contact_no username email account_info' },
                                        { path: 'car', select: 'title variant registration_no _automaker _model' },
                                        { path: 'address' }
                                    ]
                                })
                                .exec();

                            res.status(200).json({
                                responseCode: 200,
                                responseMessage: "success",
                                responseData: {
                                    _id: p.order._id,
                                    id: p.order._id,
                                    items: await q.all(fun.getBusinessOrderItems(p.order._id, business, req.headers['tz'])),
                                    user: p.order.user,
                                    car: p.order.car,
                                    address: p.order.address,
                                    due_date: moment(p.due_date).tz(req.headers['tz']).format('lll'),
                                    delivery_date: moment(p.delivery_date).tz(req.headers['tz']).format('lll'),
                                    time_slot: p.time_slot,
                                    convenience: p.convenience,
                                    order_no: p.order_no,
                                    address: p.order.address,
                                    payment: p.payment,
                                    status: p.status,
                                    due: p.due,
                                    log: p.log,
                                    created_at: moment(p.created_at).tz(req.headers['tz']).format('lll'),
                                    updated_at: moment(p.updated_at).tz(req.headers['tz']).format('lll'),
                                }
                            });
                        }
                    });
                }
            });

        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Order not found",
                responseData: {}
            });
        }
    }
});

router.get('/order/payments/log', xAccessToken.token, async function (req, res, next) {
    var business = req.headers['business'];
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    var order = await Order.findById(req.query.order).exec();
    if (order) {
        var logs = [];
        await TransactionLog.find({ source: req.query.order, business: business })
            .sort({ updated_at: -1 })
            .cursor().eachAsync(async (log) => {
                logs.push({
                    _id: log._id,
                    id: log._id,
                    activity: log.activity,
                    payment_mode: log.payment_mode,
                    paid_total: log.paid_total,
                    payment_status: log.payment_status,
                    transaction_id: log.transaction_id,
                    transaction_date: log.transaction_date,
                    transaction_status: log.transaction_status,
                    transaction_response: log.transaction_response,
                    user: log.user,
                    source: log.source,
                    paid_total: log.paid_total,
                    total: log.total,
                    type: log.type,
                    created_at: moment(log.created_at).tz(req.headers['tz']).format('lll'),
                    updated_at: moment(log.updated_at).tz(req.headers['tz']).format('lll'),
                });
            });
        res.status(200).json({
            responseCode: 200,
            responseMessage: "Transaction Log",
            responseData: logs
        });
    }
    else {
        res.status(400).json({
            responseCode: 400,
            responseMessage: "Order not found",
            responseData: {}
        });
    }
});

router.post('/order/payment/add', xAccessToken.token, async function (req, res, next) {
    var rules = {
        order: 'required',
        amount: 'required',
        date: 'required',
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Amount & Date are mandatory",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var business = req.headers['business'];
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var data = [];
        var loggedInDetails = await User.findById(decoded.user).exec();

        var order = await Order.findOne({ _id: req.body.order }).exec();
        if (order) {
            var businessOrder = await BusinessOrder.findOne({ order: req.body.order, business: business }).exec();
            if (businessOrder) {
                var recieved = parseFloat(req.body.amount);

                var date = new Date();
                var payment_mode = req.body.payment_mode;
                var transaction_id = req.body.transaction_id;

                var due_amount = 0;
                if (businessOrder.due) {
                    if (businessOrder.due.due) {
                        due_amount = businessOrder.due.due;
                    }
                }


                TransactionLog.create({
                    user: order.user,
                    activity: "Order",
                    business: business,
                    source: order._id,
                    paid_total: recieved,
                    total: businessOrder.payment.total,
                    due: due_amount,
                    payment_status: "Success",
                    payment_mode: payment_mode,
                    transaction_id: transaction_id,
                    transaction_date: new Date(req.body.date).toISOString(),
                    transaction_status: "Success",
                    transaction_response: "Success",
                    created_at: new Date(),
                    updated_at: new Date(),
                }).then(async function (transaction) {

                    var convenience_charges = 0;
                    if (businessOrder.payment.convenience_charges) {
                        convenience_charges = Math.ceil(businessOrder.payment.convenience_charges)
                    }

                    var items = await OrderLine.find({ order: order._id, business: business, status: { $nin: ['Cancelled'] } }).exec();
                    var amount = _.sumBy(items, x => x.amount);
                    var discount = _.sumBy(items, x => x.discount_total);
                    var total = amount + discount + convenience_charges;

                    var transaction_log = await TransactionLog.find({ source: order._id, payment_status: "Success", }).exec();

                    var paid_total = _.sumBy(transaction_log, x => x.paid_total);

                    var due = Math.ceil(amount.toFixed(2)) + Math.ceil(convenience_charges) - paid_total;

                    var data = {
                        updated_at: date,
                        "payment.paid_total": paid_total,
                        "payment.amount": parseFloat(amount.toFixed(2)),
                        "payment.discount_total": parseFloat(discount.toFixed(2)),
                        "payment.total": parseFloat(total.toFixed(2)),
                        "due": {
                            due: due
                        }
                    }

                    var orderInvoice = await OrderInvoice.findOne({ order: order._id, business: business }).exec();
                    if (orderInvoice) {
                        OrderInvoice.findOneAndUpdate({ order: order._id, business: business }, { $set: data }, { new: false }, async function (err, doc) {
                            if (err) {
                                return res.status(422).json({
                                    responseCode: 422,
                                    responseMessage: "Server Error",
                                    responseData: err
                                });
                            }
                        })
                    }


                    Order.findOneAndUpdate({ _id: order._id }, { $set: data }, { new: false }, async function (err, doc) {
                        if (err) {
                            res.status(422).json({
                                responseCode: 422,
                                responseMessage: "Server Error",
                                responseData: err
                            });
                        }
                        else {
                            BusinessOrder.findOneAndUpdate({ order: order._id, business: business }, { $set: data }, { new: false }, async function (err, doc) {
                                if (err) {
                                    res.status(422).json({
                                        responseCode: 422,
                                        responseMessage: "Server Error",
                                        responseData: err
                                    });
                                }
                                else {
                                    var updated = await BusinessOrder.findOne({ order: order._id, business: business }).exec();

                                    res.status(200).json({
                                        responseCode: 200,
                                        responseMessage: "Payment Recieved",
                                        responseData: {
                                            item: {},
                                            payment: transaction,
                                            due: updated.due,
                                        }
                                    });
                                }
                            });
                        }
                    });

                });
            }
            else {
                res.status(400).json({
                    responseCode: 400,
                    responseMessage: "Business Order not found",
                    responseData: {}
                });
            }
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Order not found",
                responseData: {}
            });
        }
    }
});

router.delete('/order/payment/remove', xAccessToken.token, async function (req, res, next) {
    var rules = {
        id: 'required',
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Amount & Date is required",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var business = req.headers['business'];
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var data = [];
        var loggedInDetails = await User.findById(decoded.user).exec();

        var transaction = await TransactionLog.findOne({ _id: req.body.id }).exec();
        if (transaction) {
            var order = await Order.findOne({ _id: transaction.source }).exec();
            var businessOrder = await BusinessOrder.findOne({ order: transaction.source, business: business }).exec();
            if (businessOrder) {
                var recieved = parseFloat(req.body.amount);

                var date = new Date();
                var payment_mode = req.body.payment_mode;
                var transaction_id = req.body.transaction_id;

                TransactionLog.remove({ _id: transaction._id }, async function (err) {
                    if (err) {
                        return res.status(422).json({
                            responseCode: 422,
                            responseMessage: "Server Error",
                            responseData: err
                        });
                    }
                    else {
                        var convenience_charges = 0;
                        if (businessOrder.payment.convenience_charges) {
                            convenience_charges = Math.ceil(businessOrder.payment.convenience_charges)
                        }

                        var items = await OrderLine.find({ order: order._id, business: business, status: { $nin: ['Cancelled'] } }).exec();
                        var amount = _.sumBy(items, x => x.amount);
                        var discount = _.sumBy(items, x => x.discount_total);
                        var total = amount + discount + convenience_charges;

                        var transaction_log = await TransactionLog.find({ source: order._id, payment_status: "Success", }).exec();

                        var paid_total = _.sumBy(transaction_log, x => x.paid_total);

                        var due = Math.ceil(amount.toFixed(2)) + Math.ceil(convenience_charges) - paid_total;

                        var data = {
                            updated_at: date,
                            "payment.paid_total": paid_total,
                            "payment.amount": parseFloat(amount.toFixed(2)),
                            "payment.discount_total": parseFloat(discount.toFixed(2)),
                            "payment.total": parseFloat(total.toFixed(2)),
                            "due": {
                                due: due
                            }
                        }

                        var orderInvoice = await OrderInvoice.findOne({ order: order._id, business: business }).exec();
                        if (orderInvoice) {
                            OrderInvoice.findOneAndUpdate({ order: order._id, business: business }, { $set: data }, { new: false }, async function (err, doc) {
                                if (err) {
                                    return res.status(422).json({
                                        responseCode: 422,
                                        responseMessage: "Server Error",
                                        responseData: err
                                    });
                                }
                            })
                        }


                        Order.findOneAndUpdate({ _id: order._id }, { $set: data }, { new: false }, async function (err, doc) {
                            if (err) {
                                res.status(422).json({
                                    responseCode: 422,
                                    responseMessage: "Server Error",
                                    responseData: err
                                });
                            }
                            else {
                                BusinessOrder.findOneAndUpdate({ order: order._id, business: business }, { $set: data }, { new: false }, async function (err, doc) {
                                    if (err) {
                                        res.status(422).json({
                                            responseCode: 422,
                                            responseMessage: "Server Error",
                                            responseData: err
                                        });
                                    }
                                    else {
                                        var updated = await BusinessOrder.findOne({ order: order._id, business: business }).exec();

                                        res.status(200).json({
                                            responseCode: 200,
                                            responseMessage: "Payment Recieved",
                                            responseData: {
                                                item: {},
                                                payment: updated.payment,
                                                due: updated.due,
                                            }
                                        });
                                    }
                                });
                            }
                        });
                    }
                });

            }
            else {
                res.status(400).json({
                    responseCode: 400,
                    responseMessage: "Business Order not found",
                    responseData: {}
                });
            }
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Transaction not found",
                responseData: {}
            });
        }
    }
});

router.get('/orders/get', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var business = req.headers['business'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    //paginate
    if (req.query.page == undefined) {
        var page = 0;
    }
    else {
        var page = req.query.page;
    }

    var page = Math.max(0, parseInt(page));

    var orders = [];

    var filters = [];
    var match = [];
    var queries = {};


    if (req.query.query) {
        var specification = {};
        specification['$lookup'] = {
            from: "User",
            localField: "user",
            foreignField: "_id",
            as: "user",
        };
        filters.push(specification);

        var specification = {};
        specification['$unwind'] = {
            path: "$user",
            preserveNullAndEmptyArrays: false
        };
        filters.push(specification);

        var specification = {};
        specification['$match'] = {
            business: mongoose.Types.ObjectId(business),
            $or: [
                { '_order': { $regex: req.query.query, $options: 'i' } },
                { 'status': { $regex: req.query.query, $options: 'i' } },
                { 'order_no': { $regex: req.query.query, $options: 'i' } },
                { 'user.name': { $regex: req.query.query, $options: 'i' } },
                { 'user.contact_no': { $regex: req.query.query, $options: 'i' } },
            ]
        };
        filters.push(specification);

        var specification = {};
        specification['$sort'] = {
            updated_at: -1,
        };
        filters.push(specification);

        var specification = {};
        specification['$skip'] = config.perPage * page;
        filters.push(specification);

        var specification = {};
        specification['$limit'] = config.perPage;
        filters.push(specification);
    }
    else {
        var status = "Confirmed";

        if (req.query.status) {
            var status = req.query.status;
        }


        var specification = {};
        specification['$match'] = {
            status: status
        };
        filters.push(specification);

        var specification = {};
        specification['$match'] = {
            business: mongoose.Types.ObjectId(business)
        };
        filters.push(specification);

        var specification = {};
        specification['$match'] = {
            business: mongoose.Types.ObjectId(business)
        };
        filters.push(specification);

        var specification = {};
        specification['$sort'] = {
            updated_at: -1,
        };
        filters.push(specification);

        var specification = {};
        specification['$skip'] = config.perPage * page;
        filters.push(specification);

        var specification = {};
        specification['$limit'] = config.perPage;
        filters.push(specification);
    }

    var query = filters;

    var totalResult = await BusinessOrder.aggregate(query);

    await BusinessOrder.aggregate(query)
        .allowDiskUse(true)
        .cursor({ batchSize: 20 })
        .exec()
        .eachAsync(async function (p) {
            var order = await Order.findById(p.order)
                .populate({ path: 'user', select: 'name contact_no username email account_info business_info' })
                .populate({ path: 'car', select: 'variant value' })
                .populate({ path: 'address' })
                .exec();

            orders.push({
                _id: order._id,
                id: order._id,
                user: order.user,
                car: order.car,
                address: order.address,
                due_date: moment(p.due_date).tz(req.headers['tz']).format('ll'),
                delivery_date: moment(p.delivery_date).tz(req.headers['tz']).format('ll'),
                time_slot: p.time_slot,
                convenience: p.convenience,
                _order: p._order,
                order_no: p.order_no,
                address: p.address,
                payment: p.payment,
                due: p.due,
                log: p.log,
                status: p.status,
                created_at: moment(p.created_at).tz(req.headers['tz']).format('lll'),
                updated_at: moment(p.updated_at).tz(req.headers['tz']).format('lll'),
            });
        });

    res.status(200).json({
        responseCode: 200,
        responseMessage: "success",
        responseInfo: {
            totalResult: totalResult.length,
        },
        responseData: orders
    });
});

router.delete('/order/cancel', xAccessToken.token, async function (req, res, next) {
    var business = req.headers['business'];
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var date = new Date();
    var loggedInDetails = decoded.user;
    var items = [];
    var data = [];

    var item_total = 0;
    var discount = 0;
    var item_total = 0;
    var total = 0;

    var order = await Order.findById(req.body.order).exec();
    var loggedInDetails = await User.findById(decoded.user).exec();
    if (order) {
        await OrderLine.find({ business: business, order: order._id })
            .cursor().eachAsync(async (item) => {
                if (item.issued == true) {
                    var r = await q.all(orderItemReturn(item));
                }
            });

        var date = new Date();
        var businessOrder = await BusinessOrder.findOne({ order: order._id, business: business }).exec();

        var data = {
            updated_at: new Date(),
            status: "Cancelled"
        }

        Order.findOneAndUpdate({ _id: businessOrder.order }, { $set: data }, { new: false }, async function (err, doc) {
            if (err) {
                res.status(422).json({
                    responseCode: 422,
                    responseMessage: "Server Error",
                    responseData: err
                });
            }
            else {
                BusinessOrder.findOneAndUpdate({ order: businessOrder.order, business: business }, { $set: data }, { new: false }, async function (err, doc) {
                    if (err) {
                        res.status(422).json({
                            responseCode: 422,
                            responseMessage: "Server Error",
                            responseData: err
                        });
                    }
                    else {
                        await BusinessOrder.find({ order: businessOrder.order, business: business })
                            .populate({ path: 'order', populate: [{ path: 'user', select: 'name contact_no username email account_info ' }, { path: 'car', select: 'title variant registration_no _automaker _model' }, { path: 'address' }] })
                            .cursor().eachAsync(async (p) => {

                                var orders = {
                                    _id: p.order._id,
                                    id: p.order._id,
                                    items: await q.all(fun.getBusinessOrderItems(p.order._id, business, req.headers['tz'])),
                                    user: p.order.user,
                                    car: p.order.car,
                                    address: p.order.address,
                                    due_date: moment(p.due_date).tz(req.headers['tz']).format('lll'),
                                    delivery_date: moment(p.delivery_date).tz(req.headers['tz']).format('lll'),
                                    time_slot: p.time_slot,
                                    convenience: p.order.convenience,
                                    order_no: p.order.order_no,
                                    address: p.order.address,
                                    payment: p.payment,
                                    due: p.due,
                                    log: p.log,
                                    status: p.status,
                                    created_at: moment(p.created_at).tz(req.headers['tz']).format('lll'),
                                    updated_at: moment(p.updated_at).tz(req.headers['tz']).format('lll'),
                                };

                                res.status(200).json({
                                    responseCode: 200,
                                    responseMessage: "success",
                                    responseData: orders
                                });
                            });
                    }
                });
            }
        });
    }
    else {
        res.status(400).json({
            responseCode: 400,
            responseMessage: "Order not found",
            responseData: {}
        });
    }
});

router.get('/order/details/get', xAccessToken.token, async function (req, res, next) {
    console.time('looper')
    var token = req.headers['x-access-token'];
    var business = req.headers['business'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    var p = await BusinessOrder.findOne({ order: req.query.order, business: business })
        .populate({
            path: 'order',
            populate: [
                { path: 'user', select: 'name contact_no username email account_info business_info' },
                { path: 'car', select: 'value variant' },
                { path: 'address' }
            ]
        })
        .populate({ path: "business", select: "name address business_info contact_no email account_info bank_details" })
        .exec();

    var transactions = await q.all(fun.getOrderTransaction(p.order._id, business))

    var has_invoice = false;
    var invoices = await OrderInvoice.find({ order: p.order._id, business: business }).select('status invoice_no').exec();

    if (invoices.length > 0) {
        has_invoice = true;
    }

    res.status(200).json({
        responseCode: 200,
        responseMessage: "success",
        responseData: {
            _id: p.order._id,
            id: p.order._id,
            items: await q.all(fun.getBusinessOrderItems(p.order._id, business, req.headers['tz'])),
            user: p.order.user,
            car: p.order.car,
            address: p.order.address,
            due_date: moment(p.due_date).tz(req.headers['tz']).format('lll'),
            delivery_date: moment(p.delivery_date).tz(req.headers['tz']).format('lll'),
            time_slot: p.time_slot,
            convenience: p.convenience,
            _order: p._order,
            order_no: p.order_no,
            business: p.business,
            address: p.order.address,
            payment: p.payment,
            status: p.status,
            due: p.due,
            note: p.note,
            log: p.log,
            has_invoice: has_invoice,
            invoices: invoices,
            transactions: transactions.transactions,
            created_at: moment(p.created_at).tz(req.headers['tz']).format('lll'),
            updated_at: moment(p.updated_at).tz(req.headers['tz']).format('lll'),
        }
    });

    console.timeEnd('looper')
});

router.post('/order/invoice/generate', xAccessToken.token, async function (req, res, next) {
    var business = req.headers['business'];
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var date = new Date();
    var loggedInDetails = decoded.user;
    var items = [];
    var data = [];

    var item_total = 0;
    var discount = 0;
    var item_total = 0;
    var total = 0;

    var order = await Order.findById(req.body.order).exec();
    var loggedInDetails = await User.findById(decoded.user).exec();
    if (order) {
        var invoice = await OrderInvoice.findOne({ order: order._id, business: business, status: "Active" })
            .populate({
                path: 'order',
                populate: [
                    { path: 'user', select: 'name contact_no username email account_info business_info' },
                    { path: 'car', select: 'variant value' },
                    { path: 'address' }
                ]
            })
            .exec();

        if (invoice) {
            var transactions = await q.all(fun.getOrderTransaction(p.order._id, business));

            res.status(200).json({
                responseCode: 200,
                responseMessage: "success",
                responseData: {
                    _id: invoice._id,
                    id: invoice._id,
                    items: await q.all(fun.getBusinessOrderItems(invoice.order._id, business, req.headers['tz'])),
                    user: invoice.order.user,
                    car: invoice.order.car,
                    address: invoice.order.address,
                    due_date: moment(invoice.due_date).tz(req.headers['tz']).format('lll'),
                    delivery_date: moment(invoice.delivery_date).tz(req.headers['tz']).format('lll'),
                    time_slot: invoice.time_slot,
                    convenience: invoice.convenience,
                    order_no: invoice.order_no,
                    _order: invoice._order,
                    invoice_no: invoice.invoice_no,
                    address: invoice.order.address,
                    payment: invoice.payment,
                    status: invoice.status,
                    due: invoice.due,
                    log: invoice.log,
                    transactions: transactions.transactions,
                    created_at: moment(invoice.created_at).tz(req.headers['tz']).format('lll'),
                    updated_at: moment(invoice.updated_at).tz(req.headers['tz']).format('lll'),
                }
            });
        }
        else {
            var date = new Date();
            var availablity = false;

            var items = await OrderLine.find({ order: order._id, business: business, status: { $nin: ['Cancelled'] } }).exec();

            var nd = _.filter(items, status => status.issued == true);

            if (nd.length <= 0) {
                res.status(400).json({
                    responseCode: 400,
                    responseMessage: "Error! Dispatch all items",
                    responseData: {}
                });
            }
            else {
                var businessOrder = await BusinessOrder.findOne({ order: order._id, business: business }).exec();

                OrderInvoice.create({
                    business: business,
                    user: businessOrder.user,
                    order: businessOrder.order,
                    source: businessOrder._id,
                    delivery_date: businessOrder.delivery_date,
                    due_date: businessOrder.due_date,
                    _order: businessOrder._order,
                    order_no: businessOrder.order_no,
                    note: businessOrder.note,
                    invoice_no: businessOrder.invoice_no,
                    status: "Active",
                    with_tax: true,
                    payment: businessOrder.payment,
                    due: businessOrder.due,
                    created_at: new Date(),
                    updated_at: new Date(),
                })
                    .then(async function (inv) {

                        var count = await OrderInvoice.find({ _id: { $lt: inv._id }, business: business }).count();
                        if (count == 0) {
                            var last_invoice = "";
                            var position = 1;
                        }
                        else {
                            var lv = await OrderInvoice.findOne({ _id: { $lt: inv._id }, business: business }).sort({ _id: -1 }).exec();
                            var last_invoice = lv.invoice_no;
                            position = count + 1
                        }

                        var fy = {
                            with_tax: inv.with_tax,
                            last_invoice: last_invoice,
                            position: position,
                        };

                        var assigned_invoice_no = await q.all(fun.fiscalyear(fy));
                        if (assigned_invoice_no) {
                            if (assigned_invoice_no.invoice) {
                                OrderInvoice.findOneAndUpdate({ _id: inv._id }, { $set: { invoice_no: assigned_invoice_no.invoice } }, { new: true }, async function (err, doc) {
                                    if (err) {
                                        res.status(422).json({
                                            responseCode: 422,
                                            responseMessage: "Server Error",
                                            responseData: err
                                        });
                                    }
                                    else {
                                        Order.findOneAndUpdate({ _id: order._id }, { $set: { status: "Shipped", updated_at: new Date() } }, { new: false }, async function (err, doc) {
                                            if (err) {
                                                return res.status(422).json({
                                                    responseCode: 422,
                                                    responseMessage: "Server Error",
                                                    responseData: err
                                                });
                                            }
                                            else {
                                                BusinessOrder.findOneAndUpdate({ order: order._id, business: business }, { $set: { status: "Shipped", updated_at: new Date() } }, { new: false }, async function (err, doc) {
                                                    if (err) {
                                                        return res.status(422).json({
                                                            responseCode: 422,
                                                            responseMessage: "Server Error",
                                                            responseData: err
                                                        });
                                                    }
                                                });
                                            }
                                        });


                                        var p = await OrderInvoice.findById(inv._id)
                                            .populate({
                                                path: 'order',
                                                populate: [
                                                    { path: 'user', select: 'name contact_no username email account_info business_info' },
                                                    { path: 'car', select: 'variant value' },
                                                    { path: 'address' }
                                                ]
                                            })
                                            .exec();

                                        var transactions = await q.all(fun.getOrderTransaction(p.order._id, business))

                                        res.status(200).json({
                                            responseCode: 200,
                                            responseMessage: "success",
                                            responseData: {
                                                _id: p._id,
                                                id: p._id,
                                                items: await q.all(fun.getBusinessOrderItems(p.order._id, business, req.headers['tz'])),
                                                user: p.order.user,
                                                car: p.order.car,
                                                address: p.order.address,
                                                due_date: moment(p.due_date).tz(req.headers['tz']).format('lll'),
                                                delivery_date: moment(p.delivery_date).tz(req.headers['tz']).format('lll'),
                                                time_slot: p.time_slot,
                                                convenience: p.convenience,
                                                order_no: p.order_no,
                                                _order: p._order,
                                                invoice_no: p.invoice_no,
                                                address: p.order.address,
                                                payment: p.payment,
                                                status: p.status,
                                                due: p.due,
                                                log: p.log,
                                                transactions: transactions.transactions,
                                                created_at: moment(p.created_at).tz(req.headers['tz']).format('lll'),
                                                updated_at: moment(p.updated_at).tz(req.headers['tz']).format('lll'),
                                            }
                                        });
                                    }

                                });
                            }
                            else {
                                res.status(422).json({
                                    responseCode: 422,
                                    responseMessage: "Server Error",
                                    responseData: {}
                                });
                            }
                        }
                        else {
                            res.status(422).json({
                                responseCode: 422,
                                responseMessage: "Server Error",
                                responseData: {}
                            });
                        }
                    });
            }
        }
    }
    else {
        res.status(400).json({
            responseCode: 400,
            responseMessage: "Order not found",
            responseData: {}
        });
    }
});

router.get('/order/invoices/get', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var business = req.headers['business'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    //paginate
    if (req.query.page == undefined) {
        var page = 0;
    }
    else {
        var page = req.query.page;
    }

    var page = Math.max(0, parseInt(page));

    var orders = [];

    var filters = [];
    var match = [];
    var queries = {};

    var specification = {};
    specification['$lookup'] = {
        from: "Order",
        localField: "order",
        foreignField: "_id",
        as: "order",
    };
    filters.push(specification);

    var specification = {};
    specification['$unwind'] = {
        path: "$order",
        preserveNullAndEmptyArrays: false
    };

    filters.push(specification);


    if (req.query.query) {
        var specification = {};
        specification['$lookup'] = {
            from: "User",
            localField: "user",
            foreignField: "_id",
            as: "user",
        };
        filters.push(specification);

        var specification = {};
        specification['$unwind'] = {
            path: "$user",
            preserveNullAndEmptyArrays: false
        };
        filters.push(specification);

        var specification = {};
        specification['$match'] = {
            business: mongoose.Types.ObjectId(business),
            $or: [
                { '_order': { $regex: req.query.query, $options: 'i' } },
                { 'status': { $regex: req.query.query, $options: 'i' } },
                { 'order_no': { $regex: req.query.query, $options: 'i' } },
                { 'user.name': { $regex: req.query.query, $options: 'i' } },
                { 'user.contact_no': { $regex: req.query.query, $options: 'i' } },
            ]
        };
        filters.push(specification);
    }
    else {
        var specification = {};
        specification['$match'] = {
            business: mongoose.Types.ObjectId(business)
        };
        filters.push(specification);
    }

    var query = filters;

    var totalResult = await OrderInvoice.aggregate(query);

    var specification = {};
    specification['$sort'] = {
        updated_at: -1,
    };
    filters.push(specification);

    var specification = {};
    specification['$skip'] = config.perPage * page;
    filters.push(specification);

    var specification = {};
    specification['$limit'] = config.perPage;
    filters.push(specification);

    await OrderInvoice.aggregate(query)
        .allowDiskUse(true)
        .cursor({ batchSize: 20 })
        .exec()
        .eachAsync(async function (p) {
            //orders.push(p)
            if (p) {
                var order = await Order.findById(p.order)
                    .populate({ path: 'user', select: 'name contact_no username email account_info business_info' })
                    .populate({ path: 'car', select: 'title variant registration_no _automaker _model' })
                    .populate({ path: 'address' })
                    .exec();

                orders.push({
                    _id: order._id,
                    id: order._id,
                    user: order.user,
                    car: order.car,
                    address: order.address,
                    due_date: moment(p.due_date).tz(req.headers['tz']).format('lll'),
                    delivery_date: moment(p.delivery_date).tz(req.headers['tz']).format('lll'),
                    time_slot: p.time_slot,
                    convenience: p.convenience,
                    _order: p._order,
                    order_no: p.order_no,
                    address: p.address,
                    payment: p.payment,

                    due: p.due,
                    log: p.log,
                    status: p.status,
                    created_at: moment(p.created_at).tz(req.headers['tz']).format('lll'),
                    updated_at: moment(p.updated_at).tz(req.headers['tz']).format('lll'),
                });
            }
        });

    res.status(200).json({
        responseCode: 200,
        responseMessage: "success",
        responseInfo: {
            totalResult: totalResult.length,
        },
        responseData: orders
    });
});

router.get('/order/invoice/get', xAccessToken.token, async function (req, res, next) {
    console.time('looper')
    var rules = {
        invoice: 'required',
    };

    var validation = new Validator(req.query, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Invoice is required",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var token = req.headers['x-access-token'];
        var business = req.headers['business'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);

        var p = await OrderInvoice.findById(req.query.invoice)
            .populate({
                path: 'order',
                populate: [
                    { path: 'user', select: 'name contact_no username email account_info business_info' },
                    { path: 'business', select: 'name contact_no username email account_info business_info bank_details' },
                    { path: 'car', select: 'variant value' },
                    { path: 'address' }
                ]
            })
            .exec();
        if (p) {
            var transactions = await q.all(fun.getOrderTransaction(p.order._id, business))
            var business_info = await User.findById(p.business).select('name contact_no username email account_info business_info bank_details address').exec();

            res.status(200).json({
                responseCode: 200,
                responseMessage: "success",
                responseData: {
                    _id: p._id,
                    id: p._id,
                    items: await q.all(fun.getBusinessOrderItems(p.order._id, business, req.headers['tz'])),
                    user: p.order.user,
                    car: p.order.car,
                    due_date: moment(p.due_date).tz(req.headers['tz']).format('lll'),
                    delivery_date: moment(p.delivery_date).tz(req.headers['tz']).format('lll'),
                    time_slot: p.time_slot,
                    convenience: p.convenience,
                    order_no: p.order_no,
                    _order: p._order,
                    invoice_no: p.invoice_no,
                    address: p.order.address,
                    payment: p.payment,
                    status: p.status,
                    business: business_info,
                    due: p.due,
                    note: p.note,
                    log: p.log,
                    transactions: transactions.transactions,
                    created_at: moment(p.created_at).tz(req.headers['tz']).format('lll'),
                    updated_at: moment(p.updated_at).tz(req.headers['tz']).format('lll'),
                }
            });
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Invoice not found",
                responseData: {}
            });
        }
    }
    console.timeEnd('looper')
});

router.delete('/order/invoice/cancel', xAccessToken.token, async function (req, res, next) {
    var business = req.headers['business'];
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var date = new Date();
    var loggedInDetails = decoded.user;
    var items = [];
    var data = [];

    var item_total = 0;
    var discount = 0;
    var item_total = 0;
    var total = 0;

    var invoice = await OrderInvoice.findById(req.body.invoice).exec();
    var loggedInDetails = await User.findById(decoded.user).exec();
    if (invoice) {
        var date = new Date();

        var data = {
            updated_at: new Date(),
            status: "Cancelled"
        }

        OrderInvoice.findOneAndUpdate({ _id: invoice._id }, { $set: data }, { new: false }, async function (err, doc) {
            if (err) {
                res.status(422).json({
                    responseCode: 422,
                    responseMessage: "Server Error",
                    responseData: err
                });
            }
            else {
                res.status(200).json({
                    responseCode: 200,
                    responseMessage: "Invoice has been Cancelled",
                    responseData: {}
                });
            }
        });
    }
    else {
        res.status(400).json({
            responseCode: 400,
            responseMessage: "Invoice not found",
            responseData: {}
        });
    }
});

router.post('/note/add', xAccessToken.token, async function (req, res, next) {
    var business = req.headers['business'];
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var date = new Date();
    var loggedInDetails = decoded.user;
    var items = [];
    var data = [];

    var item_total = 0;
    var discount = 0;
    var item_total = 0;
    var total = 0;

    var data = {
        updated_at: new Date(),
        note: req.body.note
    }

    var loggedInDetails = await User.findById(decoded.user).exec();
    if (req.body.type == "booking") {
        var source = await Booking.findById(req.body.source).exec();
        if (source) {
            Booking.findOneAndUpdate({ _id: source._id }, { $set: data }, { new: false }, async function (err, doc) {
                if (err) {
                    return res.status(422).json({
                        responseCode: 422,
                        responseMessage: "Server Error",
                        responseData: err
                    });
                }
                else {
                    Invoice.update({ booking: source._id }, { $set: { note: req.body.note } }, { multi: true }, async function (err, doc) {
                        if (err) {
                            return res.status(422).json({
                                responseCode: 422,
                                responseMessage: "Server Error",
                                responseData: err
                            });
                        }
                        else {
                            res.status(200).json({
                                responseCode: 200,
                                responseMessage: "Note has been updated",
                                responseData: {}
                            });
                        }
                    });
                }
            });
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Booking not found",
                responseData: {}
            });
        }
    }
    else if (req.body.type == "order") {
        var source = await BusinessOrder.findOne({ order: req.body.source }).exec();
        if (source) {
            BusinessOrder.findOneAndUpdate({ order: req.body.source }, { $set: data }, { new: false }, async function (err, doc) {
                if (err) {
                    res.status(422).json({
                        responseCode: 422,
                        responseMessage: "Server Error",
                        responseData: err
                    });
                }
                else {
                    OrderInvoice.update({ order: req.body.source }, { $set: { note: req.body.note } }, { multi: true }, async function (err, doc) {
                        if (err) {
                            return res.status(422).json({
                                responseCode: 422,
                                responseMessage: "Server Error",
                                responseData: err
                            });
                        }
                        else {
                            res.status(200).json({
                                responseCode: 200,
                                responseMessage: "Note has been updated",
                                responseData: {}
                            });
                        }
                    });
                }
            });
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Order not found",
                responseData: {}
            });
        }
    }
});

async function getPackageDiscount(data) {
    var discount = {};
    if (data.package) {
        if (data.claim == false) {
            var package = await UserPackage.findOne({ _id: data.package }).exec();
            if (package) {
                if (package.status == true) {
                    if (package.car) {
                        var packageUsed = await PackageUsed.find({ package: data.package, user: package.user, label: data.service, car: data.car }).count().exec();
                    }
                    else {
                        var packageUsed = await PackageUsed.find({ package: data.package, user: package.user, label: data.service }).count().exec();
                    }

                    var serverTime = moment.tz(new Date(), data.tz);

                    var bar = package.created_at;
                    bar.setDate(bar.getDate() + package.validity);
                    bar = moment.tz(bar, data.tz)
                    var baz = bar.diff(serverTime);
                    /// cconsole.logz)
                    if (baz > 0) {
                        package.discount.forEach(async function (dis) {
                            /// cconsole.logs);
                            if (dis.for == "category") {
                                if (dis.label == data.category) {
                                    if (dis.type == "percent") {
                                        if (!packageDiscountOn.includes(data.service)) {
                                            discount = {
                                                discount: dis.discount,
                                                discount_type: "percent"
                                            }
                                        }
                                    }
                                    else {
                                        if (!packageDiscountOn.includes(data.service)) {
                                            discount = {
                                                discount: dis.discount,
                                                discount_type: "price"
                                            }
                                        }
                                    }
                                }
                            }
                            else if (dis.for == "specific") {
                                if (dis.label == data.service) {
                                    if (dis.type == "percent") {
                                        if (dis.limit > packageUsed) {
                                            packageDiscountOn.push(data.service)
                                            discount = {
                                                discount: dis.discount,
                                                discount_type: "percent"
                                            }
                                        }
                                    }
                                    else if (dis.type == "fixed") {
                                        if (dis.limit > packageUsed) {
                                            packageDiscountOn.push(data.service)
                                            discount = {
                                                discount: dis.discount,
                                                discount_type: "fixed"
                                            }
                                        }
                                    }
                                    else {
                                        if (dis.limit > packageUsed) {
                                            packageDiscountOn.push(data.service)
                                            discount = {
                                                discount: dis.discount,
                                                discount_type: "price"
                                            }
                                        }
                                    }
                                }
                            }
                        });
                    }
                }
                else {
                    if (package.booking.equals(data.booking)) {
                        var packageUsed = await PackageUsed.find({ package: data.package, user: package.user, label: data.service, car: data.car }).count().exec();
                        var serverTime = moment.tz(new Date(), data.tz);

                        var bar = package.created_at;
                        bar.setDate(bar.getDate() + package.validity);
                        bar = moment.tz(bar, data.tz)
                        var baz = bar.diff(serverTime);
                        /// cconsole.logz);
                        if (baz > 0) {
                            package.discount.forEach(async function (dis) {
                                if (dis.for == "category") {
                                    if (dis.label == data.category) {
                                        if (dis.type == "percent") {
                                            if (!packageDiscountOn.includes(data.service)) {
                                                discount = {
                                                    discount: dis.discount,
                                                    discount_type: "percent"
                                                }
                                            }
                                        }
                                        else {
                                            if (!packageDiscountOn.includes(data.service)) {
                                                discount = {
                                                    discount: dis.discount,
                                                    discount_type: "price"
                                                }
                                            }
                                        }
                                    }
                                }
                                else if (dis.for == "specific") {
                                    if (dis.label == data.service) {
                                        if (dis.type == "percent") {
                                            if (dis.limit > packageUsed) {
                                                packageDiscountOn.push(data.service)
                                                discount = {
                                                    discount: dis.discount,
                                                    discount_type: "percent"
                                                }
                                            }
                                        }
                                        else if (dis.type == "fixed") {
                                            if (dis.limit > packageUsed) {
                                                packageDiscountOn.push(data.service)
                                                discount = {
                                                    discount: dis.discount,
                                                    discount_type: "fixed"
                                                }
                                            }
                                        }
                                        else {
                                            if (dis.limit > packageUsed) {
                                                packageDiscountOn.push(data.service)
                                                discount = {
                                                    discount: dis.discount,
                                                    discount_type: "price"
                                                }
                                            }
                                        }
                                    }
                                }
                            });
                        }
                    }
                }
            }
        }
    }
    return discount;
}

async function packageDiscount(data) {
    var labour_cost = data.labour_cost;
    var lc = data.labour_cost;
    var package = await UserPackage.findOne({ _id: data.package }).exec();
    if (data.claim == false) {
        if (package) {
            if (package.status == true) {
                if (package.car) {
                    var packageUsed = await PackageUsed.find({ package: data.package, user: package.user, label: data.service, car: data.car }).count().exec();
                }
                else {
                    var packageUsed = await PackageUsed.find({ package: data.package, user: package.user, label: data.service }).count().exec();
                }

                var serverTime = moment.tz(new Date(), data.tz);

                var bar = package.created_at;
                bar.setDate(bar.getDate() + package.validity);
                bar = moment.tz(bar, data.tz)
                var baz = bar.diff(serverTime);

                if (baz > 0) {
                    package.discount.forEach(async function (dis) {

                        if (dis.for == "category") {
                            if (dis.label == data.category) {
                                if (dis.type == "percent") {
                                    if (!packageDiscountOn.includes(data.service)) {
                                        labour_cost = lc - lc * (dis.discount / 100);
                                    }
                                }
                                else if (dis.type == "fixed") {
                                    if (!packageDiscountOn.includes(data.service)) {
                                        labour_cost = lc - dis.discount

                                    }
                                }
                                else {
                                    if (!packageDiscountOn.includes(data.service)) {
                                        labour_cost = lc - lc * (dis.discount / 100);

                                    }
                                }
                            }
                        }
                        else if (dis.for == "specific") {
                            if (dis.label == data.service) {
                                if (dis.type == "percent") {
                                    if (dis.limit > packageUsed) {
                                        packageDiscountOn.push(data.service)
                                        labour_cost = lc - lc * (dis.discount / 100);

                                    }
                                }
                                else if (dis.type == "fixed") {
                                    if (dis.limit > packageUsed) {
                                        packageDiscountOn.push(data.service)
                                        labour_cost = dis.discount;
                                    }
                                }
                                else {
                                    if (dis.limit > packageUsed) {
                                        packageDiscountOn.push(data.service)
                                        labour_cost = lc - dis.discount;
                                    }
                                }
                            }
                        }
                    });
                }
            }
            else {
                if (package.booking.equals(data.booking)) {
                    var packageUsed = await PackageUsed.find({ package: data.package, user: package.user, label: data.service, car: data.car }).count().exec();
                    var serverTime = moment.tz(new Date(), data.tz);

                    var bar = package.created_at;
                    bar.setDate(bar.getDate() + package.validity);
                    bar = moment.tz(bar, data.tz)
                    var baz = bar.diff(serverTime);

                    if (baz > 0) {
                        package.discount.forEach(async function (dis) {

                            if (dis.for == "category") {
                                if (dis.label == cat) {
                                    if (dis.type == "percent") {
                                        if (!packageDiscountOn.includes(data.service)) {
                                            labour_cost = lc - lc * (dis.discount / 100);
                                        }
                                    }
                                    else if (dis.type == "fixed") {
                                        if (!packageDiscountOn.includes(data.service)) {
                                            labour_cost = lc - dis.discount

                                        }
                                    }
                                    else {
                                        if (!packageDiscountOn.includes(data.service)) {
                                            labour_cost = lc - lc * (dis.discount / 100);

                                        }
                                    }
                                }
                            }
                            else if (dis.for == "specific") {
                                if (dis.label == data.service) {
                                    if (dis.type == "percent") {
                                        if (dis.limit > packageUsed) {
                                            packageDiscountOn.push(data.service)
                                            labour_cost = lc - lc * (dis.discount / 100);

                                        }
                                    }
                                    else if (dis.type == "fixed") {
                                        if (dis.limit > packageUsed) {
                                            packageDiscountOn.push(data.service)
                                            labour_cost = dis.discount;
                                        }
                                    }
                                    else {
                                        if (dis.limit > packageUsed) {
                                            packageDiscountOn.push(data.service)
                                            labour_cost = lc - dis.discount;
                                        }
                                    }
                                }
                            }
                        });
                    }
                }
            }
        }
    }
    return labour_cost;
}

async function packageDeduction(id) {
    var booking = await Booking.findById(id).exec();
    if (booking.package) {
        var packageUsed = [];
        var package = await UserPackage.findOne({ _id: booking.package, car: booking.car }).exec();
        if (package) {
            if (package.status == false) {
                UserPackage.findOneAndUpdate({ _id: booking.package }, { "$set": { status: true } }, async function () { });
            }

            booking.services.forEach(async function (service) {
                package.discount.forEach(async function (dis) {
                    if (dis.for == "specific") {
                        if (dis.label == service.service) {
                            if (dis.discount > 0) {
                                packageUsed.push({
                                    package: booking.package,
                                    car: booking.car,
                                    user: booking.user,
                                    booking: booking._id,
                                    for: service.type,
                                    label: service.service,
                                    created_at: new Date(),
                                    updated_at: new Date()
                                });
                            }
                        }
                    }
                    else if (dis.for == "category") {
                        if (dis.label == service.type) {
                            packageUsed.push({
                                package: booking.package,
                                car: booking.car,
                                user: booking.user,
                                booking: booking._id,
                                for: service.type,
                                label: service.type,
                                created_at: new Date(),
                                updated_at: new Date()
                            })
                        }
                    }
                });
            });

            var packageUsed = _.uniqBy(packageUsed, function (o) {
                return o.label;
            });

            packageUsed.forEach(async function (p) {
                var checkUsedPackage = await PackageUsed.find({ package: p.package, booking: p.booking, label: p.label, }).count().exec();

                if (checkUsedPackage == 0) {
                    PackageUsed.create({
                        package: p.package,
                        car: p.car,
                        user: p.user,
                        booking: p.booking,
                        for: p.for,
                        label: p.label,
                        created_at: p.created_at,
                        updated_at: p.updated_at
                    })
                }
            })
        }
    }
}

async function stockEntry(purchase, product, business) {
    var part_no = product.part_no;
    part_no = part_no.replace(/,/g, ", ");
    part_no = part_no.toUpperCase();

    var businessProduct = await BusinessProduct.findOne({ part_no: part_no, unit: product.unit, business: business }).sort({ updated_at: -1 }).exec();

    var margin_total = 0;
    if (businessProduct) {
        if (businessProduct.price.rate == product.rate) {
            var tax = [];
            var tax_info = await Tax.findOne({ rate: parseFloat(product.tax_rate), type: "GST" }).exec();
            var rate = parseFloat(product.rate);
            var amount = parseFloat(product.rate);
            var tax_rate = tax_info.detail;
            var base = amount

            /*if(product.amount_is_tax=="exclusive")
            {
                var tax_on_amount = amount;
                if(tax_rate.length>0){
                    for(var r=0; r<tax_rate.length; r++)
                    {
                        if(tax_rate[r].rate != tax_info.rate)
                        {
                            var t = tax_on_amount*(tax_rate[r].rate/100);   
                            amount = amount+t;
                            tax.push({
                                tax: tax_rate[r].tax,
                                rate: tax_rate[r].rate,
                                amount: parseFloat(t.toFixed(2))
                            })
                        }
                        else{
                            var t = tax_on_amount*(tax_info.rate/100);   
                            amount = amount+t;
                            tax.push({
                                tax: tax_info.tax,tax_rate: tax_info.rate,
                                rate: tax_info.rate,
                                amount: parseFloat(t.toFixed(2))
                            })
                        }
                    }
                }
            }  */

            if (product.amount_is_tax == "inclusive") {
                var x = (100 + tax_info.rate) / 100;
                var tax_on_amount = amount / x;
                if (tax_rate.length > 0) {
                    for (var r = 0; r < tax_rate.length; r++) {
                        if (tax_rate[r].rate != tax_info.rate) {
                            var t = tax_on_amount * (tax_rate[r].rate / 100);
                            base = base - t;
                            tax.push({
                                tax: tax_rate[r].tax,
                                rate: tax_rate[r].rate,
                                amount: parseFloat(t.toFixed(2))
                            });
                        }
                        else {
                            var t = amount - tax_on_amount;
                            base = base - t;
                            tax.push({
                                tax: tax_info.tax,
                                rate: tax_info.rate,
                                amount: parseFloat(t.toFixed(2))
                            });
                        }
                    }
                }
            }

            var tax_details = {
                tax: tax_info.tax,
                rate: tax_info.rate,
                amount: amount,
                detail: tax
            }

            var checkSku = _.filter(businessProduct.sku, sku => sku.sku == product.sku);
            if (checkSku.length > 0) {
                var totalSkuStock = parseFloat(product.stock) + parseFloat(checkSku[0].total);
                var availSkuStock = parseFloat(product.stock) + parseFloat(checkSku[0].available);

                var sku = {
                    sku: product.sku,
                    total: totalSkuStock,
                    available: availSkuStock,
                }
            }
            else {
                var sku = {
                    sku: product.sku,
                    total: product.stock,
                    available: product.stock,
                }
            }

            var stockTotal = parseFloat(businessProduct.stock.total) + parseFloat(product.stock);
            var stockAvailable = parseFloat(businessProduct.stock.available) + parseFloat(product.stock);

            var list_type = [];
            list_type = _.concat(businessProduct.list_type, "Offline");
            list_type = _.uniq(list_type);

            var purchases = [];
            purchases = _.concat(businessProduct.purchases, purchase);
            purchases = _.uniq(purchases);

            var data = {
                purchase: purchase,
                purchases: purchases,
                business: business,
                part_no: part_no,
                stock: {
                    total: stockTotal,
                    consumed: businessProduct.stock.consumed,
                    available: stockAvailable,
                },
                sku: sku,
                title: product.title,
                price: {
                    mrp: product.mrp,
                    rate: product.rate,
                    amount: amount,
                    sell_price: amount,
                    margin: product.margin,
                    margin_total: margin_total,
                },
                amount_is_tax: "inclusive",
                tax: tax_info.tax,
                tax_rate: tax_info.rate,
                tax_type: "GST",
                unit: product.unit,
                quantity: product.quantity,
                tax_info: tax_details,
                list_type: list_type,
                updated_at: new Date()
            };

            BusinessProduct.findOneAndUpdate({ _id: businessProduct._id, business: business }, { $set: data }, { new: true }, async function () {
                BusinessProduct.findOneAndUpdate({ _id: businessProduct._id, business: business }, { "$pull": { "sku": { "sku": product.sku } } }, async function () { });
                BusinessProduct.findOneAndUpdate({ _id: businessProduct._id, business: business }, { $push: { sku: sku } }, { new: true }, async function () { });
                return true;
            });
        }
        else {
            var tax = [];
            var tax_info = await Tax.findOne({ rate: product.tax_rate, type: "GST" }).exec();
            var rate = product.rate;
            var amount = product.rate;
            var tax_rate = tax_info.detail;
            var base = amount
            /*if(product.margin){
                var margin = product.margin;
                margin = margin.toString();
                if(margin.indexOf("%")>=0)
                {
                    margin = parseFloat(margin);
                    if(!isNaN(margin) && margin>0)
                    {
                        margin_total = amount*(margin/100);
                        amount = amount+margin_total
                    }
                }
                else
                {
                    margin_total = parseFloat(margin);
                    amount = amount+margin_total
                }
            }*/

            /*if(product.amount_is_tax=="exclusive")
            {
                var tax_on_amount = amount;
                if(tax_rate.length>0){
                    for(var r=0; r<tax_rate.length; r++)
                    {
                        if(tax_rate[r].rate != tax_info.rate)
                        {
                            var t = tax_on_amount*(tax_rate[r].rate/100);   
                            amount = amount+t;
                            tax.push({
                                tax: tax_rate[r].tax,
                                rate: tax_rate[r].rate,
                                amount: parseFloat(t.toFixed(2))
                            })
                        }
                        else{
                            var t = tax_on_amount*(tax_info.rate/100);   
                            amount = amount+t;
                            tax.push({
                                tax: tax_info.tax,tax_rate: tax_info.rate,
                                rate: tax_info.rate,
                                amount: parseFloat(t.toFixed(2))
                            })
                        }
                    }
                }
            }  */

            if (product.amount_is_tax == "inclusive") {
                var x = (100 + tax_info.rate) / 100;
                var tax_on_amount = amount / x;
                if (tax_rate.length > 0) {
                    for (var r = 0; r < tax_rate.length; r++) {
                        if (tax_rate[r].rate != tax_info.rate) {
                            var t = tax_on_amount * (tax_rate[r].rate / 100);
                            base = base - t;
                            tax.push({
                                tax: tax_rate[r].tax,
                                rate: tax_rate[r].rate,
                                amount: parseFloat(t.toFixed(2))
                            });
                        }
                        else {
                            var t = amount - tax_on_amount;
                            base = base - t;
                            tax.push({
                                tax: tax_info.tax,
                                rate: tax_info.rate,
                                amount: parseFloat(t.toFixed(2))
                            });
                        }
                    }
                }
            }

            var tax_details = {
                tax: tax_info.tax,
                rate: tax_info.rate,
                amount: amount,
                detail: tax
            }


            var sku = {
                sku: product.sku,
                total: product.stock,
                available: product.stock,
            };

            var stock = {
                total: product.stock,
                consumed: 0,
                available: product.stock,
            };

            var list_type = [];
            list_type = _.concat(businessProduct.list_type, "Offline");
            list_type = _.uniq(list_type);

            var purchases = [];
            purchases = _.concat(businessProduct.purchases, purchase);
            purchases = _.uniq(purchases);

            var data = {
                purchase: purchase,
                purchases: purchases,
                business: business,
                product: businessProduct.product,
                product_id: businessProduct.product_id,
                part_no: businessProduct.part_no,
                product_brand: businessProduct.product_brand,
                product_model: businessProduct.product_model,
                model: businessProduct.model,
                category: businessProduct.category,
                subcategory: businessProduct.subcategory,
                title: product.title,
                short_description: businessProduct.short_description,
                long_description: businessProduct.long_description,
                thumbnail: businessProduct.thumbnail,
                specification: businessProduct.specification,
                hsn_sac: businessProduct.hsn_sac,
                unit: businessProduct.unit,
                quantity: businessProduct.quantity,
                models: businessProduct.models,
                stock: stock,
                list_type: list_type,
                sku: sku,
                price: {
                    mrp: parseFloat(product.mrp),
                    rate: parseFloat(product.rate),
                    amount: amount,
                    sell_price: amount,
                    margin: product.margin,
                    margin_total: margin_total,
                },
                amount_is_tax: "inclusive",
                tax: tax_info.tax,
                tax_rate: tax_info.rate,
                tax_type: "GST",
                tax_info: tax_details,
                created_at: new Date(),
                updated_at: new Date()
            };

            BusinessProduct.create(data).then(async function (bp) {
            });
        }
    }
    else {
        var tax = [];
        var tax_info = await Tax.findOne({ rate: parseFloat(product.tax_rate), type: "GST" }).exec();
        var rate = parseFloat(product.rate);
        var amount = parseFloat(product.rate);
        var tax_rate = tax_info.detail;
        var base = amount
        /*if(product.margin){
            var margin = product.margin;
            margin = margin.toString();
            if(margin.indexOf("%")>=0)
            {
                margin = parseFloat(margin);
                if(!isNaN(margin) && margin>0)
                {
                    margin_total = amount*(margin/100);
                    amount = amount+margin_total
                }
            }
            else
            {
                margin_total = parseFloat(margin);
                amount = amount+margin_total
            }
        }     */

        /* if(product.amount_is_tax=="exclusive")
         {
             var tax_on_amount = amount;
             if(tax_rate.length>0){
                 for(var r=0; r<tax_rate.length; r++)
                 {
                     if(tax_rate[r].rate != tax_info.rate)
                     {
                         var t = tax_on_amount*(tax_rate[r].rate/100);   
                         amount = amount+t;
                         tax.push({
                             tax: tax_rate[r].tax,
                             rate: tax_rate[r].rate,
                             amount: parseFloat(t.toFixed(2))
                         })
                     }
                     else{
                         var t = tax_on_amount*(tax_info.rate/100);   
                         amount = amount+t;
                         tax.push({
                             tax: tax_info.tax,tax_rate: tax_info.rate,
                             rate: tax_info.rate,
                             amount: parseFloat(t.toFixed(2))
                         })
                     }
                 }
             }
         }*/

        if (product.amount_is_tax == "inclusive") {
            var x = (100 + tax_info.rate) / 100;
            var tax_on_amount = amount / x;
            if (tax_rate.length > 0) {
                for (var r = 0; r < tax_rate.length; r++) {
                    if (tax_rate[r].rate != tax_info.rate) {
                        var t = tax_on_amount * (tax_rate[r].rate / 100);
                        base = base - t;
                        tax.push({
                            tax: tax_rate[r].tax,
                            rate: tax_rate[r].rate,
                            amount: parseFloat(t.toFixed(2))
                        });
                    }
                    else {
                        var t = amount - tax_on_amount;
                        base = base - t;
                        tax.push({
                            tax: tax_info.tax,
                            rate: tax_info.rate,
                            amount: parseFloat(t.toFixed(2))
                        });
                    }
                }
            }
        }

        var tax_details = {
            tax: tax_info.tax,
            rate: tax_info.rate,
            amount: amount,
            detail: tax
        }

        var sku = {
            sku: product.sku,
            total: product.stock,
            available: product.stock,
        };

        var stock = {
            total: product.stock,
            consumed: 0,
            available: product.stock,
        };

        var list_type = [];
        list_type.push("Offline");

        var purchases = [];
        purchases.push(purchase);

        var data = {
            purchase: purchase,
            purchases: purchases,
            business: business,
            product: null,
            product_id: Math.round(+new Date() / 1000) + Math.round((Math.random() * 9999) + 1),
            part_no: part_no,
            product_brand: null,
            product_model: null,
            model: null,
            category: null,
            subcategory: null,
            title: product.title,
            short_description: "",
            long_description: "",
            thumbnail: "",
            specification: "",
            hsn_sac: product.hsn_sac,
            quantity: product.quantity,
            unit: product.unit,
            models: product.models,
            stock: stock,
            sku: sku,
            list_type: list_type,
            price: {
                mrp: product.mrp,
                rate: product.rate,
                amount: amount,
                sell_price: amount,
                margin_total: margin_total,
                margin: product.margin,
            },
            amount_is_tax: "inclusive",
            tax: tax_info.tax,
            tax_rate: tax_info.rate,
            tax_type: "GST",
            tax_info: tax_details,
            list_type: list_type,
            created_at: new Date(),
            updated_at: new Date()
        };

        BusinessProduct.create(data).then(async function (bp) {
            Purchase.findOneAndUpdate({ _id: purchase, items: { $elemMatch: { part_no: product.part_no } } }, { $set: { "items.$.product": bp._id } }, { new: false }, async function (err, doc) {
                if (err) {
                    // console.log(err)
                }
                else {
                    // console.log(bp._id)
                }
            });
        });
    }
}

async function stockRemove(purchase, product, business) {
    var part_no = product.part_no;
    part_no = part_no.replace(/,/g, ", ");
    part_no = part_no.toUpperCase();
    var businessProduct = await BusinessProduct.findOne({ purchase: purchase, part_no: part_no, business: business }).exec();

    var margin_total = 0;
    if (businessProduct) {
        var checkSku = _.filter(businessProduct.sku, sku => sku.sku == product.sku);
        if (checkSku.length > 0) {
            var totalSkuStock = parseFloat(checkSku[0].total) - parseFloat(product.stock);
            if (totalSkuStock < 0) {
                totalSkuStock = 0;
            }
            var availSkuStock = parseFloat(checkSku[0].available) - parseFloat(product.stock);
            if (availSkuStock < 0) {
                availSkuStock = 0;
            }
            var sku = {
                sku: product.sku,
                total: totalSkuStock,
                available: availSkuStock,
            }
        }
        else {
            var sku = {
                sku: product.sku,
                total: product.stock,
                available: product.stock,
            }
        }

        var stockTotal = parseFloat(businessProduct.stock.total) - parseFloat(product.stock);
        if (stockTotal < 0) {
            stockTotal = 0;
        }
        var stockAvailable = parseFloat(businessProduct.stock.available) - parseFloat(product.stock);
        if (stockAvailable < 0) {
            stockAvailable = 0;
        }

        var data = {
            stock: {
                total: stockTotal,
                consumed: stockTotal - stockAvailable,
                available: stockAvailable,
            },
            sku: sku,
            updated_at: new Date()
        };

        BusinessProduct.findOneAndUpdate({ _id: businessProduct._id, business: business }, { $set: data }, { new: false }, async function () {
            // console.log(data)
            BusinessProduct.findOneAndUpdate({ _id: businessProduct._id, business: business }, { "$pull": { "sku": { "sku": product.sku } } }, async function () { });
            BusinessProduct.findOneAndUpdate({ _id: businessProduct._id, business: business }, { $push: { sku: sku } }, { new: true }, async function () { });
        });
    }
}

async function stockDeduction(product, booking) {
    var businessProduct = await BusinessProduct.findById(product.source).exec();
    if (businessProduct) {
        if (businessProduct.stock.available >= product.quantity) {
            var id = product._id;

            var stockTotal = parseFloat(businessProduct.stock.total);
            var stockAvailable = parseFloat(businessProduct.stock.available) - product.quantity;
            var stockConsumed = parseFloat(businessProduct.stock.consumed) + product.quantity;

            if (stockAvailable < 0) {
                stockAvailable = 0
            }

            if (stockConsumed < 0) {
                stockConsumed = 0
            }

            var stock = {
                total: stockTotal,
                available: stockAvailable,
                consumed: stockConsumed
            }

            BusinessProduct.findOneAndUpdate({ _id: product.source }, { $set: { stock: stock } }, { new: false }, async function (err, doc) {
                if (err) {
                    // console.log(err)
                }
                else {
                    Booking.findOneAndUpdate({
                        _id: booking,
                        services: {
                            $elemMatch: {
                                parts: {
                                    $elemMatch: {
                                        _id: id,
                                    }
                                }
                            }
                        }
                    }, {
                        $set: {
                            //"services.$.parts.$[].source": mongoose.Types.ObjectId(source),
                            "services.$.parts.$[].issued": true,
                        }
                    }, { new: true }, async function (err, doc) {
                        if (err) {
                            // console.log(err)
                        }
                        else {
                            // console.log("Success")
                        }
                    });
                }
            });
        }
    }
}

async function orderItemReturn(product) {
    var businessProduct = await BusinessProduct.findById(product.product).exec();
    if (businessProduct) {
        var stockTotal = parseFloat(businessProduct.stock.total);
        var stockAvailable = parseFloat(businessProduct.stock.available) + product.quantity;
        var stockConsumed = parseFloat(businessProduct.stock.consumed) - product.quantity;

        if (stockAvailable < 0) {
            stockAvailable = 0
        }
        else if (stockAvailable > stockTotal) {
            stockAvailable = stockTotal
        }

        if (stockConsumed < 0) {
            stockConsumed = 0
        }
        else if (stockConsumed > stockTotal) {
            stockConsumed = stockTotal
        }

        var stock = {
            total: stockTotal,
            available: stockAvailable,
            consumed: stockConsumed
        }

        BusinessProduct.findOneAndUpdate({ _id: businessProduct.id }, { $set: { stock: stock } }, { new: false }, async function (err, doc) {
            if (err) {
                // console.log(err)
            }
            else {
                OrderLine.findOneAndUpdate({ _id: product._id }, { $set: { issued: false, status: "Confirmed" } }, { new: false }, async function (err, doc) {
                });
            }
        });
    }

    return true;
}

async function orderItemDeduct(order, business) {
    var bool = false;
    await OrderLine.find({ business: business, order: order })
        .cursor().eachAsync(async (orderLine) => {
            var businessProduct = await BusinessProduct.findById(orderLine.product).exec();
            // console.log("available: " + businessProduct.stock.available + " Required: " + orderLine.quantity)
            if (orderLine.issued == false) {
                if (businessProduct) {
                    if (businessProduct.stock.available >= orderLine.quantity) {
                        // console.log("drop")
                        var stockTotal = parseFloat(businessProduct.stock.total);
                        var stockAvailable = parseFloat(businessProduct.stock.available) - orderLine.quantity;
                        var stockConsumed = parseFloat(businessProduct.stock.consumed) + orderLine.quantity;

                        if (stockAvailable < 0) {
                            stockAvailable = 0
                        }

                        if (stockConsumed < 0) {
                            stockConsumed = 0
                        }

                        var stock = {
                            total: stockTotal,
                            available: stockAvailable,
                            consumed: stockConsumed
                        }

                        BusinessProduct.findOneAndUpdate({ _id: orderLine.product }, { $set: { stock: stock } }, { new: false }, async function (err, doc) {
                            if (err) {
                                return false;
                            }
                            else {
                                OrderLine.findOneAndUpdate({ _id: orderLine._id }, { $set: { issued: true } }, { new: false }, async function (err, doc) {
                                });
                            }
                        });
                    }
                    else {
                        // console.log("drop no where")
                    }
                }
            }
        });

    var not_issued = [];
    var orderLines = await OrderLine.find({ business: business, order: order }).exec();

    var not_issued = _.filter(orderLines, issued => issued.issued == false);

    if (not_issued.length == 0) {
        bool = true
    }

    return bool
}

async function serviceAdd(data, booking) {
    var booking = await Booking.findById(booking).exec();
    if (booking) {
        var car = await Car.findById(booking.car).populate('model').exec();
        var automaker = await Automaker.findById(car.model.automaker).exec();
        var bookingService = {
            package: data.package,
            automaker: automaker._id,
            _automaker: automaker.maker,
            model: car.model._id,
            _model: car.model.value,
            segment: car.model.segment,
            service: data.service,
            description: data.description,
            parts: data.parts,
            labour: data.labour,
            opening_fitting: data.opening_fitting,
            part_cost: data.part_cost,
            of_cost: data.of_cost,
            labour_cost: data.labour_cost,
            mileage: data.mileage,
            cost: data.labour_cost + data.part_cost,
            mrp: data.mrp,
            type: data.type,
            editable: data.editable,
            labour_cost_editable: data.labour_cost_editable,
            part_cost_editable: data.part_cost_editable,
            of_cost_editable: data.of_cost_editable,
            publish: false
        }
        if (data.type == "services") {
            Service.create(bookingService)
        }
        else if (data.type == "collision") {
            Collision.create(bookingService)
        }
        else if (data.type == "detailing") {
            Detailing.create(bookingService)
        }
        else if (data.type == "customization") {
            Customization.create(bookingService)
        }
    }
}

async function getAdvisor(user, business) {
    var advisor = business;
    var role = await Management.findOne({ user: user, business: business }).exec();
    if (role.role == "Service Advisor") {
        advisor = role.user;
    }
    else {
        var advisorBooking = [];
        await Management.find({ business: business, role: "Service Advisor" })
            .cursor().eachAsync(async (a) => {
                var d = await Booking.find({ business: business, advisor: a.user }).count().exec();
                advisorBooking.push({
                    user: a.user,
                    count: d
                })
            });

        if (advisorBooking.length != 0) {
            advisorBooking.sort(function (a, b) {
                return a.count > b.count;
            });

            advisor = advisorBooking[0].user;
        }
        else {
            advisor = role.business
        }
    }

    return advisor;
}

async function getUser(data) {
    if (data.name != "" && data.contact_no != "") {
        var user = await User.findOne({ contact_no: data.contact_no, "account_info.type": "user" }).exec();
        if (user) {
            return user._id
        }
        else {
            var name = data.name;
            var rand = Math.ceil((Math.random() * 100000) + 1);
            var id = mongoose.Types.ObjectId();

            var firstPart = (Math.random() * 46656) | 0;
            var secondPart = (Math.random() * 46656) | 0;
            firstPart = ("000" + firstPart.toString(36)).slice(-3);
            secondPart = ("000" + secondPart.toString(36)).slice(-3);
            var referral_code = firstPart.toUpperCase() + secondPart.toUpperCase();

            User.create({
                _id: id,
                name: data.name,
                rand: Math.floor((Math.random() * 100000) + 1),
                username: shortid.generate(),
                referral_code: referral_code,
                geometry: [0, 0],
                device: [],
                otp: Math.floor(Math.random() * 90000) + 10000,
                careager_cash: 0,
                socialite: "",
                optional_info: "",
                business_info: "",
                name: _.startCase(_.toLower(data.name)),
                email: data.email,
                optional_info: {},
                business_info: {},
                uuid: uuidv1(),
                contact_no: data.contact_no,
                uuid: uuidv1(),
                account_info: {
                    type: "user",
                    status: "Complete"
                },
                address: {
                    country: "India",
                    timezone: "Asia/Kolkata",
                    location: ""
                }
            }).then(async function (u) {
                event.signupSMS(u);
                //event.otpSms(u);
            });

            return id;
        }
    }
    else {
        return false;
    }
}

async function getCar(data) {
    var rg = data.registration_no;
    var reg_no_copy = rg.replace(/ /g, '');
    var car = await Car.findOne({ registration_no: reg_no_copy, status: true }).exec();
    if (car) {
        return car._id
    }
    else {
        var variant = await Variant.findOne({ _id: data.variant }).populate('model').select('-service_schedule').exec();
        if (variant) {

            var reg = await Car.find({ registration_no: reg_no_copy, status: true }).count().exec();
            if (reg == 0) {
                var id = mongoose.Types.ObjectId();
                var automaker = await Automaker.findById(variant.model.automaker).exec();
                /// cconsole.log)
                Car.create({
                    _id: id,
                    geometry: [
                        0,
                        0
                    ],
                    registration_no: reg_no_copy,
                    reg_no_copy: reg_no_copy,
                    title: variant.variant,
                    variant: variant._id,
                    _variant: variant.value,
                    automaker: variant.model.automaker,
                    _automaker: automaker.maker,
                    model: variant.model._id,
                    _model: variant.model.value,
                    segment: variant.model.segment,
                    user: data.user,
                    fuel_type: variant.specification.fuel_type,
                    transmission: variant.specification.type,
                    carId: Math.round(new Date() / 1000) + Math.round((Math.random() * 9999) + 1),
                    created_at: new Date(),
                    updated_at: new Date()
                });

                return id;
            }
            else {
                return false;
            }
        }
    }
}

router.post('/packages/get', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    var user = decoded.user;

    if (req.headers['business']) {
        user = req.headers['business'];
    }




    var packages = [];

    if (req.body.car == "") {
        req.body.car = null
    }

    await UserPackage.find({ user: user, car: req.body.car }).cursor().eachAsync(async (package) => {
        var serverTime = moment.tz(new Date(), req.headers['tz']);
        var bar = package.created_at;
        bar.setDate(bar.getDate() + package.validity);
        var e = bar;
        bar = moment.tz(bar, req.headers['tz'])

        var baz = bar.diff(serverTime);
        if (baz > 0) {
            packages.push({
                package: package._id,
                name: package.name,
                description: package.description,
                payment: package.payment,
                discount: package.discount,
                type: "package",
                cost: package.cost,
                id: package._id,
                _id: package._id,
                category: package.category,
                label: package.label,
                validity: package.validity,
                expired_at: moment(e).tz(req.headers['tz']).format('ll')
            });
        }
    });

    await UserPackage.find({ user: user, car: null }).cursor().eachAsync(async (package) => {
        var serverTime = moment.tz(new Date(), req.headers['tz']);
        var bar = package.created_at;
        bar.setDate(bar.getDate() + package.validity);
        var e = bar;
        bar = moment.tz(bar, req.headers['tz'])

        var baz = bar.diff(serverTime);
        if (baz > 0) {
            packages.push({
                package: package._id,
                name: package.name,
                description: package.description,
                payment: package.payment,
                discount: package.discount,
                type: "package",
                cost: package.cost,
                id: package._id,
                _id: package._id,
                category: package.category,
                label: package.label,
                validity: package.validity,
                expired_at: moment(e).tz(req.headers['tz']).format('ll')
            });
        }
    });


    res.status(200).json({
        responseCode: 200,
        responseMessage: "",
        responseData: packages
    });
});

router.post('/booking/business/get', xAccessToken.token, async function (req, res, next) {
    var rules = {
        car: 'required',
        isCarEager: 'required',
        latitude: 'required',
        longitude: "required"
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Error",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var user = decoded.user;

        if (req.headers['business']) {
            user = req.headers['business'];
        }

        var bookingService = [];

        if (req.body.isCarEager == true) {
            var user = await User.find({ isCarEager: true }).select('name username avatar avatar_address gender business_info account_info address').sort({ created_at: -1 }).exec();

            res.status(200).json({
                responseCode: 200,
                responseMessage: "",
                responseData: user
            });
        }
        else {
            var car = await Car.findOne({ _id: req.body.car, user: user }).populate({ path: 'model', populate: { path: 'automaker' } });
            if (car) {
                var company = car.model.automaker.maker;
                var user = await User.find({
                    geometry: {
                        $near: [parseFloat(req.body.longitude), parseFloat(req.body.latitude)],
                        $maxDistance: 1000,
                    }, "business_info.business_category": "Service Station (Authorised)", /*"business_info.company": company*/
                })
                    .select('name username avatar avatar_address gender business_info account_info address')
                    .exec();

                res.status(200).json({
                    responseCode: 200,
                    responseMessage: "",
                    responseData: user
                });
            }
            else {
                res.status(400).json({
                    responseCode: 400,
                    responseMessage: "Unauthorized",
                    responseData: {}
                });
            }
        }
    }
});

router.get('/booking/category/get', xAccessToken.token, async function (req, res, next) {
    var data = [];
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;


    if (req.headers['business']) {
        user = req.headers['business'];
    }

    await BookingCategory.find({ tag: { $ne: "package" } })
        .sort({ position: 1 })
        .cursor().eachAsync(async (d) => {

            var enable = true;


            data.push({
                _id: d._id,
                id: d._id,
                tag: d.tag,
                position: d.position,
                icon: d.icon,
                title: d.title,
                image: d.image,
                video: d.video,
                home_visibility: d.home_visibility,
                id: d._id,
                nested: d.nested,
                enable: enable,
                features: d.features
            })
        });


    res.status(200).json({
        responseCode: 200,
        responseMessage: "",
        responseData: data
    });
});

router.get('/booking/category/feature/get', xAccessToken.token, async function (req, res, next) {
    var variant = await Variant.findOne({ _id: car.variant }).exec();
    var carLength = parseInt(variant.specification.length);

    res.status(200).json({
        responseCode: 200,
        responseMessage: "",
        responseData: await BookingCategory.find({ tag: req.query.tag }).exec()
    });
});

router.post('/booking/services/get', xAccessToken.token, async function (req, res, next) {
    var rules = {
        car: 'required',
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Please select a car",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var user = decoded.user;

        if (req.headers['business']) {
            user = req.headers['business'];
        }



        var packages = [];

        if (!req.body.package) {
            req.body.package = null
        }

        var business = null;
        if (req.body.business) {
            business = req.body.business
        }


        var car = await Car.findOne({ _id: req.body.car, user: user }).populate('model').exec();
        if (car) {
            if (req.body.type == "services") {
                await Service.find({ business: business, segment: car.model.segment, part_cost: 0, publish: true, business: business })
                    .cursor().eachAsync(async (service) => {
                        var labels = [];

                        labels.push(service.type)
                        labels.push(service.service)
                        var coupons = await Coupon.find({ label: { $in: labels }, expired_at: { "$gte": new Date() }, physical: false }).exec();

                        var gallery = service.gallery;
                        var getDiscount = {
                            package: req.body.package,
                            car: req.body.car,
                            category: service.type,
                            service: service.service,
                            tz: req.headers['tz'],
                            claim: false,
                        };

                        var package = await q.all(getPackageDiscount(getDiscount));
                        var labour_list = service.labour;
                        var labours = [];

                        var discount_eligible_labour_cost = _.sumBy(labour_list, x => x.amount);
                        if (labour_list.length > 0) {
                            for (var l = 0; l < labour_list.length; l++) {
                                var quantity = 1;
                                if (labour_list[l].quantity) {
                                    quantity = labour_list[l].quantity;
                                }

                                var discount_total = 0;
                                var total = 0;
                                var tax_info = await Tax.findOne({ tax: labour_list[l].tax }).exec();

                                var tax = [];
                                var rate = labour_list[l].rate;
                                var amount = parseFloat(labour_list[l].amount);
                                var tax_rate = tax_info.detail;
                                var base = amount;

                                if (Object.keys(package).length > 0) {
                                    if (package.discount_type == "percent") {
                                        discount = parseFloat(package.discount);
                                        if (!isNaN(discount) && discount > 0) {
                                            var discount_total = amount * (discount / 100);
                                            amount = amount - parseFloat(discount_total.toFixed(2))
                                            if (amount < 0) {
                                                amount = 0
                                            }
                                        }
                                    }
                                    else if (package.discount_type == "fixed") {
                                        discount = parseFloat(package.discount);
                                        if (!isNaN(discount) && discount > 0) {
                                            var discount_total = (amount / discount_eligible_labour_cost) * discount;
                                            amount = parseFloat(discount_total.toFixed(2))
                                            discount = amount - discount_total;
                                            if (amount < 0) {
                                                amount = 0
                                            }
                                        }
                                    }
                                    else {
                                        discount = parseFloat(package.discount);
                                        if (!isNaN(discount) && discount > 0) {
                                            var discount_total = (amount / discount_eligible_labour_cost) * discount;
                                            amount = amount - parseFloat(discount_total.toFixed(2))
                                            if (amount < 0) {
                                                amount = 0
                                            }
                                        }
                                    }
                                }

                                if (labour_list[l].amount_is_tax == "inclusive") {
                                    var x = (100 + tax_info.rate) / 100;
                                    var tax_on_amount = amount / x;
                                    if (tax_rate.length > 0) {
                                        for (var r = 0; r < tax_rate.length; r++) {
                                            if (tax_rate[r].rate != tax_info.rate) {
                                                var t = tax_on_amount * (tax_rate[r].rate / 100);
                                                base = base - t;
                                                tax.push({
                                                    tax: tax_rate[r].tax,
                                                    rate: tax_rate[r].rate,
                                                    amount: parseFloat(t.toFixed(2))
                                                });
                                            }
                                            else {
                                                var t = amount - tax_on_amount;
                                                base = base - t;
                                                tax.push({
                                                    tax: tax_info.tax, tax_rate: tax_info.rate,
                                                    rate: tax_info.rate,
                                                    amount: parseFloat(t.toFixed(2))
                                                });
                                            }
                                        }

                                        //base = base - discount_total;
                                    }
                                    total = total + amount;
                                }

                                var tax_details = {
                                    tax: tax_info.tax,
                                    rate: tax_info.rate,
                                    amount: total,
                                    detail: tax
                                }


                                labours.push({
                                    item: labour_list[l].item,
                                    source: labour_list[l].source,
                                    rate: parseFloat(labour_list[l].rate),
                                    quantity: 1,
                                    base: parseFloat(total.toFixed(2)),
                                    discount: parseFloat(discount_total.toFixed(2)),
                                    amount: total,
                                    customer_dep: 100,
                                    insurance_dep: 0,
                                    tax_amount: parseFloat(_.sumBy(tax, x => x.amount).toFixed(2)),
                                    amount_is_tax: labour_list[l].amount_is_tax,
                                    tax: tax_info.tax, tax_rate: tax_info.rate,
                                    tax_info: tax_details
                                });
                            }
                        }

                        if (service.opening_fitting.length != 0) {
                            service.opening_fitting[0].customer_dep = 100;
                            service.opening_fitting[0].insurance_dep = 0;
                        }

                        if (service.parts.length != 0) {
                            service.parts[0].customer_dep = 100;
                            service.parts[0].insurance_dep = 0;
                        }


                        packages.push({
                            package: service.package,
                            service: service.service,
                            labour: labours,
                            labour_cost: _.sumBy(labours, x => x.amount),
                            parts: service.parts,
                            part_cost: Math.ceil(service.part_cost),
                            opening_fitting: service.opening_fitting,
                            of_cost: Math.ceil(service.of_cost),
                            exceeded_cost: 0,
                            mrp: _.sumBy(labours, x => x.amount) + (_.sumBy(labours, x => x.amount) * (40 / 100)),
                            cost: Math.ceil(service.part_cost) + _.sumBy(labours, x => x.amount) + service.of_cost,
                            doorstep: service.doorstep,
                            unit: service.unit,
                            quantity: service.quantity,
                            part_cost_editable: service.part_cost_editable,
                            labour_cost_editable: service.labour_cost_editable,
                            of_cost_editable: service.of_cost_editable,
                            type: service.type,
                            source: service.id,
                            gallery: gallery.length,
                            description: service.description,
                            coupons: coupons,
                            id: service.id,
                            _id: service._id
                        });
                    });

                await Service.find({ business: business, model: car.model._id, publish: true, business: business })
                    .cursor().eachAsync(async (service) => {
                        var labels = [];

                        labels.push(service.type)
                        labels.push(service.service)
                        var coupons = await Coupon.find({ label: { $in: labels }, expired_at: { "$gte": new Date() }, physical: false }).exec();

                        var gallery = service.gallery;
                        var getDiscount = {
                            package: req.body.package,
                            car: req.body.car,
                            category: service.type,
                            service: service.service,
                            tz: req.headers['tz'],
                            claim: false,
                        };

                        var package = await q.all(getPackageDiscount(getDiscount));
                        var labour_list = service.labour;
                        var labours = [];

                        var discount_eligible_labour_cost = _.sumBy(labour_list, x => x.amount);
                        if (labour_list.length > 0) {
                            for (var l = 0; l < labour_list.length; l++) {
                                var quantity = 1;
                                if (labour_list[l].quantity) {
                                    quantity = labour_list[l].quantity;
                                }

                                var discount_total = 0;
                                var total = 0;
                                var tax_info = await Tax.findOne({ tax: labour_list[l].tax }).exec();

                                var tax = [];
                                var rate = labour_list[l].rate;
                                var amount = parseFloat(labour_list[l].amount);
                                var tax_rate = tax_info.detail;
                                var base = amount;

                                if (Object.keys(package).length > 0) {
                                    if (package.discount_type == "percent") {
                                        discount = parseFloat(package.discount);
                                        if (!isNaN(discount) && discount > 0) {
                                            var discount_total = amount * (discount / 100);
                                            amount = amount - parseFloat(discount_total.toFixed(2))
                                            if (amount < 0) {
                                                amount = 0
                                            }
                                        }
                                    }
                                    else if (package.discount_type == "fixed") {
                                        discount = parseFloat(package.discount);
                                        if (!isNaN(discount) && discount > 0) {
                                            var discount_total = (amount / discount_eligible_labour_cost) * discount;
                                            amount = parseFloat(discount_total.toFixed(2))
                                            discount = amount - discount_total;
                                            if (amount < 0) {
                                                amount = 0
                                            }
                                        }
                                    }
                                    else {
                                        discount = parseFloat(package.discount);
                                        if (!isNaN(discount) && discount > 0) {
                                            var discount_total = (amount / discount_eligible_labour_cost) * discount;
                                            amount = amount - parseFloat(discount_total.toFixed(2))
                                            if (amount < 0) {
                                                amount = 0
                                            }
                                        }
                                    }
                                }

                                if (labour_list[l].amount_is_tax == "inclusive") {
                                    var x = (100 + tax_info.rate) / 100;
                                    var tax_on_amount = amount / x;
                                    if (tax_rate.length > 0) {
                                        for (var r = 0; r < tax_rate.length; r++) {
                                            if (tax_rate[r].rate != tax_info.rate) {
                                                var t = tax_on_amount * (tax_rate[r].rate / 100);
                                                base = base - t;
                                                tax.push({
                                                    tax: tax_rate[r].tax,
                                                    rate: tax_rate[r].rate,
                                                    amount: parseFloat(t.toFixed(2))
                                                });
                                            }
                                            else {
                                                var t = amount - tax_on_amount;
                                                base = base - t;
                                                tax.push({
                                                    tax: tax_info.tax, tax_rate: tax_info.rate,
                                                    rate: tax_info.rate,
                                                    amount: parseFloat(t.toFixed(2))
                                                });
                                            }
                                        }

                                        //base = base - discount_total;
                                    }
                                    total = total + amount;
                                }

                                var tax_details = {
                                    tax: tax_info.tax,
                                    rate: tax_info.rate,
                                    amount: total,
                                    detail: tax
                                }


                                labours.push({
                                    item: labour_list[l].item,
                                    source: labour_list[l].source,
                                    rate: parseFloat(labour_list[l].rate),
                                    quantity: 1,
                                    base: parseFloat(total.toFixed(2)),
                                    discount: parseFloat(discount_total.toFixed(2)),
                                    amount: total,
                                    customer_dep: 100,
                                    insurance_dep: 0,
                                    tax_amount: parseFloat(_.sumBy(tax, x => x.amount).toFixed(2)),
                                    amount_is_tax: labour_list[l].amount_is_tax,
                                    tax: tax_info.tax, tax_rate: tax_info.rate,
                                    tax_info: tax_details
                                });
                            }
                        }

                        if (service.opening_fitting.length != 0) {
                            service.opening_fitting[0].customer_dep = 100;
                            service.opening_fitting[0].insurance_dep = 0;
                        }

                        if (service.parts.length != 0) {
                            service.parts[0].customer_dep = 100;
                            service.parts[0].insurance_dep = 0;
                        }


                        packages.push({
                            package: service.package,
                            service: service.service,
                            labour: labours,
                            labour_cost: _.sumBy(labours, x => x.amount),
                            parts: service.parts,
                            part_cost: Math.ceil(service.part_cost),
                            opening_fitting: service.opening_fitting,
                            of_cost: Math.ceil(service.of_cost),
                            exceeded_cost: 0,
                            mrp: _.sumBy(labours, x => x.amount) + (_.sumBy(labours, x => x.amount) * (40 / 100)),
                            cost: Math.ceil(service.part_cost) + _.sumBy(labours, x => x.amount) + service.of_cost,
                            doorstep: service.doorstep,
                            unit: service.unit,
                            quantity: service.quantity,
                            part_cost_editable: service.part_cost_editable,
                            labour_cost_editable: service.labour_cost_editable,
                            of_cost_editable: service.of_cost_editable,
                            type: service.type,
                            source: service.id,
                            gallery: gallery.length,
                            description: service.description,
                            coupons: coupons,
                            id: service.id,
                            _id: service._id
                        });
                    });

                packages = _(packages).groupBy(x => x.package).map((value, key) => ({ package: key, services: value })).value();

                res.status(200).json({
                    responseCode: 200,
                    responseMessage: "Please hold on, we're about to update the database of discontinued cars.",
                    responseData: packages
                });
            }

            if (req.body.type == "collision") {
                await Collision.find({ business: business, segment: car.model.segment, publish: true, business: business })
                    .cursor().eachAsync(async (service) => {

                        var labels = [];

                        labels.push(service.type)
                        labels.push(service.service)
                        var coupons = await Coupon.find({ label: { $in: labels }, expired_at: { "$gte": new Date() }, physical: false }).exec();

                        var getDiscount = {
                            package: req.body.package,
                            car: req.body.car,
                            category: service.type,
                            service: service.service,
                            tz: req.headers['tz'],
                            claim: false,
                        };

                        var package = await q.all(getPackageDiscount(getDiscount));
                        var labour_list = service.labour;
                        var labours = [];

                        var discount_eligible_labour_cost = _.sumBy(labour_list, x => x.amount);
                        if (labour_list.length > 0) {
                            for (var l = 0; l < labour_list.length; l++) {
                                var quantity = 1;
                                if (labour_list[l].quantity) {
                                    quantity = labour_list[l].quantity;
                                }

                                var discount_total = 0;
                                var total = 0;
                                var tax_info = await Tax.findOne({ tax: labour_list[l].tax }).exec();

                                var tax = [];
                                var rate = labour_list[l].rate;
                                var amount = parseFloat(labour_list[l].amount);
                                var tax_rate = tax_info.detail;
                                var base = amount;

                                if (Object.keys(package).length > 0) {
                                    if (package.discount_type == "percent") {
                                        discount = parseFloat(package.discount);
                                        if (!isNaN(discount) && discount > 0) {
                                            var discount_total = amount * (discount / 100);
                                            amount = amount - parseFloat(discount_total.toFixed(2))
                                            if (amount < 0) {
                                                amount = 0
                                            }
                                        }
                                    }
                                    else if (package.discount_type == "fixed") {
                                        discount = parseFloat(package.discount);
                                        if (!isNaN(discount) && discount > 0) {
                                            var discount_total = (amount / discount_eligible_labour_cost) * discount;
                                            amount = parseFloat(discount_total.toFixed(2))
                                            discount = amount - discount_total;
                                            if (amount < 0) {
                                                amount = 0
                                            }
                                        }
                                    }
                                    else {
                                        discount = parseFloat(package.discount);
                                        if (!isNaN(discount) && discount > 0) {
                                            var discount_total = (amount / discount_eligible_labour_cost) * discount;
                                            amount = amount - parseFloat(discount_total.toFixed(2))
                                            if (amount < 0) {
                                                amount = 0
                                            }
                                        }
                                    }
                                }

                                if (labour_list[l].amount_is_tax == "inclusive") {
                                    var x = (100 + tax_info.rate) / 100;
                                    var tax_on_amount = amount / x;
                                    if (tax_rate.length > 0) {
                                        for (var r = 0; r < tax_rate.length; r++) {
                                            if (tax_rate[r].rate != tax_info.rate) {
                                                var t = tax_on_amount * (tax_rate[r].rate / 100);
                                                base = base - t;
                                                tax.push({
                                                    tax: tax_rate[r].tax,
                                                    rate: tax_rate[r].rate,
                                                    amount: parseFloat(t.toFixed(2))
                                                });
                                            }
                                            else {
                                                var t = amount - tax_on_amount;
                                                base = base - t;
                                                tax.push({
                                                    tax: tax_info.tax, tax_rate: tax_info.rate,
                                                    rate: tax_info.rate,
                                                    amount: parseFloat(t.toFixed(2))
                                                });
                                            }
                                        }

                                        //base = base - discount_total;
                                    }
                                    total = total + amount;
                                }

                                var tax_details = {
                                    tax: tax_info.tax,
                                    rate: tax_info.rate,
                                    amount: total,
                                    detail: tax
                                }


                                labours.push({
                                    item: labour_list[l].item,
                                    source: labour_list[l].source,
                                    rate: parseFloat(labour_list[l].rate),
                                    quantity: 1,
                                    base: parseFloat(total.toFixed(2)),
                                    discount: parseFloat(discount_total.toFixed(2)),
                                    amount: total,
                                    customer_dep: 100,
                                    insurance_dep: 0,
                                    tax_amount: parseFloat(_.sumBy(tax, x => x.amount).toFixed(2)),
                                    amount_is_tax: labour_list[l].amount_is_tax,
                                    tax: tax_info.tax, tax_rate: tax_info.rate,
                                    tax_info: tax_details
                                });
                            }
                        }

                        if (service.opening_fitting.length != 0) {
                            service.opening_fitting[0].customer_dep = 100;
                            service.opening_fitting[0].insurance_dep = 0;
                        }

                        if (service.parts.length != 0) {
                            service.parts[0].customer_dep = 100;
                            service.parts[0].insurance_dep = 0;
                        }


                        packages.push({
                            package: service.package,
                            service: service.service,
                            labour: labours,
                            labour_cost: _.sumBy(labours, x => x.amount),
                            parts: service.parts,
                            part_cost: Math.ceil(service.part_cost),
                            opening_fitting: service.opening_fitting,
                            of_cost: Math.ceil(service.of_cost),
                            exceeded_cost: 0,
                            mrp: _.sumBy(labours, x => x.amount) + (_.sumBy(labours, x => x.amount) * (40 / 100)),
                            cost: Math.ceil(service.part_cost) + _.sumBy(labours, x => x.amount) + service.of_cost,
                            doorstep: service.doorstep,
                            unit: service.unit,
                            quantity: service.quantity,
                            part_cost_editable: service.part_cost_editable,
                            labour_cost_editable: service.labour_cost_editable,
                            of_cost_editable: service.of_cost_editable,
                            type: service.type,
                            source: service.id,
                            gallery: 0,
                            description: service.description,
                            coupons: coupons,
                            id: service.id,
                            _id: service._id
                        });
                    });

                packages = _(packages).groupBy(x => x.package).map((value, key) => ({ package: key, services: value })).value();

                res.status(200).json({
                    responseCode: 200,
                    responseMessage: "Please hold on, we're about to update the database of discontinued cars.",
                    responseData: packages
                });
            }

            else if (req.body.type == "detailing") {
                await Detailing.find({ business: business, segment: car.model.segment, publish: true, business: business })
                    .cursor().eachAsync(async (service) => {

                        var labels = [];

                        labels.push(service.type)
                        labels.push(service.service)
                        var coupons = await Coupon.find({ label: { $in: labels }, expired_at: { "$gte": new Date() }, physical: false }).exec();

                        var gallery = service.gallery;
                        var getDiscount = {
                            package: req.body.package,
                            car: req.body.car,
                            category: service.type,
                            service: service.service,
                            tz: req.headers['tz'],
                            claim: false,
                        };

                        var package = await q.all(getPackageDiscount(getDiscount));
                        var labour_list = service.labour;
                        var labours = [];

                        var discount_eligible_labour_cost = _.sumBy(labour_list, x => x.amount);
                        if (labour_list.length > 0) {
                            for (var l = 0; l < labour_list.length; l++) {
                                var quantity = 1;
                                if (labour_list[l].quantity) {
                                    quantity = labour_list[l].quantity;
                                }

                                var discount_total = 0;
                                var total = 0;
                                var tax_info = await Tax.findOne({ tax: labour_list[l].tax }).exec();

                                var tax = [];
                                var rate = labour_list[l].rate;
                                var amount = parseFloat(labour_list[l].amount);
                                var tax_rate = tax_info.detail;
                                var base = amount;

                                if (Object.keys(package).length > 0) {
                                    if (package.discount_type == "percent") {
                                        discount = parseFloat(package.discount);
                                        if (!isNaN(discount) && discount > 0) {
                                            var discount_total = amount * (discount / 100);
                                            amount = amount - parseFloat(discount_total.toFixed(2))
                                            if (amount < 0) {
                                                amount = 0
                                            }
                                        }
                                    }
                                    else if (package.discount_type == "fixed") {
                                        discount = parseFloat(package.discount);
                                        if (!isNaN(discount) && discount > 0) {
                                            var discount_total = (amount / discount_eligible_labour_cost) * discount;
                                            amount = parseFloat(discount_total.toFixed(2))
                                            discount = amount - discount_total;
                                            if (amount < 0) {
                                                amount = 0
                                            }
                                        }
                                    }
                                    else {
                                        discount = parseFloat(package.discount);
                                        if (!isNaN(discount) && discount > 0) {
                                            var discount_total = (amount / discount_eligible_labour_cost) * discount;
                                            amount = amount - parseFloat(discount_total.toFixed(2))
                                            if (amount < 0) {
                                                amount = 0
                                            }
                                        }
                                    }
                                }

                                if (labour_list[l].amount_is_tax == "inclusive") {
                                    var x = (100 + tax_info.rate) / 100;
                                    var tax_on_amount = amount / x;
                                    if (tax_rate.length > 0) {
                                        for (var r = 0; r < tax_rate.length; r++) {
                                            if (tax_rate[r].rate != tax_info.rate) {
                                                var t = tax_on_amount * (tax_rate[r].rate / 100);
                                                base = base - t;
                                                tax.push({
                                                    tax: tax_rate[r].tax,
                                                    rate: tax_rate[r].rate,
                                                    amount: parseFloat(t.toFixed(2))
                                                });
                                            }
                                            else {
                                                var t = amount - tax_on_amount;
                                                base = base - t;
                                                tax.push({
                                                    tax: tax_info.tax, tax_rate: tax_info.rate,
                                                    rate: tax_info.rate,
                                                    amount: parseFloat(t.toFixed(2))
                                                });
                                            }
                                        }

                                        //base = base - discount_total;
                                    }
                                    total = total + amount;
                                }

                                var tax_details = {
                                    tax: tax_info.tax,
                                    rate: tax_info.rate,
                                    amount: total,
                                    detail: tax
                                }


                                labours.push({
                                    item: labour_list[l].item,
                                    source: labour_list[l].source,
                                    rate: parseFloat(labour_list[l].rate),
                                    quantity: 1,
                                    base: parseFloat(total.toFixed(2)),
                                    discount: parseFloat(discount_total.toFixed(2)),
                                    amount: total,
                                    customer_dep: 100,
                                    insurance_dep: 0,
                                    tax_amount: parseFloat(_.sumBy(tax, x => x.amount).toFixed(2)),
                                    amount_is_tax: labour_list[l].amount_is_tax,
                                    tax: tax_info.tax, tax_rate: tax_info.rate,
                                    tax_info: tax_details
                                });
                            }
                        }

                        if (service.opening_fitting.length != 0) {
                            service.opening_fitting[0].customer_dep = 100;
                            service.opening_fitting[0].insurance_dep = 0;
                        }

                        if (service.parts.length != 0) {
                            service.parts[0].customer_dep = 100;
                            service.parts[0].insurance_dep = 0;
                        }


                        packages.push({
                            package: service.package,
                            service: service.service,
                            labour: labours,
                            labour_cost: _.sumBy(labours, x => x.amount),
                            parts: service.parts,
                            part_cost: Math.ceil(service.part_cost),
                            opening_fitting: service.opening_fitting,
                            of_cost: Math.ceil(service.of_cost),
                            exceeded_cost: 0,
                            mrp: _.sumBy(labours, x => x.amount) + (_.sumBy(labours, x => x.amount) * (40 / 100)),
                            cost: Math.ceil(service.part_cost) + _.sumBy(labours, x => x.amount) + service.of_cost,
                            doorstep: service.doorstep,
                            unit: service.unit,
                            quantity: service.quantity,
                            part_cost_editable: service.part_cost_editable,
                            labour_cost_editable: service.labour_cost_editable,
                            of_cost_editable: service.of_cost_editable,
                            type: service.type,
                            source: service.id,
                            gallery: gallery.length,
                            description: service.description,
                            coupons: coupons,
                            id: service.id,
                            _id: service._id
                        });
                    });

                packages = _(packages).groupBy(x => x.package).map((value, key) => ({ package: key, services: value })).value();

                res.status(200).json({
                    responseCode: 200,
                    responseMessage: "Please hold on, we're about to update the database of discontinued cars.",
                    responseData: packages
                });
            }
            else if (req.body.type == "customization") {
                await Customization.find({ business: business, segment: car.model.segment, publish: true, business: business })
                    .cursor().eachAsync(async (service) => {

                        var labels = [];

                        labels.push(service.type)
                        labels.push(service.service)
                        var coupons = await Coupon.find({ label: { $in: labels }, expired_at: { "$gte": new Date() }, physical: false }).exec();

                        var getDiscount = {
                            package: req.body.package,
                            car: req.body.car,
                            category: service.type,
                            service: service.service,
                            tz: req.headers['tz'],
                            claim: false,
                        };

                        var package = await q.all(getPackageDiscount(getDiscount));
                        var labour_list = service.labour;
                        var labours = [];

                        var discount_eligible_labour_cost = _.sumBy(labour_list, x => x.amount);
                        if (labour_list.length > 0) {
                            for (var l = 0; l < labour_list.length; l++) {
                                var quantity = 1;
                                if (labour_list[l].quantity) {
                                    quantity = labour_list[l].quantity;
                                }

                                var discount_total = 0;
                                var total = 0;
                                var tax_info = await Tax.findOne({ tax: labour_list[l].tax }).exec();

                                var tax = [];
                                var rate = labour_list[l].rate;
                                var amount = parseFloat(labour_list[l].amount);
                                var tax_rate = tax_info.detail;
                                var base = amount;

                                if (Object.keys(package).length > 0) {
                                    if (package.discount_type == "percent") {
                                        discount = parseFloat(package.discount);
                                        if (!isNaN(discount) && discount > 0) {
                                            var discount_total = amount * (discount / 100);
                                            amount = amount - parseFloat(discount_total.toFixed(2))
                                            if (amount < 0) {
                                                amount = 0
                                            }
                                        }
                                    }
                                    else if (package.discount_type == "fixed") {
                                        discount = parseFloat(package.discount);
                                        if (!isNaN(discount) && discount > 0) {
                                            var discount_total = (amount / discount_eligible_labour_cost) * discount;
                                            amount = parseFloat(discount_total.toFixed(2))
                                            discount = amount - discount_total;
                                            if (amount < 0) {
                                                amount = 0
                                            }
                                        }
                                    }
                                    else {
                                        discount = parseFloat(package.discount);
                                        if (!isNaN(discount) && discount > 0) {
                                            var discount_total = (amount / discount_eligible_labour_cost) * discount;
                                            amount = amount - parseFloat(discount_total.toFixed(2))
                                            if (amount < 0) {
                                                amount = 0
                                            }
                                        }
                                    }
                                }

                                if (labour_list[l].amount_is_tax == "inclusive") {
                                    var x = (100 + tax_info.rate) / 100;
                                    var tax_on_amount = amount / x;
                                    if (tax_rate.length > 0) {
                                        for (var r = 0; r < tax_rate.length; r++) {
                                            if (tax_rate[r].rate != tax_info.rate) {
                                                var t = tax_on_amount * (tax_rate[r].rate / 100);
                                                base = base - t;
                                                tax.push({
                                                    tax: tax_rate[r].tax,
                                                    rate: tax_rate[r].rate,
                                                    amount: parseFloat(t.toFixed(2))
                                                });
                                            }
                                            else {
                                                var t = amount - tax_on_amount;
                                                base = base - t;
                                                tax.push({
                                                    tax: tax_info.tax, tax_rate: tax_info.rate,
                                                    rate: tax_info.rate,
                                                    amount: parseFloat(t.toFixed(2))
                                                });
                                            }
                                        }

                                        //base = base - discount_total;
                                    }
                                    total = total + amount;
                                }

                                var tax_details = {
                                    tax: tax_info.tax,
                                    rate: tax_info.rate,
                                    amount: total,
                                    detail: tax
                                }


                                labours.push({
                                    item: labour_list[l].item,
                                    source: labour_list[l].source,
                                    rate: parseFloat(labour_list[l].rate),
                                    quantity: 1,
                                    base: parseFloat(total.toFixed(2)),
                                    discount: parseFloat(discount_total.toFixed(2)),
                                    amount: total,
                                    customer_dep: 100,
                                    insurance_dep: 0,
                                    tax_amount: parseFloat(_.sumBy(tax, x => x.amount).toFixed(2)),
                                    amount_is_tax: labour_list[l].amount_is_tax,
                                    tax: tax_info.tax, tax_rate: tax_info.rate,
                                    tax_info: tax_details
                                });
                            }
                        }

                        if (service.opening_fitting.length != 0) {
                            service.opening_fitting[0].customer_dep = 100;
                            service.opening_fitting[0].insurance_dep = 0;
                        }

                        if (service.parts.length != 0) {
                            service.parts[0].customer_dep = 100;
                            service.parts[0].insurance_dep = 0;
                        }


                        packages.push({
                            package: service.package,
                            service: service.service,
                            labour: labours,
                            labour_cost: _.sumBy(labours, x => x.amount),
                            parts: service.parts,
                            part_cost: Math.ceil(service.part_cost),
                            opening_fitting: service.opening_fitting,
                            of_cost: Math.ceil(service.of_cost),
                            exceeded_cost: 0,
                            mrp: Math.ceil(service.mrp),
                            cost: Math.ceil(service.part_cost) + _.sumBy(labours, x => x.amount) + service.of_cost,
                            doorstep: service.doorstep,
                            unit: service.unit,
                            quantity: service.quantity,
                            part_cost_editable: service.part_cost_editable,
                            labour_cost_editable: service.labour_cost_editable,
                            of_cost_editable: service.of_cost_editable,
                            type: service.type,
                            source: service.id,
                            gallery: 0,
                            description: service.description,
                            coupons: coupons,
                            id: service.id,
                            _id: service._id
                        });
                    });

                packages = _(packages).groupBy(x => x.package).map((value, key) => ({ package: key, services: value })).value();

                res.status(200).json({
                    responseCode: 200,
                    responseMessage: "Please hold on, we're about to update the database of discontinued cars.",
                    responseData: packages
                });
            }
            else if (req.body.type == "package") {
                await Package.find({ business: business, label: "special" }).cursor().eachAsync(async (service) => {
                    var serverTime = moment.tz(new Date(), req.headers['tz']);

                    var bar = service.created_at;
                    bar.setDate(bar.getDate() + service.validity);

                    var e = bar;
                    bar = moment.tz(bar, req.headers['tz'])

                    var baz = bar.diff(serverTime);

                    var check = await UserPackage.find({ user: user, package: service._id, car: req.body.car }).count().exec();
                    if (check <= 0) {
                        if (baz > 0) {
                            if (service.category == "addOn") {
                                packages.push({
                                    service: service.name,
                                    mrp: 0,
                                    discount: service.discount,
                                    labour_cost: service.cost,
                                    part_cost: 0,
                                    of_cost: 0,
                                    type: "addOn",
                                    cost: service.cost,
                                    id: service.id,
                                    _id: service._id,
                                    label: service.label,
                                    doorstep: false,
                                    validity: service.validity,
                                    gallery: await Gallery.count({ source: service._id }).exec(),
                                    doorstep: service.doorstep,
                                    expired_at: moment(service.expired_at).tz(req.headers['tz']).format('ll')
                                });
                            }
                            else {
                                packages.push({
                                    service: service.name,
                                    mrp: 0,
                                    discount: service.discount,
                                    labour_cost: service.cost,
                                    part_cost: 0,
                                    of_cost: 0,
                                    type: "package",
                                    cost: service.cost,
                                    id: service.id,
                                    _id: service._id,
                                    label: service.label,
                                    doorstep: false,
                                    validity: service.validity,
                                    gallery: await Gallery.count({ source: service._id }).exec(),
                                    doorstep: service.doorstep,
                                    expired_at: moment(service.expired_at).tz(req.headers['tz']).format('ll')
                                });
                            }
                        }
                    }
                });

                res.status(200).json({
                    responseCode: 200,
                    responseMessage: "Either you have already enjoyed the existing offers, or they are unavailable at the moment",
                    responseData: packages
                });
            }
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Unauthorized",
                responseData: {},
            });
        }
    }
});

router.post('/new/booking/add/', xAccessToken.token, async function (req, res, next) {
    var rules = {
        car: 'required',
        services: 'required'
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Error",
            responseData: {
                res: validation.errors.all()
            }
        });
    }
    else {
        if (req.body.package == "") {
            req.body.package = null;
        }

        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);


        var user = req.headers['business'];


        var total = 0;
        var labourCost = 0;
        var part_cost = 0;
        var is_services = true;
        var doorstep = true;
        var bookingService = [];


        var services = req.body.services;
        var countBooking = await Booking.find({}).count().exec();
        var checkCar = await Car.findOne({ _id: req.body.car, user: user }).exec();
        var insurance_info = {
            "driver": null,
            "accident_place": "",
            "accident_date": null,
            "accident_time": "",
            "accident_cause": "",
            "fir": "",
            "branch": "",
            "cashless": "true",
            "claim": "false",
            "contact_no": "",
            "claim_no": "",
            "driver_accident": "",
            "expire": null,
            "gstin": "",
            "insurance_company": "",
            "manufacture_year": "",
            "policy_holder": "",
            "policy_no": "",
            "policy_type": "",
            "premium": 0,
            "spot_survey": "",
            "state": ""
        };

        if (checkCar) {
            var advisorBooking = [];
            await Management.find({ business: req.body.business, role: "Service Advisor" })
                .cursor().eachAsync(async (a) => {
                    var d = await Booking.find({ business: req.body.business, advisor: a.user }).count().exec();
                    advisorBooking.push({
                        user: a.user,
                        count: await Booking.find({ business: req.body.business, advisor: a.user }).count().exec()
                    })
                });

            if (advisorBooking.length != 0) {
                var min = advisorBooking.reduce(function (prev, current) {
                    return (prev.count < current.count) ? prev : current
                });
                var advisor = min.user
            }
            else {
                var advisor = req.body.business
            }

            var customer_requirements = [];
            if (req.body.requirements) {
                customer_requirements.push({
                    user: user,
                    requirement: req.body.requirements,
                });
            }
            if (req.body.is_services == false) {
                var baz = 1
            }
            else {
                var checkBooking = await Booking.findOne({ car: checkCar._id, date: new Date(req.body.date).toISOString(), status: { $in: ["Confirmed", "Pending", "Approval", "Approved", "Failed", "JobInitiated"] }, is_services: true }).exec();


                if (checkBooking) {
                    var serverTime = moment.tz(new Date(req.body.date).toISOString(), req.headers['tz']);
                    var bar = moment(checkBooking.date).tz(req.headers['tz']).format('YYYY-MM-DD');
                    bar = moment.tz(new Date(bar).toISOString(), req.headers['tz']);
                    var baz = bar.diff(serverTime);
                } else {
                    var baz = 1
                }

            }

            if (baz > 0) {
                var checkVendor = await User.findOne({ '_id': req.body.business }).exec();
                if (checkVendor) {
                    for (var i = 0; i < services.length; i++) {
                        if (services[i].type == "package") {
                            await Package.find({ _id: services[i].id }).cursor().eachAsync(async (service) => {
                                if (service) {
                                    var tax_info = await Tax.findOne({ tax: "18.0% GST" }).exec();
                                    var tax_rate = tax_info.detail;
                                    var amount = service.cost;
                                    var base = amount;
                                    var labour_tax = [];
                                    var labours = [];

                                    var x = (100 + tax_info.rate) / 100;
                                    var tax_on_amount = amount / x;
                                    if (tax_rate.length > 0) {
                                        for (var r = 0; r < tax_rate.length; r++) {
                                            if (tax_rate[r].rate != tax_info.rate) {
                                                var t = tax_on_amount * (tax_rate[r].rate / 100);
                                                base = base - t
                                                labour_tax.push({
                                                    tax: tax_rate[r].tax,
                                                    rate: parseFloat(tax_rate[r].rate.toFixed(2)),
                                                    amount: parseFloat(t.toFixed(2))
                                                })
                                            }
                                            else {
                                                base = base - t
                                                labour_tax.push({
                                                    tax: tax_info.tax, tax_rate: tax_info.rate,
                                                    rate: parseFloat(tax_info.rate.toFixed(2)),
                                                    amount: parseFloat(tax_on_amount.toFixed(2))
                                                })
                                            }
                                        }
                                    }

                                    labours.push({
                                        item: service.name,
                                        quantity: 1,
                                        rate: parseFloat(service.cost),
                                        base: parseFloat(base.toFixed(2)),
                                        amount: parseFloat(amount),
                                        discount: 0,
                                        amount_is_tax: "inclusive",
                                        tax_amount: _.sumBy(labour_tax, x => x.amount),
                                        tax: tax_info.tax, tax_rate: tax_info.rate,
                                        tax_info: {
                                            tax: tax_info.tax, tax_rate: tax_info.rate,
                                            rate: tax_info.rate,
                                            base: parseFloat(base.toFixed(2)),
                                            detail: labour_tax
                                        }
                                    })

                                    is_services = false;

                                    bookingService.push({
                                        source: services[i].id,
                                        service: service.name,
                                        description: service.description,
                                        cost: Math.ceil(service.cost),
                                        labour_cost: Math.ceil(service.cost),
                                        part_cost: 0,
                                        of_cost: 0,
                                        discount: 0,
                                        parts: [],
                                        labour: labours,
                                        opening_fitting: [],
                                        type: "package",
                                        customer_approval: true, surveyor_approval: false,
                                    });

                                    // console.log(bookingService)

                                }
                                else {
                                    res.status(400).json({
                                        responseCode: 400,
                                        responseMessage: "Service Not Found",
                                        responseData: {},
                                    });
                                }
                            });
                        }
                        else if (services[i].type == "addOn") {
                            await Package.find({ _id: services[i].id }).cursor().eachAsync(async (service) => {
                                if (service) {
                                    var tax_info = await Tax.findOne({ tax: "18.0% GST" }).exec();
                                    var tax_rate = tax_info.detail;
                                    var amount = service.cost;
                                    var base = amount;
                                    var labour_tax = [];
                                    var labours = [];

                                    var x = (100 + tax_info.rate) / 100;
                                    var tax_on_amount = amount / x;
                                    if (tax_rate.length > 0) {
                                        for (var r = 0; r < tax_rate.length; r++) {
                                            if (tax_rate[r].rate != tax_info.rate) {
                                                var t = tax_on_amount * (tax_rate[r].rate / 100);
                                                base = base - t
                                                labour_tax.push({
                                                    tax: tax_rate[r].tax,
                                                    rate: parseFloat(tax_rate[r].rate.toFixed(2)),
                                                    amount: parseFloat(t.toFixed(2))
                                                })
                                            }
                                            else {
                                                base = base - t
                                                labour_tax.push({
                                                    tax: tax_info.tax, tax_rate: tax_info.rate,
                                                    rate: parseFloat(tax_info.rate.toFixed(2)),
                                                    amount: parseFloat(tax_on_amount.toFixed(2))
                                                })
                                            }
                                        }
                                    }

                                    labours.push({
                                        item: service.name,
                                        quantity: 1,
                                        rate: parseFloat(service.cost),
                                        base: parseFloat(base.toFixed(2)),
                                        amount: parseFloat(amount),
                                        discount: 0,
                                        amount_is_tax: "inclusive",
                                        tax_amount: _.sumBy(labour_tax, x => x.amount),
                                        tax: tax_info.tax, tax_rate: tax_info.rate,
                                        tax_info: {
                                            tax: tax_info.tax, tax_rate: tax_info.rate,
                                            rate: tax_info.rate,
                                            base: parseFloat(base.toFixed(2)),
                                            detail: labour_tax
                                        }
                                    })

                                    is_services = true;

                                    bookingService.push({
                                        source: service._id,
                                        service: service.name,
                                        description: service.description,
                                        cost: Math.ceil(service.cost),
                                        labour_cost: Math.ceil(service.cost),
                                        part_cost: 0,
                                        of_cost: 0,
                                        discount: 0,
                                        parts: [],
                                        labour: labours,
                                        opening_fitting: [],
                                        type: "addOn",
                                        customer_approval: true, surveyor_approval: false,
                                    });

                                }
                                else {
                                    res.status(400).json({
                                        responseCode: 400,
                                        responseMessage: "Service Not Found",
                                        responseData: {},
                                    });
                                }
                            });
                        }
                        else if (services[i].type == "services") {
                            is_services = true;
                            await Service.find({ _id: services[i].id, publish: true, })
                                .cursor().eachAsync(async (service) => {

                                    var getDiscount = {
                                        package: req.body.package,
                                        car: req.body.car,
                                        category: service.type,
                                        service: service.service,
                                        tz: req.headers['tz'],
                                        claim: false,
                                    };

                                    if (typeof services[i].quantity != "number" || parseInt(services[i].quantity) <= 0) {
                                        var quantity = 1
                                    }
                                    else {
                                        var quantity = parseInt(services[i].quantity)
                                    }

                                    var package = await q.all(getPackageDiscount(getDiscount));



                                    var labour_list = service.labour;
                                    var labours = [];

                                    var discount_eligible_labour_cost = _.sumBy(labour_list, x => x.amount * quantity);
                                    if (labour_list.length > 0) {
                                        for (var l = 0; l < labour_list.length; l++) {
                                            var discount_total = 0;
                                            var total = 0;
                                            var tax_info = await Tax.findOne({ tax: labour_list[l].tax }).exec();

                                            var tax = [];
                                            var rate = labour_list[l].rate;
                                            var amount = parseFloat(labour_list[l].amount) * quantity;
                                            var tax_rate = tax_info.detail;
                                            var base = amount;

                                            if (Object.keys(package).length > 0) {
                                                if (package.discount_type == "percent") {
                                                    discount = parseFloat(package.discount);
                                                    if (!isNaN(discount) && discount > 0) {
                                                        var discount_total = amount * (discount / 100);
                                                        amount = amount - parseFloat(discount_total.toFixed(2))
                                                        if (amount < 0) {
                                                            amount = 0
                                                        }
                                                    }
                                                }
                                                else if (package.discount_type == "fixed") {
                                                    discount = parseFloat(package.discount);
                                                    if (!isNaN(discount) && discount > 0) {
                                                        var discount_total = (amount / discount_eligible_labour_cost) * discount;
                                                        amount = parseFloat(discount_total.toFixed(2))
                                                        discount = amount - discount_total;
                                                        if (amount < 0) {
                                                            amount = 0
                                                        }
                                                    }
                                                }
                                                else {
                                                    discount = parseFloat(package.discount);
                                                    if (!isNaN(discount) && discount > 0) {
                                                        var discount_total = (amount / discount_eligible_labour_cost) * discount;
                                                        amount = amount - parseFloat(discount_total.toFixed(2))
                                                        if (amount < 0) {
                                                            amount = 0
                                                        }
                                                    }
                                                }
                                            }

                                            if (labour_list[l].amount_is_tax == "inclusive") {
                                                var x = (100 + tax_info.rate) / 100;
                                                var tax_on_amount = amount / x;
                                                if (tax_rate.length > 0) {
                                                    for (var r = 0; r < tax_rate.length; r++) {
                                                        if (tax_rate[r].rate != tax_info.rate) {
                                                            var t = tax_on_amount * (tax_rate[r].rate / 100);
                                                            base = base - t;
                                                            tax.push({
                                                                tax: tax_rate[r].tax,
                                                                rate: tax_rate[r].rate,
                                                                amount: parseFloat(t.toFixed(2))
                                                            });
                                                        }
                                                        else {
                                                            var t = amount - tax_on_amount;
                                                            base = base - t;
                                                            tax.push({
                                                                tax: tax_info.tax, tax_rate: tax_info.rate,
                                                                rate: tax_info.rate,
                                                                amount: parseFloat(t.toFixed(2))
                                                            });
                                                        }
                                                    }

                                                    //base = base - discount_total;
                                                }
                                                total = total + amount;
                                            }

                                            var tax_details = {
                                                tax: tax_info.tax,
                                                rate: tax_info.rate,
                                                amount: total,
                                                detail: tax
                                            }


                                            labours.push({
                                                item: labour_list[l].item,
                                                source: labour_list[l].source,
                                                rate: parseFloat(labour_list[l].rate),
                                                quantity: quantity,
                                                base: parseFloat(total.toFixed(2)),
                                                discount: parseFloat(discount_total.toFixed(2)),
                                                amount: total,
                                                tax_amount: parseFloat(_.sumBy(tax, x => x.amount).toFixed(2)),
                                                amount_is_tax: labour_list[l].amount_is_tax,
                                                tax: tax_info.tax, tax_rate: tax_info.rate,
                                                tax_info: tax_details
                                            });
                                        }
                                    }

                                    bookingService.push({
                                        service: service.service,
                                        labour: labours,
                                        labour_cost: _.sumBy(labours, x => x.amount),
                                        discount: _.sumBy(labours, x => x.discount),
                                        parts: service.parts,
                                        part_cost: Math.ceil(service.part_cost),
                                        opening_fitting: service.opening_fitting,
                                        of_cost: Math.ceil(service.of_cost),
                                        exceeded_cost: 0,
                                        mrp: Math.ceil(service.mrp),
                                        cost: service.part_cost + _.sumBy(labours, x => x.amount) + service.of_cost,
                                        doorstep: service.doorstep,
                                        unit: service.unit,
                                        quantity: quantity,
                                        part_cost_editable: service.part_cost_editable,
                                        labour_cost_editable: service.labour_cost_editable,
                                        of_cost_editable: service.of_cost_editable,
                                        type: service.type,
                                        source: service.id,
                                        description: service.description,
                                        claim: false,
                                        customer_approval: true, surveyor_approval: false,
                                    });
                                });
                        }
                        else if (services[i].type == "collision") {
                            is_services = true;
                            await Collision.find({ _id: services[i].id, publish: true, })
                                .cursor().eachAsync(async (service) => {
                                    var getDiscount = {
                                        package: req.body.package,
                                        car: req.body.car,
                                        category: service.type,
                                        service: service.service,
                                        tz: req.headers['tz'],
                                        claim: false,
                                    };

                                    if (typeof services[i].quantity != "number" || parseInt(services[i].quantity) <= 0) {
                                        var quantity = 1
                                    }
                                    else {
                                        var quantity = parseInt(services[i].quantity)
                                    }

                                    var package = await q.all(getPackageDiscount(getDiscount));
                                    var labour_list = service.labour;
                                    var labours = [];

                                    var discount_eligible_labour_cost = _.sumBy(labour_list, x => x.amount * quantity);
                                    if (labour_list.length > 0) {
                                        for (var l = 0; l < labour_list.length; l++) {
                                            var discount_total = 0;
                                            var total = 0;
                                            var tax_info = await Tax.findOne({ tax: labour_list[l].tax }).exec();

                                            var tax = [];
                                            var rate = labour_list[l].rate;
                                            var amount = parseFloat(labour_list[l].amount) * quantity;
                                            var tax_rate = tax_info.detail;
                                            var base = amount;

                                            if (Object.keys(package).length > 0) {
                                                if (package.discount_type == "percent") {
                                                    discount = parseFloat(package.discount);
                                                    if (!isNaN(discount) && discount > 0) {
                                                        var discount_total = amount * (discount / 100);
                                                        amount = amount - parseFloat(discount_total.toFixed(2))
                                                        if (amount < 0) {
                                                            amount = 0
                                                        }
                                                    }
                                                }
                                                else if (package.discount_type == "fixed") {
                                                    discount = parseFloat(package.discount);
                                                    if (!isNaN(discount) && discount > 0) {
                                                        var discount_total = (amount / discount_eligible_labour_cost) * discount;
                                                        amount = parseFloat(discount_total.toFixed(2))
                                                        discount = amount - discount_total;
                                                        if (amount < 0) {
                                                            amount = 0
                                                        }
                                                    }
                                                }
                                                else {
                                                    discount = parseFloat(package.discount);
                                                    if (!isNaN(discount) && discount > 0) {
                                                        var discount_total = (amount / discount_eligible_labour_cost) * discount;
                                                        amount = amount - parseFloat(discount_total.toFixed(2))
                                                        if (amount < 0) {
                                                            amount = 0
                                                        }
                                                    }
                                                }
                                            }

                                            if (labour_list[l].amount_is_tax == "inclusive") {
                                                var x = (100 + tax_info.rate) / 100;
                                                var tax_on_amount = amount / x;
                                                if (tax_rate.length > 0) {
                                                    for (var r = 0; r < tax_rate.length; r++) {
                                                        if (tax_rate[r].rate != tax_info.rate) {
                                                            var t = tax_on_amount * (tax_rate[r].rate / 100);
                                                            base = base - t;
                                                            tax.push({
                                                                tax: tax_rate[r].tax,
                                                                rate: tax_rate[r].rate,
                                                                amount: parseFloat(t.toFixed(2))
                                                            });
                                                        }
                                                        else {
                                                            var t = amount - tax_on_amount;
                                                            base = base - t;
                                                            tax.push({
                                                                tax: tax_info.tax, tax_rate: tax_info.rate,
                                                                rate: tax_info.rate,
                                                                amount: parseFloat(t.toFixed(2))
                                                            });
                                                        }
                                                    }

                                                    //base = base - discount_total;
                                                }
                                                total = total + amount;
                                            }

                                            var tax_details = {
                                                tax: tax_info.tax,
                                                rate: tax_info.rate,
                                                amount: total,
                                                detail: tax
                                            }


                                            labours.push({
                                                item: labour_list[l].item,
                                                source: labour_list[l].source,
                                                rate: parseFloat(labour_list[l].rate),
                                                quantity: quantity,
                                                base: parseFloat(total.toFixed(2)),
                                                discount: parseFloat(discount_total.toFixed(2)),
                                                amount: total,
                                                tax_amount: parseFloat(_.sumBy(tax, x => x.amount).toFixed(2)),
                                                amount_is_tax: labour_list[l].amount_is_tax,
                                                tax: tax_info.tax, tax_rate: tax_info.rate,
                                                tax_info: tax_details
                                            });
                                        }
                                    }

                                    bookingService.push({
                                        service: service.service,
                                        labour: labours,
                                        labour_cost: _.sumBy(labours, x => x.amount),
                                        discount: _.sumBy(labours, x => x.discount),
                                        parts: service.parts,
                                        part_cost: Math.ceil(service.part_cost),
                                        opening_fitting: service.opening_fitting,
                                        of_cost: Math.ceil(service.of_cost),
                                        exceeded_cost: 0,
                                        mrp: Math.ceil(service.mrp),
                                        cost: service.part_cost + _.sumBy(labours, x => x.amount) + service.of_cost,
                                        doorstep: service.doorstep,
                                        unit: service.unit,
                                        quantity: quantity,
                                        part_cost_editable: service.part_cost_editable,
                                        labour_cost_editable: service.labour_cost_editable,
                                        of_cost_editable: service.of_cost_editable,
                                        type: service.type,
                                        source: service.id,
                                        description: service.description,
                                        claim: false,
                                        customer_approval: true, surveyor_approval: false,
                                    });
                                });
                        }
                        else if (services[i].type == "detailing") {
                            is_services = true;
                            await Detailing.find({ _id: services[i].id, publish: true, })
                                .cursor().eachAsync(async (service) => {
                                    var getDiscount = {
                                        package: req.body.package,
                                        car: req.body.car,
                                        category: service.type,
                                        service: service.service,
                                        tz: req.headers['tz'],
                                        claim: false
                                    };

                                    // console.log(getDiscount)

                                    if (typeof services[i].quantity != "number" || parseInt(services[i].quantity) <= 0) {
                                        var quantity = 1
                                    }
                                    else {
                                        var quantity = parseInt(services[i].quantity)
                                    }

                                    var package = await q.all(getPackageDiscount(getDiscount));

                                    // console.log(package)

                                    var labour_list = service.labour;
                                    var labours = [];

                                    var discount_eligible_labour_cost = _.sumBy(labour_list, x => x.amount * quantity);
                                    if (labour_list.length > 0) {
                                        for (var l = 0; l < labour_list.length; l++) {
                                            var discount_total = 0;
                                            var total = 0;
                                            var tax_info = await Tax.findOne({ tax: labour_list[l].tax }).exec();

                                            var tax = [];
                                            var rate = labour_list[l].rate;
                                            var amount = parseFloat(labour_list[l].amount) * quantity;
                                            var tax_rate = tax_info.detail;
                                            var base = amount;

                                            if (Object.keys(package).length > 0) {
                                                if (package.discount_type == "percent") {
                                                    discount = parseFloat(package.discount);
                                                    if (!isNaN(discount) && discount > 0) {
                                                        var discount_total = amount * (discount / 100);
                                                        amount = amount - parseFloat(discount_total.toFixed(2))
                                                        if (amount < 0) {
                                                            amount = 0
                                                        }
                                                    }
                                                }
                                                else if (package.discount_type == "fixed") {
                                                    discount = parseFloat(package.discount);
                                                    if (!isNaN(discount) && discount > 0) {
                                                        var discount_total = (amount / discount_eligible_labour_cost) * discount;
                                                        amount = parseFloat(discount_total.toFixed(2))
                                                        discount = amount - discount_total;
                                                        if (amount < 0) {
                                                            amount = 0
                                                        }
                                                    }
                                                }
                                                else {
                                                    discount = parseFloat(package.discount);
                                                    if (!isNaN(discount) && discount > 0) {
                                                        var discount_total = (amount / discount_eligible_labour_cost) * discount;
                                                        amount = amount - parseFloat(discount_total.toFixed(2))
                                                        if (amount < 0) {
                                                            amount = 0
                                                        }
                                                    }
                                                }
                                            }

                                            if (labour_list[l].amount_is_tax == "inclusive") {
                                                var x = (100 + tax_info.rate) / 100;
                                                var tax_on_amount = amount / x;
                                                if (tax_rate.length > 0) {
                                                    for (var r = 0; r < tax_rate.length; r++) {
                                                        if (tax_rate[r].rate != tax_info.rate) {
                                                            var t = tax_on_amount * (tax_rate[r].rate / 100);
                                                            base = base - t;
                                                            tax.push({
                                                                tax: tax_rate[r].tax,
                                                                rate: tax_rate[r].rate,
                                                                amount: parseFloat(t.toFixed(2))
                                                            });
                                                        }
                                                        else {
                                                            var t = amount - tax_on_amount;
                                                            base = base - t;
                                                            tax.push({
                                                                tax: tax_info.tax, tax_rate: tax_info.rate,
                                                                rate: tax_info.rate,
                                                                amount: parseFloat(t.toFixed(2))
                                                            });
                                                        }
                                                    }

                                                    //base = base - discount_total;
                                                }
                                                total = total + amount;
                                            }

                                            var tax_details = {
                                                tax: tax_info.tax,
                                                rate: tax_info.rate,
                                                amount: total,
                                                detail: tax
                                            }


                                            labours.push({
                                                item: labour_list[l].item,
                                                source: labour_list[l].source,
                                                rate: parseFloat(labour_list[l].rate),
                                                quantity: quantity,
                                                base: parseFloat(total.toFixed(2)),
                                                discount: parseFloat(discount_total.toFixed(2)),
                                                amount: total,
                                                tax_amount: parseFloat(_.sumBy(tax, x => x.amount).toFixed(2)),
                                                amount_is_tax: labour_list[l].amount_is_tax,
                                                tax: tax_info.tax, tax_rate: tax_info.rate,
                                                tax_info: tax_details
                                            });
                                        }
                                    }

                                    bookingService.push({
                                        service: service.service,
                                        labour: labours,
                                        labour_cost: _.sumBy(labours, x => x.amount),
                                        discount: _.sumBy(labours, x => x.discount),
                                        parts: service.parts,
                                        part_cost: Math.ceil(service.part_cost),
                                        opening_fitting: service.opening_fitting,
                                        of_cost: Math.ceil(service.of_cost),
                                        exceeded_cost: 0,
                                        mrp: Math.ceil(service.mrp),
                                        cost: service.part_cost + _.sumBy(labours, x => x.amount) + service.of_cost,
                                        doorstep: service.doorstep,
                                        unit: service.unit,
                                        quantity: quantity,
                                        part_cost_editable: service.part_cost_editable,
                                        labour_cost_editable: service.labour_cost_editable,
                                        of_cost_editable: service.of_cost_editable,
                                        type: service.type,
                                        source: service.id,
                                        description: service.description,
                                        claim: false,
                                        customer_approval: true, surveyor_approval: false,
                                    });
                                });
                        }
                        else if (services[i].type == "customization") {
                            is_services = true;
                            await Customization.find({ _id: services[i].id, publish: true, })
                                .cursor().eachAsync(async (service) => {
                                    var getDiscount = {
                                        package: req.body.package,
                                        car: req.body.car,
                                        category: service.type,
                                        service: service.service,
                                        tz: req.headers['tz'],
                                        claim: false,
                                    };

                                    if (typeof services[i].quantity != "number" || parseInt(services[i].quantity) <= 0) {
                                        var quantity = 1
                                    }
                                    else {
                                        var quantity = parseInt(services[i].quantity)
                                    }

                                    var package = await q.all(getPackageDiscount(getDiscount));
                                    var labour_list = service.labour;
                                    var labours = [];

                                    var discount_eligible_labour_cost = _.sumBy(labour_list, x => x.amount * quantity);
                                    if (labour_list.length > 0) {
                                        for (var l = 0; l < labour_list.length; l++) {
                                            var discount_total = 0;
                                            var total = 0;
                                            var tax_info = await Tax.findOne({ tax: labour_list[l].tax }).exec();

                                            var tax = [];
                                            var rate = labour_list[l].rate;
                                            var amount = parseFloat(labour_list[l].amount) * quantity;
                                            var tax_rate = tax_info.detail;
                                            var base = amount;

                                            if (Object.keys(package).length > 0) {
                                                if (package.discount_type == "percent") {
                                                    discount = parseFloat(package.discount);
                                                    if (!isNaN(discount) && discount > 0) {
                                                        var discount_total = amount * (discount / 100);
                                                        amount = amount - parseFloat(discount_total.toFixed(2))
                                                        if (amount < 0) {
                                                            amount = 0
                                                        }
                                                    }
                                                }
                                                else if (package.discount_type == "fixed") {
                                                    discount = parseFloat(package.discount);
                                                    if (!isNaN(discount) && discount > 0) {
                                                        var discount_total = (amount / discount_eligible_labour_cost) * discount;
                                                        amount = parseFloat(discount_total.toFixed(2))
                                                        discount = amount - discount_total;
                                                        if (amount < 0) {
                                                            amount = 0
                                                        }
                                                    }
                                                }
                                                else {
                                                    discount = parseFloat(package.discount);
                                                    if (!isNaN(discount) && discount > 0) {
                                                        var discount_total = (amount / discount_eligible_labour_cost) * discount;
                                                        amount = amount - parseFloat(discount_total.toFixed(2))
                                                        if (amount < 0) {
                                                            amount = 0
                                                        }
                                                    }
                                                }
                                            }

                                            if (labour_list[l].amount_is_tax == "inclusive") {
                                                var x = (100 + tax_info.rate) / 100;
                                                var tax_on_amount = amount / x;
                                                if (tax_rate.length > 0) {
                                                    for (var r = 0; r < tax_rate.length; r++) {
                                                        if (tax_rate[r].rate != tax_info.rate) {
                                                            var t = tax_on_amount * (tax_rate[r].rate / 100);
                                                            base = base - t;
                                                            tax.push({
                                                                tax: tax_rate[r].tax,
                                                                rate: tax_rate[r].rate,
                                                                amount: parseFloat(t.toFixed(2))
                                                            });
                                                        }
                                                        else {
                                                            var t = amount - tax_on_amount;
                                                            base = base - t;
                                                            tax.push({
                                                                tax: tax_info.tax, tax_rate: tax_info.rate,
                                                                rate: tax_info.rate,
                                                                amount: parseFloat(t.toFixed(2))
                                                            });
                                                        }
                                                    }

                                                    //base = base - discount_total;
                                                }
                                                total = total + amount;
                                            }

                                            var tax_details = {
                                                tax: tax_info.tax,
                                                rate: tax_info.rate,
                                                amount: total,
                                                detail: tax
                                            }


                                            labours.push({
                                                item: labour_list[l].item,
                                                source: labour_list[l].source,
                                                rate: parseFloat(labour_list[l].rate),
                                                quantity: quantity,
                                                base: parseFloat(total.toFixed(2)),
                                                discount: parseFloat(discount_total.toFixed(2)),
                                                amount: total,
                                                tax_amount: parseFloat(_.sumBy(tax, x => x.amount).toFixed(2)),
                                                amount_is_tax: labour_list[l].amount_is_tax,
                                                tax: tax_info.tax, tax_rate: tax_info.rate,
                                                tax_info: tax_details
                                            });
                                        }
                                    }

                                    bookingService.push({
                                        service: service.service,
                                        labour: labours,
                                        labour_cost: _.sumBy(labours, x => x.amount),
                                        discount: _.sumBy(labours, x => x.discount),
                                        parts: service.parts,
                                        part_cost: Math.ceil(service.part_cost),
                                        opening_fitting: service.opening_fitting,
                                        of_cost: Math.ceil(service.of_cost),
                                        exceeded_cost: 0,
                                        mrp: Math.ceil(service.mrp),
                                        cost: service.part_cost + _.sumBy(labours, x => x.amount) + service.of_cost,
                                        doorstep: service.doorstep,
                                        unit: service.unit,
                                        quantity: quantity,
                                        part_cost_editable: service.part_cost_editable,
                                        labour_cost_editable: service.labour_cost_editable,
                                        of_cost_editable: service.of_cost_editable,
                                        type: service.type,
                                        source: service.id,
                                        description: service.description,
                                        claim: false,
                                        customer_approval: true, surveyor_approval: false,
                                    });
                                });
                        }
                    }

                    if (bookingService.length > 0) {
                        var labour_cost = _.sumBy(bookingService, x => x.labour_cost);
                        var part_cost = _.sumBy(bookingService, x => x.part_cost);
                        var of_cost = _.sumBy(bookingService, x => x.of_cost);
                        var discount_total = _.sumBy(bookingService, x => x.discount);
                        var pick_up_charges = 0;
                        if (req.body.charges) {
                            pick_up_charges = parseFloat(req.body.charges);
                        }
                    }
                    else {
                        return res.status(400).json({
                            responseCode: 400,
                            responseMessage: "Services not found",
                            responseData: {},
                        });
                    }

                    if (doorstep) {
                        var paid_total = part_cost + labour_cost + of_cost + pick_up_charges;
                        var total = part_cost + labour_cost + of_cost + discount_total + pick_up_charges;
                        var payment = {
                            estimate_cost: paid_total,
                            payment_mode: req.body.payment_mode,
                            payment_status: "Pending",
                            careager_cash: 0,
                            discount_type: "",
                            coupon: "",
                            coupon_type: "",
                            discount: discount_total.toFixed(2),
                            discount_total: discount_total.toFixed(2),
                            terms: checkVendor.business_info.terms,
                            pick_up_limit: checkVendor.business_info.pick_up_limit,
                            pick_up_charges: pick_up_charges,
                            part_cost: parseFloat(part_cost.toFixed(2)),
                            labour_cost: parseFloat(labour_cost.toFixed(2)),
                            of_cost: parseFloat(of_cost.toFixed(2)),
                            paid_total: 0,
                            total: parseFloat(total.toFixed(2)),
                            discount_applied: false,
                            transaction_id: "",
                            transaction_date: "",
                            transaction_status: "",
                            transaction_response: "",
                            policy_clause: 0,
                            salvage: 0,
                        };

                        var due = {
                            due: Math.ceil(paid_total.toFixed(2))
                        };

                        if (req.body.is_services == false) {
                            var date = new Date();
                        }
                        else {
                            if (req.body.date) {
                                var date = new Date(req.body.date).toISOString()
                            }
                            else {
                                var d = new Date();
                                var date = new Date(d.getFullYear(), d.getMonth(), d.getDate() + 2);
                            }
                        }

                        var lastBooking = await Booking.findOne({ user: user, status: " Inactive" }).sort({ created_at: -1 }).exec();

                        if (lastBooking) {
                            var data = {
                                package: req.body.package,
                                car: req.body.car,
                                advisor: advisor,
                                business: req.body.business,
                                user: user,
                                services: bookingService,
                                booking_no: lastBooking.booking_no,
                                date: date,
                                customer_requirements: customer_requirements,
                                time_slot: req.body.time_slot,
                                convenience: req.body.convenience,
                                status: "Inactive",
                                payment: payment,
                                due: due,
                                insurance_info: insurance_info,
                                address: req.body.address,
                                is_services: is_services,
                                created_at: new Date(),
                                updated_at: new Date()
                            };

                            Booking.findOneAndUpdate({ _id: lastBooking._id }, { $set: data }, { new: true }, async function (err, doc) {
                                if (!err) {
                                    var booking = await Booking.findById(lastBooking._id).exec();
                                    if (booking.is_services == true) {
                                        res.status(200).json({
                                            responseCode: 200,
                                            responseMessage: "Service Request has been booked",
                                            responseData: booking
                                        });
                                    }
                                    else {
                                        res.status(200).json({
                                            responseCode: 200,
                                            responseMessage: "Package successfully purchased, Book Services Now for added benefits",
                                            responseData: booking
                                        });
                                    }
                                } else {
                                    res.status(400).json({
                                        responseCode: 400,
                                        responseMessage: "Server Error",
                                        responseData: err
                                    });
                                }
                            });
                        }
                        else {
                            var data = {
                                package: req.body.package,
                                car: req.body.car,
                                advisor: advisor,
                                business: req.body.business,
                                user: user,
                                services: bookingService,
                                booking_no: Math.round(+new Date() / 1000) + Math.round((Math.random() * 9999) + 1),
                                date: date,
                                time_slot: req.body.time_slot,
                                convenience: req.body.convenience,
                                status: "Inactive",
                                payment: payment,
                                due: due,
                                customer_requirements: customer_requirements,
                                address: req.body.address,
                                insurance_info: insurance_info,
                                is_services: is_services,
                                created_at: new Date(),
                                updated_at: new Date()
                            };

                            Booking.create(data).then(async function (booking) {
                                if (booking.is_services == true) {
                                    res.status(200).json({
                                        responseCode: 200,
                                        responseMessage: "Service Request has been booked",
                                        responseData: booking
                                    });
                                }
                                else {
                                    res.status(200).json({
                                        responseCode: 200,
                                        responseMessage: "Package successfully purchased, Book Services Now for added benefits",
                                        responseData: booking
                                    });
                                }
                            });
                        }
                    }
                    else {
                        res.status(422).json({
                            responseCode: 422,
                            responseMessage: "Doorstep is not available for selected service",
                            responseData: {},
                        });
                    }
                }
                else {
                    res.status(400).json({
                        responseCode: 400,
                        responseMessage: "Business Not Found",
                        responseData: {},
                    });
                }
            }
            else {
                res.status(422).json({
                    responseCode: 422,
                    responseMessage: "Booking already exists for the same day. Please choose a different date or ask the advisor if anything needs to be added.",
                    responseData: {},
                });
            }
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Unauthorized",
                responseData: {},
            });
        }
    }
});

router.post('/my/booking/package/add/', xAccessToken.token, async function (req, res, next) {
    var rules = {
        package: 'required',
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Error",
            responseData: {
                res: validation.errors.all()
            }
        });
    }
    else {
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var user = decoded.user;

        if (req.headers['business']) {
            user = req.headers['business'];
        }

        var total = 0;
        var labourCost = 0;
        var part_cost = 0;
        var bookingService = [];
        var services = req.body.services;
        var countBooking = await Booking.find({}).count().exec();
        var checkPackage = await UserPackage.findOne({ '_id': req.body.package, user: user }).exec();
        var car = await Car.findOne({ '_id': checkPackage.car, user: user }).populate('model').exec();
        var checkVendor = await User.findOne({ '_id': checkPackage.business }).exec();


        if (car && checkPackage) {
            var checkBooking = await Booking.findOne({ car: car._id, date: new Date(req.body.date).toISOString(), status: { $in: ["Confirmed", "Pending", "Approval", "Approved", "Failed", "JobInitiated"] }, is_services: true }).exec();

            if (checkBooking) {
                var serverTime = moment.tz(new Date(req.body.date).toISOString(), req.headers['tz']);
                var bar = moment(checkBooking.date).tz(req.headers['tz']).format('YYYY-MM-DD');
                bar = moment.tz(new Date(bar).toISOString(), req.headers['tz']);
                var baz = bar.diff(serverTime);
            }
            else {
                var baz = 1
            }


            if (baz > 0) {
                var advisorBooking = [];
                await Management.find({ business: checkPackage.business, role: "Service Advisor" })
                    .cursor().eachAsync(async (a) => {
                        var d = await Booking.find({ business: checkPackage.business, advisor: a.user }).count().exec();
                        advisorBooking.push({
                            user: a.user,
                            count: await Booking.find({ business: checkPackage.business, advisor: a.user }).count().exec()
                        })
                    });

                if (advisorBooking.length != 0) {
                    var min = advisorBooking.reduce(function (prev, current) {
                        return (prev.count < current.count) ? prev : current
                    });
                    var advisor = min.user
                }
                else {
                    var advisor = checkPackage.business
                }

                if (req.body.label == "Wheel Alignment" || req.body.label == "Wheel Balancing (cost per tyre, weights excluded)") {
                    var cond = { service: req.body.label, model: car.model, publish: true, };
                }
                else {
                    var cond = { service: req.body.label, model: car.model._id, publish: true, };
                }

                await Service.find(cond)
                    .cursor().eachAsync(async (service) => {
                        var getDiscount = {
                            package: checkPackage._id,
                            car: car._id,
                            category: service.type,
                            service: service.service,
                            tz: req.headers['tz'],
                        };

                        var package = await q.all(getPackageDiscount(getDiscount));
                        var labour_list = service.labour;
                        var labours = [];

                        var discount_eligible_labour_cost = _.sumBy(labour_list, x => x.amount);
                        if (labour_list.length > 0) {
                            for (var l = 0; l < labour_list.length; l++) {
                                var quantity = 1;
                                if (labour_list[l].quantity) {
                                    quantity = labour_list[l].quantity;
                                }

                                var discount_total = 0;
                                var total = 0;
                                var tax_info = await Tax.findOne({ tax: labour_list[l].tax }).exec();

                                var tax = [];
                                var rate = labour_list[l].rate;
                                var amount = parseFloat(labour_list[l].amount);
                                var tax_rate = tax_info.detail;
                                var base = amount;

                                if (Object.keys(package).length > 0) {
                                    if (package.discount_type == "percent") {
                                        discount = parseFloat(package.discount);
                                        if (!isNaN(discount) && discount > 0) {
                                            var discount_total = amount * (discount / 100);
                                            amount = amount - parseFloat(discount_total.toFixed(2))
                                            if (amount < 0) {
                                                amount = 0
                                            }
                                        }
                                    }
                                    else if (package.discount_type == "fixed") {
                                        discount = parseFloat(package.discount);
                                        if (!isNaN(discount) && discount > 0) {
                                            var discount_total = (amount / discount_eligible_labour_cost) * discount;
                                            amount = parseFloat(discount_total.toFixed(2))
                                            discount = amount - discount_total;
                                            if (amount < 0) {
                                                amount = 0
                                            }
                                        }
                                    }
                                    else {
                                        discount = parseFloat(package.discount);
                                        if (!isNaN(discount) && discount > 0) {
                                            var discount_total = (amount / discount_eligible_labour_cost) * discount;
                                            amount = amount - parseFloat(discount_total.toFixed(2))
                                            if (amount < 0) {
                                                amount = 0
                                            }
                                        }
                                    }
                                }

                                if (labour_list[l].amount_is_tax == "inclusive") {
                                    var x = (100 + tax_info.rate) / 100;
                                    var tax_on_amount = amount / x;
                                    if (tax_rate.length > 0) {
                                        for (var r = 0; r < tax_rate.length; r++) {
                                            if (tax_rate[r].rate != tax_info.rate) {
                                                var t = tax_on_amount * (tax_rate[r].rate / 100);
                                                base = base - t;
                                                tax.push({
                                                    tax: tax_rate[r].tax,
                                                    rate: tax_rate[r].rate,
                                                    amount: parseFloat(t.toFixed(2))
                                                });
                                            }
                                            else {
                                                var t = amount - tax_on_amount;
                                                base = base - t;
                                                tax.push({
                                                    tax: tax_info.tax, tax_rate: tax_info.rate,
                                                    rate: tax_info.rate,
                                                    amount: parseFloat(t.toFixed(2))
                                                });
                                            }
                                        }

                                        //base = base - discount_total;
                                    }
                                    total = total + amount;
                                }

                                var tax_details = {
                                    tax: tax_info.tax,
                                    rate: tax_info.rate,
                                    amount: total,
                                    detail: tax
                                }


                                labours.push({
                                    item: labour_list[l].item,
                                    source: labour_list[l].source,
                                    rate: parseFloat(labour_list[l].rate),
                                    quantity: 1,
                                    base: parseFloat(total.toFixed(2)),
                                    discount: parseFloat(discount_total.toFixed(2)),
                                    amount: total,
                                    customer_dep: labour_list[l].customer_dep,
                                    insurance_dep: labour_list[l].insurance_dep,
                                    tax_amount: parseFloat(_.sumBy(tax, x => x.amount).toFixed(2)),
                                    amount_is_tax: labour_list[l].amount_is_tax,
                                    tax: tax_info.tax, tax_rate: tax_info.rate,
                                    tax_info: tax_details
                                });
                            }
                        }
                        bookingService.push({
                            service: service.service,
                            labour: labours,
                            labour_cost: _.sumBy(labours, x => x.amount),
                            discount: _.sumBy(labours, x => x.discount),
                            parts: service.parts,
                            part_cost: Math.ceil(service.part_cost),
                            opening_fitting: service.opening_fitting,
                            of_cost: Math.ceil(service.of_cost),
                            exceeded_cost: 0,
                            mrp: Math.ceil(service.mrp),
                            cost: service.part_cost + _.sumBy(labours, x => x.amount) + service.of_cost,
                            doorstep: service.doorstep,
                            unit: service.unit,
                            quantity: service.quantity,
                            part_cost_editable: service.part_cost_editable,
                            labour_cost_editable: service.labour_cost_editable,
                            of_cost_editable: service.of_cost_editable,
                            type: service.type,
                            source: service.id,
                            description: service.description,
                            claim: false,
                            customer_approval: true, surveyor_approval: false,
                        });
                    });


                await Collision.find({ service: req.body.label, model: car.model._id }).cursor().eachAsync(async (service) => {
                    var getDiscount = {
                        package: checkPackage._id,
                        car: car._id,
                        category: service.type,
                        service: service.service,
                        tz: req.headers['tz'],
                    };

                    var package = await q.all(getPackageDiscount(getDiscount));
                    var labour_list = service.labour;
                    var labours = [];

                    var discount_eligible_labour_cost = _.sumBy(labour_list, x => x.amount);
                    if (labour_list.length > 0) {
                        for (var l = 0; l < labour_list.length; l++) {
                            var quantity = 1;
                            if (labour_list[l].quantity) {
                                quantity = labour_list[l].quantity;
                            }

                            var discount_total = 0;
                            var total = 0;
                            var tax_info = await Tax.findOne({ tax: labour_list[l].tax }).exec();

                            var tax = [];
                            var rate = labour_list[l].rate;
                            var amount = parseFloat(labour_list[l].amount);
                            var tax_rate = tax_info.detail;
                            var base = amount;

                            if (Object.keys(package).length > 0) {
                                if (package.discount_type == "percent") {
                                    discount = parseFloat(package.discount);
                                    if (!isNaN(discount) && discount > 0) {
                                        var discount_total = amount * (discount / 100);
                                        amount = amount - parseFloat(discount_total.toFixed(2))
                                        if (amount < 0) {
                                            amount = 0
                                        }
                                    }
                                }
                                else if (package.discount_type == "fixed") {
                                    discount = parseFloat(package.discount);
                                    if (!isNaN(discount) && discount > 0) {
                                        var discount_total = (amount / discount_eligible_labour_cost) * discount;
                                        amount = parseFloat(discount_total.toFixed(2))
                                        discount = amount - discount_total;
                                        if (amount < 0) {
                                            amount = 0
                                        }
                                    }
                                }
                                else {
                                    discount = parseFloat(package.discount);
                                    if (!isNaN(discount) && discount > 0) {
                                        var discount_total = (amount / discount_eligible_labour_cost) * discount;
                                        amount = amount - parseFloat(discount_total.toFixed(2))
                                        if (amount < 0) {
                                            amount = 0
                                        }
                                    }
                                }
                            }

                            if (labour_list[l].amount_is_tax == "inclusive") {
                                var x = (100 + tax_info.rate) / 100;
                                var tax_on_amount = amount / x;
                                if (tax_rate.length > 0) {
                                    for (var r = 0; r < tax_rate.length; r++) {
                                        if (tax_rate[r].rate != tax_info.rate) {
                                            var t = tax_on_amount * (tax_rate[r].rate / 100);
                                            base = base - t;
                                            tax.push({
                                                tax: tax_rate[r].tax,
                                                rate: tax_rate[r].rate,
                                                amount: parseFloat(t.toFixed(2))
                                            });
                                        }
                                        else {
                                            var t = amount - tax_on_amount;
                                            base = base - t;
                                            tax.push({
                                                tax: tax_info.tax, tax_rate: tax_info.rate,
                                                rate: tax_info.rate,
                                                amount: parseFloat(t.toFixed(2))
                                            });
                                        }
                                    }

                                    //base = base - discount_total;
                                }
                                total = total + amount;
                            }

                            var tax_details = {
                                tax: tax_info.tax,
                                rate: tax_info.rate,
                                amount: total,
                                detail: tax
                            }


                            labours.push({
                                item: labour_list[l].item,
                                source: labour_list[l].source,
                                rate: parseFloat(labour_list[l].rate),
                                quantity: 1,
                                base: parseFloat(total.toFixed(2)),
                                discount: parseFloat(discount_total.toFixed(2)),
                                amount: total,
                                customer_dep: labour_list[l].customer_dep,
                                insurance_dep: labour_list[l].insurance_dep,
                                tax_amount: parseFloat(_.sumBy(tax, x => x.amount).toFixed(2)),
                                amount_is_tax: labour_list[l].amount_is_tax,
                                tax: tax_info.tax, tax_rate: tax_info.rate,
                                tax_info: tax_details
                            });
                        }
                    }
                    bookingService.push({
                        service: service.service,
                        labour: labours,
                        labour_cost: _.sumBy(labours, x => x.amount),
                        discount: _.sumBy(labours, x => x.discount),
                        parts: service.parts,
                        part_cost: Math.ceil(service.part_cost),
                        opening_fitting: service.opening_fitting,
                        of_cost: Math.ceil(service.of_cost),
                        exceeded_cost: 0,
                        mrp: Math.ceil(service.mrp),
                        cost: service.part_cost + _.sumBy(labours, x => x.amount) + service.of_cost,
                        doorstep: service.doorstep,
                        unit: service.unit,
                        quantity: service.quantity,
                        part_cost_editable: service.part_cost_editable,
                        labour_cost_editable: service.labour_cost_editable,
                        of_cost_editable: service.of_cost_editable,
                        type: service.type,
                        source: service.id,
                        description: service.description,
                        claim: false,
                        customer_approval: true, surveyor_approval: false,
                    });
                });

                await Detailing.find({ service: req.body.label, segment: car.model.segment }).cursor().eachAsync(async (service) => {
                    var getDiscount = {
                        package: checkPackage._id,
                        car: car._id,
                        category: service.type,
                        service: service.service,
                        tz: req.headers['tz'],
                    };

                    var package = await q.all(getPackageDiscount(getDiscount));
                    var labour_list = service.labour;
                    var labours = [];

                    var discount_eligible_labour_cost = _.sumBy(labour_list, x => x.amount);
                    if (labour_list.length > 0) {
                        for (var l = 0; l < labour_list.length; l++) {
                            var quantity = 1;
                            if (labour_list[l].quantity) {
                                quantity = labour_list[l].quantity;
                            }

                            var discount_total = 0;
                            var total = 0;
                            var tax_info = await Tax.findOne({ tax: labour_list[l].tax }).exec();

                            var tax = [];
                            var rate = labour_list[l].rate;
                            var amount = parseFloat(labour_list[l].amount);
                            var tax_rate = tax_info.detail;
                            var base = amount;

                            if (Object.keys(package).length > 0) {
                                if (package.discount_type == "percent") {
                                    discount = parseFloat(package.discount);
                                    if (!isNaN(discount) && discount > 0) {
                                        var discount_total = amount * (discount / 100);
                                        amount = amount - parseFloat(discount_total.toFixed(2))
                                        if (amount < 0) {
                                            amount = 0
                                        }
                                    }
                                }
                                else if (package.discount_type == "fixed") {
                                    discount = parseFloat(package.discount);
                                    if (!isNaN(discount) && discount > 0) {
                                        var discount_total = (amount / discount_eligible_labour_cost) * discount;
                                        amount = parseFloat(discount_total.toFixed(2))
                                        discount = amount - discount_total;
                                        if (amount < 0) {
                                            amount = 0
                                        }
                                    }
                                }
                                else {
                                    discount = parseFloat(package.discount);
                                    if (!isNaN(discount) && discount > 0) {
                                        var discount_total = (amount / discount_eligible_labour_cost) * discount;
                                        amount = amount - parseFloat(discount_total.toFixed(2))
                                        if (amount < 0) {
                                            amount = 0
                                        }
                                    }
                                }
                            }

                            if (labour_list[l].amount_is_tax == "inclusive") {
                                var x = (100 + tax_info.rate) / 100;
                                var tax_on_amount = amount / x;
                                if (tax_rate.length > 0) {
                                    for (var r = 0; r < tax_rate.length; r++) {
                                        if (tax_rate[r].rate != tax_info.rate) {
                                            var t = tax_on_amount * (tax_rate[r].rate / 100);
                                            base = base - t;
                                            tax.push({
                                                tax: tax_rate[r].tax,
                                                rate: tax_rate[r].rate,
                                                amount: parseFloat(t.toFixed(2))
                                            });
                                        }
                                        else {
                                            var t = amount - tax_on_amount;
                                            base = base - t;
                                            tax.push({
                                                tax: tax_info.tax, tax_rate: tax_info.rate,
                                                rate: tax_info.rate,
                                                amount: parseFloat(t.toFixed(2))
                                            });
                                        }
                                    }

                                    //base = base - discount_total;
                                }
                                total = total + amount;
                            }

                            var tax_details = {
                                tax: tax_info.tax,
                                rate: tax_info.rate,
                                amount: total,
                                detail: tax
                            }


                            labours.push({
                                item: labour_list[l].item,
                                source: labour_list[l].source,
                                rate: parseFloat(labour_list[l].rate),
                                quantity: 1,
                                base: parseFloat(total.toFixed(2)),
                                discount: parseFloat(discount_total.toFixed(2)),
                                amount: total,
                                customer_dep: labour_list[l].customer_dep,
                                insurance_dep: labour_list[l].insurance_dep,
                                tax_amount: parseFloat(_.sumBy(tax, x => x.amount).toFixed(2)),
                                amount_is_tax: labour_list[l].amount_is_tax,
                                tax: tax_info.tax, tax_rate: tax_info.rate,
                                tax_info: tax_details
                            });
                        }
                    }
                    bookingService.push({
                        service: service.service,
                        labour: labours,
                        labour_cost: _.sumBy(labours, x => x.amount),
                        discount: _.sumBy(labours, x => x.discount),
                        parts: service.parts,
                        part_cost: Math.ceil(service.part_cost),
                        opening_fitting: service.opening_fitting,
                        of_cost: Math.ceil(service.of_cost),
                        exceeded_cost: 0,
                        mrp: Math.ceil(service.mrp),
                        cost: service.part_cost + _.sumBy(labours, x => x.amount) + service.of_cost,
                        doorstep: service.doorstep,
                        unit: service.unit,
                        quantity: service.quantity,
                        part_cost_editable: service.part_cost_editable,
                        labour_cost_editable: service.labour_cost_editable,
                        of_cost_editable: service.of_cost_editable,
                        type: service.type,
                        source: service.id,
                        description: service.description,
                        claim: false,
                        customer_approval: true, surveyor_approval: false,
                    });
                });

                await Customization.find({ service: req.body.label, model: car.model._id }).cursor().eachAsync(async (service) => {
                    var getDiscount = {
                        package: checkPackage._id,
                        car: car._id,
                        category: service.type,
                        service: service.service,
                        tz: req.headers['tz'],
                    };

                    var package = await q.all(getPackageDiscount(getDiscount));
                    var labour_list = service.labour;
                    var labours = [];

                    var discount_eligible_labour_cost = _.sumBy(labour_list, x => x.amount);
                    if (labour_list.length > 0) {
                        for (var l = 0; l < labour_list.length; l++) {
                            var quantity = 1;
                            if (labour_list[l].quantity) {
                                quantity = labour_list[l].quantity;
                            }

                            var discount_total = 0;
                            var total = 0;
                            var tax_info = await Tax.findOne({ tax: labour_list[l].tax }).exec();

                            var tax = [];
                            var rate = labour_list[l].rate;
                            var amount = parseFloat(labour_list[l].amount);
                            var tax_rate = tax_info.detail;
                            var base = amount;

                            if (Object.keys(package).length > 0) {
                                if (package.discount_type == "percent") {
                                    discount = parseFloat(package.discount);
                                    if (!isNaN(discount) && discount > 0) {
                                        var discount_total = amount * (discount / 100);
                                        amount = amount - parseFloat(discount_total.toFixed(2))
                                        if (amount < 0) {
                                            amount = 0
                                        }
                                    }
                                }
                                else if (package.discount_type == "fixed") {
                                    discount = parseFloat(package.discount);
                                    if (!isNaN(discount) && discount > 0) {
                                        var discount_total = (amount / discount_eligible_labour_cost) * discount;
                                        amount = parseFloat(discount_total.toFixed(2))
                                        discount = amount - discount_total;
                                        if (amount < 0) {
                                            amount = 0
                                        }
                                    }
                                }
                                else {
                                    discount = parseFloat(package.discount);
                                    if (!isNaN(discount) && discount > 0) {
                                        var discount_total = (amount / discount_eligible_labour_cost) * discount;
                                        amount = amount - parseFloat(discount_total.toFixed(2))
                                        if (amount < 0) {
                                            amount = 0
                                        }
                                    }
                                }
                            }

                            if (labour_list[l].amount_is_tax == "inclusive") {
                                var x = (100 + tax_info.rate) / 100;
                                var tax_on_amount = amount / x;
                                if (tax_rate.length > 0) {
                                    for (var r = 0; r < tax_rate.length; r++) {
                                        if (tax_rate[r].rate != tax_info.rate) {
                                            var t = tax_on_amount * (tax_rate[r].rate / 100);
                                            base = base - t;
                                            tax.push({
                                                tax: tax_rate[r].tax,
                                                rate: tax_rate[r].rate,
                                                amount: parseFloat(t.toFixed(2))
                                            });
                                        }
                                        else {
                                            var t = amount - tax_on_amount;
                                            base = base - t;
                                            tax.push({
                                                tax: tax_info.tax, tax_rate: tax_info.rate,
                                                rate: tax_info.rate,
                                                amount: parseFloat(t.toFixed(2))
                                            });
                                        }
                                    }

                                    //base = base - discount_total;
                                }
                                total = total + amount;
                            }

                            var tax_details = {
                                tax: tax_info.tax,
                                rate: tax_info.rate,
                                amount: total,
                                detail: tax
                            }


                            labours.push({
                                item: labour_list[l].item,
                                source: labour_list[l].source,
                                rate: parseFloat(labour_list[l].rate),
                                quantity: 1,
                                base: parseFloat(total.toFixed(2)),
                                discount: parseFloat(discount_total.toFixed(2)),
                                amount: total,
                                customer_dep: labour_list[l].customer_dep,
                                insurance_dep: labour_list[l].insurance_dep,
                                tax_amount: parseFloat(_.sumBy(tax, x => x.amount).toFixed(2)),
                                amount_is_tax: labour_list[l].amount_is_tax,
                                tax: tax_info.tax, tax_rate: tax_info.rate,
                                tax_info: tax_details
                            });
                        }
                    }
                    bookingService.push({
                        service: service.service,
                        labour: labours,
                        labour_cost: _.sumBy(labours, x => x.amount),
                        discount: _.sumBy(labours, x => x.discount),
                        parts: service.parts,
                        part_cost: Math.ceil(service.part_cost),
                        opening_fitting: service.opening_fitting,
                        of_cost: Math.ceil(service.of_cost),
                        exceeded_cost: 0,
                        mrp: Math.ceil(service.mrp),
                        cost: service.part_cost + _.sumBy(labours, x => x.amount) + service.of_cost,
                        doorstep: service.doorstep,
                        unit: service.unit,
                        quantity: service.quantity,
                        part_cost_editable: service.part_cost_editable,
                        labour_cost_editable: service.labour_cost_editable,
                        of_cost_editable: service.of_cost_editable,
                        type: service.type,
                        source: service.id,
                        description: service.description,
                        claim: false,
                        customer_approval: true, surveyor_approval: false,
                    });
                });


                /*var pick_up_charges = 0;
                if(req.body.convenience){
                    if(req.body.convenience!="Self Drop")
                    {
                        var checkTotal = part_cost+labourCost;
                        if(checkTotal<=checkVendor.business_info.pick_up_limit)
                        {
                            pick_up_charges= Math.ceil(checkVendor.business_info.pick_up_charges);
                        }
                    }
                }*/

                var labour_cost = _.sumBy(bookingService, x => x.labour_cost);
                var part_cost = _.sumBy(bookingService, x => x.part_cost);
                var of_cost = _.sumBy(bookingService, x => x.of_cost);
                var discount_total = _.sumBy(bookingService, x => x.discount);
                var pick_up_charges = 0;
                if (req.body.charges) {
                    pick_up_charges = parseFloat(req.body.charges);
                }

                var paid_total = part_cost + labour_cost + of_cost + pick_up_charges;
                var total = part_cost + labour_cost + of_cost + discount_total;

                var payment = {
                    estimate_cost: paid_total,
                    payment_mode: 'Online',
                    payment_status: "Pending",
                    discount_type: "",
                    coupon: "",
                    coupon_type: "",
                    discount: discount_total,
                    discount_total: discount_total,
                    terms: checkVendor.business_info.terms,
                    pick_up_limit: checkVendor.business_info.pick_up_limit,
                    pick_up_charges: pick_up_charges,
                    part_cost: parseFloat(part_cost.toFixed(2)),
                    labour_cost: parseFloat(labour_cost.toFixed(2)),
                    of_cost: parseFloat(of_cost.toFixed(2)),
                    paid_total: 0,
                    total: parseFloat(total.toFixed(2)),
                    discount_applied: false,
                    transaction_id: "",
                    transaction_date: "",
                    transaction_status: "",
                    transaction_response: "",
                    policy_clause: 0,
                    salvage: 0,
                };

                var due = {
                    due: parseFloat(paid_total.toFixed(2))
                }
                packageDiscountOn = [];

                var data = {
                    package: checkPackage._id,
                    car: checkPackage.car,
                    advisor: advisor,
                    business: checkPackage.business,
                    user: user,
                    services: bookingService,
                    booking_no: Math.round(+new Date() / 1000) + Math.round((Math.random() * 9999) + 1),
                    date: new Date(req.body.date).toISOString(),
                    time_slot: req.body.time_slot,
                    convenience: req.body.convenience,
                    status: "Inactive",
                    payment: payment,
                    due: due,
                    customer_requirements: [],
                    address: req.body.address,
                    is_services: true,
                    created_at: new Date(),
                    updated_at: new Date()
                };

                Booking.create(data).then(async function (booking) {
                    if (booking.is_services == true) {
                        event.zohoLead(booking._id)
                        res.status(200).json({
                            responseCode: 200,
                            responseMessage: "Service Request has been booked",
                            responseData: booking
                        });
                    }
                    else {
                        res.status(200).json({
                            responseCode: 200,
                            responseMessage: "Package successfully purchased, Book Services Now for added benefits",
                            responseData: booking
                        });
                    }
                });
            }
            else {
                res.status(422).json({
                    responseCode: 422,
                    responseMessage: "Booking already exists for the same day. Please choose a different date or ask the advisor if anything needs to be added.",
                    responseData: {},
                });
            }
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Unauthorized",
                responseData: {},
            });
        }


    }
});

router.post('/my/approved/services/add', xAccessToken.token, async function (req, res, next) {
    var rules = {
        booking: 'required',
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Validation Error",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);

        var user = req.headers['business'];


        var business = req.headers['business'];
        var bookingService = [];
        var loggedInDetails = await User.findById(decoded.user).exec();
        var booking = await Booking.findOne({ _id: req.body.booking, user: user }).exec();
        if (booking) {
            var services = req.body.services;
            for (var i = 0; i < services.length; i++) {
                var parts_visible = true;
                var part_tax = [];
                var labour_tax = [];
                var fitting_tax = [];
                var tax_detail = {};
                if (typeof services[i].quantity != "number" || parseInt(services[i].quantity) <= 0) {
                    var quantity = 1
                }
                else {
                    var quantity = parseInt(services[i].quantity)
                }

                var parts = services[i].parts;
                var part = [];
                if (parts.length > 0) {
                    part = services[i].parts
                }
                else {
                    if (services[i].part_cost != 0) {
                        parts_visible = false;
                        var tax_info = await Tax.findOne({ tax: "0% GST" }).exec();
                        var tax_rate = tax_info.detail;
                        var service = services[i].service;
                        var amount = Math.ceil(services[i].part_cost) * quantity;
                        var base = amount;
                        var part_tax = [];

                        var x = (100 + tax_info.rate) / 100;
                        var tax_on_amount = amount / x;
                        if (tax_rate.length > 0) {
                            for (var r = 0; r < tax_rate.length; r++) {
                                if (tax_rate[r].rate != tax_info.rate) {
                                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                                    base = base - t;
                                    part_tax.push({
                                        tax: tax_rate[r].tax,
                                        rate: tax_rate[r].rate,
                                        amount: parseFloat(t.toFixed(2))
                                    });
                                }
                                else {
                                    base = base - t
                                    part_tax.push({
                                        tax: tax_info.tax, tax_rate: tax_info.rate,
                                        rate: tax_info.rate,
                                        amount: parseFloat(tax_on_amount.toFixed(2))
                                    });
                                }
                            }
                        }

                        tax_detail = {
                            tax: tax_info.tax, tax_rate: tax_info.rate,
                            rate: tax_info.rate,
                            base: parseFloat(base.toFixed(2)),
                            detail: part_tax
                        }

                        part.push({
                            item: services[i].service,
                            hsn_sac: "",
                            part_no: "",
                            quantity: quantity,
                            rate: parseFloat(services[i].part_cost),
                            base: parseFloat(base.toFixed(2)),
                            amount: parseFloat(amount),
                            customer_dep: 100,
                            insurance_dep: 0,
                            tax_amount: _.sumBy(part_tax, x => x.amount),
                            amount_is_tax: "inclusive",
                            discount: 0,
                            tax: tax_info.tax, tax_rate: tax_info.rate,
                            tax_info: tax_detail
                        })
                    }

                }

                var labours = services[i].labour;
                var labour = [];

                if (labours.length > 0) {
                    labour = labours
                }
                else {
                    var tax_info = await Tax.findOne({ tax: "18.0% GST" }).exec();
                    var tax_rate = tax_info.detail;
                    var service = services[i].service;
                    var amount = Math.ceil(services[i].labour_cost) * quantity;
                    var base = amount;
                    var labour_tax = [];

                    var x = (100 + tax_info.rate) / 100;
                    var tax_on_amount = amount / x;
                    if (tax_rate.length > 0) {
                        for (var r = 0; r < tax_rate.length; r++) {
                            if (tax_rate[r].rate != tax_info.rate) {
                                var t = tax_on_amount * (tax_rate[r].rate / 100);
                                base = base - t
                                labour_tax.push({
                                    tax: tax_rate[r].tax,
                                    rate: parseFloat(tax_rate[r].rate.toFixed(2)),
                                    amount: parseFloat(t.toFixed(2))
                                })
                            }
                            else {
                                base = base - t
                                labour_tax.push({
                                    tax: tax_info.tax, tax_rate: tax_info.rate,
                                    rate: parseFloat(tax_info.rate.toFixed(2)),
                                    amount: parseFloat(tax_on_amount.toFixed(2))
                                })
                            }
                        }
                    }

                    labour.push({
                        item: services[i].service,
                        quantity: quantity,
                        rate: parseFloat(services[i].labour_cost),
                        base: parseFloat(base.toFixed(2)),
                        amount: parseFloat(amount),
                        discount: 0,
                        customer_dep: 100,
                        insurance_dep: 0,
                        amount_is_tax: "inclusive",
                        tax_amount: _.sumBy(labour_tax, x => x.amount),
                        tax: tax_info.tax, tax_rate: tax_info.rate,
                        tax_info: {
                            tax: tax_info.tax, tax_rate: tax_info.rate,
                            rate: tax_info.rate,
                            base: parseFloat(base.toFixed(2)),
                            detail: labour_tax
                        }
                    })
                }

                var opening_fittings = services[i].opening_fitting;
                var opening_fitting = [];

                if (opening_fittings.length > 0) {
                    opening_fitting = opening_fittings
                }
                else {
                    if (services[i].of_cost != 0) {
                        var tax_info = await Tax.findOne({ tax: "18.0% GST" }).exec();
                        var tax_rate = tax_info.detail;
                        var service = services[i].service;
                        var amount = Math.ceil(services[i].of_cost) * quantity;
                        var base = amount;
                        var fitting_tax = [];

                        var x = (100 + tax_info.rate) / 100;
                        var tax_on_amount = amount / x;
                        if (tax_rate.length > 0) {
                            for (var r = 0; r < tax_rate.length; r++) {
                                if (tax_rate[r].rate != tax_info.rate) {
                                    var t = tax_on_amount * (tax_rate[r].rate / 100);
                                    base = base - t
                                    fitting_tax.push({
                                        tax: tax_rate[r].tax,
                                        rate: tax_rate[r].rate,
                                        amount: parseFloat(t.toFixed(2))
                                    })
                                }
                                else {
                                    base = base - t
                                    fitting_tax.push({
                                        tax: tax_info.tax, tax_rate: tax_info.rate,
                                        rate: tax_info.rate,
                                        amount: parseFloat(tax_on_amount.toFixed(2))
                                    })
                                }
                            }
                        }

                        opening_fitting.push({
                            item: services[i].service,
                            quantity: quantity,
                            rate: parseFloat(services[i].of_cost),
                            base: parseFloat(base.toFixed(2)),
                            discount: 0,
                            amount: parseFloat(amount),
                            amount_is_tax: "inclusive",
                            customer_dep: 100,
                            insurance_dep: 0,
                            tax_amount: _.sumBy(fitting_tax, x => x.amount),
                            tax: tax_info.tax,
                            tax_rate: tax_info.rate,
                            tax_info: {
                                tax: tax_info.tax, tax_rate: tax_info.rate,
                                rate: tax_info.rate,
                                base: parseFloat(base.toFixed(2)),
                                detail: fitting_tax
                            }
                        })
                    }
                }

                bookingService.push({
                    source: services[i].source,
                    service: services[i].service,
                    mileage: services[i].mileage,
                    parts: part,
                    labour: labour,
                    opening_fitting: opening_fitting,
                    hours: services[i].hours,
                    parts_visible: parts_visible,
                    quantity: quantity,
                    description: services[i].description,
                    part_cost: _.sumBy(part, x => x.amount),
                    labour_cost: _.sumBy(labour, x => x.amount),
                    of_cost: _.sumBy(opening_fitting, x => x.amount),
                    exceeded_cost: services[i].exceeded_cost,
                    cost: _.sumBy(part, x => x.amount) + _.sumBy(labour, x => x.amount) + _.sumBy(opening_fitting, x => x.amount),
                    discount: _.sumBy(labour, x => x.discount) + _.sumBy(opening_fitting, x => x.discount) + _.sumBy(part, x => x.discount),
                    part_cost_editable: services[i].part_cost_editable,
                    labour_cost_editable: services[i].labour_cost_editable,
                    of_cost_editable: services[i].of_cost_editable,
                    type: services[i].type,
                    customer_approval: services[i].customer_approval,
                    surveyor_approval: services[i].surveyor_approval,
                    claim: services[i].claim,
                    custom: services[i].custom,
                });
            }

            var approved = _.filter(bookingService, customer_approval => customer_approval.customer_approval == true);
            if (approved.length > 0) {

                var policy_clause = 0
                if (booking.payment.policy_clause) {
                    policy_clause = booking.payment.policy_clause;
                }
                var salvage = 0
                if (booking.payment.salvage) {
                    salvage = booking.payment.salvage;
                }

                var paid_total = booking.payment.paid_total;
                var labour_cost = _.sumBy(bookingService, x => x.labour_cost);
                var part_cost = _.sumBy(bookingService, x => x.part_cost);
                var of_cost = _.sumBy(bookingService, x => x.of_cost);
                var discount_total = _.sumBy(bookingService, x => x.discount);
                var pick_up_charges = booking.payment.pick_up_charges;

                var payment_total = labour_cost + part_cost + of_cost + discount_total + policy_clause + salvage + pick_up_charges;

                var estimate_cost = labour_cost + part_cost + of_cost + policy_clause + salvage + pick_up_charges - careager_cash;
                var careager_cash = await q.all(fun.getBookingCarEagerCash(booking._id))


                var due_amount = _.sumBy(approved, x => x.labour_cost) + _.sumBy(approved, x => x.part_cost) + _.sumBy(approved, x => x.of_cost) + policy_clause + salvage + pick_up_charges - (paid_total + careager_cash);

                var due = {
                    due: Math.ceil(due_amount.toFixed(2))
                }

                var payment = {
                    estimate_cost: estimate_cost,
                    total: parseFloat(payment_total.toFixed(2)),
                    careager_cash: careager_cash,
                    of_cost: parseFloat(of_cost.toFixed(2)),
                    labour_cost: parseFloat(labour_cost.toFixed(2)),
                    part_cost: parseFloat(part_cost.toFixed(2)),
                    payment_mode: booking.payment.payment_mode,
                    payment_status: booking.payment.payment_status,
                    coupon: booking.payment.coupon,
                    coupon_type: booking.payment.coupon_type,
                    discount_by: booking.payment.discount_by,
                    discount_type: booking.payment.discount_type,
                    discount: booking.payment.discount,
                    discount_total: discount_total,
                    terms: booking.payment.terms,
                    pick_up_limit: booking.payment.pick_up_limit,
                    policy_clause: policy_clause,
                    salvage: salvage,
                    pick_up_charges: pick_up_charges,
                    paid_total: booking.payment.paid_total,
                    discount_applied: booking.payment.discount_applied,
                    transaction_id: booking.payment.transaction_id,
                    transaction_date: booking.payment.transaction_date,
                    transaction_status: booking.payment.transaction_status,
                    transaction_response: booking.payment.transaction_response
                };


                if (booking.job_no == "") {
                    if (booking.date && booking.time_slot) {
                        var stage = "Booking"
                        var status = "Confirmed";
                    }
                    else {
                        var stage = "Estimation"
                        var status = "Approved";
                    }
                }
                else {
                    if (booking.status != "JobOpen") {
                        var stage = "";
                        var status = "";
                    }
                    else {
                        var stage = "In-Process";
                        var status = "In-Process"
                    }
                }

                Booking.findOneAndUpdate({ _id: booking._id }, { $set: { services: bookingService, payment: payment, due: due, updated_at: new Date() } }, { new: false }, async function (err, doc) {
                    if (err) {
                        res.status(400).json({
                            responseCode: 400,
                            responseMessage: "Error Occurred Try again",
                            responseData: err
                        });
                    }
                    else {
                        if (status != "") {
                            Booking.findOneAndUpdate({ _id: booking._id }, { $set: { status: status, updated_at: new Date() } }, { new: false }, async function (err, doc) {
                                if (err) {
                                    return res.status(400).json({
                                        responseCode: 400,
                                        responseMessage: "Error Occurred Try again",
                                        responseData: err
                                    });
                                }
                                else {
                                    var activity = {
                                        user: loggedInDetails._id,
                                        name: loggedInDetails.name,
                                        stage: stage,
                                        activity: status,
                                    }

                                    fun.bookingLog(booking._id, activity);
                                }
                            });
                        }


                        var activity = {
                            user: loggedInDetails._id,
                            name: loggedInDetails.name,
                            stage: "ServiceApproved",
                            activity: "ServiceApproved",
                        }

                        fun.bookingLog(booking._id, activity);

                        var notify = {
                            receiver: [booking.advisor],
                            activity: "booking",
                            tag: "Approved",
                            source: booking._id,
                            sender: booking.user,
                            points: 0
                        };

                        fun.newNotification(notify);

                        if (booking.converted) {
                            if (booking.manager) {
                                var notify = {
                                    receiver: [booking.manager],
                                    activity: "booking",
                                    tag: "Approved",
                                    source: booking._id,
                                    sender: booking.user,
                                    points: 0
                                };

                                fun.newNotification(notify);
                            }
                        }
                        event.jobSms(notify);

                        var updated = await Booking.findById(booking.id).exec();

                        res.status(200).json({
                            responseCode: 200,
                            responseMessage: "Service has been added...",
                            responseData: updated
                        });
                    }
                });
            }
            else {
                res.status(400).json({
                    responseCode: 400,
                    responseMessage: "Approve service before save...",
                    responseData: {}
                });
            }
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Booking not found",
                responseData: {}
            });
        }
    }
});

router.get('/service/description/get', xAccessToken.token, async function (req, res, next) {
    var rules = {
        id: 'required',
    };

    var validation = new Validator(req.query, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Service not mention",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        if (req.query.type == "services") {
            var data = await Service.findById(req.query.id).exec();
            if (data) {
                var description = "";
                if (data.description) {
                    description = data.description;
                }
                res.status(200).json({
                    responseCode: 200,
                    responseMessage: description,
                    responseData: {}
                });
            }
            else {
                res.status(200).json({
                    responseCode: 200,
                    responseMessage: "",
                    responseData: {},
                });
            }

        }
        else if (req.query.type == "collision") {
            var data = await Collision.findById(req.query.id).exec();
            if (data) {
                var description = "";
                if (data.description) {
                    description = data.description;
                }
                res.status(200).json({
                    responseCode: 200,
                    responseMessage: description,
                    responseData: {}
                });
            }
            else {
                res.status(200).json({
                    responseCode: 200,
                    responseMessage: "",
                    responseData: {},
                });
            }
        }
        else if (req.query.type == "washing") {
            var data = await Washing.findById(req.query.id).exec();
            if (data) {
                var description = "";
                if (data.description) {
                    description = data.description;
                }
                res.status(200).json({
                    responseCode: 200,
                    responseMessage: description,
                    responseData: {}
                });
            }
            else {
                res.status(200).json({
                    responseCode: 200,
                    responseMessage: "",
                    responseData: {},
                });
            }
        }
        else if (req.query.type == "detailing") {
            var data = await Detailing.findById(req.query.id).exec();
            if (data) {
                var description = "";
                if (data.description) {
                    description = data.description;
                }
                res.status(200).json({
                    responseCode: 200,
                    responseMessage: description,
                    responseData: {}
                });
            }
            else {
                res.status(200).json({
                    responseCode: 200,
                    responseMessage: "",
                    responseData: {},
                });
            }
        }
        else if (req.query.type == "customization") {
            var data = await Customization.findById(req.query.id).exec();
            if (data) {
                var description = "";
                if (data.description) {
                    description = data.description;
                }
                res.status(200).json({
                    responseCode: 200,
                    responseMessage: description,
                    responseData: {}
                });
            }
            else {
                res.status(200).json({
                    responseCode: 200,
                    responseMessage: "",
                    responseData: {},
                });
            }
        }
        else if (req.query.type == "product") {
            var data = await Product.findById(req.query.id).exec();
            if (data) {
                var description = "";
                if (data.description) {
                    description = data.description;
                }
                res.status(200).json({
                    responseCode: 200,
                    responseMessage: description,
                    responseData: {}
                });
            }
            else {
                res.status(200).json({
                    responseCode: 200,
                    responseMessage: "",
                    responseData: {},
                });
            }
        }
        else if (req.query.type == "package") {
            var data = await Package.findById(req.query.id).exec();
            if (data) {
                var description = "";
                if (data.description) {
                    description = data.description;
                }
                res.status(200).json({
                    responseCode: 200,
                    responseMessage: description,
                    responseData: {}
                });
            }
            else {
                res.status(200).json({
                    responseCode: 200,
                    responseMessage: "",
                    responseData: {},
                });
            }
        }

        else if (req.query.type == "addOn") {
            var data = await Package.findById(req.query.id).exec();
            if (data) {
                var description = "";
                if (data.description) {
                    description = data.description;
                }
                res.status(200).json({
                    responseCode: 200,
                    responseMessage: description,
                    responseData: {}
                });
            }
            else {
                res.status(200).json({
                    responseCode: 200,
                    responseMessage: "",
                    responseData: {},
                });
            }
        }
        else {
            res.status(422).json({
                responseCode: 422,
                responseMessage: "Invalid request",
                responseData: {},
            });
        }

    }
});

router.get('/service/gallery/get', async function (req, res, next) {
    var rules = {
        id: 'required',
    };

    var validation = new Validator(req.query, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Service not mention",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var gallery = []
        if (req.query.type == "services") {
            var data = await Service.findById(req.query.id).exec();
            if (data) {
                if (Object.keys(data.gallery).length > 0) {
                    gallery = data.gallery;
                }
            }
        }
        else if (req.query.type == "collision") {
            var data = await Collision.findById(req.query.id).exec();
            if (data) {
                if (Object.keys(data.gallery).length > 0) {
                    gallery = data.gallery;
                }
            }
        }

        else if (req.query.type == "detailing") {
            var data = await Detailing.findById(req.query.id).exec();
            if (data) {
                if (Object.keys(data.gallery).length > 0) {
                    gallery = data.gallery;
                }
            }
        }
        else if (req.query.type == "customization") {
            var data = await Customization.findById(req.query.id).exec();
            if (data) {
                if (Object.keys(data.gallery).length > 0) {
                    gallery = data.gallery;
                }
            }
        }

        if (gallery.length > 0) {
            var data = []
            for (var i = 0; i < gallery.length; i++) {
                data.push({
                    id: gallery[i]._id,
                    type: gallery[i].type,
                    source: req.query.id,
                    file_address: gallery[i].file
                })
            }

            res.status(200).json({
                responseCode: 200,
                responseMessage: "",
                responseData: data
            });
        }
        else {
            res.status(200).json({
                responseCode: 200,
                responseMessage: "",
                responseData: {}
            });
        }
    }
});

router.post('/bookings/time-slot/', xAccessToken.token, async function (req, res, next) {
    var rules = {
        business: 'required',
        date: 'required',
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Service not mention",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var business = req.body.business;
        var date = new Date(new Date(req.body.date).setHours(0, 0, 0, 0));
        var next = new Date(new Date(req.body.date).setHours(0, 0, 0, 0));
        next.setDate(date.getDate() + 1);

        var check = await BookingTiming.find({ business: business }).count().exec();

        if (req.body.booking) {
            var booking = await Booking.findById(req.body.booking).exec();
            if (booking) {
                var body = booking.services;
                if (body.length <= 0) {
                    body.push({
                        type: "services"
                    });
                }
            }
        }
        else if (req.body.label) {
            var body = await q.all(getPackageService(req.body.label));
        }
        else {
            var body = req.body.services;
        }

        body = _.uniqBy(body, 'type');

        var slots = [];


        for (var i = 0; i < body.length; i++) {

            if (body[i].type == "addOn") {
                body[i].type = "services"
            }


            if (check > 0) {
                await BookingTiming.find({ business: business, category: body[i].type })
                    .sort({ sort: 1 })
                    .cursor().eachAsync(async (timing) => {
                        var slot = await Booking.find({
                            time_slot: timing.slot,
                            is_services: true,
                            business: business,
                            date: { $gte: date, $lt: next },
                            services: { $elemMatch: { type: body[i].type } },
                            status: { $nin: ["Inactive", "Rejected", "Cancelled", "Completed", "Closed"] },
                        }).count().exec();

                        if (slot < timing.booking_per_slot) {
                            slot = timing.booking_per_slot - slot
                            slots.push({
                                slot: timing.slot,
                                count: slot,
                                sort: timing.sort,
                                type: timing.category,
                                status: true
                            });
                        }
                        else {
                            slots.push({
                                slot: timing.slot,
                                count: slot,
                                sort: timing.sort,
                                type: timing.category,
                                status: false
                            });
                        }
                    });
            }
            else {
                var a = await BookingTiming.find({ business: null, category: body[i].type }).exec();

                await BookingTiming.find({ business: null, category: body[i].type })
                    .sort({ sort: 1 })
                    .cursor().eachAsync(async (timing) => {
                        // console.log(timing)
                        var slot = await Booking.find({
                            time_slot: timing.slot,
                            is_services: true,
                            business: business,
                            date: { $gte: date, $lt: next },
                            services: { $elemMatch: { type: body[i].type } },
                            status: { $nin: ["Inactive", "Rejected", "Cancelled", "Completed", "Closed"] },
                        }).count().exec();

                        if (slot < timing.booking_per_slot) {
                            slot = timing.booking_per_slot - slot
                            slots.push({
                                slot: timing.slot,
                                count: slot,
                                sort: timing.sort,
                                type: timing.category,
                                status: true
                            });
                        }
                        else {
                            slots.push({
                                slot: timing.slot,
                                count: slot,
                                sort: timing.sort,
                                type: timing.category,
                                status: false
                            });
                        }
                    });
            }
        }

        slots = _.orderBy(slots, 'count', 'desc');
        slots = _.uniqBy(slots, 'slot');
        slots = _.orderBy(slots, 'sort', 'asc');


        res.status(200).json({
            responseCode: 200,
            responseMessage: "",
            responseData: slots
        })
    }
});

router.post('/booking/coupon/remove', xAccessToken.token, async function (req, res, next) {
    var rules = {
        id: 'required',
        type: 'required',
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Coupon Code is required",
            responseData: {
                res: validation.errors.all()
            }
        });
    }
    else {
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var user = decoded.user;

        if (req.headers['business']) {
            user = req.headers['business'];
        }

        var data = new Object();
        var discount = 0;
        var booking = await Booking.findById(req.body.id).exec();
        var coupon = await Coupon.findOne({ code: req.body.coupon, is_product: false }).exec();

        if (booking) {
            if (booking.status == "Inactive") {
                data = {
                    payment: {
                        payment_mode: "",
                        discount_type: "",
                        coupon: '',
                        coupon_type: '',
                        discount: 0,
                        discount_total: 0,
                        terms: booking.payment.terms,
                        pick_up_limit: Math.ceil(booking.payment.pick_up_limit),
                        pick_up_charges: Math.ceil(booking.payment.pick_up_charges),
                        labour_cost: Math.ceil(booking.payment.labour_cost),
                        part_cost: Math.ceil(booking.payment.part_cost),
                        paid_total: Math.ceil(booking.payment.paid_total),
                        total: Math.ceil(booking.payment.total),
                        discount_applied: false,
                        transaction_id: "",
                        transaction_date: "",
                        transaction_status: "",
                        transaction_response: ""
                    }
                };


                Booking.findOneAndUpdate({ _id: booking._id }, { $set: data }, { new: false }, async function (err, doc) {
                    if (err) {
                        res.status(422).json({
                            responseCode: 422,
                            responseMessage: "Something went wrong",
                            responseData: err
                        })
                    }
                    else {
                        if (req.body.type == "coupon") {
                            await CouponUsed.remove({ user: user, booking: booking._id }).exec();
                        }

                        res.status(200).json({
                            responseCode: 200,
                            responseMessage: "Coupon Removed",
                            responseData: data.payment
                        })
                    }
                });
            }
            else {
                res.status(400).json({
                    responseCode: 400,
                    responseMessage: "Unauthorized",
                    responseData: {}
                });
            }
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Booking not found",
                responseData: {}
            });
        }
    }
});

router.get('/booking/coupon/list', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;

    if (req.headers['business']) {
        user = req.headers['business'];
    }

    var data = [];
    await Coupon.findOne({ is_product: false })
        .cursor().eachAsync(async (coupon) => {
            if (coupon) {
                var used = await CouponUsed.findOne({ code: coupon.code, user: user }).count().exec();
                if (used < coupon.usage_limit) {
                    var serverTime = moment.tz(new Date(), req.headers['tz']);
                    var bar = moment.tz(coupon.expired_at, req.headers['tz']);
                    var baz = bar.diff(serverTime);
                    // console.log(baz);
                    if (baz > 0) {

                        var limit = await CouponUsed.findOne({ code: coupon.code }).count().exec();
                        if (limit < coupon.limit) {
                            data.push({
                                _id: coupon._id,
                                id: coupon.id,
                                code: coupon.code,
                                limit: coupon.limit,
                                description: coupon.description
                            });
                        }
                    }
                }
            }


        })
    res.status(200).json({
        responseCode: 200,
        responseMessage: "Coupons",
        responseData: data
    })
});

router.get('/payment/data', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;

    if (req.headers['business']) {
        user = req.headers['business'];
    }

    var paramarray = new Object();
    var discount = 0;
    var booking = await Booking.findById(req.query.id).exec();
    var getUser = await User.findById(user).exec();
    if (booking) {
        Booking.findOneAndUpdate({ _id: req.query.id }, { $set: { order_id: Math.round(+new Date() / 1000) } }, { new: false }, async function (err, doc) {
            if (err) {
                res.status(422).json({
                    responseCode: 422,
                    responseMessage: "Error Occurred",
                    responseData: {}
                })
            }
            else {
                var booking = await Booking.findById(req.query.id).exec();
                if (booking.user == user) {
                    if (booking.due) {
                        var total = booking.due.due;
                        total = total.toFixed(2)
                    }
                    else {
                        var total = booking.payment.paid_total;
                        total = total.toFixed(2)
                    }

                    const payload = {
                        ORDER_ID: booking.order_id.toString(),
                        CUST_ID: user.toString(),
                        ACCESS_CODE: "AVYT82GA63AD63TYDA",
                        MERCHANT_ID: "203679",
                        CURRENCY: "INR",
                        TXN_AMOUNT: total.toString(),
                        EMAIL: getUser.email,
                        MOBILE_NO: getUser.contact_no,
                    };

                    var token = jwt.sign(payload, secret);

                    var paramarray = {
                        ORDER_ID: booking.order_id.toString(),
                        CUST_ID: user.toString(),
                        ACCESS_CODE: "AVYT82GA63AD63TYDA",
                        MERCHANT_ID: "203679",
                        CURRENCY: "INR",
                        TXN_AMOUNT: total.toString(),
                        EMAIL: getUser.email,
                        MOBILE_NO: getUser.contact_no,
                        MERCHANT_PARAM1: token,
                        REDIRECT_URL: "http://13.233.36.16/hdfc/ccavResponseHandler.php",
                        CANCEL_URL: "http://13.233.36.16/hdfc/ccavResponseHandler.php",
                        RSA_KEY_URL: "http://13.233.36.16/hdfc/GetRSA.php"
                    }

                    res.status(200).json({
                        responseCode: 200,
                        responseMessage: "Payment Success",
                        responseData: paramarray
                    });

                }
                else {
                    res.status(400).json({
                        responseCode: 400,
                        responseMessage: "Unauthorized",
                        responseData: {}
                    });
                }
            }
        });
    }
    else {
        res.status(400).json({
            responseCode: 400,
            responseMessage: "Booking Not Found",
            responseData: {}
        });
    }
});

router.post('/payment/gateway/request', async function (req, res, next) {
    var booking = await Booking.findOne({ order_id: req.body.id }).exec();

    if (booking) {
        if (booking.due != null) {
            if (addZeroes(booking.due.due) == addZeroes(req.body.amount)) {
                var paid_total = booking.payment.paid_total + booking.due.due;
                var transaction = addZeroes(req.body.amount);
            }
            else {
                var paid_total = booking.payment.paid_total + booking.due.due;
                var transaction = addZeroes(req.body.amount);

                var status = "Failure";
                req.body.order_status = "Decline";
                req.body.status_message = "Amount tampering found";
            }
        }
        else {
            if (addZeroes(booking.payment.paid_total) == addZeroes(req.body.amount)) {
                var paid_total = booking.payment.paid_total;
                var transaction = addZeroes(req.body.amount);
            }
            else {
                var paid_total = booking.payment.paid_total;
                var transaction = addZeroes(req.body.amount);

                var status = "Failure";
                req.body.order_status = "Decline";
                req.body.status_message = "Amount tampering found";
            }
        }

        var d1 = booking.date;
        var date = new Date();
        var d2 = new Date(date.getFullYear(), date.getMonth(), date.getDate());
        var seconds = (d1.getTime() - d2.getTime()) / 1000;

        if (req.body.order_status == "Success") {
            if (seconds >= 172800) {
                var status = "Confirmed"
            }
            else {
                var status = "Pending"
            }

            var data = {
                status: status,
                payment: {
                    payment_mode: booking.payment.payment_mode,
                    payment_status: req.body.order_status,
                    discount_type: booking.payment.discount_type,
                    coupon: booking.payment.coupon,
                    coupon_type: booking.payment.coupon_type,
                    discount: booking.payment.discount,
                    discount_total: booking.payment.discount_total,
                    labour_cost: Math.ceil(booking.payment.labour_cost),
                    part_cost: Math.ceil(booking.payment.part_cost),
                    paid_total: Math.ceil(paid_total),
                    total: Math.ceil(booking.payment.total),
                    discount_applied: booking.payment.discount_applied,
                    transaction_id: req.body.bank_ref_no,
                    transaction_date: booking.payment.transaction_date,
                    transaction_status: req.body.order_status,
                    transaction_response: req.body.status_message
                },
                due: {
                    due: 0
                },
                updated_at: new Date()
            };

            Booking.findOneAndUpdate({ _id: booking._id }, { $set: data }, { new: false }, async function (err, doc) {
                if (err) {
                    res.status(422).json({
                        responseCode: 422,
                        responseMessage: "Error Occurred",
                        responseData: {}
                    })
                }
                else {
                    fun.transactionLog(booking._id, transaction);
                    event.zohoLead(booking._id);

                    booking.services.forEach(async function (service) {
                        if (service.type == "package") {
                            var package = await Package.findOne({ _id: service.source }).exec();
                            var expired_at = new Date();
                            expired_at.setDate(expired_at.getDate() + package.validity);
                            var check = await UserPackage.find({ package: service.source, category: "free", user: booking.user, car: booking.car }).count().exec();

                            if (check <= 0) {
                                UserPackage.create({
                                    user: booking.user,
                                    car: booking.car,
                                    name: package.name,
                                    booking: booking._id,
                                    business: booking.business,
                                    description: package.description,
                                    category: package.category,
                                    package: package._id,
                                    payment: {
                                        total: service.cost,
                                        paid_total: service.cost,
                                    },
                                    discount: package.discount,
                                    validity: package.validity,
                                    expired_at: expired_at,
                                    created_at: new Date(),
                                    updated_at: new Date()
                                });

                                if (booking.is_services == true) {
                                    Booking.update(
                                        { "_id": booking._id },
                                        { "$pull": { "services": { "source": service.source } } },
                                        function (err, numAffected) {
                                            if (err) {
                                                /// cconsole.logr);
                                            }
                                        }
                                    );
                                }
                            }
                        }
                    })

                    if (booking.package) {
                        var package = await UserPackage.findOne({ _id: booking.package, car: booking.car }).exec();
                        if (package) {
                            booking.services.forEach(async function (service) {
                                package.discount.forEach(async function (dis) {
                                    if (dis.for == "specific") {
                                        if (dis.label == service.service) {
                                            PackageUsed.create({
                                                package: booking.package,
                                                car: booking.car,
                                                user: booking.user,
                                                booking: booking._id,
                                                for: service.type,
                                                label: service.service,
                                                created_at: new Date(),
                                                updated_at: new Date()
                                            });
                                        }
                                    }

                                    else if (dis.for == "category") {
                                        if (dis.label == service.type) {
                                            var cpu = await PackageUsed.find({ package: booking.package, booking: booking._id }).count().exec();
                                            // cconsole.log
                                            if (cpu == 0) {
                                                PackageUsed.create({
                                                    package: booking.package,
                                                    car: booking.car,
                                                    user: booking.user,
                                                    booking: booking._id,
                                                    for: service.type,
                                                    label: service.service,
                                                    created_at: new Date(),
                                                    updated_at: new Date()
                                                });
                                            }
                                        }
                                    }
                                });
                            });
                        }
                    }

                    if (booking.payment.discount_applied == false) {
                        if (booking.payment.discount_type == "coins") {
                            var getCoins = await User.findById(booking.user).select('careager_cash').exec();
                            var remain = getCoins.careager_cash - booking.payment.discount;

                            if (booking.payment.discount > 0) {
                                var point = {
                                    status: true,
                                    user: booking.user,
                                    activity: "booking",
                                    tag: "usedInBooking",
                                    points: booking.payment.discount,
                                    source: booking._id,
                                    created_at: new Date(),
                                    updated_at: new Date(),
                                    type: "debit",
                                };

                                Point.create(point).then(async function (point) {
                                    User.findOneAndUpdate({ _id: booking.user }, { $set: { careager_cash: remain } }, { new: false }, async function (err, doc) { });

                                    Booking.findOneAndUpdate({ _id: booking._id }, { $set: { "payment.discount_applied": true } }, { new: false }, async function (err, doc) { })
                                })
                            }
                        }

                        else if (booking.payment.discount_type == "coupon" && booking.payment.discount_total != 0 && booking.payment.discount_total) {
                            var coupon = await Coupon.findOne({ code: booking.payment.coupon }).exec();
                            var used = await CouponUsed.findOne({ code: booking.payment.coupon, user: booking.user }).count().exec();
                            if (used == 0) {
                                CouponUsed.create({
                                    coupon: coupon._id,
                                    code: coupon.code,
                                    booking: booking._id,
                                    user: booking.user,
                                    created_at: new Date(),
                                    updated_at: new Date()
                                });

                                Booking.findOneAndUpdate({ _id: booking._id }, { $set: { "payment.discount_applied": true } }, { new: false }, async function (err, doc) { })
                            }
                        }
                    }

                    if (booking.is_services == true) {
                        var notify = {
                            receiver: [booking.business],
                            activity: "booking",
                            tag: "newBooking",
                            source: booking._id,
                            sender: booking.user,
                            points: 0
                        }

                        fun.newNotification(notify);
                        event.bookingMail(booking._id);

                        if (booking.advisor) {
                            var advisor = await User.findById(booking.advisor).exec();
                            var notify = {
                                receiver: [advisor._id],
                                activity: "booking",
                                tag: "newBooking",
                                source: booking._id,
                                sender: booking.user,
                                points: 0
                            }

                            fun.newNotification(notify);
                        }


                        res.status(200).json({
                            responseCode: 200,
                            responseMessage: "Service has been booked",
                            responseData: {
                                booking_no: booking.booking_no,
                                is_services: booking.is_services
                            }
                        });
                    }
                    else {
                        var notify = {
                            receiver: [booking.business],
                            activity: "package",
                            tag: "newPackage",
                            source: booking._id,
                            sender: booking.user,
                            points: 0
                        }

                        fun.newNotification(notify);
                        event.bookingMail(booking._id);

                        res.status(200).json({
                            responseCode: 200,
                            responseMessage: "Package successfully purchased, Book Services Now for added benefits",
                            responseData: {
                                booking_no: booking.booking_no,
                                is_services: booking.is_services
                            }
                        });
                    }
                }
            });
        }
        else {
            if (booking.due) {
                var data = {
                    status: "Failure",
                    payment: {
                        payment_mode: booking.payment.payment_mode,
                        payment_status: req.body.order_status,
                        discount_type: booking.payment.discount_type,
                        coupon: booking.payment.coupon,
                        coupon_type: booking.payment.coupon_type,
                        discount: booking.payment.discount,
                        discount_total: booking.payment.discount_total,
                        labour_cost: Math.ceil(booking.payment.labour_cost),
                        part_cost: Math.ceil(booking.payment.part_cost),
                        paid_total: Math.ceil(booking.payment.paid_total),
                        total: Math.ceil(booking.payment.total),
                        discount_applied: booking.payment.discount_applied,
                        transaction_id: req.body.bank_ref_no,
                        transaction_date: booking.payment.transaction_date,
                        transaction_status: req.body.order_status,
                        transaction_response: req.body.status_message
                    },
                    due: booking.due
                }
            }
            else {
                var data = {
                    status: "Failure",
                    payment: {
                        payment_mode: booking.payment.payment_mode,
                        payment_status: req.body.order_status,
                        discount_type: booking.payment.discount_type,
                        coupon: booking.payment.coupon,
                        coupon_type: booking.payment.coupon_type,
                        discount: booking.payment.discount,
                        discount_total: booking.payment.discount_total,
                        labour_cost: 0,
                        part_cost: 0,
                        paid_total: 0,
                        total: 0,
                        discount_applied: booking.payment.discount_applied,
                        transaction_id: req.body.bank_ref_no,
                        transaction_date: booking.payment.transaction_date,
                        transaction_status: req.body.order_status,
                        transaction_response: req.body.status_message
                    },
                    due: {
                        labour_cost: booking.payment.labour_cost,
                        part_cost: booking.payment.part_cost,
                        due: booking.payment.paid_total
                    }
                }
            }

            Booking.findOneAndUpdate({ _id: booking._id }, { $set: data }, { new: false }, async function (err, doc) {
                fun.transactionLog(booking._id, req.body.amount);
                if (err) {
                    res.status(422).json({
                        responseCode: 422,
                        responseMessage: "Error Occurred",
                        responseData: {}
                    })
                }

                if (booking.payment.discount_applied == false) {
                    if (booking.payment.discount_type == "coins") {
                        var getCoins = await User.findById(booking.user).select('careager_cash').exec();
                        var remain = getCoins.careager_cash - booking.payment.discount;

                        if (booking.payment.discount > 0) {
                            var point = {
                                status: true,
                                user: booking.user,
                                activity: "booking",
                                tag: "usedInBooking",
                                points: booking.payment.discount,
                                source: booking._id,
                                created_at: new Date(),
                                updated_at: new Date(),
                                type: "debit",
                            };

                            Point.create(point).then(async function (point) {
                                User.findOneAndUpdate({ _id: booking.user }, { $set: { careager_cash: remain } }, { new: false }, async function (err, doc) { });

                                Booking.findOneAndUpdate({ _id: booking._id }, { $set: { "payment.discount_applied": true } }, { new: false }, async function (err, doc) { })
                            })
                        }
                    }

                    else if (booking.payment.discount_type == "coupon" && booking.payment.discount_total != 0 && booking.payment.discount_total) {
                        var coupon = await Coupon.findOne({ code: booking.payment.coupon }).exec();
                        var used = await CouponUsed.findOne({ code: booking.payment.coupon, user: booking.user }).count().exec();
                        if (used == 0) {
                            CouponUsed.create({
                                coupon: coupon._id,
                                code: coupon.code,
                                booking: booking._id,
                                user: booking.user,
                                created_at: new Date(),
                                updated_at: new Date()
                            });

                            Booking.findOneAndUpdate({ _id: booking._id }, { $set: { "payment.discount_applied": true } }, { new: false }, async function (err, doc) { })
                        }
                    }
                }

                UserPackage.findOneAndUpdate({ booking: booking._id }, { $set: { "status": false, updated_at: new Date() } }, { new: false }, async function (err, doc) { })
            });

            res.status(200).json({
                responseCode: 200,
                responseMessage: "Your transaction has been declined",
                responseData: req.body
            })
        }
    }
    else {
        res.status(400).json({
            responseCode: 400,
            responseMessage: "Booking not found",
            responseData: req.body
        })
    }
});

router.get('/booking/convenience', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var data = [];
    var a = null;
    var u = null;
    var c = "";
    var booking = await Booking.findById(req.query.booking).exec();
    if (booking) {
        if (booking.address) {
            a = booking.address
        }

        if (booking.convenience) {
            c = booking.convenience
        }
    }

    var addresses = [];
    await Address.find({ user: decoded.user })
        .cursor().eachAsync(async (address) => {
            if (address._id.equals(a)) {
                var checked = true
            }
            else {
                var checked = false
            }

            addresses.push({
                _id: address._id,
                id: address.id,
                user: address.user,
                address: address.address,
                area: address.area,
                landmark: address.landmark,
                zip: address.zip,
                city: address.city,
                state: address.state,
                checked: checked
            });
        });

    var conveniences = [];
    await BusinessConvenience.find({ business: req.query.business })
        .cursor().eachAsync(async (convenience) => {
            if (convenience.convenience == c) {
                var checked = true
            }
            else {
                var checked = false
            }

            conveniences.push({
                _id: convenience._id,
                id: convenience.id,
                convenience: convenience.convenience,
                charges: convenience.charges,
                business: convenience.business,
                checked: checked
            });
        });


    res.status(200).json({
        responseCode: 200,
        responseMessage: "",
        responseData: {
            address: addresses,
            convenience: conveniences
        }
    });
});

function addZeroes(num) {
    var num = Number(num);
    if (String(num).split(".").length < 2 || String(num).split(".")[1].length <= 2) {
        num = num.toFixed(2);
    }
    return num;
}

router.get('/payment/checksum/generate', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;

    if (req.headers['business']) {
        user = req.headers['business'];
    }

    var paramarray = new Object();
    var discount = 0;


    var checkBooking = await Booking.findById(req.query.id).exec();
    var getUser = await User.findById(user).exec();
    if (checkBooking) {
        if (req.query.pay) {
            var data = {
                due: {
                    due: checkBooking.due.due,
                    pay: parseFloat(req.query.pay)
                },
                order_id: Math.round(+new Date() / 1000),
                updated_at: new Date()
            };
        }
        else {
            var data = {
                order_id: Math.round(+new Date() / 1000),
                updated_at: new Date()
            }
        }


        Booking.findOneAndUpdate({ _id: req.query.id }, { $set: data }, { new: false }, async function (err, doc) {
            if (err) {
                res.status(422).json({
                    responseCode: 422,
                    responseMessage: "Error Occurred",
                    responseData: {}
                })
            }
            else {
                var booking = await Booking.findById(req.query.id).exec();
                if (booking.user == user) {
                    if (booking.due) {
                        if (req.query.pay) {
                            var total = booking.due.pay;
                            total = parseFloat(total.toFixed(2))
                        }
                        else {
                            var total = booking.due.due;
                            total = parseFloat(total.toFixed(2))
                        }
                    }
                    else {
                        var total = booking.payment.paid_total;
                        total = parseFloat(total.toFixed(2))
                    }

                    var paramarray = {
                        MID: paytm_config.MID,
                        ORDER_ID: booking.order_id.toString(),
                        CUST_ID: user.toString(),
                        INDUSTRY_TYPE_ID: paytm_config.INDUSTRY_TYPE_ID,
                        CHANNEL_ID: "WAP",
                        TXN_AMOUNT: total.toString(),
                        WEBSITE: paytm_config.WEBSITE,
                        CALLBACK_URL: paytm_config.CALLBACK + 'theia/paytmCallback?ORDER_ID=' + booking.order_id.toString(),
                        EMAIL: getUser.email,
                        MOBILE_NO: getUser.contact_no
                    };

                    //res.json(paramarray)

                    paytm_checksum.genchecksum(paramarray, paytm_config.MERCHANT_KEY, function (err, data) {
                        if (err) {
                            res.status(422).json({
                                responseCode: 422,
                                responseMessage: "failure",
                                responseData: err
                            });
                        }
                        else {
                            res.status(200).json({
                                responseCode: 200,
                                responseMessage: "Checksum generated",
                                responseData: data
                            });
                        }
                    });
                }
                else {
                    res.status(400).json({
                        responseCode: 400,
                        responseMessage: "Unauthorized",
                        responseData: {}
                    });
                }
            }
        });
    }
    else {
        res.status(400).json({
            responseCode: 400,
            responseMessage: "Booking Not Found",
            responseData: {}
        });
    }
});

router.get('/payment/transaction/status', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;

    if (req.headers['business']) {
        user = req.headers['business'];
    }


    var paramarray = new Object();
    var discount = 0;
    var booking = await Booking.findOne({ order_id: req.query.id, user: user }).exec();
    var getUser = await User.findById(user).exec();
    if (booking) {
        if (booking.user == user) {
            var payment_paid_total = booking.payment.paid_total;
            if (booking.due != null) {
                if (booking.due.pay) {
                    var due_pay = booking.due.pay;
                    var paid_total = parseFloat(payment_paid_total.toFixed(2)) + parseFloat(due_pay.toFixed(2));
                }
                else {
                    var payment_due = booking.due.due;
                    var paid_total = parseFloat(payment_paid_total.toFixed(2)) + parseFloat(payment_due.toFixed(2));
                }
            }
            else {
                var paid_total = parseFloat(payment_paid_total.toFixed(2))

                User.findOneAndUpdate({ _id: booking.user }, {
                    $push: {
                        "bookings": booking._id
                    }
                }, { new: true }, async function (err, doc) {
                    if (err) {
                        // console.log(err)
                    }
                    else {
                        /// cconsole.logc)
                    }
                });
            }

            var paramarray = {
                MID: paytm_config.MID,
                ORDER_ID: booking.order_id.toString(),
                CUST_ID: user.toString(),
                INDUSTRY_TYPE_ID: paytm_config.INDUSTRY_TYPE_ID,
                CHANNEL_ID: "WAP",
                TXN_AMOUNT: paid_total.toString(),
                WEBSITE: paytm_config.WEBSITE,
                CALLBACK_URL: paytm_config.CALLBACK + 'theia/paytmCallback?ORDER_ID=' + req.query.id,
                EMAIL: getUser.email,
                MOBILE_NO: getUser.contact_no
            };


            paytm_checksum.genchecksum(paramarray, paytm_config.MERCHANT_KEY, async function (err, result) {
                result["CHECKSUMHASH"] = encodeURIComponent(result["CHECKSUMHASH"]);
                var finalstring = "JsonData=" + JSON.stringify(result);
                request.post({ url: paytm_config.CALLBACK + 'merchant-status/getTxnStatus?' + finalstring }, async function (error, httpResponse, body) {
                    if (error) {
                        res.status(422).json({
                            responseCode: 422,
                            responseMessage: "failure",
                            responseData: err
                        });
                    }
                    else {
                        var paytmRes = JSON.parse(body);
                        if (paytmRes.STATUS == "TXN_SUCCESS") {
                            if (booking.sub_status != "") {
                                var stage = "In-Process";
                                var status = booking.status;
                            }
                            else {
                                if (booking.date) {
                                    var d1 = booking.date;
                                    var date = new Date();
                                    var d2 = new Date(date.getFullYear(), date.getMonth(), date.getDate());
                                    var seconds = (d1.getTime() - d2.getTime()) / 1000;
                                    if (seconds >= 172800) {
                                        var stage = "Booking";
                                        var status = "Confirmed";
                                    }
                                    else {
                                        var stage = "Booking";
                                        var status = "Pending";
                                    }
                                }
                                else {
                                    var stage = "Booking";
                                    var status = "Pending";
                                }
                            }

                            if (booking.due) {
                                if (booking.due.pay) {
                                    var due = booking.due.due - parseFloat(paytmRes.TXNAMOUNT);
                                    if (due > 0) {
                                        var due_info = {
                                            due: Math.ceil(due.toFixed(2)),
                                            pay: 0
                                        }
                                    }
                                    else {
                                        var due_info = null
                                    }
                                }
                            }
                            else {
                                var due_info = null
                            }

                            var data = {
                                status: status,
                                payment: {
                                    payment_mode: booking.payment.payment_mode,
                                    payment_status: "Success",
                                    discount_type: booking.payment.discount_type,
                                    coupon: booking.payment.coupon,
                                    coupon_type: booking.payment.coupon_type,
                                    discount: booking.payment.discount,
                                    discount_total: booking.payment.discount_total,
                                    discount_applied: booking.payment.discount_applied,
                                    terms: booking.payment.terms,
                                    pick_up_limit: booking.payment.pick_up_limit,
                                    pick_up_charges: booking.payment.pick_up_charges,
                                    labour_cost: booking.payment.labour_cost,
                                    of_cost: booking.payment.of_cost,
                                    part_cost: booking.payment.part_cost,
                                    paid_total: paid_total,
                                    total: booking.payment.total,
                                    policy_clause: booking.payment.policy_clause,
                                    salvage: booking.payment.salvage,
                                    transaction_id: paytmRes.TXNID,
                                    transaction_date: paytmRes.TXNDATE,
                                    transaction_status: paytmRes.STATUS,
                                    transaction_response: paytmRes.RESPMSG
                                },
                                due: due_info,
                                updated_at: new Date()
                            };

                            Booking.findOneAndUpdate({ _id: booking._id }, { $set: data }, { new: false }, async function (err, doc) {
                                if (err) {
                                    res.status(422).json({
                                        responseCode: 422,
                                        responseMessage: "Error Occurred",
                                        responseData: {}
                                    })
                                }
                                else {
                                    var activity = {
                                        user: getUser._id,
                                        name: getUser.name,
                                        stage: stage,
                                        activity: status,
                                    };

                                    fun.bookingLog(booking._id, activity);

                                    fun.transactionLog(booking._id, parseFloat(paytmRes.TXNAMOUNT));
                                    event.zohoLead(booking._id);

                                    booking.services.forEach(async function (service) {
                                        if (service.type == "package") {
                                            var package = await Package.findOne({ _id: service.source }).exec();
                                            var expired_at = new Date();
                                            expired_at.setDate(expired_at.getDate() + package.validity);
                                            var check = await UserPackage.find({ package: service.source, category: "free", user: booking.user, car: booking.car }).count().exec();

                                            if (check <= 0) {

                                                UserPackage.create({
                                                    user: booking.user,
                                                    car: booking.car,
                                                    booking: booking._id,
                                                    name: package.name,
                                                    business: booking.business,
                                                    description: package.description,
                                                    category: package.category,
                                                    package: package._id,
                                                    payment: {
                                                        total: service.cost,
                                                        paid_total: service.cost,
                                                    },
                                                    discount: package.discount,
                                                    validity: package.validity,
                                                    expired_at: expired_at,
                                                    created_at: new Date(),
                                                    updated_at: new Date()
                                                });

                                                if (package.cashback) {
                                                    var point = {
                                                        user: booking.user,
                                                        activity: "coin",
                                                        tag: "cashback",
                                                        source: booking._id,
                                                        sender: null,
                                                        points: package.cashback,
                                                        title: "",
                                                        body: "",
                                                        status: true
                                                    }

                                                    fun.addPoints(point)
                                                }
                                            }
                                        }
                                    })

                                    if (booking.package) {
                                        var packageUsed = [];
                                        var package = await UserPackage.findOne({ _id: booking.package, car: booking.car }).exec();
                                        if (package) {
                                            booking.services.forEach(async function (service) {
                                                package.discount.forEach(async function (dis) {
                                                    if (dis.for == "specific") {
                                                        if (dis.label == service.service) {
                                                            if (dis.discount > 0) {
                                                                packageUsed.push({
                                                                    package: booking.package,
                                                                    car: booking.car,
                                                                    user: booking.user,
                                                                    booking: booking._id,
                                                                    for: service.type,
                                                                    label: service.service,
                                                                    created_at: new Date(),
                                                                    updated_at: new Date()
                                                                });
                                                            }
                                                        }
                                                    }
                                                    else if (dis.for == "category") {
                                                        if (dis.label == service.type) {
                                                            packageUsed.push({
                                                                package: booking.package,
                                                                car: booking.car,
                                                                user: booking.user,
                                                                booking: booking._id,
                                                                for: service.type,
                                                                label: service.type,
                                                                created_at: new Date(),
                                                                updated_at: new Date()
                                                            })
                                                        }
                                                    }
                                                });
                                            });

                                            var packageUsed = _.uniqBy(packageUsed, function (o) {
                                                return o.label;
                                            });

                                            packageUsed.forEach(async function (p) {
                                                var checkUsedPackage = await PackageUsed.find({ package: p.package, booking: p.booking, label: p.label, }).count().exec();

                                                if (checkUsedPackage == 0) {
                                                    PackageUsed.create({
                                                        package: p.package,
                                                        car: p.car,
                                                        user: p.user,
                                                        booking: p.booking,
                                                        for: p.for,
                                                        label: p.label,
                                                        created_at: p.created_at,
                                                        updated_at: p.updated_at
                                                    })
                                                }
                                            })
                                        }
                                    }

                                    if (booking.payment.discount_applied == false) {
                                        if (booking.payment.discount_type == "coins") {
                                            var getCoins = await User.findById(booking.user).select('careager_cash').exec();
                                            var remain = getCoins.careager_cash - booking.payment.discount;

                                            if (booking.payment.discount > 0) {
                                                var point = {
                                                    status: true,
                                                    user: booking.user,
                                                    activity: "booking",
                                                    tag: "usedInBooking",
                                                    points: booking.payment.discount,
                                                    source: booking._id,
                                                    created_at: new Date(),
                                                    updated_at: new Date(),
                                                    type: "debit",
                                                };

                                                Point.create(point).then(async function (point) {
                                                    User.findOneAndUpdate({ _id: booking.user }, { $set: { careager_cash: remain } }, { new: false }, async function (err, doc) { });

                                                    Booking.findOneAndUpdate({ _id: booking._id }, { $set: { "payment.discount_applied": true } }, { new: false }, async function (err, doc) { })
                                                })
                                            }
                                        }

                                        else if (booking.payment.discount_type == "coupon" && booking.payment.discount_total != 0 && booking.payment.discount_total) {
                                            var coupon = await Coupon.findOne({ code: booking.payment.coupon }).exec();
                                            var used = await CouponUsed.findOne({ code: booking.payment.coupon, user: booking.user }).count().exec();
                                            if (used == 0) {
                                                CouponUsed.create({
                                                    coupon: coupon._id,
                                                    code: coupon.code,
                                                    booking: booking._id,
                                                    user: booking.user,
                                                    created_at: new Date(),
                                                    updated_at: new Date()
                                                });

                                                Booking.findOneAndUpdate({ _id: booking._id }, { $set: { "payment.discount_applied": true } }, { new: false }, async function (err, doc) { })
                                            }
                                        }
                                    }

                                    if (booking.is_services == true) {
                                        var notify = {
                                            receiver: [booking.business],
                                            activity: "booking",
                                            tag: "newBooking",
                                            source: booking._id,
                                            sender: booking.user,
                                            points: 0
                                        }

                                        fun.newNotification(notify);
                                        event.bookingMail(booking._id);

                                        if (booking.advisor) {
                                            var advisor = await User.findById(booking.advisor).exec();
                                            var notify = {
                                                receiver: [advisor._id],
                                                activity: "booking",
                                                tag: "newBooking",
                                                source: booking._id,
                                                sender: booking.user,
                                                points: 0
                                            }

                                            fun.newNotification(notify);
                                        }

                                        res.status(200).json({
                                            responseCode: 200,
                                            responseMessage: "Payment Done",
                                            responseData: paytmRes
                                        });
                                    }
                                    else {
                                        var notify = {
                                            receiver: [booking.business],
                                            activity: "package",
                                            tag: "newPackage",
                                            source: booking._id,
                                            sender: booking.user,
                                            points: 0
                                        }

                                        fun.newNotification(notify);
                                        event.bookingMail(booking._id);

                                        res.status(200).json({
                                            responseCode: 200,
                                            responseMessage: "Package successfully purchased, Book Services Now for added benefits",
                                            responseData: paytmRes
                                        });
                                    }
                                }
                            });
                        }
                        else {
                            var data = {
                                status: "Failure",
                                payment: {
                                    careager_cash: booking.payment.careager_cash,
                                    payment_mode: booking.payment.payment_mode,
                                    payment_status: "Failure",
                                    discount_type: booking.payment.discount_type,
                                    coupon: booking.payment.coupon,
                                    coupon_type: booking.payment.coupon_type,
                                    discount: booking.payment.discount,
                                    terms: booking.payment.terms,
                                    pick_up_limit: booking.payment.pick_up_limit,
                                    pick_up_charges: booking.payment.pick_up_charges,
                                    discount_total: booking.payment.discount_total,
                                    labour_cost: booking.payment.labour_cost,
                                    of_cost: booking.payment.of_cost,
                                    part_cost: booking.payment.part_cost,
                                    paid_total: booking.payment.paid_total,
                                    total: booking.payment.total,
                                    discount_applied: booking.payment.discount_applied,
                                    policy_clause: booking.payment.policy_clause,
                                    salvage: booking.payment.salvage,
                                    transaction_id: paytmRes.TXNID,
                                    transaction_date: paytmRes.TXNDATE,
                                    transaction_status: paytmRes.STATUS,
                                    transaction_response: paytmRes.RESPMSG,
                                    transaction_response: paytmRes.TXNAMOUNT
                                },
                                due: {
                                    due: booking.payment.part_cost + booking.payment.labour_cost + booking.payment.of_cost + booking.payment.salvage + booking.payment.pick_up_charges + booking.payment.policy_clause - booking.payment.careager_cash
                                },
                                updated_at: new Date()
                            }


                            Booking.findOneAndUpdate({ _id: booking._id }, { $set: data }, { new: false }, async function (err, doc) {
                                fun.transactionLog(booking._id, parseFloat(paytmRes.TXNAMOUNT));
                                if (err) {
                                    res.status(422).json({
                                        responseCode: 422,
                                        responseMessage: "Error Occurred",
                                        responseData: {}
                                    })
                                }

                                if (booking.payment.discount_applied == false) {
                                    if (booking.payment.discount_type == "coins") {
                                        var getCoins = await User.findById(booking.user).select('careager_cash').exec();
                                        var remain = getCoins.careager_cash - booking.payment.discount;

                                        if (booking.payment.discount > 0) {
                                            var point = {
                                                status: true,
                                                user: booking.user,
                                                activity: "booking",
                                                tag: "usedInBooking",
                                                points: booking.payment.discount,
                                                source: booking._id,
                                                created_at: new Date(),
                                                updated_at: new Date(),
                                                type: "debit",
                                            };

                                            Point.create(point).then(async function (point) {
                                                User.findOneAndUpdate({ _id: booking.user }, { $set: { careager_cash: remain } }, { new: false }, async function (err, doc) { });

                                                Booking.findOneAndUpdate({ _id: booking._id }, { $set: { "payment.discount_applied": true } }, { new: false }, async function (err, doc) { })
                                            })
                                        }
                                    }

                                    else if (booking.payment.discount_type == "coupon" && booking.payment.discount_total != 0 && booking.payment.discount_total) {
                                        var coupon = await Coupon.findOne({ code: booking.payment.coupon }).exec();
                                        var used = await CouponUsed.findOne({ code: booking.payment.coupon, user: booking.user }).count().exec();
                                        if (used == 0) {
                                            CouponUsed.create({
                                                coupon: coupon._id,
                                                code: coupon.code,
                                                booking: booking._id,
                                                user: booking.user,
                                                created_at: new Date(),
                                                updated_at: new Date()
                                            });

                                            Booking.findOneAndUpdate({ _id: booking._id }, { $set: { "payment.discount_applied": true } }, { new: false }, async function (err, doc) { })
                                        }
                                    }
                                }

                                event.zohoLead(booking._id);
                            });

                            res.status(200).json({
                                responseCode: 200,
                                responseMessage: "Your transaction has been declined",
                                responseData: paytmRes
                            })
                        }

                    }
                });
            });
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Unauthorized",
                responseData: {}
            });
        }
    }
    else {
        res.status(400).json({
            responseCode: 400,
            responseMessage: "Booking Not Found",
            responseData: {}
        });
    }
});

router.post('/payment/gateway/response', xAccessToken.token, async function (req, res, next) {
    var rules = {
        id: 'required',
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Error",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var user = decoded.user;

        if (req.headers['business']) {
            user = req.headers['business'];
        }

        var booking = await Booking.findById(req.body.id).exec();

        if (booking) {
            var transaction = await TransactionLog.findOne({ source: booking._id }).sort({ created_at: -1 }).exec()
            if (booking.payment.payment_status == "Success" || booking.payment.payment_status == "success") {
                res.status(200).json({
                    responseCode: 200,
                    responseMessage: "Payment Done",
                    responseData: {
                        booking_no: booking.booking_no,
                        payment: transaction,
                        is_services: booking.is_services
                    }
                });
            }
            else {
                res.status(200).json({
                    responseCode: 200,
                    responseMessage: "Payment Failure",
                    responseData: {
                        booking_no: booking.booking_no,
                        payment: transaction,
                        is_services: booking.is_services
                    }
                });
            }
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Booking not found",
                responseData: {}
            })
        }
    }
});

router.post('/payment/gateway/tampering', xAccessToken.token, async function (req, res, next) {
    var rules = {
        id: 'required',
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Error",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var booking = await Booking.findOne({ _id: req.body.id }).exec();

        if (booking) {

            var data = {
                status: "Failure",
                payment: {
                    payment_mode: booking.payment.payment_mode,
                    payment_status: req.body.order_status,
                    discount_type: booking.payment.discount_type,
                    coupon: booking.payment.coupon,
                    coupon_type: booking.payment.coupon_type,
                    terms: booking.payment.terms,
                    pick_up_limit: booking.payment.pick_up_limit,
                    pick_up_charges: booking.payment.pick_up_charges,
                    discount: booking.payment.discount,
                    discount_total: booking.payment.discount_total,
                    labour_cost: booking.payment.labour_cost,
                    part_cost: booking.payment.part_cost,
                    paid_total: 0,
                    //paid_total: booking.payment.paid_total,
                    total: booking.payment.total,
                    discount_applied: booking.payment.discount_applied,
                    transaction_id: req.body.bank_ref_no,
                    transaction_date: booking.payment.transaction_date,
                    transaction_status: req.body.order_status,
                    transaction_response: req.body.status_message
                },
                due: booking.due
            }

            Booking.findOneAndUpdate({ _id: booking._id }, { $set: data }, { new: false }, async function (err, doc) {
                fun.transactionLog(booking._id, req.body.amount);
                if (err) {
                    res.status(422).json({
                        responseCode: 422,
                        responseMessage: "Error Occurred",
                        responseData: {}
                    })
                }

                if (booking.payment.discount_applied == false) {
                    if (booking.payment.discount_type == "coins") {
                        var getCoins = await User.findById(booking.user).select('careager_cash').exec();
                        var remain = getCoins.careager_cash - booking.payment.discount;

                        if (booking.payment.discount > 0) {
                            var point = {
                                status: true,
                                user: booking.user,
                                activity: "booking",
                                tag: "usedInBooking",
                                points: booking.payment.discount,
                                source: booking._id,
                                created_at: new Date(),
                                updated_at: new Date(),
                                type: "debit",
                            };

                            Point.create(point).then(async function (point) {
                                User.findOneAndUpdate({ _id: booking.user }, { $set: { careager_cash: remain } }, { new: false }, async function (err, doc) { });

                                Booking.findOneAndUpdate({ _id: booking._id }, { $set: { "payment.discount_applied": true } }, { new: false }, async function (err, doc) { })
                            })
                        }
                    }

                    else if (booking.payment.discount_type == "coupon" && booking.payment.discount_total != 0 && booking.payment.discount_total) {
                        var coupon = await Coupon.findOne({ code: booking.payment.coupon }).exec();
                        var used = await CouponUsed.findOne({ code: booking.payment.coupon, user: booking.user }).count().exec();
                        if (used == 0) {
                            CouponUsed.create({
                                coupon: coupon._id,
                                code: coupon.code,
                                booking: booking._id,
                                user: booking.user,
                                created_at: new Date(),
                                updated_at: new Date()
                            });

                            Booking.findOneAndUpdate({ _id: booking._id }, { $set: { "payment.discount_applied": true } }, { new: false }, async function (err, doc) { })
                        }
                    }

                    var checkPackage = UserPackage.findOne({ booking: booking.id }).exec();
                    if (checkPackage) {
                        UserPackage.findOneAndUpdate({ booking: booking._id }, { $set: { "status": false, updated_at: new Date() } }, { new: false }, async function (err, doc) { })
                    }

                }

                //event.zohoLead(booking._id); 
            });

            res.status(200).json({
                responseCode: 200,
                responseMessage: "Your transaction has been declined",
                responseData: req.body
            })

        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Booking not found",
                responseData: req.body
            })
        }
    }
});

router.post('/pay/later', xAccessToken.token, async function (req, res, next) {
    var rules = {
        id: 'required',
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Error",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var user = decoded.user;

        if (req.headers['business']) {
            user = req.headers['business'];
        }


        var loggedInDetails = await User.findById(user).exec();
        var booking = await Booking.findById(req.body.id).exec();
        var coupon = await Coupon.findOne({ code: req.body.coupon }).exec();

        if (booking) {
            var package = _.filter(booking.services, type => type.type == "package");

            if (Object.keys(package).length <= 0) {
                var d1 = booking.date;
                var date = new Date();
                var d2 = new Date(date.getFullYear(), date.getMonth(), date.getDate());
                var seconds = (d1.getTime() - d2.getTime()) / 1000;
                /// cconsole.logconds)
                if (seconds >= 172800) {
                    var status = "Confirmed"
                }
                else {
                    var status = "Pending"
                }


                var data = {
                    status: status,
                    updated_at: new Date()
                }

                Booking.findOneAndUpdate({ _id: req.body.id }, { $set: data }, { new: false }, async function (err, doc) {
                    if (err) {
                        res.status(422).json({
                            responseCode: 422,
                            responseMessage: "Error Occurred",
                            responseData: {}
                        })
                    }
                    else {
                        User.findOneAndUpdate({ _id: booking.user }, {
                            $push: {
                                "bookings": booking._id
                            }
                        }, { new: true }, async function (err, doc) {
                            if (err) {
                                // console.log(err)
                            }
                            else {
                                /// cconsole.logc)
                            }
                        });


                        var activity = {
                            user: loggedInDetails._id,
                            name: loggedInDetails.name,
                            stage: "Booking",
                            activity: status,
                        }

                        fun.bookingLog(booking._id, activity);

                        booking.services.forEach(async function (service) {
                            if (service.type == "package") {
                                var package = await Package.findOne({ _id: service.source }).exec();
                                var expired_at = new Date();
                                expired_at.setDate(expired_at.getDate() + package.validity);
                                var check = await UserPackage.find({ package: service.source, category: "free", user: user, car: booking.car }).count().exec();

                                if (check <= 0) {
                                    UserPackage.create({
                                        user: user,
                                        car: booking.car,
                                        name: package.name,
                                        booking: booking._id,
                                        business: booking.business,
                                        description: package.description,
                                        category: package.category,
                                        package: package._id,
                                        payment: {
                                            total: service.cost,
                                            paid_total: service.cost,
                                        },
                                        discount: package.discount,
                                        validity: package.validity,
                                        expired_at: expired_at,
                                        created_at: new Date(),
                                        updated_at: new Date()
                                    });

                                    if (booking.is_services == true) {
                                        Booking.update(
                                            { "_id": booking._id },
                                            { "$pull": { "services": { "source": service.source } } },
                                            function (err, numAffected) {
                                                if (err) {
                                                    /// cconsole.logr);
                                                }
                                            }
                                        );
                                    }
                                }
                            }
                        })

                        if (booking.package) {
                            var packageUsed = [];
                            var package = await UserPackage.findOne({ _id: booking.package, car: booking.car }).exec();
                            if (package) {
                                booking.services.forEach(async function (service) {
                                    package.discount.forEach(async function (dis) {

                                        if (dis.for == "specific") {
                                            if (dis.label == service.service) {
                                                if (dis.discount > 0) {
                                                    packageUsed.push({
                                                        source: service.source,
                                                        package: booking.package,
                                                        car: booking.car,
                                                        user: booking.user,
                                                        booking: booking._id,
                                                        for: service.type,
                                                        label: service.service,
                                                        created_at: new Date(),
                                                        updated_at: new Date()
                                                    });
                                                }
                                            }
                                        }

                                        else if (dis.for == "category") {
                                            if (dis.label == service.type) {
                                                if (dis.discount > 0) {
                                                    packageUsed.forEach(async function (c) {
                                                        if (c.source != service.source) {
                                                            packageUsed.push({
                                                                source: service.source,
                                                                package: booking.package,
                                                                car: booking.car,
                                                                user: booking.user,
                                                                booking: booking._id,
                                                                for: service.type,
                                                                label: service.type,
                                                                created_at: new Date(),
                                                                updated_at: new Date()
                                                            })
                                                        }
                                                    })
                                                }
                                            }
                                        }
                                    });
                                });

                                var packageUsed = _.uniqBy(packageUsed, function (o) {
                                    return o.label;
                                });

                                /// cconsole.logckageUsed)

                                packageUsed.forEach(async function (p) {
                                    var check = await PackageUsed.find({ package: p.package, car: p.car, user: p.user, booking: p.booking, label: p.label }).count().exec();
                                    if (check == 0) {
                                        PackageUsed.create({
                                            package: p.package,
                                            car: p.car,
                                            user: p.user,
                                            booking: p.booking,
                                            for: p.for,
                                            label: p.label,
                                            created_at: p.created_at,
                                            updated_at: p.updated_at
                                        })
                                    }
                                })
                            }
                        }


                        if (booking.payment.careager_cash > 0) {
                            var point = {
                                user: booking.user,
                                activity: "booking",
                                tag: "booking",
                                title: "",
                                body: "",
                                points: booking.payment.careager_cash,
                                status: true
                            }

                            fun.deductPoints(point);
                        }

                        else if (booking.payment.discount_type == "coupon" && booking.payment.discount_total != 0 && booking.payment.discount_total) {
                            var coupon = await Coupon.findOne({ code: booking.payment.coupon }).exec();

                            CouponUsed.create({
                                coupon: coupon._id,
                                code: coupon.code,
                                booking: booking._id,
                                user: user,
                                created_at: new Date(),
                                updated_at: new Date()
                            });
                        }


                        if (booking.is_services == true) {
                            var notify = {
                                receiver: [booking.business],
                                activity: "booking",
                                tag: "newBooking",
                                source: booking._id,
                                sender: user,
                                points: 0
                            }

                            fun.newNotification(notify);
                            event.bookingMail(booking._id);

                            if (booking.advisor) {
                                var advisor = await User.findById(booking.advisor).exec();
                                var notify = {
                                    receiver: [advisor._id],
                                    activity: "booking",
                                    tag: "newBooking",
                                    source: booking._id,
                                    sender: user,
                                    points: 0
                                }

                                fun.newNotification(notify);
                            }

                            res.status(200).json({
                                responseCode: 200,
                                responseMessage: "Service has been booked",
                                responseData: {
                                    booking_no: booking.booking_no,
                                    is_services: booking.is_services
                                }
                            });
                        }
                        else {
                            var notify = {
                                receiver: [booking.business],
                                activity: "package",
                                tag: "newPackage",
                                source: booking._id,
                                sender: user,
                                points: 0
                            }

                            fun.newNotification(notify);
                            event.bookingMail(booking._id);

                            res.status(200).json({
                                responseCode: 200,
                                responseMessage: "Package successfully purchased, Book Services Now for added benefits",
                                responseData: {
                                    booking_no: booking.booking_no,
                                    is_services: booking.is_services
                                }
                            });
                        }
                    }
                });
            }
            else {
                res.status(422).json({
                    responseCode: 422,
                    responseMessage: "'Pay Later' is not applicable for packages.",
                    responseData: {}
                })
            }
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Booking not found",
                responseData: {}
            })
        }
    }
});

router.get('/wallet/get', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    if (req.headers['business']) {
        user = req.headers['business'];
    }
    var points = [];
    var total = 0, used = 0;
    var unused = await User.findOne({ _id: user }).select('careager_cash referral_code').exec();
    await Point.find({ user: user }).sort({ created_at: -1 }).cursor().eachAsync(async (point) => {
        if (point.type == "credit") {
            total = total + point.points;
        }

        if (point.type == "debit") {
            used = used + point.points;
        }

        if (point.tag == "commission") {
            var booking = await Booking.findById(point.source).populate({ path: 'user', populate: { path: 'user', select: "_id id name contact_no" } }).exec();
            if (booking) {
                var booking_no = booking.booking_no;
                if (booking.user) {
                    var name = booking.user.name
                }
                else {
                    var booking_no = "";
                    var name = "";
                }
            }
            else {
                var booking_no = "";
                var name = "";
            }
            var tag = "Commission - " + name + " - #" + booking_no;
        }

        else if (point.tag == "referNEarn") {
            var user = await User.findById(point.source).exec();
            var tag = "Refer & Earn - " + user.name;
        }
        else {
            var tag = _.startCase(point.tag)
        }

        points.push({
            _id: point._id,
            points: Math.ceil(point.points),
            type: point.type,
            tag: tag,
            status: point.status,
            activity: _.startCase(point.activity),
            user: point.user,
            month: moment(point.created_at).tz(req.headers['tz']).format('MMMM YYYY'),
            created_at: moment(point.created_at).tz(req.headers['tz']).format("Do"),
            updated_at: moment(point.updated_at).tz(req.headers['tz']).format("Do")
        });
    });

    var group = _(points).groupBy(x => x.month).map((value, key) => ({ month: key, transaction: value })).value();

    var uu = unused.careager_cash;

    res.status(200).json({
        responseCode: 200,
        responseMessage: "success",
        responseData: {
            total: Math.ceil(total),
            used: Math.ceil(used),
            unused: Math.ceil(uu),
            referral_code: unused.referral_code,
            total_refferal: await Referral.find({ owner: user }).count(),
            list: group
        }
    });
});

router.put('/my/booking/reschedule/', xAccessToken.token, async function (req, res, next) {
    var rules = {
        id: 'required',
        date: 'required',
        time_slot: 'required'
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Error",
            responseData: {
                res: validation.errors.all()
            }
        });
    }
    else {
        if (req.body.package == "") {
            req.body.package = null;
        }

        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var user = req.headers['business'];
        var total = 0;
        var labour_cost = 0;
        var part_cost = 0;
        var bookingService = [];
        var services = req.body.services;
        var loggedInDetails = await User.findById(user).exec();

        var booking = await Booking.findOne({ _id: req.body.id, user: user, is_services: true }).exec();


        if (booking) {
            var d1 = new Date(req.body.date);
            var date = new Date();
            var d2 = new Date(date.getFullYear(), date.getMonth(), date.getDate());
            var seconds = (d1.getTime() - d2.getTime()) / 1000;
            // console.log(seconds)
            if (seconds >= 172800) {
                var status = "Confirmed"
            }
            else {
                var status = "Pending"
            }

            var data = {
                date: new Date(req.body.date).toISOString(),
                time_slot: req.body.time_slot,
                status: status,
                updated_at: new Date()
            };

            Booking.findOneAndUpdate({ _id: booking._id }, { $set: data }, { new: false }, async function (err, doc) {
                if (err) {
                    var json = ({
                        responseCode: 400,
                        responseMessage: "Error occured",
                        responseData: {}
                    });
                    res.status(400).json(json)
                }
                else {
                    if (loggedInDetails.account_info.type == "user") {
                        var notify = {
                            receiver: [booking.business],
                            activity: "booking",
                            tag: "bookingReschedule",
                            source: booking._id,
                            sender: user,
                            points: 0,
                            tz: req.headers['tz']
                        };
                        fun.newNotification(notify);
                        var activity = {
                            user: loggedInDetails._id,
                            name: loggedInDetails.name,
                            stage: "Booking",
                            activity: "BookingReschedule",
                        };

                        fun.bookingLog(booking._id, activity);
                    }
                    else {
                        var notify = {
                            receiver: [booking.user],
                            activity: "booking",
                            tag: "bookingReschedule",
                            source: booking._id,
                            sender: user,
                            points: 0,
                            tz: req.headers['tz']
                        };
                        fun.newNotification(notify);

                        var activity = {
                            user: loggedInDetails._id,
                            name: loggedInDetails.name,
                            stage: "Booking",
                            activity: "BookingReschedule",
                        };

                        fun.bookingLog(booking._id, activity);
                    }

                    event.rescheduleMail(booking._id, loggedInDetails.account_info.type);

                    var activity = {
                        user: user,
                        model: "Booking",
                        activity: "bookingReschedule",
                        source: booking._id,
                        modified: moment(booking.date).tz(req.headers['tz']).format('ll') + " (" + booking.time_slot + ")" + " to " + moment(data.date).tz(req.headers['tz']).format('ll') + " (" + data.time_slot + ")",
                        created_at: data.updated_at,
                        updated_at: data.updated_at
                    }
                    fun.bookingLog(activity);

                    var json = ({
                        responseCode: 200,
                        responseMessage: "Booking rescheduled",
                        responseData: {
                            date: moment(data.date).tz(req.headers['tz']).format('ll'),
                            time_slot: data.time_slot,
                            updated_at: data.updated_at
                        }
                    });
                    res.status(200).json(json)
                }
            });
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Unauthorized",
                responseData: {},
            });
        }
    }
});

router.put('/my/booking/status', xAccessToken.token, async function (req, res, next) {
    var rules = {
        id: 'required',
        status: 'required',
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Error",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);
        var user = req.headers['business'];
        if (req.body.status == "Cancelled" || req.body.status == "Confirmed") {
            var check = await Booking.findOne({ _id: req.body.id, user: user, is_services: true }).exec();
        }

        var getUser = await User.findById(user).exec();

        if (!check) {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Unauthorized",
                responseData: {},
            });
        }
        else {
            var status = check.status;
            var data = {
                status: req.body.status,
                updated_at: new Date()
            };

            Booking.findOneAndUpdate({ _id: req.body.id }, { $set: data }, { new: true }, async function (err, doc) {
                if (err) {
                    var json = ({
                        responseCode: 422,
                        responseMessage: "Error occured",
                        responseData: {}
                    });

                    res.status(422).json(json)
                }
                else {
                    var booking = await Booking.findOne({ _id: check._id }).exec();
                    var activity = {
                        user: user,
                        model: "Booking",
                        activity: "updateBookingStatus",
                        source: booking._id,
                        modified: check.status + " to " + data.status,
                        created_at: data.updated_at,
                        updated_at: data.updated_at
                    };

                    fun.bookingLog(activity);

                    event.zohoLead(booking._id);

                    if (booking.payment.careager_cash > 0) {
                        var point = {
                            status: true,
                            user: user,
                            activity: "coin",
                            tag: "BookingCancelled",
                            points: booking.payment.careager_cash,
                            source: booking._id,
                            title: "",
                            body: "",
                            sender: null
                        };
                        fun.addPoints(point)
                    }


                    if (booking.package) {
                        var package = await UserPackage.findOne({ _id: booking.package, user: user, car: booking.car }).exec();
                        if (package) {
                            var checkPackageUsed = await PackageUsed.find({ package: booking.package, user: user, booking: booking._id, car: booking.car }).count().exec();

                            if (checkPackageUsed > 0) {
                                await PackageUsed.remove({ package: booking.package, user: user, booking: booking._id, car: booking.car }).exec();
                            }
                        }
                    }

                    if (booking.payment.coupon) {
                        var checkCouponUsed = await CouponUsed.find({ user: user, booking: booking._id }).count().exec();
                        if (checkCouponUsed > 0) {
                            await CouponUsed.remove({ user: user, booking: booking._id }).exec();
                        }
                    }

                    Booking.findOneAndUpdate({ _id: req.body.id }, { $set: { due: { due: 0 } } }, { new: true }, async function (err, doc) { })

                    var notify = {
                        receiver: [booking.advisor],
                        activity: "booking",
                        tag: "userCancelledBooking",
                        source: booking._id,
                        sender: user,
                        points: 0
                    }

                    fun.newNotification(notify);

                    if (booking.converted) {
                        if (booking.manager) {
                            var notify = {
                                receiver: [booking.manager],
                                activity: "booking",
                                tag: "userCancelledBooking",
                                source: booking._id,
                                sender: user,
                                points: 0
                            }
                            fun.newNotification(notify);
                        }
                    }
                }

                event.zohoLead(booking._id);

                var json = ({
                    responseCode: 200,
                    responseMessage: "Booking has been " + booking.status,
                    responseData: {}
                });
                res.status(200).json(json)
            });
        }
    };
});

router.get('/my/bookings/get', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    var user = req.headers['business'];
    var orders = [];

    var country = await Country.findOne({ timezone: { $in: req.headers['tz'] } }).exec();

    if (req.query.page == undefined) {
        var page = 0;
    }
    else {
        var page = req.query.page;
    }

    var page = Math.max(0, parseInt(page));

    var sortBy = new Object();

    if (req.query.sortBy) {
        if (req.query.sortBy == "date") {
            sortBy = { date: -1 }
        }
    }
    else {
        sortBy = { created_at: -1 }
    }

    var thumbnail = []

    await Booking.find({ 'user': user, status: { $in: ["Cancelled", "Confirmed", "Pending", "Rejected", "Closed", "Completed", "Failure", "In-Process", "Dissatisfied", "Approval", "Approved", "Failed", "JobInitiated", "JobOpen", "EstimateRequested", "ApprovalAwaited", "StartWork", "CloseWork", "CompleteWork", "QC", "StoreApproval", "GMApproval", "Rework", "Ready"] }, is_services: true })
        .populate({ path: 'business', populate: { path: 'user', select: "_id id name contact_no" } })
        .populate({ path: 'car', select: '_id id title registration_no ic rc', populate: { path: 'thumbnails' } })
        .sort(sortBy).skip(config.perPage * page).limit(config.perPage)
        .cursor().eachAsync(async (booking) => {

            var car = null;
            var address = await Address.findOne({ _id: booking.address }).exec();
            if (booking.car) {
                var thumbnail = []
                if (booking.car.thumbnails[0]) {
                    var thumbnail = [booking.car.thumbnails[0]];
                }

                car = {
                    title: booking.car.title,
                    _id: booking.car._id,
                    id: booking.car.id,
                    ic: booking.car.ic,
                    rc: booking.car.rc,
                    ic_address: booking.car.ic_address,
                    rc_address: booking.car.rc_address,
                    registration_no: booking.car.registration_no,
                    thumbnails: thumbnail
                };
            }

            orders.push({
                _id: booking._id,
                id: booking._id,
                car: car,
                business: {
                    name: booking.business.name,
                    _id: booking.business._id,
                    id: booking.business.id,
                    contact_no: booking.business.contact_no
                },
                services: booking.services,
                convenience: booking.convenience,
                date: moment(booking.date).tz(req.headers['tz']).format('ll'),
                time_slot: booking.time_slot,
                status: booking.status,
                booking_no: booking.booking_no,
                job_no: booking.job_no,
                payment: booking.payment,
                due: booking.due,
                address: address,
                txnid: booking.txnid,
                __v: booking.__v,
                address: address,
                created_at: booking.updated_at,
                updated_at: booking.updated_at,
                listing: "booking",
            });

        });

    res.status(200).json({
        responseCode: 200,
        responseMessage: country.countryName,
        responseData: orders,
        responseInfo: {
            totalResult: await Booking.find({ 'user': user, status: { $in: ["Cancelled", "Confirmed", "Pending", "Rejected", "Closed", "Completed", "Failure", "In-Process", "Dissatisfied", "Approval", "Approved", "Failed", "JobInitiated", "JobOpen", "EstimatePrepared", "ApprovalAwaited", "StartWork", "CloseWork", "CompleteWork", "QC", "StoreApproval", "GMApproval", "Rework", "Ready"] }, is_services: true }).count().exec()
        }
    });
});

router.post('/car/add', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);


    var business = req.headers['business'];

    var limit = await q.all(businessPlanLimit(business, req.headers['tz']));


    var added = await Car.find({ user: business, status: true }).count().exec();
    if (limit) {
        if (limit.cars > added) {
            var result = new Object();
            var userInfo = await User.findById(business).exec();
            var currentDate = new Date();
            var variant = await Variant.findOne({ _id: req.body.variant }).populate('model').select('-service_schedule').exec();
            var rg = req.body.registration_no;
            req.body.registration_no = rg.replace(/ /g, '');

            if (variant != null && variant) {
                var reg = await Car.find({ registration_no: req.body.registration_no, status: true }).count().exec();
                if (reg == 0) {
                    var count = await Car.find({}).count().exec();

                    if (req.body.longitude != undefined || req.body.longitude != null && req.body.latitude != undefined || req.body.latitude != null) {
                        req.body.geometry = [req.body.longitude, req.body.latitude];
                    }
                    else {
                        req.body.geometry = [0, 0];
                    }


                    var automaker = await Automaker.findById(variant.model.automaker).exec();

                    req.body.created_at = currentDate;
                    req.body.updated_at = currentDate;

                    req.body.title = variant.variant;
                    req.body._variant = variant.value;
                    req.body.automaker = variant.model.automaker;
                    req.body._automaker = automaker.maker;
                    req.body.model = variant.model._id;
                    req.body._model = variant.model.value;
                    req.body.segment = variant.model.segment;
                    req.body.user = business;
                    req.body.fuel_type = variant.specification.fuel_type;
                    req.body.transmission = variant.specification.type;
                    req.body.carId = Math.round(+new Date() / 1000) + Math.round((Math.random() * 9999) + 1),

                        Car.create(req.body).then(async function (car) {
                            User.findOneAndUpdate({ _id: business }, {
                                $push: {
                                    "cars": car._id
                                }
                            }, { new: true }, async function (err, doc) {
                                if (err) {
                                    // console.log(err)
                                }
                                else {
                                    // console.log(err)
                                }
                            })

                            //fun.addMember(b,variant.model);

                            await Car.find({ _id: car._id })
                                .populate('bookmark')
                                .populate('thumbnails')
                                .populate({ path: 'user', select: 'name username avatar avatar_address address' })
                                .populate({ path: 'variant', populate: { path: 'model' } })
                                .cursor().eachAsync(async (doc) => {
                                    result = {
                                        __v: 0,
                                        _id: doc._id,
                                        id: doc.id,
                                        title: doc.title,
                                        variant: doc.variant._id,
                                        model: doc.model,
                                        modelName: doc.variant.model.model,
                                        price: price(doc.price),
                                        numericPrice: doc.price,
                                        accidental: doc.accidental,
                                        body_style: doc.body_style,
                                        description: doc.description,
                                        driven: doc.driven,
                                        carId: doc.carId,
                                        fuel_type: doc.fuel_type,
                                        insurance_info: doc.insurance_info,
                                        location: doc.location,
                                        manufacture_year: doc.manufacture_year,
                                        mileage: doc.mileage,
                                        owner: doc.owner,
                                        registration_no: doc.registration_no,
                                        service_history: doc.service_history,
                                        transmission: doc.transmission,
                                        vehicle_color: doc.vehicle_color,
                                        vehicle_status: doc.vehicle_status,
                                        geometry: doc.geometry,
                                        publish: doc.publish,
                                        status: doc.status,
                                        premium: doc.premium,
                                        is_bookmarked: doc.is_bookmarked,
                                        thumbnails: doc.thumbnails,
                                        user: doc.user,
                                        created_at: doc.created_at,
                                        updated_at: doc.updated_at
                                    }
                                });

                            res.status(200).json({
                                responseCode: 200,
                                responseMessage: "Car has been added",
                                responseData: {
                                    item: result
                                }
                            });
                        });
                }
                else {
                    res.status(422).json({
                        responseCode: 422,
                        responseMessage: "Registration no already exist",
                        responseData: {}
                    });
                }
            }
            else {
                res.status(400).json({
                    responseCode: 400,
                    responseMessage: "Unprocessable Entity",
                    responseData: {}
                });
            }
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Limit Exceed!",
                responseData: {}
            });
        }
    }
    else {
        res.status(400).json({
            responseCode: 400,
            responseMessage: "Plan expired",
            responseData: {}
        });
    }
});

router.put('/car/edit', xAccessToken.token, async function (req, res, next) {
    var rules = {
        car: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Car is required",
            responseData: {}
        })
    }
    else {
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);

        var user = req.headers['business'];
        var result;

        var loggedInDetails = await User.findOne({ _id: decoded.user }).exec();
        var car = await Car.findOne({ _id: req.body.car, user: user }).populate('user').exec();
        var variant = await Variant.findOne({ _id: req.body.variant }).populate('model').select('-service_schedule').exec();
        if (car) {
            var rg = req.body.registration_no;
            req.body.registration_no = rg.replace(/ /g, '');

            var check_rn = await Car.findOne({ _id: { $ne: car._id }, registration_no: req.body.registration_no, status: true }).exec();

            if (check_rn) {
                res.status(400).json({
                    responseCode: 400,
                    responseMessage: "Car registration no already exist",
                    responseData: {}
                });
            }
            else {
                if (variant) {
                    var automaker = await Automaker.findById(variant.model.automaker).exec();

                    var publish = false;
                    if (req.body.publish == true) {
                        publish = true;

                    }

                    if (car.user.partner) {
                        if (car.user.partner.partner == true) {
                            req.body.is_package == true
                        }
                    }

                    var package = null;

                    if (publish == true) {
                        if (req.body.is_package == true) {
                            var getpackage = await Package.findOne({ name: "#CarEagerClub Membership" }).exec();
                            package = getpackage._id;
                        }
                    }

                    if (variant.specification.type) {
                        req.body.transmission = variant.specification.type
                    }

                    req.body.geometry = [req.body.longitude, req.body.latitude];
                    req.body.automaker = variant.model.automaker;
                    req.body._automaker = automaker.maker;
                    req.body.model = variant.model.id;
                    req.body._model = variant.model.value;
                    req.body.title = variant.variant;
                    req.body._variant = variant.value;
                    req.body.fuel_type = variant.specification.fuel_type;
                    req.body.package = package;
                    req.body.posted_by = "business";
                    req.body.updated_at = new Date();

                    Car.findOneAndUpdate({ _id: req.body.car, user: user }, { $set: req.body }, { new: false }, async function (err, s) {
                        if (err) {
                            res.status(400).json({
                                responseCode: 400,
                                responseMessage: "Error occured",
                                responseData: err
                            });
                        }
                        else {
                            if (publish == true) {
                                var log = {
                                    user: loggedInDetails._id,
                                    name: loggedInDetails.name,
                                    status: "Published",
                                    remark: "",
                                    updated_at: new Date(),
                                    created_at: new Date(),
                                };

                                var sell = await CarSell.findOne({ car: car._id, sold: false }).exec();
                                if (sell) {
                                    CarSell.findOneAndUpdate({ car: car._id, sold: false }, {
                                        $set: {
                                            otp: Math.floor(Math.random() * 90000) + 10000,
                                            user_verified: true,
                                            admin_verified: false,
                                        }
                                    }, { new: false }, async function (err, doc) {
                                        if (err) {
                                            // console.log(err)
                                        }
                                        else {
                                            event.sellerApproval(sell._id, req.headers['tz'])
                                        }
                                    })
                                }
                                else {
                                    CarSell.create({
                                        car: car._id,
                                        seller: car.user,
                                        owner: car.user,
                                        buyer: null,
                                        otp: Math.floor(Math.random() * 90000) + 10000,
                                        user_verified: true,
                                        admin_verified: false,
                                        created_at: new Date(),
                                        updated_at: new Date(),
                                    }).then(function (d) {
                                        event.sellerApproval(d._id, req.headers['tz'])
                                    });
                                }
                            }

                            fun.addMember(user, variant.model);

                            await Car.findOne({ _id: req.body.car })
                                .populate('bookmark')
                                .populate('thumbnails')
                                .populate({ path: 'user', select: 'name username avatar avatar_address address' })
                                .populate({ path: 'variant', populate: { path: 'model' } })
                                .cursor().eachAsync(async (doc) => {
                                    result = {
                                        __v: 0,
                                        _id: doc._id,
                                        id: doc.id,
                                        title: doc.title,
                                        variant: doc.variant._id,
                                        model: doc.model,
                                        modelName: doc.variant.model.model,
                                        price: price(doc.price),
                                        numericPrice: doc.price,
                                        accidental: doc.accidental,
                                        body_style: doc.body_style,
                                        description: doc.description,
                                        driven: doc.driven,
                                        carId: doc.carId,
                                        odometer: doc.odometer,
                                        fuel_type: doc.fuel_type,
                                        insurance_info: doc.insurance_info,
                                        location: doc.location,
                                        manufacture_year: doc.manufacture_year,
                                        mileage: doc.mileage,
                                        owner: doc.owner,
                                        registration_no: doc.registration_no,
                                        service_history: doc.service_history,
                                        transmission: doc.transmission,
                                        vehicle_color: doc.vehicle_color,
                                        vehicle_status: doc.vehicle_status,
                                        geometry: doc.geometry,
                                        link: "/car/" + slugify(doc.title + " " + doc._id),
                                        publish: doc.publish,
                                        status: doc.status,
                                        premium: doc.premium,
                                        is_bookmarked: doc.is_bookmarked,
                                        thumbnails: doc.thumbnails,
                                        user: doc.user,
                                        created_at: doc.created_at,
                                        updated_at: doc.updated_at
                                    }
                                });

                            var responseMessage = "Successfully updated";

                            if (publish == true) {
                                responseMessage = "Car has been sent to admin for approval";
                            }

                            res.status(200).json({
                                responseCode: 200,
                                responseMessage: responseMessage,
                                responseData: {
                                    item: result
                                }
                            });
                        }
                    });
                }
                else {
                    res.status(400).json({
                        responseCode: 400,
                        responseMessage: "Unprocessable Entity",
                        responseData: {}
                    });
                }
            }
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Car not found",
                responseData: {}
            });
        }
    }
});

router.delete('/car/delete', xAccessToken.token, async function (req, res, next) {
    var rules = {
        car: "required",
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Car is required",
            responseData: {
                res: validation.errors.all()
            }
        })
    }
    else {
        var token = req.headers['x-access-token'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);

        var user = req.headers['business'];

        var car = await Car.findOne({ _id: req.body.car, user: user }).populate('user').exec();
        if (car) {
            var data = {
                status: false,
                updated_at: new Date()
            }

            Car.findOneAndUpdate({ _id: req.body.car, user: user }, { $set: data }, { new: false }, async function (err, s) {
                if (err) {
                    res.status(400).json({
                        responseCode: 400,
                        responseMessage: "Error occured",
                        responseData: err
                    });
                }
                else {
                    var cars = [];
                    await Car.find({ user: user, status: true })
                        .cursor().eachAsync(async (car) => {
                            cars.push(mongoose.Types.ObjectId(car._id))
                        });

                    var newvalues = {
                        $set: { cars: cars }
                    }

                    User.findOneAndUpdate({ _id: user }, newvalues, { new: false }, async function (err, s) {
                        if (err) {
                            res.status(400).json({
                                responseCode: 400,
                                responseMessage: "Error occured",
                                responseData: err
                            });
                        }
                        else {
                            res.status(200).json({
                                responseCode: 200,
                                responseMessage: "Car has been deleted",
                                responseData: {}
                            });
                        }
                    });
                }
            });
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Unauthorized",
                responseData: {}
            });
        }
    }
});

router.post('/car/publish', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var business = req.headers['business'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);


    var published = await Car.find({ user: business, publish: true }).count().exec();

    var car = await Car.findById(req.body.car).populate('user').exec();
    var business = req.headers['business'];
    var limit = await q.all(businessPlanLimit(business, req.headers['tz']));
    if (limit.car_publish > published) {
        if (car) {
            if (loggedInDetails) {
                var check_listing = await CarSell.findOne({ car: car._id, buyer: null, sold: false }).exec();
                if (check_listing) {
                    if (!check_listing.seller.equals(check_listing.owner)) {
                        event.otp(car.user.contact_no, check_listing.otp);

                        res.status(200).json({
                            responseCode: 200,
                            responseMessage: "OTP has been sent to owner. Kindly Verify it.",
                            responseData: {
                                sell: check_listing._id
                            }
                        })
                    }
                    else {
                        res.status(200).json({
                            responseCode: 200,
                            responseMessage: "Admin approval pending",
                            responseData: {
                                sell: null
                            }
                        })
                    }
                }
                else {
                    var log = {
                        user: loggedInDetails._id,
                        name: loggedInDetails.name,
                        status: "Published",
                        remark: "",
                        updated_at: new Date(),
                        created_at: new Date(),
                    };

                    var user_verified = false;

                    if (loggedInDetails._id.equals(car.user._id)) {
                        user_verified = true;
                    }

                    CarSell.create({
                        car: car._id,
                        seller: business,
                        owner: car.user._id,
                        buyer: null,
                        otp: Math.floor(Math.random() * 90000) + 10000,
                        user_verified: user_verified,
                        admin_verified: false,
                        logs: log,
                        created_at: new Date(),
                        updated_at: new Date(),
                    })
                        .then(async function (sell) {
                            var variant = await Variant.findOne({ _id: car.variant }).populate('model').select('-service_schedule').exec();
                            var automaker = await Automaker.findById(variant.model.automaker).exec();

                            Car.findOneAndUpdate({ _id: car._id }, {
                                $set: {
                                    posted_by: "business",
                                    user: sell.seller,
                                    variant: variant._id,
                                    _variant: variant.value,
                                    model: variant.model._id,
                                    _model: variant.model.value,
                                    automaker: variant.model.automaker,
                                    _automaker: automaker.maker,
                                    title: variant.variant,
                                    publish: false,
                                    updated_at: new Date()
                                }
                            }, { new: false }, function (err, doc) {
                                if (err) {
                                    res.status(400).json({
                                        responseCode: 400,
                                        responseMessage: "Server Error",
                                        responseData: err
                                    })
                                }
                                else {
                                    if (user_verified == false) {
                                        event.otp(car.user.contact_no, check_listing.otp);
                                        res.status(200).json({
                                            responseCode: 200,
                                            responseMessage: "OTP has been sent to owner. Kindly Verify it.",
                                            responseData: {
                                                sell: sell._id
                                            }
                                        })
                                    }
                                    else {
                                        res.status(200).json({
                                            responseCode: 200,
                                            responseMessage: "Admin approval pending",
                                            responseData: {
                                                sell: null
                                            }
                                        })
                                    }

                                }
                            });
                        });
                }
            }
            else {
                res.status(400).json({
                    responseCode: 400,
                    responseMessage: "Seller not found",
                    responseData: {}
                })
            }
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Unauthorized",
                responseData: {}
            })
        }
    }
    else {
        res.status(400).json({
            responseCode: 400,
            responseMessage: "Limit Exceed",
            responseData: {}
        })
    }
});

router.post('/car/sell/verification', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    var loggedInDetails = await User.findById(decoded.user).exec();
    var sell = await CarSell.findOne({ _id: req.body.sell, otp: req.body.otp, buyer: null, sold: false }).exec();

    var validation = false;
    if (sell) {
        var car = await Car.findById(sell.car).exec();
        if (car) {
            var data = {
                user_verified: true,
                admin_verified: false,
                updated_at: new Date()
            }

            CarSell.findOneAndUpdate({ _id: req.body.sell }, { $set: data }, { new: false }, async function (err, doc) {
                if (err) {
                    res.status(400).json({
                        responseCode: 400,
                        responseMessage: "Server Error",
                        responseData: err
                    })
                }
                else {
                    CarSell.findOneAndUpdate({ _id: req.body.sell }, {
                        $push: {
                            user: loggedInDetails._id,
                            name: loggedInDetails.name,
                            status: "SellerVerfied",
                            remark: "",
                            created_at: new Date(),
                            updated_at: new Date()
                        }
                    }, { new: false }, async function (err, doc) {
                        if (err) {
                            res.status(400).json({
                                responseCode: 400,
                                responseMessage: "Error Occured",
                                responseData: err
                            });
                        }
                        else {
                            Car.findOneAndUpdate({ _id: car._id }, {
                                $set: {
                                    publish: true,
                                    updated_at: new Date()
                                }
                            }, { new: false }, function (err, doc) {
                                if (err) {
                                    res.status(400).json({
                                        responseCode: 400,
                                        responseMessage: "Server Error",
                                        responseData: err
                                    })
                                }
                                else {
                                    res.status(200).json({
                                        responseCode: 200,
                                        responseMessage: "Admin approval pending",
                                        responseData: {}
                                    })
                                }
                            });
                        }
                    });
                }
            });
        }
        else {
            return res.status(400).json({
                responseCode: 400,
                responseMessage: "Car not found",
                responseData: {}
            })
        }
    }
    else {
        return res.status(400).json({
            responseCode: 400,
            responseMessage: "Listing not found",
            responseData: {}
        })
    }
});

router.get('/sold/cars/get', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var business = req.headers['business'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var result = [];
    if (req.query.page == undefined) {
        var page = 0;
    } else {
        var page = req.query.page;
    }
    var page = Math.max(0, parseInt(page));

    await CarSell.find({ seller: business })
        .populate({ path: 'car' })
        .populate({ path: 'seller', select: 'name username avatar avatar_address address contact_no email ' })
        .populate({ path: 'buyer', select: 'name username avatar avatar_address address contact_no email ' })
        .populate({ path: 'owner', select: 'name username avatar avatar_address address contact_no email' })
        .skip(25 * page).limit(25)
        .cursor().eachAsync(async (p) => {
            var buyer = null
            if (p.buyer) {
                buyer = {
                    _id: p.buyer._id,
                    id: p.buyer._id,
                    name: p.buyer.name,
                    contact_no: p.buyer.contact_no,
                    email: p.buyer.email,
                }
            }

            var refurbishment_cost = 0
            if (parseFloat(p.refurbishment_cost) > 0) {
                refurbishment_cost = parseFloat(p.refurbishment_cost)
            }
            var purchase_price = 0
            if (p.purchase_price > 0) {
                purchase_price = p.purchase_price
            }

            var price = 0
            if (p.price > 0) {
                price = p.price
            }


            var revenue = 0;
            if (p.sold) {
                revenue = (parseFloat(purchase_price) + parseFloat(refurbishment_cost) + parseFloat(p.package_cost)) - price
            }



            result.push({
                _id: p._id,
                id: p._id,
                car: {
                    _id: p.car._id,
                    id: p.car._id,
                    title: p.car.title,
                    _automaker: p.car._automaker,
                    _model: p.car._model,
                    registration_no: p.car.registration_no,
                },
                owner: {
                    _id: p.owner._id,
                    id: p.owner._id,
                    name: p.owner.name,
                    contact_no: p.owner.contact_no,
                    email: p.owner.email,
                },
                seller: {
                    _id: p.seller._id,
                    id: p.seller._id,
                    name: p.seller.name,
                    contact_no: p.seller.contact_no,
                    email: p.seller.email,
                },
                buyer: buyer,
                logs: p.logs,
                price: price,
                purchase_price: purchase_price,
                refurbishment_cost: parseFloat(refurbishment_cost),
                package_cost: p.package_cost,
                revenue: revenue,
                sold: p.sold,
                package_sold: p.package_sold,
                user_verified: p.user_verified,
                buyer_verified: p.buyer_verified,
                admin_verified: p.admin_verified,
                created_at: moment(p.created_at).tz(req.headers['tz']).format('LLL'),
                updated_at: moment(p.updated_at).tz(req.headers['tz']).format('LLL'),
            });
        });


    res.status(200).json({
        responseCode: 200,
        responseMessage: "",
        responseData: result
    })
});

router.post('/car/sold/', xAccessToken.token, async function (req, res, next) {
    var rules = {
        car: "required",
        price: "required"
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Car and Sold Price is required",
            responseData: {}
        })
    }
    else {
        var token = req.headers['x-access-token'];
        var business = req.headers['business'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);

        var loggedInDetails = await User.findById(decoded.user).exec();
        var sell = await CarSell.findOne({ car: req.body.car, sold: false, seller: business }).exec();

        if (sell) {
            var logs = sell.logs;
            var car = await Car.findById(sell.car).exec();
            if (car) {
                var buyer = await User.findById(req.body.buyer).exec();
                if (buyer) {
                    var otp = Math.floor(Math.random() * 90000) + 10000;
                    logs.push({
                        user: loggedInDetails._id,
                        name: loggedInDetails.name,
                        status: "BuyerAdded",
                        remark: "",
                        created_at: new Date(),
                        updated_at: new Date()
                    });

                    var data = {
                        buyer_otp: otp,
                        buyer: buyer._id,
                        logs: logs,
                        price: req.body.price,
                        purchase_price: car.purchase_price,
                        refurbishment_cost: car.refurbishment_cost,
                        user_verified: true,
                        admin_verified: true,
                        buyer_verified: false,
                        updated_at: new Date()
                    };

                    CarSell.findOneAndUpdate({ _id: sell._id }, { $set: data }, { new: false }, async function (err, doc) {
                        if (err) {
                            res.status(400).json({
                                responseCode: 400,
                                responseMessage: "Server Error",
                                responseData: err
                            });
                        }
                        else {
                            event.otp(buyer.contact_no, otp);
                            Car.findOneAndUpdate({ _id: car._id }, {
                                $set: {
                                    price: req.body.price,
                                    publish: true,
                                    admin_approved: true,
                                    updated_at: new Date()
                                }
                            }, { new: false }, function (err, doc) {
                                if (err) {
                                    res.status(400).json({
                                        responseCode: 400,
                                        responseMessage: "Server Error",
                                        responseData: err
                                    })
                                }
                                else {
                                    res.status(200).json({
                                        responseCode: 200,
                                        responseMessage: "OTP Sent to Buyer",
                                        responseData: {}
                                    })
                                }
                            });

                        }
                    });
                }
                else {
                    return res.status(400).json({
                        responseCode: 400,
                        responseMessage: "Buyer not found",
                        responseData: {}
                    })
                }
            }
            else {
                return res.status(400).json({
                    responseCode: 400,
                    responseMessage: "Car not found",
                    responseData: {}
                })
            }
        }
        else {
            return res.status(400).json({
                responseCode: 400,
                responseMessage: "Listing not found",
                responseData: {}
            })
        }
    }
});

router.post('/car/buyer/verification', xAccessToken.token, async function (req, res, next) {
    var rules = {
        car: "required",
        otp: "required"
    };

    var validation = new Validator(req.body, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Car and OTP is required",
            responseData: { /*res: validation.errors.all()*/ }
        })
    }
    else {
        var token = req.headers['x-access-token'];
        var business = req.headers['business'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);

        var loggedInDetails = await User.findById(decoded.user).exec();
        var sell = await CarSell.findOne({ car: req.body.car, sold: false, seller: business }).populate('seller').populate('buyer').populate('car').exec();

        if (sell) {
            var logs = sell.logs;

            if (sell.buyer_otp == req.body.otp) {
                logs.push({
                    user: loggedInDetails._id,
                    name: loggedInDetails.name,
                    status: "BuyerVerified",
                    remark: "",
                    created_at: new Date(),
                    updated_at: new Date()
                });

                var data = {
                    buyer_otp: null,
                    logs: logs,
                    buyer_verified: true,
                    sold: true,
                    updated_at: new Date()
                };

                CarSell.findOneAndUpdate({ _id: sell._id }, { $set: data }, { new: false }, async function (err, doc) {
                    if (err) {
                        res.status(400).json({
                            responseCode: 400,
                            responseMessage: "Server Error",
                            responseData: err
                        });
                    }
                    else {

                        Car.findOneAndUpdate({ _id: sell.car._id }, {
                            $set: {
                                user: sell.buyer,
                                publish: false,
                                admin_approved: false,
                                updated_at: new Date()
                            }
                        }, { new: false }, async function (err, doc) {
                            if (err) {
                                res.status(400).json({
                                    responseCode: 400,
                                    responseMessage: "Server Error",
                                    responseData: err
                                });
                            }
                            else {
                                var updated = await CarSell.findById(sell._id).populate('car').exec();

                                var owner = sell.seller.referral_code;

                                var checkReferral = await Referral.find({ user: sell.buyer._id }).count().exec();
                                if (checkReferral == 0) {
                                    Referral.create({
                                        code: sell.seller.referral_code,
                                        owner: sell.seller._id,
                                        user: sell.buyer._id,
                                        created_at: new Date(),
                                        updated_at: new Date()
                                    });
                                }

                                res.status(200).json({
                                    responseCode: 200,
                                    responseMessage: "Car has been sold successfully",
                                    responseData: updated
                                })
                            }
                        });

                    }
                });
            }
            else {
                return res.status(400).json({
                    responseCode: 400,
                    responseMessage: "OTP not match",
                    responseData: {}
                })
            }
        }
        else {
            return res.status(400).json({
                responseCode: 400,
                responseMessage: "Listing not found",
                responseData: {}
            })
        }
    }
});

router.get('/sell/car/package/checksum', xAccessToken.token, async function (req, res, next) {
    var rules = {
        sell: "required"
    };

    var validation = new Validator(req.query, rules);

    if (validation.fails()) {
        res.status(422).json({
            responseCode: 422,
            responseMessage: "Car  is required",
            responseData: {}
        })
    }
    else {
        var token = req.headers['x-access-token'];
        var business = req.headers['business'];
        var secret = config.secret;
        var decoded = jwt.verify(token, secret);

        var loggedInDetails = await User.findById(decoded.user).exec();
        var sell = await CarSell.findOne({ _id: req.query.sell, seller: business }).populate('seller').populate('car').exec();

        if (sell) {
            if (sell.car.package) {
                var discount = 0;
                if (sell.seller.partner) {
                    if (sell.seller.partner.partner == true) {
                        discount = sell.seller.partner.package_discount
                    }
                }
                var package = await Package.findById(sell.car.package).exec();
                var data = {
                    package: package._id,
                    package_cost: package.cost - discount,
                };

                CarSell.findOneAndUpdate({ _id: sell._id }, { $set: data }, { new: false }, async function (err, doc) {
                    if (err) {
                        res.status(422).json({
                            responseCode: 422,
                            responseMessage: "failure",
                            responseData: err
                        });
                    }
                    else {
                        var paramarray = {
                            MID: paytm_config.MID,
                            ORDER_ID: sell._id.toString(),
                            CUST_ID: sell.seller._id.toString(),
                            INDUSTRY_TYPE_ID: paytm_config.INDUSTRY_TYPE_ID,
                            CHANNEL_ID: "WAP",
                            TXN_AMOUNT: data.package_cost.toString(),
                            WEBSITE: paytm_config.WEBSITE,
                            CALLBACK_URL: paytm_config.CALLBACK + 'theia/paytmCallback?ORDER_ID=' + sell._id.toString(),
                            EMAIL: sell.seller.email,
                            MOBILE_NO: sell.seller.contact_no
                        };

                        paytm_checksum.genchecksum(paramarray, paytm_config.MERCHANT_KEY, function (err, data) {
                            if (err) {
                                res.status(422).json({
                                    responseCode: 422,
                                    responseMessage: "failure",
                                    responseData: err
                                });
                            }
                            else {
                                res.status(200).json({
                                    responseCode: 200,
                                    responseMessage: "Checksum generated",
                                    responseData: data
                                });
                            }
                        });
                    }
                });
            }
            else {
                return res.status(400).json({
                    responseCode: 400,
                    responseMessage: "Package not found",
                    responseData: {}
                })
            }
        }
        else {
            return res.status(400).json({
                responseCode: 400,
                responseMessage: "Listing not found",
                responseData: {}
            })
        }
    }
});

router.get('/sell/car/package/transaction/', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var business = req.headers['business'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var paramarray = new Object();
    var discount = 0;
    var sell = await CarSell.findOne({ _id: req.query.id, seller: business }).populate('seller').exec();
    var getUser = await User.findById(user).exec();
    if (sell) {
        var package = await Package.findOne({ _id: sell.package }).exec();

        var paramarray = {
            MID: paytm_config.MID,
            ORDER_ID: sell._id.toString(),
            CUST_ID: sell.seller._id.toString(),
            INDUSTRY_TYPE_ID: paytm_config.INDUSTRY_TYPE_ID,
            CHANNEL_ID: "WAP",
            TXN_AMOUNT: sell.package_cost.toString(),
            WEBSITE: paytm_config.WEBSITE,
            CALLBACK_URL: paytm_config.CALLBACK + 'theia/paytmCallback?ORDER_ID=' + sell._id.toString(),
            EMAIL: sell.seller.email,
            MOBILE_NO: sell.seller.contact_no
        };


        paytm_checksum.genchecksum(paramarray, paytm_config.MERCHANT_KEY, async function (err, result) {
            result["CHECKSUMHASH"] = encodeURIComponent(result["CHECKSUMHASH"]);
            var finalstring = "JsonData=" + JSON.stringify(result);
            request.post({ url: paytm_config.CALLBACK + 'merchant-status/getTxnStatus?' + finalstring }, async function (error, httpResponse, body) {
                if (error) {
                    res.status(422).json({
                        responseCode: 422,
                        responseMessage: "failure",
                        responseData: err
                    });
                }
                else {
                    var paytmRes = JSON.parse(body);
                    if (paytmRes.STATUS == "TXN_SUCCESS") {

                        CarSell.findOneAndUpdate({ _id: sell._id }, { $set: { package_sold: true } }, { new: false }, async function (err, doc) {
                            if (err) {
                                res.status(422).json({
                                    responseCode: 422,
                                    responseMessage: "Error Occurred",
                                    responseData: err
                                })
                            }
                            else {


                                var expired_at = new Date();
                                expired_at.setDate(expired_at.getDate() + package.validity);
                                var check = await UserPackage.find({ package: sell.package, category: "free", user: sell.buyer, car: sell.car }).count().exec();

                                if (check <= 0) {
                                    UserPackage.create({
                                        user: sell.buyer,
                                        car: sell.car,
                                        booking: null,
                                        name: package.name,
                                        business: "5bfec47ef651033d1c99fbca",
                                        description: package.description,
                                        category: package.category,
                                        package: package._id,
                                        payment: {
                                            total: package.cost,
                                            paid_total: package.cost,
                                        },
                                        discount: package.discount,
                                        validity: package.validity,
                                        expired_at: expired_at,
                                        created_at: new Date(),
                                        updated_at: new Date()
                                    });

                                    if (package.cashback) {
                                        var point = {
                                            user: sell.buyer,
                                            activity: "coin",
                                            tag: "cashback",
                                            source: sell._id,
                                            sender: null,
                                            title: "",
                                            body: "",
                                            points: package.cashback,
                                            status: true
                                        }

                                        fun.addPoints(point)
                                    }

                                    res.status(200).json({
                                        responseCode: 200,
                                        responseMessage: "Your transaction has been successfully done",
                                        responseData: paytmRes
                                    })
                                }
                            }
                        });
                    }
                    else {
                        res.status(200).json({
                            responseCode: 200,
                            responseMessage: "Your transaction has been declined",
                            responseData: paytmRes
                        })
                    }

                }
            });
        });
    }
    else {
        res.status(400).json({
            responseCode: 400,
            responseMessage: "Car Not Found",
            responseData: {}
        });
    }
});

router.delete('/car/unpublish', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var business = req.headers['business'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    var loggedInDetails = await User.findById(decoded.user).exec();
    var car = await Car.findById(req.body.car).populate('user').exec();

    if (car) {
        if (loggedInDetails) {
            var check_listing = await CarSell.findOne({ car: car._id, seller: business, sold: false }).exec();
            if (check_listing) {
                Car.findOneAndUpdate({ _id: car._id }, {
                    $set: {
                        user: check_listing.owner,
                        publish: false,
                        package: null,
                        admin_approved: false,
                        updated_at: new Date()
                    }
                }, { new: false }, async function (err, doc) {
                    if (err) {
                        res.status(400).json({
                            responseCode: 400,
                            responseMessage: "Server Error",
                            responseData: err
                        })
                    }
                    else {
                        CarSell.findByIdAndRemove(check_listing._id).exec();
                        res.status(200).json({
                            responseCode: 200,
                            responseMessage: "Successfully unpublished",
                            responseData: {}
                        })
                    }
                });
            }
            else {
                res.status(400).json({
                    responseCode: 400,
                    responseMessage: "Unauthorized",
                    responseData: {}
                })
            }
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Seller not found",
                responseData: {}
            })
        }
    }
    else {
        res.status(400).json({
            responseCode: 400,
            responseMessage: "Unauthorized",
            responseData: {}
        })
    }
});

router.put('/car/rc/add', xAccessToken.token, function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = req.headers['business'];
    let extension = "";
    var upload = multer({
        storage: multerS3({
            s3: s3,
            bucket: config.BUCKET_NAME + '/car',
            acl: 'public-read',
            contentType: multerS3.AUTO_CONTENT_TYPE,
            // contentDisposition: 'attachment',
            key: function (req, file, cb) {
                let extArray = file.mimetype.split("/");
                extension = extArray[extArray.length - 1];

                var filename = uuidv1() + '.' + extension;
                if (extension == 'png' || extension == 'jpg' || extension == 'jpeg' || extension == 'gif') {
                    cb(null, filename);
                }
                else {
                    var params = {
                        Bucket: config.BUCKET_NAME + "/car",
                        Key: filename
                    };
                    s3.deleteObject(params, async function (err, data) {
                        var json = ({
                            responseCode: 422,
                            responseMessage: "Invalid extension",
                            responseData: {}
                        });
                        res.status(422).json(json)
                    });
                }
            }
        })
    }).array('media', 1);

    upload(req, res, async function (error) {
        if (error) {
            var json = ({
                responseCode: 400,
                responseMessage: "Error occured",
                responseData: {}
            });
            res.status(400).json(json)
        }

        if (req.files.length == 0) {
            var json = ({
                responseCode: 400,
                responseMessage: "Media is required",
                responseData: err
            });
            res.status(400).json(json)
        }
        else {
            var car = await Car.findOne({ _id: req.body.id, user: user }).exec();
            if (car) {
                if (car.ic) {
                    var params = {
                        Bucket: config.BUCKET_NAME + "/car",
                        Key: car.rc
                    };
                    s3.deleteObject(params, async function (err, data) {
                        if (err) {
                            res.status(400).json({
                                responseCode: 400,
                                responseMessage: "Error occured",
                                responseData: {
                                    res: {
                                        next: "",
                                        errors: "",
                                        rld: false
                                    },
                                }
                            });
                        }
                    });
                }

                var data = {
                    rc: req.files[0].key,
                    updated_at: new Date,
                }

                Car.findOneAndUpdate({ _id: req.body.id, user: user }, { $set: data }, { new: true }, function (err, doc) { });

                var data = {
                    user: req.headers['business'],
                    car: req.body.id,
                    file_type: extension.toUpperCase(),
                    caption: "Registration No",
                    file: req.files[0].key,
                    created_at: new Date(),
                    updated_at: new Date(),
                };

                var carDocument = new CarDocument(data);
                carDocument.save();

                res.status(200).json({
                    responseCode: 200,
                    responseMessage: "File has been uploaded",
                    responseData: {
                        file_address: 'https://s3.ap-south-1.amazonaws.com/' + config.BUCKET_NAME + '/car/' + req.files[0].key,
                    }
                })
            }
        }
    });
});

router.put('/car/ic/add', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = req.headers['business'];
    let extension = "";
    // var car = await Car.findById().exec();
    // res.json(req.body)
    var upload = multer({
        storage: multerS3({
            s3: s3,
            bucket: config.BUCKET_NAME + '/car',
            acl: 'public-read',
            contentType: multerS3.AUTO_CONTENT_TYPE,
            // contentDisposition: 'attachment',
            key: function (req, file, cb) {
                let extArray = file.mimetype.split("/");
                extension = extArray[extArray.length - 1];

                var filename = uuidv1() + '.' + extension;
                if (extension == 'png' || extension == 'jpg' || extension == 'jpeg' || extension == 'gif') {
                    cb(null, filename);
                }
                else {
                    var params = {
                        Bucket: config.BUCKET_NAME + "/car",
                        Key: filename
                    };
                    s3.deleteObject(params, async function (err, data) {
                        var json = ({
                            responseCode: 422,
                            responseMessage: "Invalid extension",
                            responseData: {}
                        });
                        res.status(422).json(json)
                    });
                }
            }
        })
    }).array('media', 1);

    upload(req, res, async function (error) {
        if (error) {
            var json = ({
                responseCode: 400,
                responseMessage: "Error occured",
                responseData: {}
            });
            res.status(400).json(json)
        }

        if (req.files.length == 0) {
            var json = ({
                responseCode: 400,
                responseMessage: "Media is required",
                responseData: {}
            });
            res.status(400).json(json)
        }
        else {
            var car = await Car.findOne({ _id: req.body.id, user: user }).exec();
            if (car) {
                if (car.ic) {
                    var params = {
                        Bucket: config.BUCKET_NAME + "/car",
                        Key: car.ic
                    };
                    s3.deleteObject(params, async function (err, data) {
                        if (err) {
                            res.status(400).json({
                                responseCode: 400,
                                responseMessage: "Error occured",
                                responseData: {
                                    res: {
                                        next: "",
                                        errors: "",
                                        rld: false
                                    },
                                }
                            });
                        }
                    });
                }

                var data = {
                    ic: req.files[0].key,
                    updated_at: new Date,
                }

                Car.findOneAndUpdate({ _id: req.body.id, user: user }, { $set: data }, { new: true }, function (err, doc) { });


                CarDocument.create({
                    user: req.headers['business'],
                    car: req.body.id,
                    file_type: extension.toUpperCase(),
                    caption: "Insurance",
                    file: req.files[0].key,
                    created_at: new Date(),
                    updated_at: new Date(),
                });


                res.status(200).json({
                    responseCode: 200,
                    responseMessage: "File has been uploaded",
                    responseData: {
                        file_address: 'https://s3.ap-south-1.amazonaws.com/' + config.BUCKET_NAME + '/car/' + req.files[0].key,
                    }
                })
            }
        }
    });
});

router.delete('/car/rc/delete', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = req.headers['business'];

    if (!req.body.id) {
        var json = ({
            responseCode: 422,
            responseMessage: "Invalid Car",
            responseData: {}
        });
        res.status(422).json(json)
    }
    else {
        var car = await Car.findOne({ _id: req.body.id, user: user }).exec();
        if (car) {
            if (car.ic) {
                var params = {
                    Bucket: config.BUCKET_NAME + "/car",
                    Key: car.rc
                };
                s3.deleteObject(params, async function (err, data) {
                    if (err) {
                        res.status(400).json({
                            responseCode: 400,
                            responseMessage: "Error occured",
                            responseData: {
                                res: {
                                    next: "",
                                    errors: "",
                                    rld: false
                                },
                            }
                        });
                    }
                });
            }

            var data = {
                rc: '',
                updated_at: new Date,
            }

            Car.findOneAndUpdate({ _id: req.body.id, user: user }, { $set: data }, { new: true }, function (err, doc) { });

            res.status(200).json({
                responseCode: 200,
                responseMessage: "File has been deleted",
                responseData: {}
            })
        }
    }
});

router.delete('/car/ic/delete', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = req.headers['business'];

    if (!req.body.id) {
        var json = ({
            responseCode: 422,
            responseMessage: "Invalid Car",
            responseData: {}
        });
        res.status(422).json(json)
    }
    else {
        var car = await Car.findOne({ _id: req.body.id, user: user }).exec();
        if (car) {
            if (car.ic) {
                var params = {
                    Bucket: config.BUCKET_NAME + "/car",
                    Key: car.ic
                };
                s3.deleteObject(params, async function (err, data) {
                    if (err) {
                        res.status(400).json({
                            responseCode: 400,
                            responseMessage: "Error occured",
                            responseData: {
                                res: {
                                    next: "",
                                    errors: "",
                                    rld: false
                                },
                            }
                        });
                    }
                });
            }

            var data = {
                ic: '',
                updated_at: new Date,
            }

            Car.findOneAndUpdate({ _id: req.body.id, user: user }, { $set: data }, { new: true }, function (err, doc) { });

            res.status(200).json({
                responseCode: 200,
                responseMessage: "File has been deleted",
                responseData: {}
            })
        }
    }
});

router.post('/car/add/image', xAccessToken.token, function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    var upload = multer({
        storage: multerS3({
            s3: s3,
            bucket: config.BUCKET_NAME + '/car',
            acl: 'public-read',
            contentType: multerS3.AUTO_CONTENT_TYPE,
            // contentDisposition: 'attachment',
            key: function (req, file, cb) {
                let extArray = file.mimetype.split("/");
                let extension = extArray[extArray.length - 1];

                var filename = uuidv1() + '.' + extension;
                if (extension == 'png' || extension == 'jpg' || extension == 'jpeg' || extension == 'gif') {
                    cb(null, filename);
                }
                else {
                    var params = {
                        Bucket: config.BUCKET_NAME + "/car",
                        Key: filename
                    };
                    s3.deleteObject(params, async function (err, data) {
                        var json = ({
                            responseCode: 422,
                            responseMessage: "Invalid extension",
                            responseData: {}
                        });
                        res.status(422).json(json)
                    });
                }
            }
        })
    }).array('media', 1);

    upload(req, res, function (error) {
        if (error) {
            var json = ({
                responseCode: 400,
                responseMessage: "Error occured",
                responseData: {}
            });
            res.status(400).json(json)
        }

        if (req.files.length == 0) {
            var json = ({
                responseCode: 400,
                responseMessage: "Media is required",
                responseData: {}
            });
            res.status(400).json(json)
        } else {
            var data = {
                car: req.body.id,
                file: req.files[0].key,
                created_at: new Date(),
                updated_at: new Date(),
            };

            var carImage = new CarImage(data);
            carImage.save();

            res.status(200).json({
                responseCode: 200,
                responseMessage: "File has been uploaded",
                responseData: {
                    item: carImage
                }
            })
        }
    });
});

router.post('/car/document/add/', xAccessToken.token, function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    let extension = "";
    var upload = multer({
        storage: multerS3({
            s3: s3,
            bucket: config.BUCKET_NAME + '/car',
            acl: 'public-read',
            contentType: multerS3.AUTO_CONTENT_TYPE,
            // contentDisposition: 'attachment',
            key: function (req, file, cb) {
                let extArray = file.mimetype.split("/");
                extension = extArray[extArray.length - 1];
                var filename = uuidv1() + '.' + extension;

                if (extension == "msword") {
                    extension = "doc"
                }
                if (extension == "vnd.openxmlformats-officedocument.wordprocessingml.document") {
                    extension = "docx"
                }

                if (extension == 'png' || extension == 'jpg' || extension == 'jpeg' || extension == 'gif' || extension == 'pdf' || extension == 'doc' || extension == 'docx') {
                    cb(null, filename);
                }
                else {
                    var params = {
                        Bucket: config.BUCKET_NAME + "/car",
                        Key: filename
                    };
                    s3.deleteObject(params, async function (err, data) {
                        var json = ({
                            responseCode: 422,
                            responseMessage: "Invalid extension",
                            responseData: filename
                        });
                        res.status(422).json(json)
                    });
                }
            }
        })
    }).array('media', 1);

    upload(req, res, function (error) {
        if (error) {
            var json = ({
                responseCode: 400,
                responseMessage: "Error occured",
                responseData: {}
            });
            res.status(400).json(json)
        }

        if (req.files.length == 0) {
            var json = ({
                responseCode: 400,
                responseMessage: "Media is required",
                responseData: {}
            });
            res.status(400).json(json)
        } else {
            var data = {
                user: req.headers['business'],
                car: req.body.id,
                file_type: extension.toUpperCase(),
                caption: _.startCase(_.toLower(req.body.caption)),
                file: req.files[0].key,
                created_at: new Date(),
                updated_at: new Date(),
            };

            var carDocument = new CarDocument(data);
            carDocument.save();

            res.status(200).json({
                responseCode: 200,
                responseMessage: "File has been uploaded",
                responseData: carDocument
            })
        }
    });
});

router.delete('/car/document/delete', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    var image_id = req.body.id;
    const media = await CarDocument.findById(image_id).exec();

    if (media) {
        var params = {
            Bucket: config.BUCKET_NAME + "/car",
            Key: media.file
        };
        s3.deleteObject(params, async function (err, data) {
            if (err) {
                res.status(400).json({
                    responseCode: 400,
                    responseMessage: "Error occured",
                    responseData: {}
                });
            }
            else {
                await CarDocument.findByIdAndRemove(image_id).exec();
                res.status(200).json({
                    responseCode: 200,
                    responseMessage: "File has been deleted",
                    responseData: {},
                })
            }
        });
    } else {
        res.status(400).json({
            responseCode: 400,
            responseMessage: "Wrong image",
            responseData: {},
        })
    }
});

router.get('/car/documents/get', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var business = req.headers['business'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    var document = await CarDocument.find({ user: business, car: req.query.car }).exec();

    res.status(200).json({
        responseCode: 200,
        responseMessage: "",
        responseData: document
    })
});

router.delete('/car/image/delete', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    var image_id = req.body.id;
    const media = await CarImage.findById(image_id).exec();

    if (media) {
        var params = {
            Bucket: config.BUCKET_NAME + "/car",
            Key: media.file
        };
        s3.deleteObject(params, async function (err, data) {
            if (err) {
                res.status(400).json({
                    responseCode: 400,
                    responseMessage: "Error occured",
                    responseData: {}
                });
            }
            else {
                await CarImage.findByIdAndRemove(image_id).exec();
                res.status(200).json({
                    responseCode: 200,
                    responseMessage: "File has been deleted",
                    responseData: {},
                })
            }
        });
    } else {
        res.status(400).json({
            responseCode: 400,
            responseMessage: "Wrong image",
            responseData: {},
        })
    }
});

router.get('/explore/used/car', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    var filterBy = new Object();

    var business = req.headers['business'];
    var result = [];
    var geo, range;

    if (req.query.page == undefined) {
        var page = 0;
    } else {
        var page = req.query.page;
    }



    var range = 100000;

    if (req.query.range) {
        var range = parseInt(req.query.range) * 10000
    }


    var near = [0, 0];
    if (req.query.longitude && req.query.longitude) {
        near = [parseFloat(req.query.longitude), parseFloat(req.query.latitude)]
    }


    var query = Car.find({
        geometry: {
            $near: near,
            $maxDistance: range,
        },
        publish: true,
        admin_approved: true,
        status: true,
        user: { $ne: business }
    })


    if (req.query.fuel) {
        fuel = req.query.fuel;
        query = query.where('fuel_type').in(fuel.split(','));
    }

    if (req.query.transmission) {
        transmissions = req.query.transmission;
        query = query.where('transmission').in(transmissions.split(','));
    }

    if (req.query.postedBy) {
        posted_by = req.query.postedBy;
        query = query.where('posted_by').in(posted_by.split(','));
    }

    if (req.query.body) {
        body_style = req.query.body;
        query = query.where('body_style').in(body_style.split(','));
    }

    if (req.query.model) {
        models = req.query.model;
        filterBy.model = models.split(',');
        query = query.where('_model').in(models.split(','));
    }

    if (req.query.color) {
        colors = req.query.color;
        filterBy.colors = colors.split(',');
        query = query.where('vehicle_color').in(colors.split(','));
    }

    if (req.query.min && req.query.max) {
        query = query.where('price').gte(req.query.min * 100000).lte(req.query.max * 100000);
    }

    var totalResult = await query.count().exec();

    await query
        .populate({ path: 'thumbnails' })
        .populate('bookmark')
        .populate('package')
        .populate({ path: 'user', select: 'name avatar avatar_address account_info business_info partner' })
        .sort({ updated_at: -1 }).limit(config.perPage).skip(config.perPage * page)
        .cursor().eachAsync(async (doc) => {
            result.push({
                __v: 0,
                title: doc.title,
                variant: doc.variant,
                model: doc.model,
                price: price(doc.price),
                accidental: doc.accidental,
                body_style: doc.body_style,
                description: doc.description,
                driven: doc.driven,
                carId: doc.carId,
                fuel_type: doc.fuel_type,
                location: doc.location,
                manufacture_year: doc.manufacture_year,
                odometer: doc.odometer,
                owner: doc.owner,
                registration_no: doc.registration_no,
                service_history: doc.service_history,
                transmission: doc.transmission,
                vehicle_color: doc.vehicle_color,
                vehicle_status: doc.vehicle_status,
                geometry: doc.geometry,
                created_at: moment(doc.created_at).tz(req.headers['tz']).format('ll'),
                updated_at: moment(doc.updated_at).tz(req.headers['tz']).format('ll'),
                user: doc.user,
                _id: doc._id,
                link: "/car/" + slugify(doc.title + " " + doc._id),
                publish: doc.publish,
                status: doc.status,
                careager_rating: doc.careager_rating,
                video_url: doc.video_url,
                is_bookmarked: doc.is_bookmarked,
                isChatEnable: await q.all(fun.isChatEnable(doc.user._id, req.headers['tz'])),
                id: doc.id,
                package: doc.package,
                thumbnails: doc.thumbnails
            });
        });

    res.status(200).json({
        responseCode: 200,
        responseInfo: {
            totalResult: totalResult,
        },
        responseMessage: "success",
        responseData: result,
    });
});


async function businessPlan(business, category) {
    var plans = await BusinessPlan.find({ business: business, category: category }).populate('suite').exec();
    var suite = _.map(plans, 'suite');

    for (var i = 0; i < suite.length; i++) {
        var defaults = suite[i].default;
        for (var j = 0; j < defaults.length; j++) {
            var foundIndex = def.findIndex(x => x.action == defaults[j].action);
            if (foundIndex == -1) {
                def.push({
                    tag: defaults[j].tag,
                    module: defaults[j].module,
                    action: defaults[j].action,
                    enable: defaults[j].enable,
                    activityTab: defaults[j].activityTab,
                })
            }
        }

        var serverTime = moment.tz(new Date(), req.headers['tz']);
        var bar = plans[i].created_at;
        bar.setDate(bar.getDate() + plans[i].validity);
        var e = bar;
        bar = moment.tz(bar, req.headers['tz'])

        var baz = bar.diff(serverTime);

        if (baz > 0) {
            var mains = suite[i].main;
            for (var k = 0; k < mains.length; k++) {
                var foundIndex = main.findIndex(x => x.action == mains[k].action);
                if (foundIndex >= 0) {
                    main[foundIndex] = {
                        tag: mains[k].tag,
                        module: mains[k].action,
                        action: mains[k].action,
                        enable: mains[k].enable,
                        activityTab: mains[k].activityTab,

                    }
                }
                else {
                    main.push({
                        tag: mains[k].tag,
                        module: mains[k].module,
                        action: mains[k].action,
                        enable: mains[k].enable,
                        activityTab: mains[k].activityTab,
                    })
                }
            }
        }

        if (suite[i].chat == true) {
            chat = true;
        }
    }
}

async function businessPlanCategory(business) {
    var plans = await BusinessPlan.find({ business: business }).populate('suite').exec();
    var suite = _.map(plans, 'suite');

    var category = []

    for (var i = 0; i < suite.length; i++) {
        category.push(suite[i].category)
    }

    return category
}

async function businessPlanLimit(business, tz) {
    var plans = await BusinessPlan.find({ business: business }).populate('suite').exec();
    var suite = _.map(plans, 'suite');

    var limits = [];
    for (var i = 0; i < suite.length; i++) {
        var serverTime = moment.tz(new Date(), tz);
        var bar = plans[i].created_at;
        bar.setDate(bar.getDate() + plans[i].validity);
        var e = bar;
        bar = moment.tz(bar, tz)

        var baz = bar.diff(serverTime);

        if (baz > 0) {
            limits.push(suite[i].limits[0]);

        }
    }

    result = limits.reduce((r, o) => {
        if (!typeof (o) === 'object' || o === null) {
            return r;
        }

        Object.keys(o).forEach((key) => r[key] = r[key] !== undefined ? Math.max(r[key], o[key]) : o[key]);
        return r;
    }, {});

    return result;
}

function price(value) {
    var val = Math.abs(value)
    if (val >= 10000000) {
        val = (val / 10000000).toFixed(2) + 'Cr';
    }
    else if (val >= 100000) {
        val = (val / 100000).toFixed(2) + 'L';
    }

    else if (val >= 1000) {
        val = (val / 1000).toFixed(2) + 'K';
    }
    return val.toString();
}

function slugify(string) {
    return string
        .toString()
        .trim()
        .toLowerCase()
        .replace(/\s+/g, "-")
        .replace(/[^\w\-]+/g, "")
        .replace(/\-\-+/g, "-")
        .replace(/^-+/, "")
        .replace(/-+$/, "");
}

async function getAssignee(user, business) {
    var role = await Management.findOne({ user: user, business: business }).exec();
    if (role.role == "CRE") {
        advisor = role.user;
    }
    else {
        var assigneeLead = [];
        await Management.find({ business: business, role: "CRE" })
            .cursor().eachAsync(async (a) => {
                var d = await Lead.find({ business: business, assignee: a.user }).count().exec();
                assigneeLead.push({
                    user: a.user,
                    count: d
                })
            });

        if (assigneeLead.length != 0) {
            assigneeLead.sort(function (a, b) {
                return a.count > b.count;
            });

            advisor = assigneeLead[0].user;

        }
        else {
            advisor = role.business;
        }
    }


    return advisor;
}

router.get('/user/wallet/get', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);

    var points = [];
    var total = 0, used = 0;
    var unused = await User.findOne({ _id: req.query.user }).select('careager_cash referral_code').exec();
    await Point.find({ user: req.query.user }).sort({ created_at: -1 }).cursor().eachAsync(async (point) => {
        if (point.type == "credit") {
            total = total + point.points;
        }

        if (point.type == "debit") {
            used = used + point.points;
        }

        if (point.tag == "commission") {
            var booking = await Booking.findById(point.source).populate({ path: 'user', populate: { path: 'user', select: "_id id name contact_no" } }).exec();
            if (booking) {
                var booking_no = booking.booking_no;
                if (booking.user) {
                    var name = booking.user.name
                }
                else {
                    var booking_no = "";
                    var name = "";
                }
            }
            else {
                var booking_no = "";
                var name = "";
            }
            var tag = "Commission - " + name + " - #" + booking_no;
        }

        else if (point.tag == "referNEarn") {
            var user = await User.findById(point.source).exec();
            var tag = "Refer & Earn - " + user.name;
        }
        else {
            var tag = _.startCase(point.tag)
        }

        points.push({
            _id: point._id,
            points: Math.ceil(point.points),
            type: point.type,
            tag: tag,
            status: point.status,
            activity: _.startCase(point.activity),
            user: point.user,
            month: moment(point.created_at).tz(req.headers['tz']).format('MMMM YYYY'),
            created_at: moment(point.created_at).tz(req.headers['tz']).format("Do"),
            updated_at: moment(point.updated_at).tz(req.headers['tz']).format("Do")
        });
    });

    var group = _(points).groupBy(x => x.month).map((value, key) => ({ month: key, transaction: value })).value();

    var uu = unused.careager_cash;

    res.status(200).json({
        responseCode: 200,
        responseMessage: "success",
        responseData: {
            total: Math.ceil(total),
            used: Math.ceil(used),
            unused: Math.ceil(uu),
            referral_code: unused.referral_code,
            total_refferal: await Referral.find({ owner: req.query.user }).count(),
            list: group
        }
    });
});

router.put('/logo/update', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers['business'];
    var bookings = [];
    var totalResult = 0;
    var loggedInDetails = await User.findById(decoded.user).exec();
    if (loggedInDetails) {
        var management = await Management.findOne({ user: decoded.user, business: business, role: "Admin" }).populate('user').exec();
        if (management) {

            var upload = multer({
                storage: multerS3({
                    s3: s3,
                    bucket: config.BUCKET_NAME + '/avatar',
                    acl: 'public-read',
                    contentType: multerS3.AUTO_CONTENT_TYPE,
                    // contentDisposition: 'attachment',
                    key: function (req, file, cb) {
                        let extArray = file.mimetype.split("/");
                        let extension = extArray[extArray.length - 1];

                        var filename = uuidv1() + '.' + extension;
                        if (extension == 'png' || extension == 'jpg' || extension == 'jpeg' || extension == 'gif') {
                            cb(null, filename);
                        }
                        else {
                            var params = {
                                Bucket: config.BUCKET_NAME + "/avatar",
                                Key: filename
                            };
                            s3.deleteObject(params, async function (err, data) {
                                var json = ({
                                    responseCode: 422,
                                    responseMessage: "Invalid extension",
                                    responseData: {}
                                });
                                res.status(422).json(json)
                            });
                        }
                    }
                })
            }).array('media', 1);

            upload(req, res, async function (error) {
                if (error) {
                    var json = ({
                        responseCode: 400,
                        responseMessage: "Error occured",
                        responseData: {}
                    });
                    res.status(400).json(json)
                }

                if (req.files.length == 0) {
                    var json = ({
                        responseCode: 400,
                        responseMessage: "Media is required",
                        responseData: {}
                    });
                    res.status(400).json(json)
                }
                else {
                    var data = {
                        "business_info.company_logo": 'https://s3.ap-south-1.amazonaws.com/' + config.BUCKET_NAME + '/avatar/' + req.files[0].key,
                        "updated_at": new Date(),
                    }

                    User.findOneAndUpdate({ _id: business }, { $set: data }, { new: false }, async function (err, doc) {
                        if (err) {
                            res.status(422).json({
                                responseCode: 422,
                                responseMessage: "Server Error",
                                responseData: err
                            });
                        }
                        else {
                            var updated = await User.findOne({ _id: business }).exec();
                            res.status(200).json({
                                responseCode: 200,
                                responseMessage: "Business Setting",
                                responseData: updated
                            });
                        }
                    });
                }
            });
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Authorization Error",
                responseData: {}
            });
        }
    }
    else {
        res.status(400).json({
            responseCode: 400,
            responseMessage: "User not found",
            responseData: {}
        });
    }
});

router.put('/qr-code/update', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers['business'];
    var bookings = [];
    var totalResult = 0;
    var loggedInDetails = await User.findById(decoded.user).exec();
    if (loggedInDetails) {
        var management = await Management.findOne({ user: decoded.user, business: business, role: "Admin" }).populate('user').exec();
        if (management) {

            var upload = multer({
                storage: multerS3({
                    s3: s3,
                    bucket: config.BUCKET_NAME + '/avatar',
                    acl: 'public-read',
                    contentType: multerS3.AUTO_CONTENT_TYPE,
                    // contentDisposition: 'attachment',
                    key: function (req, file, cb) {
                        let extArray = file.mimetype.split("/");
                        let extension = extArray[extArray.length - 1];

                        var filename = uuidv1() + '.' + extension;
                        if (extension == 'png' || extension == 'jpg' || extension == 'jpeg' || extension == 'gif') {
                            cb(null, filename);
                        }
                        else {
                            var params = {
                                Bucket: config.BUCKET_NAME + "/avatar",
                                Key: filename
                            };
                            s3.deleteObject(params, async function (err, data) {
                                var json = ({
                                    responseCode: 422,
                                    responseMessage: "Invalid extension",
                                    responseData: {}
                                });
                                res.status(422).json(json)
                            });
                        }
                    }
                })
            }).array('media', 1);

            upload(req, res, async function (error) {
                if (error) {
                    var json = ({
                        responseCode: 400,
                        responseMessage: "Error occured",
                        responseData: {}
                    });
                    res.status(400).json(json)
                }

                if (req.files.length == 0) {
                    var json = ({
                        responseCode: 400,
                        responseMessage: "Media is required",
                        responseData: {}
                    });
                    res.status(400).json(json)
                }
                else {
                    var data = {
                        "business_info.qr_code": 'https://s3.ap-south-1.amazonaws.com/' + config.BUCKET_NAME + '/avatar/' + req.files[0].key,
                        "updated_at": new Date(),
                    }

                    User.findOneAndUpdate({ _id: business }, { $set: data }, { new: false }, async function (err, doc) {
                        if (err) {
                            res.status(422).json({
                                responseCode: 422,
                                responseMessage: "Server Error",
                                responseData: err
                            });
                        }
                        else {
                            var updated = await User.findOne({ _id: business }).exec();
                            res.status(200).json({
                                responseCode: 200,
                                responseMessage: "Business Setting",
                                responseData: updated
                            });
                        }
                    });
                }
            });
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Authorization Error",
                responseData: {}
            });
        }
    }
    else {
        res.status(400).json({
            responseCode: 400,
            responseMessage: "User not found",
            responseData: {}
        });
    }
});

router.delete('/qr-code/delete', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers['business'];
    var bookings = [];
    var totalResult = 0;
    var loggedInDetails = await User.findById(decoded.user).exec();
    if (loggedInDetails) {
        var management = await Management.findOne({ user: decoded.user, business: business, role: "Admin" }).populate('user').exec();
        if (management) {
            var info = await User.findById(business).exec()

            var file = info.business_info.qr_code;

            var x = file.split("avatar/");

            if (x[1]) {
                var params = {
                    Bucket: config.BUCKET_NAME + "/avatar",
                    Key: x[1]
                };

                // console.log(params);

                s3.deleteObject(params, async function (err, data) {
                    if (err) {
                        res.status(422).json({
                            responseCode: 422,
                            responseMessage: "Invalid extension",
                            responseData: {}
                        })
                    }
                    else {
                        User.findOneAndUpdate({ _id: business }, { $set: { "business_info.qr_code": "" } }, { new: false }, async function (err, doc) {
                            if (err) {
                                res.status(422).json({
                                    responseCode: 422,
                                    responseMessage: "Invalid extension",
                                    responseData: {}
                                });
                            }
                            else {
                                res.status(200).json({
                                    responseCode: 200,
                                    responseMessage: "Deleted Successfully",
                                    responseData: {}
                                })
                            }
                        });
                    }
                });
            }
            else {
                res.status(400).json({
                    responseCode: 400,
                    responseMessage: "File not Found",
                    responseData: {}
                });
            }
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Authorization Error",
                responseData: {}
            });
        }
    }
    else {
        res.status(400).json({
            responseCode: 400,
            responseMessage: "User not found",
            responseData: {}
        });
    }
});

router.put('/info/update', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers['business'];
    var bookings = [];
    var totalResult = 0;
    var loggedInDetails = await User.findById(decoded.user).exec();
    if (loggedInDetails) {
        var management = await Management.findOne({ user: decoded.user, business: business, role: "Admin" }).populate('user').exec();
        if (management) {
            var data = {
                "business_info.company_name": req.body.company_name,
                "business_info.gst_registration_type": req.body.gst_registration_type,
                "business_info.gstin": req.body.gstin,
                "business_info.policy": req.body.policy,
                "business_info.terms": req.body.terms,
                "business_info.order_terms": req.body.order_terms,
                "business_info.pick_up_limit": req.body.pick_up_limit,
                "updated_at": new Date(),
            }

            User.findOneAndUpdate({ _id: business }, { $set: data }, { new: false }, async function (err, doc) {
                if (err) {
                    res.status(422).json({
                        responseCode: 422,
                        responseMessage: "Server Error",
                        responseData: err
                    });
                }
                else {
                    var updated = await User.findOne({ _id: business }).exec();
                    res.status(200).json({
                        responseCode: 200,
                        responseMessage: "Business Setting",
                        responseData: updated
                    });
                }
            });

        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Authorization Error",
                responseData: {}
            });
        }
    }
    else {
        res.status(400).json({
            responseCode: 400,
            responseMessage: "User not found",
            responseData: {}
        });
    }
});

router.put('/address/update', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers['business'];
    var bookings = [];
    var totalResult = 0;
    var loggedInDetails = await User.findById(decoded.user).exec();
    if (loggedInDetails) {
        var management = await Management.findOne({ user: decoded.user, business: business, role: "Admin" }).populate('user').exec();
        if (management) {
            var data = {
                "address.country": req.body.country,
                "address.state": req.body.state,
                "address.zip": req.body.zip,
                "address.area": req.body.area,
                "address.city": req.body.city,
                "address.address": req.body.address,
                "updated_at": new Date(),
            }

            User.findOneAndUpdate({ _id: business }, { $set: data }, { new: false }, async function (err, doc) {
                if (err) {
                    res.status(422).json({
                        responseCode: 422,
                        responseMessage: "Server Error",
                        responseData: err
                    });
                }
                else {
                    var updated = await User.findOne({ _id: business }).exec();
                    res.status(200).json({
                        responseCode: 200,
                        responseMessage: "Business Setting",
                        responseData: updated
                    });
                }
            });
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Authorization Error",
                responseData: {}
            });
        }
    }
    else {
        res.status(400).json({
            responseCode: 400,
            responseMessage: "User not found",
            responseData: {}
        });
    }
});

router.put('/bank-details/update', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers['business'];
    var bookings = [];
    var totalResult = 0;
    var loggedInDetails = await User.findById(decoded.user).exec();
    if (loggedInDetails) {
        var management = await Management.findOne({ user: decoded.user, business: business, role: "Admin" }).populate('user').exec();
        if (management) {
            var data = [{
                "bank": req.body.bank,
                "branch": req.body.branch,
                "ifsc": req.body.ifsc,
                "account_no": req.body.account_no,
                "account_holder": req.body.account_holder,
            }]


            User.findOneAndUpdate({ _id: business }, { $set: { bank_details: data } }, { new: false }, async function (err, doc) {
                if (err) {
                    res.status(422).json({
                        responseCode: 422,
                        responseMessage: "Server Error",
                        responseData: err
                    });
                }
                else {
                    var updated = await User.findOne({ _id: business }).exec();
                    res.status(200).json({
                        responseCode: 200,
                        responseMessage: "Business Setting",
                        responseData: updated
                    });
                }
            });
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Authorization Error",
                responseData: {}
            });
        }
    }
    else {
        res.status(400).json({
            responseCode: 400,
            responseMessage: "User not found",
            responseData: {}
        });
    }
});

router.put('/job/setting/update', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var user = decoded.user;
    var business = req.headers['business'];
    var bookings = [];
    var totalResult = 0;
    var loggedInDetails = await User.findById(decoded.user).exec();
    if (loggedInDetails) {
        var management = await Management.findOne({ user: decoded.user, business: business, role: "Admin" }).populate('user').exec();
        if (management) {
            var businessSetting = await BusinessSetting.findOne({ business: business }).exec();
            if (businessSetting) {
                req.body.updated_at = new Date();

                BusinessSetting.findOneAndUpdate({ business: business }, { $set: req.body }, { new: false }, async function (err, doc) {
                    if (err) {
                        res.status(422).json({
                            responseCode: 422,
                            responseMessage: "Server Error",
                            responseData: err
                        });
                    }
                    else {
                        var updated = await BusinessSetting.findOne({ business: business }).exec();
                        res.status(200).json({
                            responseCode: 200,
                            responseMessage: "Business Setting",
                            responseData: updated
                        });
                    }
                });
            }
            else {
                req.body.business = business;
                req.body.created_at = new Date();
                req.body.updated_at = new Date();

                BusinessSetting.create(req.body)
                    .then(async function (e) {
                        res.status(200).json({
                            responseCode: 200,
                            responseMessage: "Added",
                            responseData: e
                        });
                    });
            }
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Authorization Error",
                responseData: {}
            });
        }
    }
    else {
        res.status(400).json({
            responseCode: 400,
            responseMessage: "User not found",
            responseData: {}
        });
    }
});

router.put('/profile/update', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var business = req.headers['business'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var loggedInDetails = await User.findById(decoded.user).exec();
    if (loggedInDetails) {
        var management = await Management.findOne({ user: decoded.user, business: business, role: "Admin" }).populate('user').exec();
        if (management) {
            var data = {
                name: req.body.name,
                contact_no: req.body.contact_no,
                optional_info: {
                    email: req.body.secondary_email,
                    contact_no: req.body.secondary_contact_no,
                    overview: req.body.overview,
                },
            };

            var rules = {
                name: 'required',
            };

            var validation = new Validator(data, rules);

            if (validation.fails()) {
                res.status(422).json({
                    responseCode: 422,
                    responseMessage: "Error",
                    responseData: {
                        res: validation.errors.all()
                    }
                })
            }
            else {
                User.findOneAndUpdate({ _id: business }, { $set: data }, { new: true }, function (err, doc) {
                    if (err) {
                        var json = ({
                            responseCode: 400,
                            responseMessage: "Error Occurred",
                            responseData: err
                        });

                        res.status(400).json(json)
                    }
                    else {
                        var json = ({
                            responseCode: 200,
                            responseMessage: "Profile has been updated",
                            responseData: {}
                        });
                        res.status(200).json(json)
                    }
                })
            }
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Authorization Error",
                responseData: {}
            });
        }
    }
    else {
        res.status(400).json({
            responseCode: 400,
            responseMessage: "User not found",
            responseData: {}
        });
    }
});

router.put('/timing/update', xAccessToken.token, async function (req, res, next) {
    var business = req.headers['business'];
    var token = req.headers['x-access-token'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var loggedInDetails = await User.findById(decoded.user).exec();
    if (loggedInDetails) {
        var management = await Management.findOne({ user: decoded.user, business: business, role: "Admin" }).populate('user').exec();
        if (management) {
            var timings = req.body;

            BusinessTiming.remove({ business: business }, function (err) {
                if (!err) {
                    timings.forEach(function (u) {
                        var timing = new BusinessTiming({
                            business: business,
                            day: u.day,
                            open: u.open,
                            close: u.close,
                            is_closed: u.is_closed,
                            created_at: new Date(),
                            updated_at: new Date(),
                        });
                        timing.save();
                    });

                    var json = ({
                        responseCode: 200,
                        responseMessage: "Timing has been updated",
                        responseData: {}
                    });
                    res.status(200).json(json)
                }
                else {
                    var json = ({
                        responseCode: 400,
                        responseMessage: "Error Occurred",
                        responseData: {}
                    });
                    res.status(400).json(json)
                }
            });
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Authorization Error",
                responseData: {}
            });
        }
    }
    else {
        res.status(400).json({
            responseCode: 400,
            responseMessage: "User not found",
            responseData: {}
        });
    }
});

router.put('/booking/timings/update', xAccessToken.token, async function (req, res, next) {
    var token = req.headers['x-access-token'];
    var business = req.headers['business'];
    var secret = config.secret;
    var decoded = jwt.verify(token, secret);
    var loggedInDetails = await User.findById(decoded.user).exec();
    if (loggedInDetails) {
        var management = await Management.findOne({ user: decoded.user, business: business, role: "Admin" }).populate('user').exec();
        if (management) {
            var timings = req.body;
            BookingTiming.remove({ business: business }, function (err) {
                if (!err) {
                    timings.forEach(function (u) {
                        var timing = new BookingTiming({
                            business: business,
                            slot: u.slot,
                            sort: u.index,
                            booking_per_slot: u.bookings,
                            status: u.status,
                            created_at: new Date(),
                            updated_at: new Date(),
                        });
                        timing.save();
                    });

                    var json = ({
                        responseCode: 200,
                        responseMessage: "Booking timing has been updated",
                        responseData: {}
                    });
                    res.status(200).json(json)
                }
                else {
                    var json = ({
                        responseCode: 400,
                        responseMessage: "Error Occurred",
                        responseData: {}
                    });
                    res.status(400).json(json)
                }
            });
        }
        else {
            res.status(400).json({
                responseCode: 400,
                responseMessage: "Authorization Error",
                responseData: {}
            });
        }
    }
    else {
        res.status(400).json({
            responseCode: 400,
            responseMessage: "User not found",
            responseData: {}
        });
    }
});

function segmentSort(segment) {
    var s = 0;
    if (segment == "Small") {
        s = 1;
    }
    else if (segment == "Medium") {
        s = 2;
    }
    else if (segment == "Premium") {
        s = 3;
    }
    else if (segment == "Premium XL") {
        s = 4;
    }
    else if (segment == "Luxury") {
        s = 5;
    }
    else if (segment == "Luxury XL") {
        s = 6;
    }
    else if (segment == "Sports") {
        s = 7;
    }

    return s;
}

module.exports = router